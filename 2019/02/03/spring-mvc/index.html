<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>servlet_spring-mvc | Zyumin</title>
  <meta name="keywords" content=" spring , servlet , spring-mvc , spring-webflux ">
  <meta name="description" content="servlet_spring-mvc | Zyumin">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta property="og:type" content="website">
<meta property="og:title" content="tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="Zyumin">
<meta property="og:description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-03-23T07:09:38.000Z">
<meta property="article:modified_time" content="2019-03-23T07:09:56.000Z">
<meta property="article:author" content="zhengyumin">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/github-gist.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.png"/>
</a>
<div class="author">
    <span>zhengyumin</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/Zyumin"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=60037019"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(57)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="design">
                        
                        design
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="java">
                        
                        java
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="jdk">
                        
                        jdk
                        <small>(13)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="mysql">
                        
                        mysql
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="redis">
                        
                        redis
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="spring">
                        
                        spring
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="57">
<input type="hidden" id="yelog_site_word_count" value="189.6k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>aop</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>applicationContext</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>beanFactory</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>classLoader</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>collections</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>design</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>distributed</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>doc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ejb</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>elasticsearch</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>event</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>file</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>framework</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>gc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hbase</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hide</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hotspot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>io</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ioc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>j2ee</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jdk</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>job</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>juc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>kafka</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>lang</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>map</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mysql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>netty</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>note</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>packages</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>serialization</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>servlet</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spark</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spec</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring-mvc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring-webflux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>summary</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>thread</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>tomcat</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>utils</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>week</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>zookeeper</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a id="top" class="全部文章 java "
           href="/2019/02/02/Overview_java/"
           data-tag="summary"
           data-author="" >
            <span class="post-title" title="Overview_java">Overview_java</span>
            <span class="post-date" title="2019-02-02 20:43:14">2019/02/02</span>
        </a>
        
        
        <a id="top" class="全部文章 spring "
           href="/2019/03/02/Overview_Spring/"
           data-tag="spring,framework"
           data-author="" >
            <span class="post-title" title="Overview-Spring">Overview-Spring</span>
            <span class="post-date" title="2019-03-02 12:29:06">2019/03/02</span>
        </a>
        
        
        <a id="top" class="全部文章 jdk "
           href="/2019/06/13/Overview_JDK/"
           data-tag="jdk,hotspot"
           data-author="" >
            <span class="post-title" title="Overview_JDK">Overview_JDK</span>
            <span class="post-date" title="2019-06-13 19:36:54">2019/06/13</span>
        </a>
        
        
        <a id="top" class="全部文章 java "
           href="/2020/05/10/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"
           data-tag="job"
           data-author="" >
            <span class="post-title" title="面试常见知识点梳理">面试常见知识点梳理</span>
            <span class="post-date" title="2020-05-10 23:46:06">2020/05/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/06/30/about/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="about">about</span>
            <span class="post-date" title="2022-06-30 17:44:53">2022/06/30</span>
        </a>
        
        
        <a  class="全部文章 design "
           href="/2022/06/30/%E5%86%8D%E8%AF%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="design"
           data-author="" >
            <span class="post-title" title="再读设计模式">再读设计模式</span>
            <span class="post-date" title="2022-06-30 16:11:33">2022/06/30</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2021/01/13/GC%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/"
           data-tag="jvm,gc,summary"
           data-author="" >
            <span class="post-title" title="GC调优总结">GC调优总结</span>
            <span class="post-date" title="2021-01-13 21:36:01">2021/01/13</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2020/03/18/Overview-Hbase/"
           data-tag="distributed,hbase,framework"
           data-author="" >
            <span class="post-title" title="Overview_Hbase">Overview_Hbase</span>
            <span class="post-date" title="2020-03-18 22:00:51">2020/03/18</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2020/03/18/Overview-Spark/"
           data-tag="distributed,framework,spark"
           data-author="" >
            <span class="post-title" title="Overview_Spark">Overview_Spark</span>
            <span class="post-date" title="2020-03-18 22:00:43">2020/03/18</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2020/02/28/Redis%E9%9B%86%E7%BE%A4%E7%AF%87/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="Redis集群篇">Redis集群篇</span>
            <span class="post-date" title="2020-02-28 18:52:52">2020/02/28</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2020/02/28/Redis%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="Redis实战篇">Redis实战篇</span>
            <span class="post-date" title="2020-02-28 18:52:43">2020/02/28</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2020/02/28/Redis%E5%8E%9F%E7%90%86%E7%AF%87/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="Redis原理篇">Redis原理篇</span>
            <span class="post-date" title="2020-02-28 18:52:35">2020/02/28</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2020/01/23/spring-aop/"
           data-tag="spring,aop"
           data-author="" >
            <span class="post-title" title="spring-aop">spring-aop</span>
            <span class="post-date" title="2020-01-23 23:54:29">2020/01/23</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2020/01/16/Spring-ApplicationContext/"
           data-tag="spring,applicationContext"
           data-author="" >
            <span class="post-title" title="Spring-ApplicationContext">Spring-ApplicationContext</span>
            <span class="post-date" title="2020-01-16 21:04:45">2020/01/16</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/12/05/spring-BeanFactory/"
           data-tag="spring,beanFactory"
           data-author="" >
            <span class="post-title" title="spring-BeanFactory">spring-BeanFactory</span>
            <span class="post-date" title="2019-12-05 21:28:57">2019/12/05</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/12/02/spring-Q-A/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="spring Q&amp;A">spring Q&amp;A</span>
            <span class="post-date" title="2019-12-02 18:20:38">2019/12/02</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/10/29/Documentation-Spring-Core-IOC/"
           data-tag="spring,doc"
           data-author="" >
            <span class="post-title" title="Documentation-Spring_Core_IOC">Documentation-Spring_Core_IOC</span>
            <span class="post-date" title="2019-10-29 21:51:07">2019/10/29</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/09/26/JDK-Packages-java-nio/"
           data-tag="jdk,packages,nio"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_nio">JDK_Packages_java_nio</span>
            <span class="post-date" title="2019-09-26 10:39:22">2019/09/26</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/09/23/JDK-Packages-java-io/"
           data-tag="jdk,packages,io,serialization,file"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_io">JDK_Packages_java_io</span>
            <span class="post-date" title="2019-09-23 16:07:43">2019/09/23</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/31/JDK-Class/"
           data-tag="jdk"
           data-author="" >
            <span class="post-title" title="JDK_Class">JDK_Class</span>
            <span class="post-date" title="2019-08-31 19:38:34">2019/08/31</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/31/JDK-Thread/"
           data-tag="jvm,jdk,hotspot"
           data-author="" >
            <span class="post-title" title="JDK_Thread">JDK_Thread</span>
            <span class="post-date" title="2019-08-31 18:16:08">2019/08/31</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/08/29/JVM-main%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/"
           data-tag="jvm,java"
           data-author="" >
            <span class="post-title" title="JVM_main方法分析">JVM_main方法分析</span>
            <span class="post-date" title="2019-08-29 23:38:13">2019/08/29</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/24/JDK-ReentrantLock/"
           data-tag="juc,jdk"
           data-author="" >
            <span class="post-title" title="JDK_ReentrantLock">JDK_ReentrantLock</span>
            <span class="post-date" title="2019-08-24 18:48:54">2019/08/24</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/08/17/JVM-Synchronized/"
           data-tag="jvm"
           data-author="" >
            <span class="post-title" title="JVM_Synchronized">JVM_Synchronized</span>
            <span class="post-date" title="2019-08-17 17:01:54">2019/08/17</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/08/11/Overview-Java-Virtual-Machine/"
           data-tag="jvm"
           data-author="" >
            <span class="post-title" title="Overview_Java Virtual Machine">Overview_Java Virtual Machine</span>
            <span class="post-date" title="2019-08-11 19:05:38">2019/08/11</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/11/JDK-Packages-java-lang/"
           data-tag="jdk,packages,lang"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_lang">JDK_Packages_java_lang</span>
            <span class="post-date" title="2019-08-11 19:04:56">2019/08/11</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/11/JDK-Packages-java-utils/"
           data-tag="jdk,packages,utils"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_utils">JDK_Packages_java_utils</span>
            <span class="post-date" title="2019-08-11 19:04:25">2019/08/11</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/10/JDK-The-Concurrent-Framework/"
           data-tag="juc,jdk"
           data-author="" >
            <span class="post-title" title="JDK_The Concurrent Framework">JDK_The Concurrent Framework</span>
            <span class="post-date" title="2019-08-10 19:45:39">2019/08/10</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/07/29/JDK-The-Collections-Framework/"
           data-tag="jdk,collections"
           data-author="" >
            <span class="post-title" title="JDK_The Collections Framework">JDK_The Collections Framework</span>
            <span class="post-date" title="2019-07-29 15:26:01">2019/07/29</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/07/10/Note-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"
           data-tag="java,note"
           data-author="" >
            <span class="post-title" title="Note_码农翻身">Note_码农翻身</span>
            <span class="post-date" title="2019-07-10 22:18:56">2019/07/10</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/07/06/JDK-ClassLoader/"
           data-tag="jdk,classLoader"
           data-author="" >
            <span class="post-title" title="JDK_ClassLoader">JDK_ClassLoader</span>
            <span class="post-date" title="2019-07-06 23:12:51">2019/07/06</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/07/03/spring-ApplicationContext%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"
           data-tag="spring,classLoader,servlet,tomcat,event"
           data-author="" >
            <span class="post-title" title="spring-ApplicationContext启动流程和事件机制">spring-ApplicationContext启动流程和事件机制</span>
            <span class="post-date" title="2019-07-03 09:37:08">2019/07/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/26/Overview_Elasticsearch/"
           data-tag="framework,elasticsearch"
           data-author="" >
            <span class="post-title" title="Overview_Elasticsearch">Overview_Elasticsearch</span>
            <span class="post-date" title="2019-06-26 18:06:48">2019/06/26</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/06/24/J-U-C-ConcurrentHashMap/"
           data-tag="juc,map"
           data-author="" >
            <span class="post-title" title="J.U.C_ConcurrentHashMap">J.U.C_ConcurrentHashMap</span>
            <span class="post-date" title="2019-06-24 19:03:29">2019/06/24</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/06/19/JVM-Garbage-Collection/"
           data-tag="jvm,gc"
           data-author="" >
            <span class="post-title" title="JVM_Garbage Collection">JVM_Garbage Collection</span>
            <span class="post-date" title="2019-06-19 00:28:10">2019/06/19</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/06/16/J-U-C-InterruptedException/"
           data-tag="juc"
           data-author="" >
            <span class="post-title" title="J.U.C_InterruptedException">J.U.C_InterruptedException</span>
            <span class="post-date" title="2019-06-16 16:09:43">2019/06/16</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/06/14/Spec-JSR133/"
           data-tag="jvm,Spec,thread"
           data-author="" >
            <span class="post-title" title="Spec_JSR133">Spec_JSR133</span>
            <span class="post-date" title="2019-06-14 19:26:57">2019/06/14</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/06/13/Spec-Java-Virtual-Machine/"
           data-tag="jvm,Spec"
           data-author="" >
            <span class="post-title" title="Spec_Java Virtual Machine">Spec_Java Virtual Machine</span>
            <span class="post-date" title="2019-06-13 17:25:17">2019/06/13</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/12/Overview_Kafka/"
           data-tag="framework,kafka"
           data-author="" >
            <span class="post-title" title="kafka深入浅出">kafka深入浅出</span>
            <span class="post-date" title="2019-06-12 20:05:37">2019/06/12</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2019/06/10/Overview_Redis/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="redis深入浅出">redis深入浅出</span>
            <span class="post-date" title="2019-06-10 18:33:40">2019/06/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/06/Note_java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"
           data-tag="juc,java,note"
           data-author="" >
            <span class="post-title" title="Note_java并发编程的艺术">Note_java并发编程的艺术</span>
            <span class="post-date" title="2019-06-06 19:05:01">2019/06/06</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/05/Overview_Netty/"
           data-tag="nio,framework,netty"
           data-author="" >
            <span class="post-title" title="Netty深入浅出">Netty深入浅出</span>
            <span class="post-date" title="2019-06-05 22:01:31">2019/06/05</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/05/Note_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag="jvm,java,note"
           data-author="" >
            <span class="post-title" title="Note_深入理解java虚拟机">Note_深入理解java虚拟机</span>
            <span class="post-date" title="2019-06-05 21:12:25">2019/06/05</span>
        </a>
        
        
        <a  class="全部文章 mysql "
           href="/2019/06/04/Overview_MySQL/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="MySQL深入浅出">MySQL深入浅出</span>
            <span class="post-date" title="2019-06-04 22:02:31">2019/06/04</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/03/Overview_Zookeeper/"
           data-tag="distributed,framework,zookeeper"
           data-author="" >
            <span class="post-title" title="Zookeeper深入浅出">Zookeeper深入浅出</span>
            <span class="post-date" title="2019-06-03 21:15:05">2019/06/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/03/Overview_Distributed/"
           data-tag="distributed"
           data-author="" >
            <span class="post-title" title="分布式理论基础">分布式理论基础</span>
            <span class="post-date" title="2019-06-03 20:34:37">2019/06/03</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/04/10/spring-api-1-0/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="spring-api-1.0">spring-api-1.0</span>
            <span class="post-date" title="2019-04-10 09:45:25">2019/04/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/04/01/3%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"
           data-tag="week,hide"
           data-author="" >
            <span class="post-title" title="3月第四周知识点记录">3月第四周知识点记录</span>
            <span class="post-date" title="2019-04-01 09:51:07">2019/04/01</span>
        </a>
        
        
        <a  class="全部文章 mysql "
           href="/2019/03/30/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%9F%A5%E8%AF%A2in%E7%9A%84%E6%80%9D%E8%80%83/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="记一次mysql查询in的思考">记一次mysql查询in的思考</span>
            <span class="post-date" title="2019-03-30 20:39:49">2019/03/30</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/26/%E8%AE%B0%E4%B8%80%E6%AC%A1Broken-pipe%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"
           data-tag="tomcat"
           data-author="" >
            <span class="post-title" title="记一次Broken pipe问题的思考">记一次Broken pipe问题的思考</span>
            <span class="post-date" title="2019-03-26 10:53:37">2019/03/26</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/24/3%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"
           data-tag="week,hide"
           data-author="" >
            <span class="post-title" title="3月第三周知识点记录">3月第三周知识点记录</span>
            <span class="post-date" title="2019-03-24 20:55:31">2019/03/24</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/10/Note_Expert%20One-on-One-J2EE-Development-without-EJB/"
           data-tag="spring,j2ee,ejb"
           data-author="" >
            <span class="post-title" title="Expert One-on-One J2EE Development without EJB">Expert One-on-One J2EE Development without EJB</span>
            <span class="post-date" title="2019-03-10 19:45:57">2019/03/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/10/Note_Expert-One-on-One-J2EE-Design-and-Development/"
           data-tag="spring,j2ee"
           data-author="" >
            <span class="post-title" title="Expert One-on-One J2EE Design and Development">Expert One-on-One J2EE Design and Development</span>
            <span class="post-date" title="2019-03-10 19:45:18">2019/03/10</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/03/03/spring-Core-Container%E9%A2%84%E8%A7%88/"
           data-tag="spring,ioc"
           data-author="" >
            <span class="post-title" title="spring-Core-Container预览">spring-Core-Container预览</span>
            <span class="post-date" title="2019-03-03 14:51:56">2019/03/03</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/02/03/spring-mvc/"
           data-tag="spring,servlet,spring-mvc,spring-webflux"
           data-author="" >
            <span class="post-title" title="servlet_spring-mvc">servlet_spring-mvc</span>
            <span class="post-date" title="2019-02-03 15:50:16">2019/02/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/02/03/Overview_Tomcat/"
           data-tag="servlet,tomcat"
           data-author="" >
            <span class="post-title" title="servlet_tomcat">servlet_tomcat</span>
            <span class="post-date" title="2019-02-03 15:49:08">2019/02/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/02/02/Spec_Servlet/"
           data-tag="j2ee,servlet"
           data-author="" >
            <span class="post-title" title="j2ee_servlet">j2ee_servlet</span>
            <span class="post-date" title="2019-02-02 18:05:54">2019/02/02</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-spring-mvc" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">servlet_spring-mvc</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="spring">spring</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">spring</a>
            
            <a class="color3">servlet</a>
            
            <a class="color1">spring-mvc</a>
            
            <a class="color5">spring-webflux</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2020-01-25 16:27:29'>2019-02-03 15:50</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:11.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#springMVC-%E6%A0%B8%E5%BF%83servlet-%E2%80%94DispatcherServlet"><span class="toc-text">springMVC 核心servlet —DispatcherServlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">整体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%9B%BE%E9%A2%84%E8%A7%88"><span class="toc-text">时序图预览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpServletBean%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">HttpServletBean的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FramewordkServlet%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">FramewordkServlet的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DispatcherServlet%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">DispatcherServlet的创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88"><span class="toc-text">组件概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerMapping"><span class="toc-text">HandlerMapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerAdapter"><span class="toc-text">HandlerAdapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerExceptionResolver"><span class="toc-text">HandlerExceptionResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewResolver"><span class="toc-text">ViewResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RequestToViewNameTranslator"><span class="toc-text">RequestToViewNameTranslator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocaleResolver"><span class="toc-text">LocaleResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThemeResolver"><span class="toc-text">ThemeResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MultipartResolver"><span class="toc-text">MultipartResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FlashMapManager"><span class="toc-text">FlashMapManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-text">处理请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameworkServlet"><span class="toc-text">FrameworkServlet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DispatcherServlet"><span class="toc-text">DispatcherServlet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#doService"><span class="toc-text">doService</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doDispatch"><span class="toc-text">doDispatch</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-text">异步请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#servlet%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81"><span class="toc-text">servlet异步支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletRequest"><span class="toc-text">ServletRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%AE%B9%E5%99%A8AsyncContext"><span class="toc-text">异步容器AsyncContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncListener%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">AsyncListener监听器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6"><span class="toc-text">SpringMVC中的相关组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncWebRequest"><span class="toc-text">AsyncWebRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebAsyncManager"><span class="toc-text">WebAsyncManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebAsyncUtils"><span class="toc-text">WebAsyncUtils</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E4%B8%AD%E8%AF%B7%E6%B1%82%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">SpringMVC中请求的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-webFlux"><span class="toc-text">spring webFlux</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​	本文分析基于	<code>基于spring-webmvc 4.0.3.RELEASE</code></p>
<span id="more"></span>



<h2 id="springMVC-核心servlet-—DispatcherServlet"><a href="#springMVC-核心servlet-—DispatcherServlet" class="headerlink" title="springMVC 核心servlet —DispatcherServlet"></a>springMVC 核心servlet —DispatcherServlet</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fyc0ein61sj31m20u0adx.jpg" alt="image-20181219135235499"></p>
<blockquote>
<p>Aware：如果某个类想使用Spring的一些东西，就可以实现Aware接口</p>
<p>Capable:具有spring某个类的能力</p>
</blockquote>
<h3 id="时序图预览"><a href="#时序图预览" class="headerlink" title="时序图预览"></a>时序图预览</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8v5w3d34j31p90u0any.jpg" alt="image-20200125155900180"></p>
<h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><h4 id="HttpServletBean的创建"><a href="#HttpServletBean的创建" class="headerlink" title="HttpServletBean的创建"></a>HttpServletBean的创建</h4><p>​	    实现了<code>EnvironmentCapable</code>、<code>EnvironmentAware</code> ，主要作用是将Servlet中配置的参数设置到相应的容器</p>
<h4 id="FramewordkServlet的创建"><a href="#FramewordkServlet的创建" class="headerlink" title="FramewordkServlet的创建"></a>FramewordkServlet的创建</h4><p>​	    实现了<code>ApplicationContextAware</code>，其主要作用是调用<code>initWebApplicationContext()</code>初始化<code>WebApplicationContext</code></p>
<ul>
<li>获取spring的根工期rootContext</li>
<li>设置webApplicationContext并根据情况调用onRefresh方法</li>
<li>将WebApplicationContext设置到ServletContext中</li>
</ul>
<p>			</p>
<h4 id="DispatcherServlet的创建"><a href="#DispatcherServlet的创建" class="headerlink" title="DispatcherServlet的创建"></a>DispatcherServlet的创建</h4><p>​	onRefresh方法是DispatcherServlet的入口方法，onRefresh中调用了initStrategies()方法来初始化一些策略组件</p>
<pre><code class="java">protected void onRefresh(ApplicationContext context) &#123;
    this.initStrategies(context);
&#125;

/**
 * Initialize the strategy objects that this servlet uses.
 * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.
 */
protected void initStrategies(ApplicationContext context) &#123;
    initMultipartResolver(context);
    initLocaleResolver(context);
    initThemeResolver(context);
    initHandlerMappings(context);
    initHandlerAdapters(context);
    initHandlerExceptionResolvers(context);
    initRequestToViewNameTranslator(context);
    initViewResolvers(context);
    initFlashMapManager(context);
&#125;
</code></pre>
<p>如果没有配置相关，会使用默认的配置，在DispatcherServlet.properties文件中</p>
<pre><code class="properties"># Default implementation classes for DispatcherServlet&#39;s strategy interfaces.
# Used as fallback when no matching beans are found in the DispatcherServlet context.
# Not meant to be customized by application developers.

org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver

org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver

org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
   org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping

org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\
   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
   org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter

org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\
   org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\
   org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver

org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator

org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver

org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager
</code></pre>
<blockquote>
<p>Tips：If no bean is defined with the given name in the BeanFactory for this namespace, no multipart handling is provided.</p>
</blockquote>
<h3 id="组件概览"><a href="#组件概览" class="headerlink" title="组件概览"></a>组件概览</h3><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>​	它的作用是根据request找到对应的处理器handler和Interceptors ,首先看下接口信息</p>
<pre><code class="java">package org.springframework.web.servlet;
import javax.servlet.http.HttpServletRequest;
/**
 * Interface to be implemented by objects that define a mapping between
 * requests and handler objects.
 * @see org.springframework.core.Ordered
 * @see org.springframework.web.servlet.handler.AbstractHandlerMapping
 * @see org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping
 * @see org.springframework.web.servlet.handler.SimpleUrlHandlerMapping
 */
public interface HandlerMapping &#123;

   String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;;

   String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;;

   String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;;

   String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;;

   String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.matrixVariables&quot;;

   String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;;

   /**
    * Return a handler and any interceptors for this request. The choice may be made
    * on request URL, session state, or any factor the implementing class chooses.
    * &lt;p&gt;The returned HandlerExecutionChain contains a handler Object, rather than
    * even a tag interface, so that handlers are not constrained in any way.
    * For example, a HandlerAdapter could be written to allow another framework&#39;s
    * handler objects to be used.
    * &lt;p&gt;Returns &#123;@code null&#125; if no match was found. This is not an error.
    * The DispatcherServlet will query all registered HandlerMapping beans to find
    * a match, and only decide there is an error if none can find a handler.
    * @param request current HTTP request
    * @return a HandlerExecutionChain instance containing handler object and
    * any interceptors, or &#123;@code null&#125; if no mapping found
    * @throws Exception if there is an internal error
    */
   HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;

&#125;
</code></pre>
<p>以常用接口实现为例，RequestMappingHandlerMapping</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fyc839v8vdj31l20u043g.jpg" alt="image-20181219181838287"></p>
<blockquote>
<p>这里提供了Ordered接口，可以确定匹配的顺序，同时通过继承WebApplicationObjectSupport抽象类，可以获取相关Bean（handler）,更多细节可查看 类AbstractHandlerMapping。</p>
</blockquote>
<h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>​	之所以要使用HandlerAdapter，是因为SpringMVC中并没有对处理器做任何的限制，可以是个类，方法（HandlerMethod）这点从hanlder是Object就可以看出，首先是接口实现</p>
<pre><code class="java">package org.springframework.web.servlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * MVC framework SPI interface, allowing parameterization of core MVC workflow.
 *
 * &lt;p&gt;Interface that must be implemented for each handler type to handle a request.
 * This interface is used to allow the &#123;@link DispatcherServlet&#125; to be indefinitely
 * extensible. The DispatcherServlet accesses all installed handlers through this
 * interface, meaning that it does not contain code specific to any handler type.
 *
 * &lt;p&gt;Note that a handler can be of type &#123;@code Object&#125;. This is to enable
 * handlers from other frameworks to be integrated with this framework without
 * custom coding, as well as to allow for annotation handler objects that do
 * not obey any specific Java interface.
 *
 * &lt;p&gt;This interface is not intended for application developers. It is available
 * to handlers who want to develop their own web workflow.
 *
 * &lt;p&gt;Note: HandlerAdaptger implementators may implement the
 * &#123;@link org.springframework.core.Ordered&#125; interface to be able to specify a
 * sorting order (and thus a priority) for getting applied by DispatcherServlet.
 * Non-Ordered instances get treated as lowest priority.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter
 * @see org.springframework.web.servlet.handler.SimpleServletHandlerAdapter
 */
public interface HandlerAdapter &#123;

   /**
    * Given a handler instance, return whether or not this HandlerAdapter can
    * support it. Typical HandlerAdapters will base the decision on the handler
    * type. HandlerAdapters will usually only support one handler type each.
    * &lt;p&gt;A typical implementation:
    * &lt;p&gt;&#123;@code
    * return (handler instanceof MyHandler);
    * &#125;
    * @param handler handler object to check
    * @return whether or not this object can use the given handler
    */
   boolean supports(Object handler);

   /**
    * Use the given handler to handle this request.
    * The workflow that is required may vary widely.
    * @param request current HTTP request
    * @param response current HTTP response
    * @param handler handler to use. This object must have previously been passed
    * to the &#123;@code supports&#125; method of this interface, which must have
    * returned &#123;@code true&#125;.
    * @throws Exception in case of errors
    * @return ModelAndView object with the name of the view and the required
    * model data, or &#123;@code null&#125; if the request has been handled directly
    */
   ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;

   /**
    * Same contract as for HttpServlet&#39;s &#123;@code getLastModified&#125; method.
    * Can simply return -1 if there&#39;s no support in the handler class.
    * @param request current HTTP request
    * @param handler handler to use
    * @return the lastModified value for the given handler
    * @see javax.servlet.http.HttpServlet#getLastModified
    * @see org.springframework.web.servlet.mvc.LastModified#getLastModified
    */
   long getLastModified(HttpServletRequest request, Object handler);

&#125;
</code></pre>
<p>其中一个实现类<code>SimpleControllerHandlerAdapter</code></p>
<pre><code class="java">package org.springframework.web.servlet.mvc;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.ModelAndView;

/**
 * Adapter to use the plain &#123;@link Controller&#125; workflow interface with
 * the generic &#123;@link org.springframework.web.servlet.DispatcherServlet&#125;.
 * Supports handlers that implement the &#123;@link LastModified&#125; interface.
 * &lt;p&gt;This is an SPI class, not used directly by application code.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see org.springframework.web.servlet.DispatcherServlet
 * @see Controller
 * @see LastModified
 * @see HttpRequestHandlerAdapter
 */
public class SimpleControllerHandlerAdapter implements HandlerAdapter &#123;
   @Override
   public boolean supports(Object handler) &#123;
      return (handler instanceof Controller);
   &#125;
   @Override
   public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
      return ((Controller) handler).handleRequest(request, response);
   &#125;

   @Override
   public long getLastModified(HttpServletRequest request, Object handler) &#123;
      if (handler instanceof LastModified) &#123;
         return ((LastModified) handler).getLastModified(request);
      &#125;
      return -1L;
   &#125;

&#125;
</code></pre>
<p>一般默认使用的是 RequestMappingHandlerAdapter ,在其父类中有这样一句设置Order</p>
<p><code>private int order = Ordered.LOWEST_PRECEDENCE;</code></p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fyc7lnlrzmj318o0u042e.jpg" alt="image-20181219180136155"></p>
<blockquote>
<p>HandlerAdapter implementators may implement the Order，使用时候是遍历 handlerAdapters ，调用supports判断直接返回（除了设置的，默认的实现有3个）。注意Order是越低优先级越高的。更多细节可以查看#afterPropertiesSet()方法</p>
</blockquote>
<p>总结一下，主要做了三件事，解析参数、执行请求，处理返回结果</p>
<ul>
<li>解析参数的过程中用到的参数来源有多个，大体可分为两类<ul>
<li>一类是从Model来的（通过FlashMapManager和ModelFactory）</li>
<li>另一类是从Request来的, 具体使用HandlerMethodArgumentResolver进行解析（有的是@InitBinder WebDataBinder）</li>
</ul>
</li>
<li>执行请求的是用HandlerMethod的子类ServletInvocableHandlerMethod</li>
<li>返回值用HandlerMethodReturnValueHandler进行解析。</li>
</ul>
<p>另外，整个处理过程中ModelAndViewContainer起着参数传递的作用。</p>
<p>​	这里还有一个需要注意的，就是<code>RequestMappingHandlerAdapter</code> 是怎么注入的，通过debug发现，默认的实现HandlerAdapter 有 3个 ,除了前者还有<code>HttpRequestHandlerAdapte</code>、<code>SimpleControllerHandlerAdapte</code>的</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/3.2.10.RELEASE/spring-framework-reference/html/mvc.html#mvc-config-enable">通过查询官方文档发现</a>，有两种方式, 会自动生成相关@RequestMapping的类。</p>
<ul>
<li>@EnableWebMvc</li>
<li>配置文件配置了<code>mvc:annotation-driven</code></li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8vloeh4nj31wo0u0qdk.jpg" alt="image-20200125161405442"></p>
<blockquote>
<p>官方文档截图</p>
</blockquote>
<h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h4><p>​	根据异常设置ModelAndView，之后交给render方法去渲染，这里要注意它是在render之前工作，所以只作用于解析对请求做处理过程中的产生的异常。</p>
<pre><code class="java">package org.springframework.web.servlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * Interface to be implemented by objects than can resolve exceptions thrown
 * during handler mapping or execution, in the typical case to error views.
 * Implementors are typically registered as beans in the application context.
 *
 * &lt;p&gt;Error views are analogous to the error page JSPs, but can be used with
 * any kind of exception including any checked exception, with potentially
 * fine-granular mappings for specific handlers.
 *
 * @author Juergen Hoeller
 * @since 22.11.2003
 */
public interface HandlerExceptionResolver &#123;
   /**
    * Try to resolve the given exception that got thrown during on handler execution,
    * returning a ModelAndView that represents a specific error page if appropriate.
    * &lt;p&gt;The returned ModelAndView may be &#123;@linkplain ModelAndView#isEmpty() empty&#125;
    * to indicate that the exception has been resolved successfully but that no view
    * should be rendered, for instance by setting a status code.
    * @param request current HTTP request
    * @param response current HTTP response
    * @param handler the executed handler, or &#123;@code null&#125; if none chosen at the
    * time of the exception (for example, if multipart resolution failed)
    * @param ex the exception that got thrown during handler execution
    * @return a corresponding ModelAndView to forward to,
    * or &#123;@code null&#125; for default processing
    */
   ModelAndView resolveException(
         HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);

&#125;
</code></pre>
<p>其实现SimpleMappingExceptionResolver 可以通过扩展配置，设置自定义类型</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyc6u9xp9nj30zn0u0ag3.jpg" alt="image-20181219173520333"></p>
<blockquote>
<p>可以配合定制自定义Exception，前端统一展示等</p>
</blockquote>
<h4 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h4><p>​	通过viewName来找到 对应的View，View是用来渲染页面的，主要解决用什么模版和用什么规则填入参数</p>
<pre><code class="java">package org.springframework.web.servlet;
import java.util.Locale;

/**
 * Interface to be implemented by objects that can resolve views by name.
 *
 * &lt;p&gt;View state doesn&#39;t change during the running of the application,
 * so implementations are free to cache views.
 *
 * &lt;p&gt;Implementations are encouraged to support internationalization,
 * i.e. localized view resolution.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see org.springframework.web.servlet.view.InternalResourceViewResolver
 * @see org.springframework.web.servlet.view.ResourceBundleViewResolver
 * @see org.springframework.web.servlet.view.XmlViewResolver
 */
public interface ViewResolver &#123;

   /**
    * Resolve the given view by name.
    * &lt;p&gt;Note: To allow for ViewResolver chaining, a ViewResolver should
    * return &#123;@code null&#125; if a view with the given name is not defined in it.
    * However, this is not required: Some ViewResolvers will always attempt
    * to build View objects with the given name, unable to return &#123;@code null&#125;
    * (rather throwing an exception when View creation failed).
    * @param viewName name of the view to resolve
    * @param locale Locale in which to resolve the view.
    * ViewResolvers that support internationalization should respect this.
    * @return the View object, or &#123;@code null&#125; if not found
    * (optional, to allow for ViewResolver chaining)
    * @throws Exception if the view cannot be resolved
    * (typically in case of problems creating an actual View object)
    */
   View resolveViewName(String viewName, Locale locale) throws Exception;

&#125;
</code></pre>
<p>常用的jsp解析</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fycat4mrudj310q0u043a.jpg" alt="image-20181219195241323"></p>
<p>按照类图可以把继承<code>AbstractCachingViewResolver</code>(里面两个Map的方式值得学习)分成两类</p>
<ul>
<li><code>ResourceBundleViewResolver</code>  可以同时支持多种类型的视图，需要将每一个视图名和对应的视图类型配置到相应的properties文件中,该类的注释中，解释了其用法,</li>
</ul>
<pre><code class="java"> /* &lt;p&gt;This &#123;@code ViewResolver&#125; supports localized view definitions,
 * using the default support of &#123;@link java.util.PropertyResourceBundle&#125;.
 * For example, the basename &quot;views&quot; will be resolved as class path resources
 * &quot;views_de_AT.properties&quot;, &quot;views_de.properties&quot;, &quot;views.properties&quot; -
 * for a given Locale &quot;de_AT&quot;./
</code></pre>
<ul>
<li><code>UrlBasedViewResolver</code>系列的解析器都是对单一视图进行解析的，只需找到模版就行，例如</li>
</ul>
<p><code>InternalResourceViewResolver</code> 是专门用来解析jsp，<code>FreeMarkerViewResolver</code>只针对FreeMarker</p>
<blockquote>
<p>相关扩展ExecelViewResolver、SimpleMapViewResolver</p>
<p>默认实现是 InternalResourceViewResolver</p>
</blockquote>
<h4 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h4><p>比较简单，当handler处理完后，没有View和ViewName的会调用该方法。</p>
<pre><code class="java">/**
 * Do we need view name translation?
 */
private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception &#123;
   if (mv != null &amp;&amp; !mv.hasView()) &#123;
      mv.setViewName(getDefaultViewName(request));
   &#125;
&#125;
/**
 * Translate the supplied request into a default view name.
 * @param request current HTTP servlet request
 * @return the view name (or &#123;@code null&#125; if no default found)
 * @throws Exception if view name translation failed
 */
protected String getDefaultViewName(HttpServletRequest request) throws Exception &#123;
    return this.viewNameTranslator.getViewName(request);
&#125;
</code></pre>
<blockquote>
<p>​	默认实现是RequestToViewNameTranslator</p>
</blockquote>
<h4 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h4><p>​	用于从request中解析出Locale,默认实现是</p>
<pre><code class="java">package org.springframework.web.servlet.i18n;

import java.util.Locale;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.LocaleResolver;

/**
 * &#123;@link LocaleResolver&#125; implementation that simply uses the primary locale
 * specified in the &quot;accept-language&quot; header of the HTTP request (that is,
 * the locale sent by the client browser, normally that of the client&#39;s OS).
 *
 * &lt;p&gt;Note: Does not support &#123;@code setLocale&#125;, since the accept header
 * can only be changed through changing the client&#39;s locale settings.
 *
 * @author Juergen Hoeller
 * @since 27.02.2003
 * @see javax.servlet.http.HttpServletRequest#getLocale()
 */
public class AcceptHeaderLocaleResolver implements LocaleResolver &#123;

   public Locale resolveLocale(HttpServletRequest request) &#123;
      return request.getLocale();
   &#125;

   public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;
      throw new UnsupportedOperationException(
            &quot;Cannot change HTTP accept header - use a different locale resolution strategy&quot;);
   &#125;

&#125;
</code></pre>
<p>​	在DispatcherServlet#doSerive()方法中， <code>request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</code> 放进request中，这里除了视图解析的时候需要用到，在使用国际化主题的时候也会用到</p>
<blockquote>
<p>切换相关，可查看 LocaleChangeInterceptor</p>
</blockquote>
<h4 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h4><p>​	SpringMVC中和主题相关的类有如下</p>
<ul>
<li>ThemeResolver 作用是从request中解析出主题名,默认实现FixedThemeResolver</li>
<li>ThemeSource 根据主题名找到对应的主题 ，默认使用WebApplicationContext</li>
<li>Theme 就是主题，包含了具体资源</li>
</ul>
<pre><code class="java">package org.springframework.web.servlet.theme;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * &#123;@link org.springframework.web.servlet.ThemeResolver&#125; implementation
 * that simply uses a fixed theme. The fixed name can be defined via
 * the &quot;defaultThemeName&quot; property; out of the box, it is &quot;theme&quot;.
 *
 * &lt;p&gt;Note: Does not support &#123;@code setThemeName&#125;, as the fixed theme
 * cannot be changed.
 *
 * @author Jean-Pierre Pawlak
 * @author Juergen Hoeller
 * @since 17.06.2003
 * @see #setDefaultThemeName
 */
public class FixedThemeResolver extends AbstractThemeResolver &#123;
   @Override
   public String resolveThemeName(HttpServletRequest request) &#123;
      return getDefaultThemeName();
   &#125;

   @Override
   public void setThemeName(HttpServletRequest request, HttpServletResponse response, String themeName) &#123;
      throw new UnsupportedOperationException(&quot;Cannot change theme - use a different theme resolution strategy&quot;);
   &#125;

&#125;
</code></pre>
<blockquote>
<p>切换相关，可查看 ThemeChangeInterceptor</p>
</blockquote>
<h4 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h4><p>​	用于处理文件上传，注意这个组件在DispatcherServlet.properties 中 没有默认实现,首先是接口</p>
<pre><code class="java">package org.springframework.web.multipart;

import javax.servlet.http.HttpServletRequest;

/**
 * A strategy interface for multipart file upload resolution in accordance
 * with &lt;a href=&quot;http://www.ietf.org/rfc/rfc1867.txt&quot;&gt;RFC 1867&lt;/a&gt;.
 * Implementations are typically usable both within an application context
 * and standalone.
 *
 * &lt;p&gt;There are two concrete implementations included in Spring, as of Spring 3.1:
 * &lt;ul&gt;
 * &lt;li&gt;&#123;@link org.springframework.web.multipart.commons.CommonsMultipartResolver&#125; for Jakarta Commons FileUpload
 * &lt;li&gt;&#123;@link org.springframework.web.multipart.support.StandardServletMultipartResolver&#125; for Servlet 3.0 Part API
 * &lt;/ul&gt;
 *
 * @author Juergen Hoeller
 * @author Trevor D. Cook
 * @since 29.09.2003
 * @see MultipartHttpServletRequest
 * @see MultipartFile
 * @see org.springframework.web.multipart.commons.CommonsMultipartResolver
 * @see org.springframework.web.multipart.support.ByteArrayMultipartFileEditor
 * @see org.springframework.web.multipart.support.StringMultipartFileEditor
 * @see org.springframework.web.servlet.DispatcherServlet
 */
public interface MultipartResolver &#123;

   /**
    * Determine if the given request contains multipart content.
    * &lt;p&gt;Will typically check for content type &quot;multipart/form-data&quot;, but the actually
    * accepted requests might depend on the capabilities of the resolver implementation.
    * @param request the servlet request to be evaluated
    * @return whether the request contains multipart content
    */
   boolean isMultipart(HttpServletRequest request);

   /**
    * Parse the given HTTP request into multipart files and parameters,
    * and wrap the request inside a
    * &#123;@link org.springframework.web.multipart.MultipartHttpServletRequest&#125; object
    * that provides access to file descriptors and makes contained
    * parameters accessible via the standard ServletRequest methods.
    * @param request the servlet request to wrap (must be of a multipart content type)
    * @return the wrapped servlet request
    * @throws MultipartException if the servlet request is not multipart, or if
    * implementation-specific problems are encountered (such as exceeding file size limits)
    * @see MultipartHttpServletRequest#getFile
    * @see MultipartHttpServletRequest#getFileNames
    * @see MultipartHttpServletRequest#getFileMap
    * @see javax.servlet.http.HttpServletRequest#getParameter
    * @see javax.servlet.http.HttpServletRequest#getParameterNames
    * @see javax.servlet.http.HttpServletRequest#getParameterMap
    */
   MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException;

   /**
    * Cleanup any resources used for the multipart handling,
    * like a storage for the uploaded files.
    * @param request the request to cleanup resources for
    */
   void cleanupMultipart(MultipartHttpServletRequest request);

&#125;
</code></pre>
<p>常用实现CommonsMultipartResolver</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fycdyq4kmxj31ta0u0ahy.jpg" alt="image-20181219214146380"></p>
<p>对于上传类型判断是 multipart&#x2F;form-data, 两种实现</p>
<ul>
<li>一种是Servlet的标准实现StandardServletMultipartResolver</li>
<li>一种是Apache的commons-fileupload方式</li>
</ul>
<h4 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h4><p>​	FlashMap主要用于redirect中传递参数，FlashMapManage是用来管理FlashMap的</p>
<pre><code class="java">package org.springframework.web.servlet;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * A strategy interface for retrieving and saving FlashMap instances.
 * See &#123;@link FlashMap&#125; for a general overview of flash attributes.
 *
 * @author Rossen Stoyanchev
 * @since 3.1
 * @see FlashMap
 */
public interface FlashMapManager &#123;

   /**
    * Find a FlashMap saved by a previous request that matches to the current
    * request, remove it from underlying storage, and also remove other
    * expired FlashMap instances.
    * &lt;p&gt;This method is invoked in the beginning of every request in contrast
    * to &#123;@link #saveOutputFlashMap&#125;, which is invoked only when there are
    * flash attributes to be saved - i.e. before a redirect.
    * @param request the current request
    * @param response the current response
    * @return a FlashMap matching the current request or &#123;@code null&#125;
    */
   FlashMap retrieveAndUpdate(HttpServletRequest request, HttpServletResponse response);

   /**
    * Save the given FlashMap, in some underlying storage and set the start
    * of its expiration period.
    * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Invoke this method prior to a redirect in order
    * to allow saving the FlashMap in the HTTP session or in a response
    * cookie before the response is committed.
    * @param flashMap the FlashMap to save
    * @param request the current request
    * @param response the current response
    */
   void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response);

&#125;
</code></pre>
<p>​	两个方法，分别是retrieveAndUpdate 用于恢复参数，saveOutputFlashMap用于保存参数</p>
<p>类图也比较简单</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fyce346qynj30zc0u0q9t.jpg" alt="image-20181219214559988"></p>
<blockquote>
<p>默认实现是SessionFlashMapManager</p>
</blockquote>
<p>整个redirects 的参数通过FlashMap传递的过程分三步</p>
<ol>
<li>首先，RequestMappingHandlerAapter会将其设置到<code>outputFlashMap</code>中，如果是redirect类型的返回类型值（将需要传递的参数设置到<code>outputFlashMap</code>中，也可以是RedirectAttributes类型的参数中）</li>
<li>在RedirectView中会调用<code>#saveOutputFlashMap()</code>方法，将<code>outputFlashMap</code>中的参数设置到Session</li>
<li>请求redirect后，DispatcherServlet会调有你<code>#retrieveAndUpdate()</code>方法从Session中获取<code>inputFlashMap</code>并设置到Request的属性中备用，同时从Session中删除</li>
</ol>
<h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><h4 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h4><p>​	Servlet的处理过程，首先是从Servlet接口的service，然后在HttpServlet的service方法中根据请求的类型不同将请求路由到了doGet、doHead等方法。</p>
<p>​	FrameworkServlet中重写了doGet等方法。将请求集中到processRequest方法进行统一处理</p>
<pre><code class="java">/**
 * Override the parent class implementation in order to intercept PATCH
 * requests.
 */
@Override
protected void service(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException &#123;

    String method = request.getMethod();
    if (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;
        processRequest(request, response);
    &#125;
    else &#123;
        super.service(request, response);
    &#125;
&#125;
/**
 * Delegate GET requests to processRequest/doService.
 * &lt;p&gt;Will also be invoked by HttpServlet&#39;s default implementation of &#123;@code doHead&#125;,
 * with a &#123;@code NoBodyResponse&#125; that just captures the content length.
 * @see #doService
 * @see #doHead
 */
@Override
protected final void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException &#123;

    processRequest(request, response);
&#125;
</code></pre>
<p>​	processRequest这个方法主要做了两件事情(当然还有doService，和对异步请求对处理)</p>
<ul>
<li>对LocaleContext（获取locale）和RequestAttributes(管理request和session属性)的设置及恢复</li>
<li>处理完后发布ServletRequestHandledEvent消息</li>
</ul>
<p>LocaleContextHolder 、RequestContextHolder </p>
<pre><code class="java">public abstract class LocaleContextHolder &#123;
    private static final ThreadLocal localeContextHolder = new NamedThreadLocal(&quot;Locale context&quot;);
    private static final ThreadLocal inheritableLocaleContextHolder = new NamedInheritableThreadLocal(&quot;Locale context&quot;);
    ....
&#125;
</code></pre>
<p> 这里比较有意思的地方是这是个抽象类，里面的方法实现都是静态方法，只能调用不能实例化。RequestContextHolder的实现类似，封装的是ServletRequestAttributes</p>
<blockquote>
<p>这里之所以需要对LocaleContext和RequestAttributes恢复，是因为在Servlet外面可能还有别等操作，例如Filter（Spring-MVC的HandlerInterceptor）,为了不影响那些操作。</p>
</blockquote>
<h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>​	DispatcherServlet是FrameworkServlet的子类，实现了doService方法</p>
<h5 id="doService"><a href="#doService" class="headerlink" title="doService"></a>doService</h5><pre><code class="java">/**
 * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;@link #doDispatch&#125;
 * for the actual dispatching.
 */
@Override
protected void doService(HttpServletRequest request, HttpServletResponse response) 
    throws Exception &#123;
    // Keep a snapshot of the request attributes in case of an include,
    // to be able to restore the original attributes after the include.
    Map&lt;String, Object&gt; attributesSnapshot = null;
    if (WebUtils.isIncludeRequest(request)) &#123;
        attributesSnapshot = new HashMap&lt;String, Object&gt;();
        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();
        while (attrNames.hasMoreElements()) &#123;
            String attrName = (String) attrNames.nextElement();
            if (this.cleanupAfterInclude || attrName.startsWith(&quot;org.springframework.web.servlet&quot;)) &#123;
                attributesSnapshot.put(attrName, request.getAttribute(attrName));
            &#125;
        &#125;
    &#125;

    // Make framework objects available to handlers and view objects.
    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

    //Pass paramter use to Redirect
    FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
    if (inputFlashMap != null) &#123;
        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
    &#125;
    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);

    try &#123;
        doDispatch(request, response);
    &#125;
    finally &#123;
        if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;
            return;
        &#125;
        // Restore the original attribute snapshot, in case of an include.
        if (attributesSnapshot != null) &#123;
            restoreAttributesAfterInclude(request, attributesSnapshot);
        &#125;
    &#125;
&#125;
</code></pre>
<p>在doDispatch之前做了</p>
<ul>
<li>判断是否include请求，是的话保存快照（attributesSnapshot）</li>
<li>为request设置默认的属性，在后面的handlers和view中需要使用</li>
</ul>
<h5 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a>doDispatch</h5><p>下面是doDispatch的方法的实现，主要的功能是 Process the actual dispatching to the handler.</p>
<pre><code class="java">/**
 * Process the actual dispatching to the handler.
 * &lt;p&gt;The handler will be obtained by applying the servlet&#39;s HandlerMappings in order.
 * The HandlerAdapter will be obtained by querying the servlet&#39;s installed HandlerAdapters
 * to find the first that supports the handler class.
 * &lt;p&gt;All HTTP methods are handled by this method. It&#39;s up to HandlerAdapters or handlers
 * themselves to decide which methods are acceptable.
 * @param request current HTTP request
 * @param response current HTTP response
 * @throws Exception in case of any kind of processing failure
 */
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) 
    throws Exception &#123;
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    try &#123;
        ModelAndView mv = null;
        Exception dispatchException = null;

        try &#123;
            processedRequest = checkMultipart(request);
            multipartRequestParsed = processedRequest != request;

            // Determine handler for the current request.
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null || mappedHandler.getHandler() == null) &#123;
                noHandlerFound(processedRequest, response);
                return;
            &#125;

            // Determine handler adapter for the current request.
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = &quot;GET&quot;.equals(method);
            if (isGet || &quot;HEAD&quot;.equals(method)) &#123;
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);
                &#125;
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;
                    return;
                &#125;
            &#125;

            if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
                return;
            &#125;

            try &#123;
                // Actually invoke the handler.
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
            &#125;
            finally &#123;
                if (asyncManager.isConcurrentHandlingStarted()) &#123;
                    return;
                &#125;
            &#125;
            applyDefaultViewName(request, mv);
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        &#125;catch (Exception ex) &#123;
            dispatchException = ex;
        &#125;
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    &#125;catch (Exception ex) &#123;
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    &#125;catch (Error err) &#123;
        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);
    &#125;finally &#123;
        if (asyncManager.isConcurrentHandlingStarted()) &#123;
            // Instead of postHandle and afterCompletion
            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            return;
        &#125;
        // Clean up any resources used by a multipart request.
        if (multipartRequestParsed) &#123;
            cleanupMultipart(processedRequest);
        &#125;
    &#125;
&#125;
</code></pre>
<p>整个处理过程最核心的代码只有4句</p>
<ul>
<li>根据request请求在HandlerMapping找到对应的Handler </li>
<li>根据Handler找到对应的HandlerAdapter</li>
<li>用HandlerAdapter处理Handler,返回一个ModelAndView(Controller就是在这个地方执行)</li>
<li>根据ModelAndView的信息（或异常处理），通过ViewResolver找到View,并根据Model中的数据渲染输出后给用户</li>
</ul>
<p>整个<code>#doDispatcher()</code>处理流程如下</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fybvzj6p72j30u00ynju2.jpg" alt="image-20181219111943655"></p>
<blockquote>
<p>​	从请求开始的话，当请求到达服务器，服务器(Tomcat connector)分配一个socket线程来连接，创建request和response ，然后交给对应的servlet处理（中间经过Pipeline,Filter），这样请求就从容器(Tomcat)到Servlet（springMVC）</p>
</blockquote>
<p>​	</p>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>​	http协议是单向的，只能客户端自己拉，不能服务端主动推。</p>
<p>异步请求一般有两种方式，定时轮询或长链接。Servlet对异步的支持是通过长链接的方式。</p>
<h3 id="servlet异步支持"><a href="#servlet异步支持" class="headerlink" title="servlet异步支持"></a>servlet异步支持</h3><h4 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h4><p>​	首先是在 3.0后的 ServletRequest 中可以找到<code>#startAsync()</code> 返回一个异步容器</p>
<pre><code class="java">package javax.servlet;

import java.io.*;
import java.util.*;

/**
 * Defines an object to provide client request information to a servlet.  The
 * servlet container creates a &lt;code&gt;ServletRequest&lt;/code&gt; object and passes
 * it as an argument to the servlet&#39;s &lt;code&gt;service&lt;/code&gt; method.
 *
 * &lt;p&gt;A &lt;code&gt;ServletRequest&lt;/code&gt; object provides data including
 * parameter name and values, attributes, and an input stream.
 * Interfaces that extend &lt;code&gt;ServletRequest&lt;/code&gt; can provide
 * additional protocol-specific data (for example, HTTP data is
 * provided by &#123;@link javax.servlet.http.HttpServletRequest&#125;.
 * 
 * @author 	Various
 *
 * @see 	javax.servlet.http.HttpServletRequest
 *
 */
public interface ServletRequest &#123;
    /**
     * Puts this request into asynchronous mode, and initializes its
     * &#123;@link AsyncContext&#125; with the original (unwrapped) ServletRequest
     * and ServletResponse objects.
     *
     * &lt;p&gt;Calling this method will cause committal of the associated
     * response to be delayed until &#123;@link AsyncContext#complete&#125; is
     * called on the returned &#123;@link AsyncContext&#125;, or the asynchronous
     * operation has timed out.
     *
     * &lt;p&gt;Calling &#123;@link AsyncContext#hasOriginalRequestAndResponse()&#125; on
     * the returned AsyncContext will return &lt;code&gt;true&lt;/code&gt;. Any filters
     * invoked in the &lt;i&gt;outbound&lt;/i&gt; direction after this request was put
     * into asynchronous mode may use this as an indication that any request
     * and/or response wrappers that they added during their &lt;i&gt;inbound&lt;/i&gt;
     * invocation need not stay around for the duration of the asynchronous
     * operation, and therefore any of their associated resources may be
     * released.
     *
     * &lt;p&gt;This method clears the list of &#123;@link AsyncListener&#125; instances
     * (if any) that were registered with the AsyncContext returned by the
     * previous call to one of the startAsync methods, after calling each
     * AsyncListener at its &#123;@link AsyncListener#onStartAsync onStartAsync&#125;
     * method.
     *
     * &lt;p&gt;Subsequent invocations of this method, or its overloaded 
     * variant, will return the same AsyncContext instance, reinitialized
     * as appropriate.
     *
     * @return the (re)initialized AsyncContext
     * 
     * @throws IllegalStateException if this request is within the scope of
     * a filter or servlet that does not support asynchronous operations
     * (that is, &#123;@link #isAsyncSupported&#125; returns false),
     * or if this method is called again without any asynchronous dispatch
     * (resulting from one of the &#123;@link AsyncContext#dispatch&#125; methods),
     * is called outside the scope of any such dispatch, or is called again
     * within the scope of the same dispatch, or if the response has
     * already been closed
     *
     * @since Servlet 3.0
     */
    public AsyncContext startAsync() throws IllegalStateException;
    //...
&#125;
</code></pre>
<h4 id="异步容器AsyncContext"><a href="#异步容器AsyncContext" class="headerlink" title="异步容器AsyncContext"></a>异步容器AsyncContext</h4><pre><code class="java">package javax.servlet;

/**
 * Class representing the execution context for an asynchronous operation
 * that was initiated on a ServletRequest.
 *
 * &lt;p&gt;An AsyncContext is created and initialized by a call to
 * &#123;@link ServletRequest#startAsync()&#125; or
 * &#123;@link ServletRequest#startAsync(ServletRequest, ServletResponse)&#125;.
 * Repeated invocations of these methods will return the same AsyncContext
 * instance, reinitialized as appropriate.
 *
 * &lt;p&gt;In the event that an asynchronous operation has timed out, the
 * container must run through these steps:
 * &lt;ol&gt;
 * &lt;li&gt;Invoke, at their &#123;@link AsyncListener#onTimeout onTimeout&#125; method, all
 * &#123;@link AsyncListener&#125; instances registered with the ServletRequest
 * on which the asynchronous operation was initiated.&lt;/li&gt;
 * &lt;li&gt;If none of the listeners called &#123;@link #complete&#125; or any of the
 * &#123;@link #dispatch&#125; methods, perform an error dispatch with a status code
 * equal to &lt;tt&gt;HttpServletResponse.SC_INTERNAL_SERVER_ERROR&lt;/tt&gt;.&lt;/li&gt;
 * &lt;li&gt;If no matching error page was found, or the error page did not call
 * &#123;@link #complete&#125; or any of the &#123;@link #dispatch&#125; methods, call
 * &#123;@link #complete&#125;.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @since Servlet 3.0
 */
public interface AsyncContext &#123;

    /**
     * The name of the request attribute under which the original
     * request URI is made available to the target of a
     * &#123;@link #dispatch(String)&#125; or &#123;@link #dispatch(ServletContext,String)&#125; 
     */
    static final String ASYNC_REQUEST_URI = &quot;javax.servlet.async.request_uri&quot;;

    /**
     * The name of the request attribute under which the original
     * context path is made available to the target of a
     * &#123;@link #dispatch(String)&#125; or &#123;@link #dispatch(ServletContext,String)&#125; 
     */
    static final String ASYNC_CONTEXT_PATH = &quot;javax.servlet.async.context_path&quot;;

    /**
     * The name of the request attribute under which the original
     * path info is made available to the target of a
     * &#123;@link #dispatch(String)&#125; or &#123;@link #dispatch(ServletContext,String)&#125; 
     */
    static final String ASYNC_PATH_INFO = &quot;javax.servlet.async.path_info&quot;;

    /**
     * The name of the request attribute under which the original
     * servlet path is made available to the target of a
     * &#123;@link #dispatch(String)&#125; or &#123;@link #dispatch(ServletContext,String)&#125;  
     */
    static final String ASYNC_SERVLET_PATH = &quot;javax.servlet.async.servlet_path&quot;;

    /**
     * The name of the request attribute under which the original
     * query string is made available to the target of a
     * &#123;@link #dispatch(String)&#125; or &#123;@link #dispatch(ServletContext,String)&#125; 
     */
    static final String ASYNC_QUERY_STRING = &quot;javax.servlet.async.query_string&quot;;


    /**
     * Gets the request that was used to initialize this AsyncContext
     * by calling &#123;@link ServletRequest#startAsync()&#125; or
     * &#123;@link ServletRequest#startAsync(ServletRequest, ServletResponse)&#125;.
     *
     * @return the request that was used to initialize this AsyncContext
     */
    public ServletRequest getRequest();


    /**
     * Gets the response that was used to initialize this AsyncContext
     * by calling &#123;@link ServletRequest#startAsync()&#125; or
     * &#123;@link ServletRequest#startAsync(ServletRequest, ServletResponse)&#125;.
     *
     * @return the response that was used to initialize this AsyncContext
     */
    public ServletResponse getResponse();


    /**
     * Checks if this AsyncContext was initialized with the original or
     * application-wrapped request and response objects.
     * 
     * &lt;p&gt;This information may be used by filters invoked in the
     * &lt;i&gt;outbound&lt;/i&gt; direction, after a request was put into
     * asynchronous mode, to determine whether any request and/or response
     * wrappers that they added during their &lt;i&gt;inbound&lt;/i&gt; invocation need
     * to be preserved for the duration of the asynchronous operation, or may
     * be released.
     *
     * @return true if this AsyncContext was initialized with the original
     * request and response objects by calling
     * &#123;@link ServletRequest#startAsync()&#125;, or if it was initialized by
     * calling
     * &#123;@link ServletRequest#startAsync(ServletRequest, ServletResponse)&#125;,
     * and neither the ServletRequest nor ServletResponse arguments 
     * carried any application-provided wrappers; false otherwise
     */
    public boolean hasOriginalRequestAndResponse();


    /**
     * Dispatches the request and response objects of this AsyncContext
     * to the servlet container.
     * 
     * &lt;p&gt;If the asynchronous cycle was started with
     * &#123;@link ServletRequest#startAsync(ServletRequest, ServletResponse)&#125;,
     * and the request passed is an instance of HttpServletRequest,
     * then the dispatch is to the URI returned by
     * &#123;@link javax.servlet.http.HttpServletRequest#getRequestURI&#125;.
     * Otherwise, the dispatch is to the URI of the request when it was
     * last dispatched by the container.
     *
     * &lt;p&gt;The following sequence illustrates how this will work:
     * &lt;code&gt;&lt;pre&gt;
     * // REQUEST dispatch to /url/A
     * AsyncContext ac = request.startAsync();
     * ...
     * ac.dispatch(); // ASYNC dispatch to /url/A
     * 
     * // FORWARD dispatch to /url/B
     * getRequestDispatcher(&quot;/url/B&quot;).forward(request,response);
     * // Start async operation from within the target of the FORWARD
     * // dispatch
     * ac = request.startAsync();
     * ...
     * ac.dispatch(); // ASYNC dispatch to /url/A
     * 
     * // FORWARD dispatch to /url/B
     * getRequestDispatcher(&quot;/url/B&quot;).forward(request,response);
     * // Start async operation from within the target of the FORWARD
     * // dispatch
     * ac = request.startAsync(request,response);
     * ...
     * ac.dispatch(); // ASYNC dispatch to /url/B
     * &lt;/pre&gt;&lt;/code&gt;
     *
     * &lt;p&gt;This method returns immediately after passing the request
     * and response objects to a container managed thread, on which the
     * dispatch operation will be performed.
     * If this method is called before the container-initiated dispatch
     * that called &lt;tt&gt;startAsync&lt;/tt&gt; has returned to the container, the
     * dispatch operation will be delayed until after the container-initiated
     * dispatch has returned to the container.
     *
     * &lt;p&gt;The dispatcher type of the request is set to
     * &lt;tt&gt;DispatcherType.ASYNC&lt;/tt&gt;. Unlike
     * &#123;@link RequestDispatcher#forward(ServletRequest, ServletResponse)
     * forward dispatches&#125;, the response buffer and
     * headers will not be reset, and it is legal to dispatch even if the
     * response has already been committed.
     *
     * &lt;p&gt;Control over the request and response is delegated
     * to the dispatch target, and the response will be closed when the
     * dispatch target has completed execution, unless
     * &#123;@link ServletRequest#startAsync()&#125; or
     * &#123;@link ServletRequest#startAsync(ServletRequest, ServletResponse)&#125;
     * are called.
     * 
     * &lt;p&gt;Any errors or exceptions that may occur during the execution
     * of this method must be caught and handled by the container, as
     * follows:
     * &lt;ol&gt;
     * &lt;li&gt;Invoke, at their &#123;@link AsyncListener#onError onError&#125; method, all
     * &#123;@link AsyncListener&#125; instances registered with the ServletRequest
     * for which this AsyncContext was created, and make the caught 
     * &lt;tt&gt;Throwable&lt;/tt&gt; available via &#123;@link AsyncEvent#getThrowable&#125;.&lt;/li&gt;
     * &lt;li&gt;If none of the listeners called &#123;@link #complete&#125; or any of the
     * &#123;@link #dispatch&#125; methods, perform an error dispatch with a status code
     * equal to &lt;tt&gt;HttpServletResponse.SC_INTERNAL_SERVER_ERROR&lt;/tt&gt;, and
     * make the above &lt;tt&gt;Throwable&lt;/tt&gt; available as the value of the
     * &lt;tt&gt;RequestDispatcher.ERROR_EXCEPTION&lt;/tt&gt; request attribute.&lt;/li&gt;
     * &lt;li&gt;If no matching error page was found, or the error page did not call
     * &#123;@link #complete&#125; or any of the &#123;@link #dispatch&#125; methods, call
     * &#123;@link #complete&#125;.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;There can be at most one asynchronous dispatch operation per
     * asynchronous cycle, which is started by a call to one of the
     * &#123;@link ServletRequest#startAsync&#125; methods. Any attempt to perform an
     * additional asynchronous dispatch operation within the same
     * asynchronous cycle will result in an IllegalStateException.
     * If startAsync is subsequently called on the dispatched request,
     * then any of the dispatch or &#123;@link #complete&#125; methods may be called.
     *
     * @throws IllegalStateException if one of the dispatch methods
     * has been called and the startAsync method has not been
     * called during the resulting dispatch, or if &#123;@link #complete&#125;
     * was called
     *
     * @see ServletRequest#getDispatcherType
     */
    public void dispatch();


    /**
     * Dispatches the request and response objects of this AsyncContext
     * to the given &lt;tt&gt;path&lt;/tt&gt;.
     *
     * &lt;p&gt;The &lt;tt&gt;path&lt;/tt&gt; parameter is interpreted in the same way 
     * as in &#123;@link ServletRequest#getRequestDispatcher(String)&#125;, within
     * the scope of the &#123;@link ServletContext&#125; from which this
     * AsyncContext was initialized.
     *
     * &lt;p&gt;All path related query methods of the request must reflect the
     * dispatch target, while the original request URI, context path,
     * path info, servlet path, and query string may be recovered from
     * the &#123;@link #ASYNC_REQUEST_URI&#125;, &#123;@link #ASYNC_CONTEXT_PATH&#125;,
     * &#123;@link #ASYNC_PATH_INFO&#125;, &#123;@link #ASYNC_SERVLET_PATH&#125;, and
     * &#123;@link #ASYNC_QUERY_STRING&#125; attributes of the request. These
     * attributes will always reflect the original path elements, even under
     * repeated dispatches.
     *
     * &lt;p&gt;There can be at most one asynchronous dispatch operation per
     * asynchronous cycle, which is started by a call to one of the
     * &#123;@link ServletRequest#startAsync&#125; methods. Any attempt to perform an
     * additional asynchronous dispatch operation within the same
     * asynchronous cycle will result in an IllegalStateException.
     * If startAsync is subsequently called on the dispatched request,
     * then any of the dispatch or &#123;@link #complete&#125; methods may be called.
     *
     * &lt;p&gt;See &#123;@link #dispatch()&#125; for additional details, including error
     * handling.
     *
     * @param path the path of the dispatch target, scoped to the
     * ServletContext from which this AsyncContext was initialized
     *
     * @throws IllegalStateException if one of the dispatch methods
     * has been called and the startAsync method has not been
     * called during the resulting dispatch, or if &#123;@link #complete&#125;
     * was called
     *
     * @see ServletRequest#getDispatcherType
     */
    public void dispatch(String path);


    /**
     * Dispatches the request and response objects of this AsyncContext
     * to the given &lt;tt&gt;path&lt;/tt&gt; scoped to the given &lt;tt&gt;context&lt;/tt&gt;.
     *
     * &lt;p&gt;The &lt;tt&gt;path&lt;/tt&gt; parameter is interpreted in the same way 
     * as in &#123;@link ServletRequest#getRequestDispatcher(String)&#125;, except that
     * it is scoped to the given &lt;tt&gt;context&lt;/tt&gt;.
     *
     * &lt;p&gt;All path related query methods of the request must reflect the
     * dispatch target, while the original request URI, context path,
     * path info, servlet path, and query string may be recovered from
     * the &#123;@link #ASYNC_REQUEST_URI&#125;, &#123;@link #ASYNC_CONTEXT_PATH&#125;,
     * &#123;@link #ASYNC_PATH_INFO&#125;, &#123;@link #ASYNC_SERVLET_PATH&#125;, and
     * &#123;@link #ASYNC_QUERY_STRING&#125; attributes of the request. These
     * attributes will always reflect the original path elements, even under
     * repeated dispatches.
     *
     * &lt;p&gt;There can be at most one asynchronous dispatch operation per
     * asynchronous cycle, which is started by a call to one of the
     * &#123;@link ServletRequest#startAsync&#125; methods. Any attempt to perform an
     * additional asynchronous dispatch operation within the same
     * asynchronous cycle will result in an IllegalStateException.
     * If startAsync is subsequently called on the dispatched request,
     * then any of the dispatch or &#123;@link #complete&#125; methods may be called.
     *
     * &lt;p&gt;See &#123;@link #dispatch()&#125; for additional details, including error
     * handling.
     *
     * @param context the ServletContext of the dispatch target
     * @param path the path of the dispatch target, scoped to the given
     * ServletContext
     *
     * @throws IllegalStateException if one of the dispatch methods
     * has been called and the startAsync method has not been
     * called during the resulting dispatch, or if &#123;@link #complete&#125;
     * was called
     *
     * @see ServletRequest#getDispatcherType
     */
    public void dispatch(ServletContext context, String path);


    /**
     * Completes the asynchronous operation that was started on the request
     * that was used to initialze this AsyncContext, closing the response
     * that was used to initialize this AsyncContext.
     *
     * &lt;p&gt;Any listeners of type &#123;@link AsyncListener&#125; that were registered
     * with the ServletRequest for which this AsyncContext was created will
     * be invoked at their &#123;@link AsyncListener#onComplete(AsyncEvent)
     * onComplete&#125; method.
     *
     * &lt;p&gt;It is legal to call this method any time after a call to
     * &#123;@link ServletRequest#startAsync()&#125; or
     * &#123;@link ServletRequest#startAsync(ServletRequest, ServletResponse)&#125;,
     * and before a call to one of the &lt;tt&gt;dispatch&lt;/tt&gt; methods
     * of this class. 
     * If this method is called before the container-initiated dispatch
     * that called &lt;tt&gt;startAsync&lt;/tt&gt; has returned to the container, then
     * the call will not take effect (and any invocations of
     * &#123;@link AsyncListener#onComplete(AsyncEvent)&#125; will be delayed) until
     * after the container-initiated dispatch has returned to the container.
     */
    public void complete();


    /**
     * Causes the container to dispatch a thread, possibly from a managed
     * thread pool, to run the specified &lt;tt&gt;Runnable&lt;/tt&gt;. The container may
     * propagate appropriate contextual information to the &lt;tt&gt;Runnable&lt;/tt&gt;. 
     *
     * @param run the asynchronous handler
     */
    public void start(Runnable run);


    /**
     * Registers the given &#123;@link AsyncListener&#125; with the most recent
     * asynchronous cycle that was started by a call to one of the
     * &#123;@link ServletRequest#startAsync&#125; methods.
     *
     * &lt;p&gt;The given AsyncListener will receive an &#123;@link AsyncEvent&#125; when
     * the asynchronous cycle completes successfully, times out, or results
     * in an error.
     *
     * &lt;p&gt;AsyncListener instances will be notified in the order in which
     * they were added.
     *
     * @param listener the AsyncListener to be registered
     * 
     * @throws IllegalStateException if this method is called after
     * the container-initiated dispatch, during which one of the
     * &#123;@link ServletRequest#startAsync&#125; methods was called, has
     * returned to the container
     */
    public void addListener(AsyncListener listener);


    /**
     * Registers the given &#123;@link AsyncListener&#125; with the most recent
     * asynchronous cycle that was started by a call to one of the
     * &#123;@link ServletRequest#startAsync&#125; methods.
     *
     * &lt;p&gt;The given AsyncListener will receive an &#123;@link AsyncEvent&#125; when
     * the asynchronous cycle completes successfully, times out, or results
     * in an error.
     *
     * &lt;p&gt;AsyncListener instances will be notified in the order in which
     * they were added.
     *
     * &lt;p&gt;The given ServletRequest and ServletResponse objects will
     * be made available to the given AsyncListener via the
     * &#123;@link AsyncEvent#getSuppliedRequest getSuppliedRequest&#125; and
     * &#123;@link AsyncEvent#getSuppliedResponse getSuppliedResponse&#125; methods,
     * respectively, of the &#123;@link AsyncEvent&#125; delivered to it. These objects
     * should not be read from or written to, respectively, at the time the
     * AsyncEvent is delivered, because additional wrapping may have
     * occurred since the given AsyncListener was registered, but may be used
     * in order to release any resources associated with them.
     *
     * @param listener the AsyncListener to be registered
     * @param servletRequest the ServletRequest that will be included
     * in the AsyncEvent
     * @param servletResponse the ServletResponse that will be included
     * in the AsyncEvent
     *
     * @throws IllegalStateException if this method is called after
     * the container-initiated dispatch, during which one of the
     * &#123;@link ServletRequest#startAsync&#125; methods was called, has
     * returned to the container
     */
    public void addListener(AsyncListener listener,
                            ServletRequest servletRequest,
                            ServletResponse servletResponse);


    /**
     * Instantiates the given &#123;@link AsyncListener&#125; class.
     *
     * &lt;p&gt;The returned AsyncListener instance may be further customized
     * before it is registered with this AsyncContext via a call to one of 
     * the &lt;code&gt;addListener&lt;/code&gt; methods.
     *
     * &lt;p&gt;The given AsyncListener class must define a zero argument
     * constructor, which is used to instantiate it.
     *
     * &lt;p&gt;This method supports resource injection if the given
     * &lt;tt&gt;clazz&lt;/tt&gt; represents a Managed Bean.
     * See the Java EE platform and JSR 299 specifications for additional
     * details about Managed Beans and resource injection.

     * &lt;p&gt;This method supports any annotations applicable to AsyncListener.
     *
     * @param clazz the AsyncListener class to instantiate
     *
     * @return the new AsyncListener instance
     *
     * @throws ServletException if the given &lt;tt&gt;clazz&lt;/tt&gt; fails to be
     * instantiated
     */
    public &lt;T extends AsyncListener&gt; T createListener(Class&lt;T&gt; clazz)
        throws ServletException; 


    /**
     * Sets the timeout (in milliseconds) for this AsyncContext.
     *
     * &lt;p&gt;The timeout applies to this AsyncContext once the
     * container-initiated dispatch during which one of the
     * &#123;@link ServletRequest#startAsync&#125; methods was called has
     * returned to the container. 
     *
     * &lt;p&gt;The timeout will expire if neither the &#123;@link #complete&#125; method
     * nor any of the dispatch methods are called. A timeout value of
     * zero or less indicates no timeout. 
     * 
     * &lt;p&gt;If &#123;@link #setTimeout&#125; is not called, then the container&#39;s
     * default timeout, which is available via a call to
     * &#123;@link #getTimeout&#125;, will apply.
     *
     * @param timeout the timeout in milliseconds
     *
     * @throws IllegalStateException if this method is called after
     * the container-initiated dispatch, during which one of the
     * &#123;@link ServletRequest#startAsync&#125; methods was called, has
     * returned to the container
     */
    public void setTimeout(long timeout);


    /**
     * Gets the timeout (in milliseconds) for this AsyncContext.
     *
     * &lt;p&gt;This method returns the container&#39;s default timeout for
     * asynchronous operations, or the timeout value passed to the most
     * recent invocation of &#123;@link #setTimeout&#125;.
     *
     * &lt;p&gt;A timeout value of zero or less indicates no timeout.
     *
     * @return the timeout in milliseconds
     */
    public long getTimeout();

&#125;
</code></pre>
<pre><code> 比较简单，通过看代码中的注释就能知其大意了，异步就是不等待结果立即返回，这里start一般用新线程的方式，线程运行完后(#complete)，需要通知（#addListener）,以及超时检测处理（#setTimeout,由容器Tomcat来设置）
</code></pre>
<h4 id="AsyncListener监听器"><a href="#AsyncListener监听器" class="headerlink" title="AsyncListener监听器"></a>AsyncListener监听器</h4><pre><code class="java">package javax.servlet;

import java.io.IOException;
import java.util.EventListener;

/**
 * Listener that will be notified in the event that an asynchronous
 * operation initiated on a ServletRequest to which the listener had been 
 * added has completed, timed out, or resulted in an error.
 *
 * @since Servlet 3.0
 */
public interface AsyncListener extends EventListener &#123;
    
    /**
     * Notifies this AsyncListener that an asynchronous operation
     * has been completed.
     * 
     * &lt;p&gt;The &#123;@link AsyncContext&#125; corresponding to the asynchronous
     * operation that has been completed may be obtained by calling
     * &#123;@link AsyncEvent#getAsyncContext getAsyncContext&#125; on the given
     * &lt;tt&gt;event&lt;/tt&gt;.
     *
     * &lt;p&gt;In addition, if this AsyncListener had been registered via a call
     * to &#123;@link AsyncContext#addListener(AsyncListener,
     * ServletRequest, ServletResponse)&#125;, the supplied ServletRequest and
     * ServletResponse objects may be retrieved by calling
     * &#123;@link AsyncEvent#getSuppliedRequest getSuppliedRequest&#125; and
     * &#123;@link AsyncEvent#getSuppliedResponse getSuppliedResponse&#125;,
     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.
     *
     * @param event the AsyncEvent indicating that an asynchronous
     * operation has been completed
     *
     * @throws IOException if an I/O related error has occurred during the
     * processing of the given AsyncEvent
     */
    public void onComplete(AsyncEvent event) throws IOException;


    /**
     * Notifies this AsyncListener that an asynchronous operation
     * has timed out.
     * 
     * &lt;p&gt;The &#123;@link AsyncContext&#125; corresponding to the asynchronous
     * operation that has timed out may be obtained by calling
     * &#123;@link AsyncEvent#getAsyncContext getAsyncContext&#125; on the given
     * &lt;tt&gt;event&lt;/tt&gt;.
     *
     * &lt;p&gt;In addition, if this AsyncListener had been registered via a call
     * to &#123;@link AsyncContext#addListener(AsyncListener,
     * ServletRequest, ServletResponse)&#125;, the supplied ServletRequest and
     * ServletResponse objects may be retrieved by calling
     * &#123;@link AsyncEvent#getSuppliedRequest getSuppliedRequest&#125; and
     * &#123;@link AsyncEvent#getSuppliedResponse getSuppliedResponse&#125;,
     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.
     *
     * @param event the AsyncEvent indicating that an asynchronous
     * operation has timed out
     *
     * @throws IOException if an I/O related error has occurred during the
     * processing of the given AsyncEvent
     */
    public void onTimeout(AsyncEvent event) throws IOException;


    /**
     * Notifies this AsyncListener that an asynchronous operation 
     * has failed to complete.
     * 
     * &lt;p&gt;The &#123;@link AsyncContext&#125; corresponding to the asynchronous
     * operation that failed to complete may be obtained by calling
     * &#123;@link AsyncEvent#getAsyncContext getAsyncContext&#125; on the given
     * &lt;tt&gt;event&lt;/tt&gt;.
     * 
     * &lt;p&gt;In addition, if this AsyncListener had been registered via a call
     * to &#123;@link AsyncContext#addListener(AsyncListener,
     * ServletRequest, ServletResponse)&#125;, the supplied ServletRequest and
     * ServletResponse objects may be retrieved by calling
     * &#123;@link AsyncEvent#getSuppliedRequest getSuppliedRequest&#125; and
     * &#123;@link AsyncEvent#getSuppliedResponse getSuppliedResponse&#125;,
     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.
     *
     * @param event the AsyncEvent indicating that an asynchronous
     * operation has failed to complete
     *
     * @throws IOException if an I/O related error has occurred during the
     * processing of the given AsyncEvent
     */
    public void onError(AsyncEvent event) throws IOException;


    /**
     * Notifies this AsyncListener that a new asynchronous cycle is being
     * initiated via a call to one of the &#123;@link ServletRequest#startAsync&#125;
     * methods.
     *
     * &lt;p&gt;The &#123;@link AsyncContext&#125; corresponding to the asynchronous
     * operation that is being reinitialized may be obtained by calling
     * &#123;@link AsyncEvent#getAsyncContext getAsyncContext&#125; on the given
     * &lt;tt&gt;event&lt;/tt&gt;.
     * 
     * &lt;p&gt;In addition, if this AsyncListener had been registered via a call
     * to &#123;@link AsyncContext#addListener(AsyncListener,
     * ServletRequest, ServletResponse)&#125;, the supplied ServletRequest and
     * ServletResponse objects may be retrieved by calling
     * &#123;@link AsyncEvent#getSuppliedRequest getSuppliedRequest&#125; and
     * &#123;@link AsyncEvent#getSuppliedResponse getSuppliedResponse&#125;,
     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.
     *
     * &lt;p&gt;This AsyncListener will not receive any events related to the
     * new asynchronous cycle unless it registers itself (via a call
     * to &#123;@link AsyncContext#addListener&#125;) with the AsyncContext that
     * is delivered as part of the given AsyncEvent.
     *
     * @param event the AsyncEvent indicating that a new asynchronous
     * cycle is being initiated
     *
     * @throws IOException if an I/O related error has occurred during the
     * processing of the given AsyncEvent
     */
    public void onStartAsync(AsyncEvent event) throws IOException;     

&#125;
</code></pre>
<p>​	监听器主要有4个事件，开始、完成、超时、错误。</p>
<h3 id="SpringMVC中的相关组件"><a href="#SpringMVC中的相关组件" class="headerlink" title="SpringMVC中的相关组件"></a>SpringMVC中的相关组件</h3><p>​	SpringMVC中异步请求相关组件 AsyncWebRequest、WebAsyncManager、WebAsyncUtils	</p>
<h4 id="AsyncWebRequest"><a href="#AsyncWebRequest" class="headerlink" title="AsyncWebRequest"></a>AsyncWebRequest</h4><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fydgk0syd0j30u019f7aj.jpg" alt="image-20181220195645682"></p>
<p>其实现有两个，其中<code>NoSupportAsyncWebRequest</code>不支持异步，所以我们只需要关注<code>StandarServletAsyncWebRequest</code>即可。（可以看到其实主要是对Servelt中支持异步的类的一些特性进行整合）</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fydgqk142nj31bm0pawie.jpg" alt="image-20181220200306736"></p>
<blockquote>
<p>具体细节看StandarServletAsyncWebRequest的实现</p>
</blockquote>
<h4 id="WebAsyncManager"><a href="#WebAsyncManager" class="headerlink" title="WebAsyncManager"></a>WebAsyncManager</h4><pre><code class="java">package org.springframework.web.context.request.async;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.task.AsyncTaskExecutor;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.util.Assert;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.async.DeferredResult.DeferredResultHandler;
import org.springframework.web.util.UrlPathHelper;

/**
 * The central class for managing asynchronous request processing, mainly intended
 * as an SPI and not typically used directly by application classes.
 *
 * &lt;p&gt;An async scenario starts with request processing as usual in a thread (T1).
 * Concurrent request handling can be initiated by calling
 * &#123;@link #startCallableProcessing(Callable, Object...) startCallableProcessing&#125; or
 * &#123;@link #startDeferredResultProcessing(DeferredResult, Object...) startDeferredResultProcessing&#125;,
 * both of which produce a result in a separate thread (T2). The result is saved
 * and the request dispatched to the container, to resume processing with the saved
 * result in a third thread (T3). Within the dispatched thread (T3), the saved
 * result can be accessed via &#123;@link #getConcurrentResult()&#125; or its presence
 * detected via &#123;@link #hasConcurrentResult()&#125;.
 *
 * @author Rossen Stoyanchev
 * @since 3.2
 *
 * @see org.springframework.web.context.request.AsyncWebRequestInterceptor
 * @see org.springframework.web.servlet.AsyncHandlerInterceptor
 * @see org.springframework.web.filter.OncePerRequestFilter#shouldNotFilterAsyncDispatch
 * @see org.springframework.web.filter.OncePerRequestFilter#isAsyncDispatch
 */
public final class WebAsyncManager &#123;

   private static final Object RESULT_NONE = new Object();

   private static final Log logger = LogFactory.getLog(WebAsyncManager.class);

   private static final UrlPathHelper urlPathHelper = new UrlPathHelper();

   private static final CallableProcessingInterceptor timeoutCallableInterceptor =
         new TimeoutCallableProcessingInterceptor();

   private static final DeferredResultProcessingInterceptor timeoutDeferredResultInterceptor =
         new TimeoutDeferredResultProcessingInterceptor();


   private AsyncWebRequest asyncWebRequest;

   private AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(this.getClass().getSimpleName());

   private Object concurrentResult = RESULT_NONE;

   private Object[] concurrentResultContext;

   private final Map&lt;Object, CallableProcessingInterceptor&gt; callableInterceptors =
         new LinkedHashMap&lt;Object, CallableProcessingInterceptor&gt;();

   private final Map&lt;Object, DeferredResultProcessingInterceptor&gt; deferredResultInterceptors =
         new LinkedHashMap&lt;Object, DeferredResultProcessingInterceptor&gt;();


   /**
    * Package private constructor.
    * @see WebAsyncUtils#getAsyncManager(javax.servlet.ServletRequest)
    * @see WebAsyncUtils#getAsyncManager(org.springframework.web.context.request.WebRequest)
    */
   WebAsyncManager() &#123;
   &#125;

   /**
    * Configure the &#123;@link AsyncWebRequest&#125; to use. This property may be set
    * more than once during a single request to accurately reflect the current
    * state of the request (e.g. following a forward, request/response
    * wrapping, etc). However, it should not be set while concurrent handling
    * is in progress, i.e. while &#123;@link #isConcurrentHandlingStarted()&#125; is
    * &#123;@code true&#125;.
    *
    * @param asyncWebRequest the web request to use
    */
   public void setAsyncWebRequest(final AsyncWebRequest asyncWebRequest) &#123;
      Assert.notNull(asyncWebRequest, &quot;AsyncWebRequest must not be null&quot;);
      Assert.state(!isConcurrentHandlingStarted(), &quot;Can&#39;t set AsyncWebRequest with concurrent handling in progress&quot;);
      this.asyncWebRequest = asyncWebRequest;
      this.asyncWebRequest.addCompletionHandler(new Runnable() &#123;
         @Override
         public void run() &#123;
            asyncWebRequest.removeAttribute(WebAsyncUtils.WEB_ASYNC_MANAGER_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);
         &#125;
      &#125;);
   &#125;

   /**
    * Configure an AsyncTaskExecutor for use with concurrent processing via
    * &#123;@link #startCallableProcessing(Callable, Object...)&#125;.
    * &lt;p&gt;By default a &#123;@link SimpleAsyncTaskExecutor&#125; instance is used.
    */
   public void setTaskExecutor(AsyncTaskExecutor taskExecutor) &#123;
      this.taskExecutor = taskExecutor;
   &#125;

   /**
    * Whether the selected handler for the current request chose to handle the
    * request asynchronously. A return value of &quot;true&quot; indicates concurrent
    * handling is under way and the response will remain open. A return value
    * of &quot;false&quot; means concurrent handling was either not started or possibly
    * that it has completed and the request was dispatched for further
    * processing of the concurrent result.
    */
   public boolean isConcurrentHandlingStarted() &#123;
      return ((this.asyncWebRequest != null) &amp;&amp; this.asyncWebRequest.isAsyncStarted());
   &#125;

   /**
    * Whether a result value exists as a result of concurrent handling.
    */
   public boolean hasConcurrentResult() &#123;
      return (this.concurrentResult != RESULT_NONE);
   &#125;

   /**
    * Provides access to the result from concurrent handling.
    *
    * @return an Object, possibly an &#123;@code Exception&#125; or &#123;@code Throwable&#125; if
    * concurrent handling raised one.
    * @see #clearConcurrentResult()
    */
   public Object getConcurrentResult() &#123;
      return this.concurrentResult;
   &#125;

   /**
    * Provides access to additional processing context saved at the start of
    * concurrent handling.
    *
    * @see #clearConcurrentResult()
    */
   public Object[] getConcurrentResultContext() &#123;
      return this.concurrentResultContext;
   &#125;

   /**
    * Get the &#123;@link CallableProcessingInterceptor&#125; registered under the given key.
    * @param key the key
    * @return the interceptor registered under that key or &#123;@code null&#125;
    */
   public CallableProcessingInterceptor getCallableInterceptor(Object key) &#123;
      return this.callableInterceptors.get(key);
   &#125;

   /**
    * Get the &#123;@link DeferredResultProcessingInterceptor&#125; registered under the given key.
    * @param key the key
    * @return the interceptor registered under that key or &#123;@code null&#125;
    */
   public DeferredResultProcessingInterceptor getDeferredResultInterceptor(Object key) &#123;
      return this.deferredResultInterceptors.get(key);
   &#125;

   /**
    * Register a &#123;@link CallableProcessingInterceptor&#125; under the given key.
    * @param key the key
    * @param interceptor the interceptor to register
    */
   public void registerCallableInterceptor(Object key, CallableProcessingInterceptor interceptor) &#123;
      Assert.notNull(key, &quot;Key is required&quot;);
      Assert.notNull(interceptor, &quot;CallableProcessingInterceptor  is required&quot;);
      this.callableInterceptors.put(key, interceptor);
   &#125;

   /**
    * Register a &#123;@link CallableProcessingInterceptor&#125; without a key.
    * The key is derived from the class name and hashcode.
    * @param interceptors one or more interceptors to register
    */
   public void registerCallableInterceptors(CallableProcessingInterceptor... interceptors) &#123;
      Assert.notNull(interceptors, &quot;A CallableProcessingInterceptor is required&quot;);
      for (CallableProcessingInterceptor interceptor : interceptors) &#123;
         String key = interceptor.getClass().getName() + &quot;:&quot; + interceptor.hashCode();
         this.callableInterceptors.put(key, interceptor);
      &#125;
   &#125;

   /**
    * Register a &#123;@link DeferredResultProcessingInterceptor&#125; under the given key.
    * @param key the key
    * @param interceptor the interceptor to register
    */
   public void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor) &#123;
      Assert.notNull(key, &quot;Key is required&quot;);
      Assert.notNull(interceptor, &quot;DeferredResultProcessingInterceptor is required&quot;);
      this.deferredResultInterceptors.put(key, interceptor);
   &#125;

   /**
    * Register a &#123;@link DeferredResultProcessingInterceptor&#125; without a key.
    * The key is derived from the class name and hashcode.
    * @param interceptors one or more interceptors to register
    */
   public void registerDeferredResultInterceptors(DeferredResultProcessingInterceptor... interceptors) &#123;
      Assert.notNull(interceptors, &quot;A DeferredResultProcessingInterceptor is required&quot;);
      for (DeferredResultProcessingInterceptor interceptor : interceptors) &#123;
         String key = interceptors.getClass().getName() + &quot;:&quot; + interceptors.hashCode();
         this.deferredResultInterceptors.put(key, interceptor);
      &#125;
   &#125;

   /**
    * Clear &#123;@linkplain #getConcurrentResult() concurrentResult&#125; and
    * &#123;@linkplain #getConcurrentResultContext() concurrentResultContext&#125;.
    */
   public void clearConcurrentResult() &#123;
      this.concurrentResult = RESULT_NONE;
      this.concurrentResultContext = null;
   &#125;

   /**
    * Start concurrent request processing and execute the given task with an
    * &#123;@link #setTaskExecutor(AsyncTaskExecutor) AsyncTaskExecutor&#125;. The result
    * from the task execution is saved and the request dispatched in order to
    * resume processing of that result. If the task raises an Exception then
    * the saved result will be the raised Exception.
    *
    * @param callable a unit of work to be executed asynchronously
    * @param processingContext additional context to save that can be accessed
    * via &#123;@link #getConcurrentResultContext()&#125;
    * @throws Exception If concurrent processing failed to start
    *
    * @see #getConcurrentResult()
    * @see #getConcurrentResultContext()
    */
   @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)
   public void startCallableProcessing(final Callable&lt;?&gt; callable, Object... processingContext) throws Exception &#123;
      Assert.notNull(callable, &quot;Callable must not be null&quot;);
      startCallableProcessing(new WebAsyncTask(callable), processingContext);
   &#125;

   /**
    * Use the given &#123;@link WebAsyncTask&#125; to configure the task executor as well as
    * the timeout value of the &#123;@code AsyncWebRequest&#125; before delegating to
    * &#123;@link #startCallableProcessing(Callable, Object...)&#125;.
    *
    * @param webAsyncTask a WebAsyncTask containing the target &#123;@code Callable&#125;
    * @param processingContext additional context to save that can be accessed
    * via &#123;@link #getConcurrentResultContext()&#125;
    * @throws Exception If concurrent processing failed to start
    */
   public void startCallableProcessing(final WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext) throws Exception &#123;
      Assert.notNull(webAsyncTask, &quot;WebAsyncTask must not be null&quot;);
      Assert.state(this.asyncWebRequest != null, &quot;AsyncWebRequest must not be null&quot;);

      Long timeout = webAsyncTask.getTimeout();
      if (timeout != null) &#123;
         this.asyncWebRequest.setTimeout(timeout);
      &#125;

      AsyncTaskExecutor executor = webAsyncTask.getExecutor();
      if (executor != null) &#123;
         this.taskExecutor = executor;
      &#125;

      List&lt;CallableProcessingInterceptor&gt; interceptors = new ArrayList&lt;CallableProcessingInterceptor&gt;();
      interceptors.add(webAsyncTask.getInterceptor());
      interceptors.addAll(this.callableInterceptors.values());
      interceptors.add(timeoutCallableInterceptor);

      final Callable&lt;?&gt; callable = webAsyncTask.getCallable();
      final CallableInterceptorChain interceptorChain = new CallableInterceptorChain(interceptors);

      this.asyncWebRequest.addTimeoutHandler(new Runnable() &#123;
         @Override
         public void run() &#123;
            logger.debug(&quot;Processing timeout&quot;);
            Object result = interceptorChain.triggerAfterTimeout(asyncWebRequest, callable);
            if (result != CallableProcessingInterceptor.RESULT_NONE) &#123;
               setConcurrentResultAndDispatch(result);
            &#125;
         &#125;
      &#125;);

      this.asyncWebRequest.addCompletionHandler(new Runnable() &#123;
         @Override
         public void run() &#123;
            interceptorChain.triggerAfterCompletion(asyncWebRequest, callable);
         &#125;
      &#125;);

      interceptorChain.applyBeforeConcurrentHandling(asyncWebRequest, callable);

      startAsyncProcessing(processingContext);

      this.taskExecutor.submit(new Runnable() &#123;
         @Override
         public void run() &#123;
            Object result = null;
            try &#123;
               interceptorChain.applyPreProcess(asyncWebRequest, callable);
               result = callable.call();
            &#125;
            catch (Throwable t) &#123;
               result = t;
            &#125;
            finally &#123;
               result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result);
            &#125;
            setConcurrentResultAndDispatch(result);
         &#125;
      &#125;);
   &#125;

   private void setConcurrentResultAndDispatch(Object result) &#123;
      synchronized (WebAsyncManager.this) &#123;
         if (hasConcurrentResult()) &#123;
            return;
         &#125;
         concurrentResult = result;
      &#125;

      if (asyncWebRequest.isAsyncComplete()) &#123;
         logger.error(&quot;Could not complete async processing due to timeout or network error&quot;);
         return;
      &#125;

      logger.debug(&quot;Concurrent result value [&quot; + concurrentResult + &quot;]&quot;);
      logger.debug(&quot;Dispatching request to resume processing&quot;);

      asyncWebRequest.dispatch();
   &#125;

   /**
    * Start concurrent request processing and initialize the given
    * &#123;@link DeferredResult&#125; with a &#123;@link DeferredResultHandler&#125; that saves
    * the result and dispatches the request to resume processing of that
    * result. The &#123;@code AsyncWebRequest&#125; is also updated with a completion
    * handler that expires the &#123;@code DeferredResult&#125; and a timeout handler
    * assuming the &#123;@code DeferredResult&#125; has a default timeout result.
    *
    * @param deferredResult the DeferredResult instance to initialize
    * @param processingContext additional context to save that can be accessed
    * via &#123;@link #getConcurrentResultContext()&#125;
    * @throws Exception If concurrent processing failed to start
    *
    * @see #getConcurrentResult()
    * @see #getConcurrentResultContext()
    */
   public void startDeferredResultProcessing(
         final DeferredResult&lt;?&gt; deferredResult, Object... processingContext) throws Exception &#123;

      Assert.notNull(deferredResult, &quot;DeferredResult must not be null&quot;);
      Assert.state(this.asyncWebRequest != null, &quot;AsyncWebRequest must not be null&quot;);

      Long timeout = deferredResult.getTimeoutValue();
      if (timeout != null) &#123;
         this.asyncWebRequest.setTimeout(timeout);
      &#125;

      List&lt;DeferredResultProcessingInterceptor&gt; interceptors = new ArrayList&lt;DeferredResultProcessingInterceptor&gt;();
      interceptors.add(deferredResult.getInterceptor());
      interceptors.addAll(this.deferredResultInterceptors.values());
      interceptors.add(timeoutDeferredResultInterceptor);

      final DeferredResultInterceptorChain interceptorChain = new DeferredResultInterceptorChain(interceptors);

      this.asyncWebRequest.addTimeoutHandler(new Runnable() &#123;
         @Override
         public void run() &#123;
            try &#123;
               interceptorChain.triggerAfterTimeout(asyncWebRequest, deferredResult);
            &#125;
            catch (Throwable t) &#123;
               setConcurrentResultAndDispatch(t);
            &#125;
         &#125;
      &#125;);

      this.asyncWebRequest.addCompletionHandler(new Runnable() &#123;
         @Override
         public void run() &#123;
            interceptorChain.triggerAfterCompletion(asyncWebRequest, deferredResult);
         &#125;
      &#125;);

      interceptorChain.applyBeforeConcurrentHandling(asyncWebRequest, deferredResult);

      startAsyncProcessing(processingContext);

      try &#123;
         interceptorChain.applyPreProcess(this.asyncWebRequest, deferredResult);
         deferredResult.setResultHandler(new DeferredResultHandler() &#123;
            @Override
            public void handleResult(Object result) &#123;
               result = interceptorChain.applyPostProcess(asyncWebRequest, deferredResult, result);
               setConcurrentResultAndDispatch(result);
            &#125;
         &#125;);
      &#125;
      catch (Throwable t) &#123;
         setConcurrentResultAndDispatch(t);
      &#125;
   &#125;

   private void startAsyncProcessing(Object[] processingContext) &#123;

      clearConcurrentResult();
      this.concurrentResultContext = processingContext;

      this.asyncWebRequest.startAsync();

      if (logger.isDebugEnabled()) &#123;
         HttpServletRequest request = this.asyncWebRequest.getNativeRequest(HttpServletRequest.class);
         String requestUri = urlPathHelper.getRequestUri(request);
         logger.debug(&quot;Concurrent handling starting for &quot; + request.getMethod() + &quot; [&quot; + requestUri + &quot;]&quot;);
      &#125;
   &#125;

&#125;
</code></pre>
<p>​	类中有两个重要的方法#startCallableProcessing（用于处理Callable和WebAsyncTask类型），#startDeferredResultProcessing（用于处理DeferredResult和ListenableFuture类型）,是启动异步处理的入口方法，它们一共做了三件事</p>
<ul>
<li>启动异步处理</li>
<li>给Request设置相应属性（timeout、timeoutHandler和completionHandler）</li>
<li>在相应的位置调用相应的拦截器（CallableProcessingInterceptor和DeferredResultProcessingInterceptor都封装在相应的Chain中）</li>
</ul>
<blockquote>
<p>更多细节 可查看startCallableProcessing的执行过程</p>
</blockquote>
<h4 id="WebAsyncUtils"><a href="#WebAsyncUtils" class="headerlink" title="WebAsyncUtils"></a>WebAsyncUtils</h4><pre><code class="java">package org.springframework.web.context.request.async;

import java.lang.reflect.Constructor;

import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.BeanUtils;
import org.springframework.util.ClassUtils;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.WebRequest;

/**
 * Utility methods related to processing asynchronous web requests.
 *
 * @author Rossen Stoyanchev
 * @since 3.2
 */
public abstract class WebAsyncUtils &#123;

   public static final String WEB_ASYNC_MANAGER_ATTRIBUTE = WebAsyncManager.class.getName() + &quot;.WEB_ASYNC_MANAGER&quot;;

   private static Constructor&lt;?&gt; standardAsyncRequestConstructor;


   /**
    * Obtain the &#123;@link WebAsyncManager&#125; for the current request, or if not
    * found, create and associate it with the request.
    */
   public static WebAsyncManager getAsyncManager(ServletRequest servletRequest) &#123;
      WebAsyncManager asyncManager = (WebAsyncManager) servletRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE);
      if (asyncManager == null) &#123;
         asyncManager = new WebAsyncManager();
         servletRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager);
      &#125;
      return asyncManager;
   &#125;

   /**
    * Obtain the &#123;@link WebAsyncManager&#125; for the current request, or if not
    * found, create and associate it with the request.
    */
   public static WebAsyncManager getAsyncManager(WebRequest webRequest) &#123;
      int scope = RequestAttributes.SCOPE_REQUEST;
      WebAsyncManager asyncManager = (WebAsyncManager) webRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, scope);
      if (asyncManager == null) &#123;
         asyncManager = new WebAsyncManager();
         webRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager, scope);
      &#125;
      return asyncManager;
   &#125;

   /**
    * Create an AsyncWebRequest instance. By default an instance of
    * &#123;@link StandardServletAsyncWebRequest&#125; is created if running in Servlet
    * 3.0 (or higher) environment or as a fallback, an instance of
    * &#123;@link NoSupportAsyncWebRequest&#125; is returned.
    *
    * @param request the current request
    * @param response the current response
    * @return an AsyncWebRequest instance, never &#123;@code null&#125;
    */
   public static AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) &#123;
      return ClassUtils.hasMethod(ServletRequest.class, &quot;startAsync&quot;) ?
            createStandardServletAsyncWebRequest(request, response) : new NoSupportAsyncWebRequest(request, response);
   &#125;

   private static AsyncWebRequest createStandardServletAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) &#123;
      try &#123;
         if (standardAsyncRequestConstructor == null) &#123;
            String className = &quot;org.springframework.web.context.request.async.StandardServletAsyncWebRequest&quot;;
            Class&lt;?&gt; clazz = ClassUtils.forName(className, WebAsyncUtils.class.getClassLoader());
            standardAsyncRequestConstructor = clazz.getConstructor(HttpServletRequest.class, HttpServletResponse.class);
         &#125;
         return (AsyncWebRequest) BeanUtils.instantiateClass(standardAsyncRequestConstructor, request, response);
      &#125;
      catch (Throwable t) &#123;
         throw new IllegalStateException(&quot;Failed to instantiate StandardServletAsyncWebRequest&quot;, t);
      &#125;
   &#125;

&#125;
</code></pre>
<p>​	可以看到这个类主要是提供WebAsyncManage、AsyncWebRequest 相关的操作</p>
<h3 id="SpringMVC中请求的支持"><a href="#SpringMVC中请求的支持" class="headerlink" title="SpringMVC中请求的支持"></a>SpringMVC中请求的支持</h3><ol>
<li><p><code>FrameworkServlet</code>中添加了<code>RequestBindingInterceptor</code></p>
</li>
<li><p><code>RequestMappingHandlerAdapter</code>的<code>#invokeHandlerMethod</code> 提供了对异步请求的核心支持</p>
<p> ​	2.1 创建<code>AsyncWebRequest</code>并设置超时时间</p>
<p> ​	2.2 对当前请求<code>WebAsyncManager</code>设置了属性<code>（taskExecutor、asyncWebRequest、callabltinterceptors和deferredResultInterceptors）</code></p>
<p> ​	2.3 并判断是否有结果，如果有对结果进行处理。<code>requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</code></p>
<p> ​	2.4 然后执行方法 <code>requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</code></p>
</li>
<li><p>返回值处理器，<code>AsyncTaskMethodReturnValueHandler</code> <code>CallableMethodReturnValueHandler</code> <code>DeferredResultMethodReturnValueHandler</code> <code>ListenableFutureReturnValueHandler</code></p>
</li>
<li><p><code>DispatcherServlet</code>的<code>#doDispatcher</code>，如果是异步直接返回。</p>
</li>
</ol>
<pre><code class="java">/**
 * Invoke the &#123;@link RequestMapping&#125; handler method preparing a &#123;@link ModelAndView&#125;
 * if view resolution is required.
 */
private ModelAndView invokeHandleMethod(HttpServletRequest request,
      HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

   ServletWebRequest webRequest = new ServletWebRequest(request, response);

   WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
   ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
   ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);

   ModelAndViewContainer mavContainer = new ModelAndViewContainer();
   mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
   modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);
   mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

   AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
   asyncWebRequest.setTimeout(this.asyncRequestTimeout);

   final WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
   asyncManager.setTaskExecutor(this.taskExecutor);
   asyncManager.setAsyncWebRequest(asyncWebRequest);
   asyncManager.registerCallableInterceptors(this.callableInterceptors);
   asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

   if (asyncManager.hasConcurrentResult()) &#123;
      Object result = asyncManager.getConcurrentResult();
      mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
      asyncManager.clearConcurrentResult();

      if (logger.isDebugEnabled()) &#123;
         logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
      &#125;
      requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);
   &#125;

   requestMappingMethod.invokeAndHandle(webRequest, mavContainer);

   if (asyncManager.isConcurrentHandlingStarted()) &#123;
      return null;
   &#125;

   return getModelAndView(mavContainer, modelFactory, webRequest);
&#125;
</code></pre>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="spring-webFlux"><a href="#spring-webFlux" class="headerlink" title="spring webFlux"></a>spring webFlux</h3><p>等待填坑</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 951488791@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>servlet_spring-mvc</p>
    <p><span class="copy-title">字数:</span><span class="post-count">11.6k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="zhengyumin">zhengyumin</a></p>
    <p><span class="copy-title">发布时间:</span>2019-02-03, 15:50:16</p>
    <p><span class="copy-title">最后更新:</span>2020-01-25, 16:27:29</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/02/03/spring-mvc/" title="servlet_spring-mvc">http://yoursite.com/2019/02/03/spring-mvc/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#34;署名-非商用-相同方式共享 4.0&#34;</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2022 zhengyumin
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
