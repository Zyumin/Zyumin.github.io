<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>JDK_ReentrantLock | Zyumin</title>
  <meta name="keywords" content=" jdk , juc ">
  <meta name="description" content="JDK_ReentrantLock | Zyumin">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta name="keywords" content="java">
<meta property="og:type" content="website">
<meta property="og:title" content="tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="Zyumin">
<meta property="og:description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-23T07:09:56.946Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tags">
<meta name="twitter:description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/github-gist.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1.0.1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.png">
</a>
<div class="author">
    <span>zhengyumin</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/Zyumin" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"/>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=60037019" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"/>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(43)</small></div></li>
    
        
            
            <li><div data-rel="jdk">jdk<small>(13)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="java">java<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="spring">spring<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="mysql">mysql<small>(2)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="43">
<input type="hidden" id="yelog_site_word_count" value="132.6k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="以 in: 开头进行全文搜索" autocomplete="off" id="local-search-input">
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none">
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">week</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">hide</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">jdk</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">packages</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">utils</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">note</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">jvm</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">juc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">classLoader</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">hotspot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">j2ee</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">distributed</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">kafka</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">framework</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">redis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">netty</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">nio</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">zookeeper</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Spec</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">thread</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">mysql</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">tomcat</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">lang</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">summary</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">io</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">serialization</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">file</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">gc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">ejb</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">elasticsearch</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">servlet</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">collections</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">map</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">spring-mvc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">spring-webflux</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">doc</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a id="top" class="java " href="/2019/02/02/Overview_java/" data-tag="summary" data-author="">
            <span class="post-title" title="Overview_java">Overview_java</span>
            <span class="post-date" title="2019-02-02 20:43:14">2019/02/02</span>
        </a>
        
        <a id="top" class="spring " href="/2019/03/02/Overview_Spring/" data-tag="spring,framework" data-author="">
            <span class="post-title" title="Overview-Spring">Overview-Spring</span>
            <span class="post-date" title="2019-03-02 12:29:06">2019/03/02</span>
        </a>
        
        <a id="top" class="jdk " href="/2019/06/13/Overview_JDK/" data-tag="jdk,hotspot" data-author="">
            <span class="post-title" title="Overview_JDK">Overview_JDK</span>
            <span class="post-date" title="2019-06-13 19:36:54">2019/06/13</span>
        </a>
        
        <a class="spring " href="/2019/12/02/spring-Q-A/" data-tag="spring" data-author="">
            <span class="post-title" title="spring Q&amp;A">spring Q&amp;A</span>
            <span class="post-date" title="2019-12-02 18:20:38">2019/12/02</span>
        </a>
        
        <a class="spring " href="/2019/10/29/Documentation-Spring-Core-IOC/" data-tag="spring,doc" data-author="">
            <span class="post-title" title="Documentation-Spring_Core_IOC">Documentation-Spring_Core_IOC</span>
            <span class="post-date" title="2019-10-29 21:51:07">2019/10/29</span>
        </a>
        
        <a class="jdk " href="/2019/09/26/JDK-Packages-java-nio/" data-tag="jdk,packages,nio" data-author="">
            <span class="post-title" title="JDK_Packages_java_nio">JDK_Packages_java_nio</span>
            <span class="post-date" title="2019-09-26 10:39:22">2019/09/26</span>
        </a>
        
        <a class="jdk " href="/2019/09/23/JDK-Packages-java-io/" data-tag="jdk,packages,io,serialization,file" data-author="">
            <span class="post-title" title="JDK_Packages_java_io">JDK_Packages_java_io</span>
            <span class="post-date" title="2019-09-23 16:07:43">2019/09/23</span>
        </a>
        
        <a class="jdk " href="/2019/08/31/JDK-Class/" data-tag="jdk" data-author="">
            <span class="post-title" title="JDK_Class">JDK_Class</span>
            <span class="post-date" title="2019-08-31 19:38:34">2019/08/31</span>
        </a>
        
        <a class="jdk " href="/2019/08/31/JDK-Thread/" data-tag="jdk,jvm,hotspot" data-author="">
            <span class="post-title" title="JDK_Thread">JDK_Thread</span>
            <span class="post-date" title="2019-08-31 18:16:08">2019/08/31</span>
        </a>
        
        <a class="java " href="/2019/08/29/JVM-main方法分析/" data-tag="java,jvm" data-author="">
            <span class="post-title" title="JVM_main方法分析">JVM_main方法分析</span>
            <span class="post-date" title="2019-08-29 23:38:13">2019/08/29</span>
        </a>
        
        <a class="jdk " href="/2019/08/24/JDK-ReentrantLock/" data-tag="jdk,juc" data-author="">
            <span class="post-title" title="JDK_ReentrantLock">JDK_ReentrantLock</span>
            <span class="post-date" title="2019-08-24 18:48:54">2019/08/24</span>
        </a>
        
        <a class="java " href="/2019/08/17/JVM-Synchronized/" data-tag="jvm" data-author="">
            <span class="post-title" title="JVM_Synchronized">JVM_Synchronized</span>
            <span class="post-date" title="2019-08-17 17:01:54">2019/08/17</span>
        </a>
        
        <a class="java " href="/2019/08/11/Overview-Java-Virtual-Machine/" data-tag="jvm" data-author="">
            <span class="post-title" title="Overview_Java Virtual Machine">Overview_Java Virtual Machine</span>
            <span class="post-date" title="2019-08-11 19:05:38">2019/08/11</span>
        </a>
        
        <a class="jdk " href="/2019/08/11/JDK-Packages-java-lang/" data-tag="jdk,packages,lang" data-author="">
            <span class="post-title" title="JDK_Packages_java_lang">JDK_Packages_java_lang</span>
            <span class="post-date" title="2019-08-11 19:04:56">2019/08/11</span>
        </a>
        
        <a class="jdk " href="/2019/08/11/JDK-Packages-java-utils/" data-tag="jdk,packages,utils" data-author="">
            <span class="post-title" title="JDK_Packages_java_utils">JDK_Packages_java_utils</span>
            <span class="post-date" title="2019-08-11 19:04:25">2019/08/11</span>
        </a>
        
        <a class="jdk " href="/2019/08/10/JDK-The-Concurrent-Framework/" data-tag="jdk,juc" data-author="">
            <span class="post-title" title="JDK_The Concurrent Framework">JDK_The Concurrent Framework</span>
            <span class="post-date" title="2019-08-10 19:45:39">2019/08/10</span>
        </a>
        
        <a class="jdk " href="/2019/07/29/JDK-The-Collections-Framework/" data-tag="jdk,collections" data-author="">
            <span class="post-title" title="JDK_The Collections Framework">JDK_The Collections Framework</span>
            <span class="post-date" title="2019-07-29 15:26:01">2019/07/29</span>
        </a>
        
        <a class="" href="/2019/07/10/Note-码农翻身/" data-tag="java,note" data-author="">
            <span class="post-title" title="Note_码农翻身">Note_码农翻身</span>
            <span class="post-date" title="2019-07-10 22:18:56">2019/07/10</span>
        </a>
        
        <a class="jdk " href="/2019/07/06/JDK-ClassLoader/" data-tag="jdk,classLoader" data-author="">
            <span class="post-title" title="JDK_ClassLoader">JDK_ClassLoader</span>
            <span class="post-date" title="2019-07-06 23:12:51">2019/07/06</span>
        </a>
        
        <a class="" href="/2019/06/26/Overview_Elasticsearch/" data-tag="framework,elasticsearch" data-author="">
            <span class="post-title" title="Overview_Elasticsearch">Overview_Elasticsearch</span>
            <span class="post-date" title="2019-06-26 18:06:48">2019/06/26</span>
        </a>
        
        <a class="jdk " href="/2019/06/24/J-U-C-ConcurrentHashMap/" data-tag="juc,map" data-author="">
            <span class="post-title" title="J.U.C_ConcurrentHashMap">J.U.C_ConcurrentHashMap</span>
            <span class="post-date" title="2019-06-24 19:03:29">2019/06/24</span>
        </a>
        
        <a class="java " href="/2019/06/19/JVM-Garbage-Collection/" data-tag="jvm,gc" data-author="">
            <span class="post-title" title="JVM_Garbage Collection">JVM_Garbage Collection</span>
            <span class="post-date" title="2019-06-19 00:28:10">2019/06/19</span>
        </a>
        
        <a class="jdk " href="/2019/06/16/J-U-C-InterruptedException/" data-tag="juc" data-author="">
            <span class="post-title" title="J.U.C_InterruptedException">J.U.C_InterruptedException</span>
            <span class="post-date" title="2019-06-16 16:09:43">2019/06/16</span>
        </a>
        
        <a class="java " href="/2019/06/14/Spec-JSR133/" data-tag="jvm,Spec,thread" data-author="">
            <span class="post-title" title="Spec_JSR133">Spec_JSR133</span>
            <span class="post-date" title="2019-06-14 19:26:57">2019/06/14</span>
        </a>
        
        <a class="java " href="/2019/06/13/Spec-Java-Virtual-Machine/" data-tag="jvm,Spec" data-author="">
            <span class="post-title" title="Spec_Java Virtual Machine">Spec_Java Virtual Machine</span>
            <span class="post-date" title="2019-06-13 17:25:17">2019/06/13</span>
        </a>
        
        <a class="" href="/2019/06/12/Overview_Kafka/" data-tag="kafka,framework" data-author="">
            <span class="post-title" title="kafka深入浅出">kafka深入浅出</span>
            <span class="post-date" title="2019-06-12 20:05:37">2019/06/12</span>
        </a>
        
        <a class="" href="/2019/06/10/Overview_Redis/" data-tag="framework,redis" data-author="">
            <span class="post-title" title="redis深入浅出">redis深入浅出</span>
            <span class="post-date" title="2019-06-10 18:33:40">2019/06/10</span>
        </a>
        
        <a class="" href="/2019/06/06/Note_java并发编程的艺术/" data-tag="java,note,juc" data-author="">
            <span class="post-title" title="Note_java并发编程的艺术">Note_java并发编程的艺术</span>
            <span class="post-date" title="2019-06-06 19:05:01">2019/06/06</span>
        </a>
        
        <a class="" href="/2019/06/05/Overview_Netty/" data-tag="framework,netty,nio" data-author="">
            <span class="post-title" title="Netty深入浅出">Netty深入浅出</span>
            <span class="post-date" title="2019-06-05 22:01:31">2019/06/05</span>
        </a>
        
        <a class="" href="/2019/06/05/Note_深入理解java虚拟机/" data-tag="java,note,jvm" data-author="">
            <span class="post-title" title="Note_深入理解java虚拟机">Note_深入理解java虚拟机</span>
            <span class="post-date" title="2019-06-05 21:12:25">2019/06/05</span>
        </a>
        
        <a class="mysql " href="/2019/06/04/Overview_MySQL/" data-tag="mysql" data-author="">
            <span class="post-title" title="MySQL深入浅出">MySQL深入浅出</span>
            <span class="post-date" title="2019-06-04 22:02:31">2019/06/04</span>
        </a>
        
        <a class="" href="/2019/06/03/Overview_Zookeeper/" data-tag="distributed,framework,zookeeper" data-author="">
            <span class="post-title" title="Zookeeper深入浅出">Zookeeper深入浅出</span>
            <span class="post-date" title="2019-06-03 21:15:05">2019/06/03</span>
        </a>
        
        <a class="" href="/2019/06/03/Overview_Distributed/" data-tag="distributed" data-author="">
            <span class="post-title" title="分布式理论基础">分布式理论基础</span>
            <span class="post-date" title="2019-06-03 20:34:37">2019/06/03</span>
        </a>
        
        <a class="spring " href="/2019/04/10/spring-api-1-0/" data-tag="spring" data-author="">
            <span class="post-title" title="spring-api-1.0">spring-api-1.0</span>
            <span class="post-date" title="2019-04-10 09:45:25">2019/04/10</span>
        </a>
        
        <a class="" href="/2019/04/01/3月第四周知识点记录/" data-tag="week,hide" data-author="">
            <span class="post-title" title="3月第四周知识点记录">3月第四周知识点记录</span>
            <span class="post-date" title="2019-04-01 09:51:07">2019/04/01</span>
        </a>
        
        <a class="mysql " href="/2019/03/30/记一次mysql查询in的思考/" data-tag="mysql" data-author="">
            <span class="post-title" title="记一次mysql查询in的思考">记一次mysql查询in的思考</span>
            <span class="post-date" title="2019-03-30 20:39:49">2019/03/30</span>
        </a>
        
        <a class="" href="/2019/03/26/记一次Broken-pipe问题的思考/" data-tag="tomcat" data-author="">
            <span class="post-title" title="记一次Broken pipe问题的思考">记一次Broken pipe问题的思考</span>
            <span class="post-date" title="2019-03-26 10:53:37">2019/03/26</span>
        </a>
        
        <a class="" href="/2019/03/24/3月第三周知识点记录/" data-tag="week,hide" data-author="">
            <span class="post-title" title="3月第三周知识点记录">3月第三周知识点记录</span>
            <span class="post-date" title="2019-03-24 20:55:31">2019/03/24</span>
        </a>
        
        <a class="" href="/2019/03/10/Note_Expert One-on-One-J2EE-Development-without-EJB/" data-tag="j2ee,spring,ejb" data-author="">
            <span class="post-title" title="Expert One-on-One J2EE Development without EJB">Expert One-on-One J2EE Development without EJB</span>
            <span class="post-date" title="2019-03-10 19:45:57">2019/03/10</span>
        </a>
        
        <a class="" href="/2019/03/10/Note_Expert-One-on-One-J2EE-Design-and-Development/" data-tag="j2ee,spring" data-author="">
            <span class="post-title" title="Expert One-on-One J2EE Design and Development">Expert One-on-One J2EE Design and Development</span>
            <span class="post-date" title="2019-03-10 19:45:18">2019/03/10</span>
        </a>
        
        <a class="spring " href="/2019/02/03/spring-mvc/" data-tag="spring,servlet,spring-mvc,spring-webflux" data-author="">
            <span class="post-title" title="servlet_spring-mvc">servlet_spring-mvc</span>
            <span class="post-date" title="2019-02-03 15:50:16">2019/02/03</span>
        </a>
        
        <a class="" href="/2019/02/03/Overview_Tomcat/" data-tag="tomcat,servlet" data-author="">
            <span class="post-title" title="servlet_tomcat">servlet_tomcat</span>
            <span class="post-date" title="2019-02-03 15:49:08">2019/02/03</span>
        </a>
        
        <a class="" href="/2019/02/02/Spec_Servlet/" data-tag="j2ee,servlet" data-author="">
            <span class="post-title" title="j2ee_servlet">j2ee_servlet</span>
            <span class="post-date" title="2019-02-02 18:05:54">2019/02/02</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-JDK-ReentrantLock" class="article article-type-post" itemscope="" itemprop="blogPost">
    
        <h1 class="article-title">JDK_ReentrantLock</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="jdk">jdk</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color4">jdk</a>
            
            <a href="javascript:" class="color4">juc</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title="更新时间: 2020-01-12 23:08:21">2019-08-24 18:48</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:6.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入锁-ReentrantLock-skeleton"><span class="toc-text">可重入锁(ReentrantLock skeleton)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类关系图-Class-Diagrams"><span class="toc-text">类关系图(Class Diagrams)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#框架细节-skeleton"><span class="toc-text">框架细节(skeleton)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#锁的实现-Lock-implement"><span class="toc-text">锁的实现(Lock implement)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#扩展功能-extended-capabilities"><span class="toc-text">扩展功能(extended capabilities)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象同步队列-AQS"><span class="toc-text">抽象同步队列(AQS )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-Diagrams"><span class="toc-text">Class Diagrams</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS-skeleton"><span class="toc-text">AQS skeleton</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#队列节点-Node"><span class="toc-text">队列节点(Node)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#数据结构-struct"><span class="toc-text">数据结构(struct)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#模式-mode"><span class="toc-text">模式(mode)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#状态-waitStatus"><span class="toc-text">状态(waitStatus)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#队列节点的相关操作-Node-operation"><span class="toc-text">队列节点的相关操作(Node operation)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#UnsupportedOperationException-method"><span class="toc-text">UnsupportedOperationException method</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Condition"><span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AQS-impl-example"><span class="toc-text">AQS impl example</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁-解锁分析-lock-unlock"><span class="toc-text">加锁/解锁分析 (lock /unlock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tryAcquire"><span class="toc-text">tryAcquire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addWaiter"><span class="toc-text">addWaiter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#acquireQueued"><span class="toc-text">acquireQueued</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#shouldParkAfterFailedAcquire"><span class="toc-text">shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#parkAndCheckInterrupt"><span class="toc-text">parkAndCheckInterrupt</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#队列状态"><span class="toc-text">队列状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一致性问题"><span class="toc-text">一致性问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#可见性问题"><span class="toc-text">可见性问题</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#条件分析-Condition"><span class="toc-text">条件分析(Condition)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类关系图-Class-Diagrams-1"><span class="toc-text">类关系图(Class Diagrams)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#await"><span class="toc-text">await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#addConditionWaiter"><span class="toc-text">addConditionWaiter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fullyRelease-释放Lock"><span class="toc-text">fullyRelease(释放Lock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#isOnSyncQueue-阻塞"><span class="toc-text">isOnSyncQueue(阻塞)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#checkInterruptWhileWaiting-检查是否被中断"><span class="toc-text">checkInterruptWhileWaiting (检查是否被中断)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#信号前中断的特殊情况"><span class="toc-text">信号前中断的特殊情况</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unlinkCancelledWaiters"><span class="toc-text">unlinkCancelledWaiters</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reportInterruptAfterWait"><span class="toc-text">reportInterruptAfterWait</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signal"><span class="toc-text">signal</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transferForSignal"><span class="toc-text">transferForSignal</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-1"><span class="toc-text">总结</span></a></li></ol></li>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过ReentrantLock  , 类来分析JUC包的基石 AbstractQueuedSynchronizer(后续简称 AQS)</p>
<ul>
<li>ReentrantLock skeleton</li>
<li>AQS  skeleton</li>
<li>Lock 、unlock</li>
<li>Condition</li>
</ul>
<a id="more"></a>
<h3 id="可重入锁-ReentrantLock-skeleton"><a href="#可重入锁-ReentrantLock-skeleton" class="headerlink" title="可重入锁(ReentrantLock skeleton)"></a>可重入锁(ReentrantLock skeleton)</h3><h4 id="类关系图-Class-Diagrams"><a href="#类关系图-Class-Diagrams" class="headerlink" title="类关系图(Class Diagrams)"></a>类关系图(Class Diagrams)</h4><p>​    从下图的类图来看,<code>ReentrantLock</code>  类实现了<code>Lock</code> 接口, 非阻塞式,超时支持.</p>
<p>​    更多细节参考 <a href="https://zyumin.github.io/2019/08/10/JDK-The-Concurrent-Framework/#Locks-锁" target="_blank" rel="noopener">JDK-The-Concurrent-Framework</a></p>
<p><img src="http://ww2.sinaimg.cn/large/006y8mN6gy1g69g1omdxdj31c80pwgnw.jpg" width="70%" height="70%"></p>
<h4 id="框架细节-skeleton"><a href="#框架细节-skeleton" class="headerlink" title="框架细节(skeleton)"></a>框架细节(skeleton)</h4><p>#### </p>
<p><img src="http://ww4.sinaimg.cn/large/006y8mN6gy1g69k0z6ir1j30u00y8tfp.jpg" width="70%" height="70%"></p>
<h5 id="锁的实现-Lock-implement"><a href="#锁的实现-Lock-implement" class="headerlink" title="锁的实现(Lock implement)"></a>锁的实现(Lock implement)</h5><p>看ReentrantLock的源码我们可以发现,实现Lock接口的类 都由Sync 处理, Sync 类是extends AbstractQueuedSynchronizer. Sync 有两个实现,非别是公平和非公平锁</p>
<h5 id="扩展功能-extended-capabilities"><a href="#扩展功能-extended-capabilities" class="headerlink" title="扩展功能(extended capabilities)"></a>扩展功能(extended capabilities)</h5><p>除了实现Lock 的方法外,  还具有扩展功能。获取等待队列,当前线程是否获得锁等监控</p>
<p>源码:</p>
<pre><code class="java">public class ReentrantLock implements Lock, java.io.Serializable {
    private final Sync sync;
    abstract static class Sync extends AbstractQueuedSynchronizer {
      ...
        }
        static final class NonfairSync extends Sync{}
        static final class FairSync extends Sync{}
        public ReentrantLock() {
        sync = new NonfairSync();
    }
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    public void lock() {
        sync.lock();
    }
    public void unlock() {
        sync.release(1);
    }
    ...
}
</code></pre>
<h3 id="抽象同步队列-AQS"><a href="#抽象同步队列-AQS" class="headerlink" title="抽象同步队列(AQS )"></a>抽象同步队列(AQS )</h3><h4 id="Class-Diagrams"><a href="#Class-Diagrams" class="headerlink" title="Class Diagrams"></a>Class Diagrams</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6aynej1qtj30u10u0n0j.jpg" alt="image-20190823192643197"></p>
<p>我们需要关注的是蓝色圈圈里的, AQS 其实底层用的是volatile 的Node节点 和 CAS 的操作, 实现阻塞队列的语义.  </p>
<h4 id="AQS-skeleton"><a href="#AQS-skeleton" class="headerlink" title="AQS skeleton"></a>AQS skeleton</h4><p>简单来说, AQS的实现可以从 双向节点、以及维护这些节点的方法 这两个方法去归类 ( 这里先不考虑Condition)</p>
<h5 id="队列节点-Node"><a href="#队列节点-Node" class="headerlink" title="队列节点(Node)"></a>队列节点(Node)</h5><h6 id="数据结构-struct"><a href="#数据结构-struct" class="headerlink" title="数据结构(struct)"></a>数据结构(struct)</h6><p>是一个双向链表,注意nextWaiter 是用于condition的Node</p>
<pre><code class="java">        /**
         * Link to predecessor node that current node/thread relies on
         * for checking waitStatus. Assigned during enqueuing, and nulled
         * out (for sake of GC) only upon dequeuing.  Also, upon
         * cancellation of a predecessor, we short-circuit while
         * finding a non-cancelled one, which will always exist
         * because the head node is never cancelled: A node becomes
         * head only as a result of successful acquire. A
         * cancelled thread never succeeds in acquiring, and a thread only
         * cancels itself, not any other node.
         */
        volatile Node prev;

        /**
         * Link to the successor node that the current node/thread
         * unparks upon release. Assigned during enqueuing, adjusted
         * when bypassing cancelled predecessors, and nulled out (for
         * sake of GC) when dequeued.  The enq operation does not
         * assign next field of a predecessor until after attachment,
         * so seeing a null next field does not necessarily mean that
         * node is at end of queue. However, if a next field appears
         * to be null, we can scan prev&#39;s from the tail to
         * double-check.  The next field of cancelled nodes is set to
         * point to the node itself instead of null, to make life
         * easier for isOnSyncQueue.
         */
        volatile Node next;
        /**
         * Link to next node waiting on condition, or the special
         * value SHARED.  Because condition queues are accessed only
         * when holding in exclusive mode, we just need a simple
         * linked queue to hold nodes while they are waiting on
         * conditions. They are then transferred to the queue to
         * re-acquire. And because conditions can only be exclusive,
         * we save a field by using special value to indicate shared
         * mode.
         */
        Node nextWaiter;
        /**
         * The thread that enqueued this node.  Initialized on
         * construction and nulled out after use.
         */
        volatile Thread thread;
</code></pre>
<h6 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式(mode)"></a>模式(mode)</h6><p>​       共享锁( 例如: 读锁 )还是排斥锁 </p>
<pre><code class="java">        /** Marker to indicate a node is waiting in shared mode */
        static final Node SHARED = new Node();
        /** Marker to indicate a node is waiting in exclusive mode */
        static final Node EXCLUSIVE = null;

        /**
         * Returns true if node is waiting in shared mode.
         */
        final boolean isShared() {
            return nextWaiter == SHARED;
        }
</code></pre>
<h6 id="状态-waitStatus"><a href="#状态-waitStatus" class="headerlink" title="状态(waitStatus)"></a>状态(waitStatus)</h6><p> 状态相关细节如下 </p>
<pre><code class="java">        /** waitStatus value to indicate thread has cancelled */
        static final int CANCELLED =  1;
        /** waitStatus value to indicate successor&#39;s thread needs unparking */
        static final int SIGNAL    = -1;
        /** waitStatus value to indicate thread is waiting on condition */
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;

                /**
         * Status field, taking on only the values:
         *   SIGNAL:     The successor of this node is (or will soon be)
         *               blocked (via park), so the current node must
         *               unpark its successor when it releases or
         *               cancels. To avoid races, acquire methods must
         *               first indicate they need a signal,
         *               then retry the atomic acquire, and then,
         *               on failure, block.
         *   CANCELLED:  This node is cancelled due to timeout or interrupt.
         *               Nodes never leave this state. In particular,
         *               a thread with cancelled node never again blocks.
         *   CONDITION:  This node is currently on a condition queue.
         *               It will not be used as a sync queue node
         *               until transferred, at which time the status
         *               will be set to 0. (Use of this value here has
         *               nothing to do with the other uses of the
         *               field, but simplifies mechanics.)
         *   PROPAGATE:  A releaseShared should be propagated to other
         *               nodes. This is set (for head node only) in
         *               doReleaseShared to ensure propagation
         *               continues, even if other operations have
         *               since intervened.
         *   0:          None of the above
         *
         * The values are arranged numerically to simplify use.
         * Non-negative values mean that a node doesn&#39;t need to
         * signal. So, most code doesn&#39;t need to check for particular
         * values, just for sign.
         *
         * The field is initialized to 0 for normal sync nodes, and
         * CONDITION for condition nodes.  It is modified using CAS
         * (or when possible, unconditional volatile writes).
         */
        volatile int waitStatus;
</code></pre>
<h5 id="队列节点的相关操作-Node-operation"><a href="#队列节点的相关操作-Node-operation" class="headerlink" title="队列节点的相关操作(Node operation)"></a>队列节点的相关操作(Node operation)</h5><h6 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h6><p> 对节点的cas操作</p>
<pre><code class="java">    /**
     * Setup to support compareAndSet. We need to natively implement
     * this here: For the sake of permitting future enhancements, we
     * cannot explicitly subclass AtomicInteger, which would be
     * efficient and useful otherwise. So, as the lesser of evils, we
     * natively implement using hotspot intrinsics API. And while we
     * are at it, we do the same for other CASable fields (which could
     * otherwise be done with atomic field updaters).
     */
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long stateOffset;
    private static final long headOffset;
    private static final long tailOffset;
    private static final long waitStatusOffset;
    private static final long nextOffset;

    static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(&quot;waitStatus&quot;));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(&quot;next&quot;));

        } catch (Exception ex) { throw new Error(ex); }
    }
    /**
     * CAS head field. Used only by enq.
     */
    private final boolean compareAndSetHead(Node update) {
        return unsafe.compareAndSwapObject(this, headOffset, null, update);
    }
    /**
     * CAS tail field. Used only by enq.
     */
    private final boolean compareAndSetTail(Node expect, Node update) {
        return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
    }
    /**
     * CAS waitStatus field of a node.
     */
    private static final boolean compareAndSetWaitStatus(Node node,int expect,int update) {
        return unsafe.compareAndSwapInt(node, waitStatusOffset,expect, update);
    }
    /**
     * CAS next field of a node.
     */
    private static final boolean compareAndSetNext(Node node,Node expect, Node update) {
        return unsafe.compareAndSwapObject(node, nextOffset, expect, update);
    }
</code></pre>
<p>state</p>
<p> 队列状态, 例如, <code>ReentrantLock</code> 中用于记录重入次数</p>
<pre><code class="java">/**
 * Atomically sets synchronization state to the given updated
 * value if the current state value equals the expected value.
 * This operation has memory semantics of a {@code volatile} read
 * and write.
 *
 * @param expect the expected value
 * @param update the new value
 * @return {@code true} if successful. False return indicates that the actual
 *         value was not equal to the expected value.
 */
protected final boolean compareAndSetState(int expect, int update) {
    // See below for intrinsics setup to support this
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
    /**
     * The synchronization state.
     */
    private volatile int state;
</code></pre>
<h6 id="UnsupportedOperationException-method"><a href="#UnsupportedOperationException-method" class="headerlink" title="UnsupportedOperationException method"></a>UnsupportedOperationException method</h6><p>子类需要实现的方法, UnsupportedOperationException method</p>
<p>To use this class as the basis of a synchronizer, redefine the following methods, as applicable, by inspecting and/or modifying the synchronization state using <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState--" target="_blank" rel="noopener"><code>getState()</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState-int-" target="_blank" rel="noopener"><code>setState(int)</code></a> and/or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState-int-int-" target="_blank" rel="noopener"><code>compareAndSetState(int, int)</code></a>:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire-int-" target="_blank" rel="noopener"><code>tryAcquire(int)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease-int-" target="_blank" rel="noopener"><code>tryRelease(int)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared-int-" target="_blank" rel="noopener"><code>tryAcquireShared(int)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared-int-" target="_blank" rel="noopener"><code>tryReleaseShared(int)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively--" target="_blank" rel="noopener"><code>isHeldExclusively()</code></a></li>
</ul>
<p>Each of these methods by default throws <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html" target="_blank" rel="noopener"><code>UnsupportedOperationException</code></a><em>only</em><code>final</code></p>
<p>You may also find the inherited methods from <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractOwnableSynchronizer.html" target="_blank" rel="noopener"><code>AbstractOwnableSynchronizer</code></a> useful to keep track of the thread owning an exclusive synchronizer. You are encouraged to use them – this enables monitoring and diagnostic tools to assist users in determining which threads hold locks.</p>
<h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>条件队列相关,下文分析</p>
<h5 id="AQS-impl-example"><a href="#AQS-impl-example" class="headerlink" title="AQS impl example"></a>AQS impl example</h5><p>ReentrantLock中的实现,  重点看看tryAcquire tryRelease的实现,  这里以Sync的实现NonfairSync (默认的非公平锁,注意非公平体现 不能保证FIFO,会造成线程饥饿, 但是好处是减少上下文切换)分析</p>
<p>Sync:</p>
<pre><code class="java">abstract static class Sync extends AbstractQueuedSynchronizer {
        //抽象方法 留给子类实现
        abstract void lock();
        // 尝试加锁,初始化或者重入可以加锁成功
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
        //尝试释放锁
        protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
        //当前线程是否持有锁
        protected final boolean isHeldExclusively() {
            // While we must in general read state before owner,
            // we don&#39;t need to do so to check if current thread is owner
            return getExclusiveOwnerThread() == Thread.currentThread();
        }
                   ...
}
</code></pre>
<p>NonfairSync :</p>
<pre><code class="java">static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    /**
     * Performs lock.  Try immediate barge, backing up to normal
     * acquire on failure.
     */
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
</code></pre>
<h3 id="加锁-解锁分析-lock-unlock"><a href="#加锁-解锁分析-lock-unlock" class="headerlink" title="加锁/解锁分析 (lock /unlock)"></a>加锁/解锁分析 (lock /unlock)</h3><p>我们从<code>java.util.concurrent.locks.ReentrantLock.NonfairSync#lock</code>入手 , 来看看语言层面怎么实现同步语义( 注意,实现过程没有用到同步语义,所以我们要重点关注volidate,cas 以及顺序等)</p>
<pre><code class="java">/**
 * Performs lock.  Try immediate barge, backing up to normal
 * acquire on failure.
 */
final void lock() {
    //CAS设置state,成功则获取锁,并设置当前占有锁的线程
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
   //否则进行获取锁的操作(阻塞、入队等)
        acquire(1);
}
</code></pre>
<p>如果CAS获取失败, 调用<code>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</code></p>
<pre><code class="java"> /**
  * Acquires in exclusive mode, ignoring interrupts.  Implemented
  * by invoking at least once {@link #tryAcquire},
  * returning on success.  Otherwise the thread is queued, possibly
  * repeatedly blocking and unblocking, invoking {@link
  * #tryAcquire} until success.  This method can be used
  * to implement method {@link Lock#lock}.
  *
  * @param arg the acquire argument.  This value is conveyed to
  *  {@link #tryAcquire} but is otherwise uninterpreted and
  *  can represent anything you like.
  */
public final void acquire(int arg) {
    //获取失败 , 并且返回acquireQueued 返回true(阻塞状态被中断) 
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        //回放中断
        selfInterrupt();
}
</code></pre>
<p>下面, 依次分析下面三个方法:</p>
<ul>
<li>tryAcquire</li>
<li>addWaiter</li>
<li>acquireQueued</li>
</ul>
<h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><p>在阻塞之前, 再次(注意在一开始lock方法中就尝试过一次, 可能是作者有意为之,或是…)尝试获取</p>
<pre><code class="java">  protected final boolean tryAcquire(int acquires) {
      return nonfairTryAcquire(acquires);
  }
  final boolean nonfairTryAcquire(int acquires) {
      final Thread current = Thread.currentThread();
      int c = getState();
      //如果当前state为0, 再次尝试获取
      if (c == 0) {
    if (compareAndSetState(0, acquires)) {
        setExclusiveOwnerThread(current);
        return true;
    }
      }
      //判断是否重入线程
      else if (current == getExclusiveOwnerThread()) {
    //这里操作无需加锁, 是线程安全的,其他线程是进不到这里
    int nextc = c + acquires;
    //最大可重入次数是Integer.MAX
    if (nextc &lt; 0) // overflow
        throw new Error(&quot;Maximum lock count exceeded&quot;);
    setState(nextc);
    return true;
      }
      return false;
  }
</code></pre>
<h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p> 因为第一次CAS尝试逻辑和enq方法中一致, 所以我们只需要关注enq中的操作即可</p>
<pre><code class="java">/**
 * Creates and enqueues node for current thread and given mode.
 *
 * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
 * @return the new node
 */
private Node addWaiter(Node mode) {
    //注意这里入参mode是EXCLUSIVE , 即上面Node中的mode
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    //当tail队列不为空的时候,说明已经初始化过了, 直接进行一次CAS操作
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //否则进入enq
    enq(node);
    return node;
}

  /**
   * Inserts node into queue, initializing if necessary. See picture above.
   * @param node the node to insert
   * @return node&#39;s predecessor
   */
  private Node enq(final Node node) {
    for (;;) {
      Node t = tail;
      //初始化队列
      if (t == null) { // Must initialize
        if (compareAndSetHead(new Node()))
          tail = head;
      } else {
        //非原子操作, 会出现 &quot;队列在prev方向一致，next方向不一致&quot;
        node.prev = t;
        if (compareAndSetTail(t, node)) {
          t.next = node;
          return t;
        }
      }
    }
  }
</code></pre>
<p>注意这里, 在插入过程中，会出现“node.prev指向旧的尾节点，但旧的尾节点.next为null未指向node（尽管，尾指针指向node）”的状态，即“<strong>队列在prev方向一致，next方向不一致</strong>”</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6aync8atgj30nq0b5q3c.jpg" alt="AQS@enqå¼±ä¸è´ç¶æ"></p>
<h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>经过上述操作, 只是插入了队列, 状态并未变更, 所以这里要做的就是状态的维护</p>
<pre><code class="java">/**
 * Acquires in exclusive uninterruptible mode for thread already in
 * queue. Used by condition wait methods as well as acquire.
 *
 * @param node the node
 * @param arg the acquire argument
 * @return {@code true} if interrupted while waiting
 */
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            //如果当前节点的前继节点是头节点,才开始尝试获取锁,获取成功则返回
            if (p == head &amp;&amp; tryAcquire(arg)) {
                //Head 一开始为空节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //否则,阻塞或处理中断
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<p>​    如果获取失败,  AQS.shouldParkAfterFailedAcquire()判断是否需要阻塞等待，如果需要，则通过AQS#parkAndCheckInterrupt()阻塞等待，直到被唤醒或被中断。</p>
<h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><p>​    请求获取锁失败后处理, 是否需要阻塞判断,以及队列状态的维护</p>
<pre><code class="java">  /**
   * Checks and updates status for a node that failed to acquire.
   * Returns true if thread should block. This is the main signal
   * control in all acquire loops.  Requires that pred == node.prev.
   *
   * @param pred node&#39;s predecessor holding status
   * @param node the node
   * @return {@code true} if thread should block
   */
  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
      /*
       * This node has already set status asking a release
       * to signal it, so it can safely park.
       */
      return true;
    //如果前继节点的状态大于0,则代表是取消状态,需要维护队列节点的状态
    if (ws &gt; 0) {
      /*
       * Predecessor was cancelled. Skip over predecessors and
       * indicate retry.
       */
      //因为当前node为尾节点,遍历队列, 找到未被取消的节点
      do {
        node.prev = pred = pred.prev;
      } while (pred.waitStatus &gt; 0);
      //非原子操作, 会出现 &quot;队列在prev方向一致，next方向不一致&quot;
      pred.next = node;
    } else {
      /*
       * waitStatus must be 0 or PROPAGATE.  Indicate that we
       * need a signal, but don&#39;t park yet.  Caller will need to
       * retry to make sure it cannot acquire before parking.
       */
      //CAS修改ws的状态,直到ws的状态修改成功,才返回true需要阻塞
      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
  }
</code></pre>
<p>注意这里, 在插入过程中，会出现“node.prev指向非CACELLED的node，非CACELLED的node.next指向node（CACELLED）”的状态，即“<strong>队列在prev方向一致，next方向不一致</strong>”</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6aynd2ovpj31cm0jkab7.jpg" alt="image-20190824131725953"></p>
<h6 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h6><pre><code class="java">  /**
   * Convenience method to park and then check if interrupted
   *
   * @return {@code true} if interrupted
   */
  private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
  }
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="队列状态"><a href="#队列状态" class="headerlink" title="队列状态"></a>队列状态</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ayndml1ij318w0j8q3z.jpg" alt="image-20190824114533939"></p>
<ul>
<li>除了头节点，剩余节点都被阻塞，线程处于<code>WAITING</code>状态。</li>
<li>除了尾节点，剩余节点都满足<code>waitStatus==SIGNAL</code>，表示释放后需要唤醒后继节点。</li>
</ul>
<p>tips:unlock的可以按照以上分析</p>
<h5 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h5><p>​    为什么要从尾节点向前遍历，而不能从node向后遍历？这是因为，AQS中的等待队列基于一个弱一致性双向链表实现，允许某些时刻下，<strong>队列在prev方向一致，next方向不一致</strong>。 (上述已经分析了,这里做个总结)</p>
<blockquote>
<p>理想情况下，队列每时每刻都处于一致的状态（强一致性模型），从node向后遍历找第一个未取消节点是更高效的做法。然而，维护一致性通常需要牺牲部分性能，为了进一步的提升性能，脑洞大开的神牛们想出了各种高性能的弱一致性模型。尽管模型允许了更多弱一致状态，但所有弱一致状态都在控制之下，不会出现一致性问题。</p>
</blockquote>
<h5 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h5><p>我们以tryRelease为例子, 看volidate的用法(对照tryAcquire分析tryRelease)</p>
<pre><code class="java">protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        //先写exclusiveOwnerThread C
        setExclusiveOwnerThread(null);
    }
    //再写state D
    setState(c);
    return free;
}
//
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    //先读state  A
    int c = getState();
    if (c == 0) {
      if (compareAndSetState(0, acquires)) {
        setExclusiveOwnerThread(current);
        return true;
      }
    }
    //再读exclusiveOwnerThread B
    else if (current == getExclusiveOwnerThread()) {
      int nextc = c + acquires;
      if (nextc &lt; 0) // overflow
        throw new Error(&quot;Maximum lock count exceeded&quot;);
      setState(nextc);
      return true;
    }
    return false;
  }
</code></pre>
<p>核心是三条Happens-Before规则：</p>
<ul>
<li><code>程序顺序规则</code>：如果程序中操作A在操作B之前，那么在线程中操作A将在操作B之前执行。</li>
<li><code>传递性</code>：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。</li>
<li><code>volatile变量规则</code>：对volatile变量的写入操作必须在对该变量的读操作之前执行。</li>
</ul>
<p>下面分析为什么C和D要按照这样的顺序</p>
<p>根据h-b规则可见性分析:</p>
<ul>
<li>A-&gt;B</li>
<li>C-&gt;D</li>
<li>D-&gt;A</li>
<li>C-&gt;B</li>
</ul>
<p>推出:</p>
<p><strong>C(写exclusiveOwnerThread)-&gt;D(写state)-&gt;A(读state)-&gt;B(读exclusiveOwnerThread)</strong></p>
<p><strong>保证所有写对所有读可见</strong></p>
<hr>
<p>否则, 假设C和D操作互换下</p>
<ul>
<li>A(读state)-&gt;B(读ex)</li>
<li>C(写state)-&gt;D(写ex)</li>
<li>C-&gt;A</li>
<li>D-&gt;B</li>
</ul>
<p>推出:</p>
<ul>
<li>C-&gt;D-&gt;B</li>
<li>C-&gt;A-&gt;B</li>
</ul>
<p><strong>D(写ex)和A(读state)没有h-b关系</strong></p>
<h3 id="条件分析-Condition"><a href="#条件分析-Condition" class="headerlink" title="条件分析(Condition)"></a>条件分析(Condition)</h3><p>Lock接口对标内置锁，而Condition接口对标内置条件队列。Condition主要提供了await、signal两种语义，和两种语义的衍生品。</p>
<h4 id="类关系图-Class-Diagrams-1"><a href="#类关系图-Class-Diagrams-1" class="headerlink" title="类关系图(Class Diagrams)"></a>类关系图(Class Diagrams)</h4><p>与AQS skeleton类似,也是维护了一个条件队列,下面以await和signal()分析</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6aynfh4hvj30u0101gqh.jpg" alt="image-20190824151905654"></p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>可以先简单理解没有中断版本的,只是设置中断标记,不会抛出异常</p>
<pre><code class="java">public final void awaitUninterruptibly() {
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    boolean interrupted = false;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if (Thread.interrupted())
            interrupted = true;
    }
    if (acquireQueued(node, savedState) || interrupted)
        selfInterrupt();
}
</code></pre>
<p>注意调用await,会释放当前线程持有的Lock,知道被通知或中断(signal)</p>
<pre><code class="java">public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 创建等待节点并放入队尾
    Node node = addConditionWaiter();
    //释放锁并保存释放前的状态(释放的是Lock,否则外部无法获取)
        int savedState = fullyRelease(node);
    /***** 无锁状态开始 *****/
    int interruptMode = 0;
    //如果不在AQS的同步队列中(signal中入队), 阻塞,直到收到信号或被中断
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        //现在node的是AQS条件队列上的节点,后续的操作 与#lock方法的类似
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
                        //恢复申请锁状态,并更新中断状态
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
     /***** 无锁状态结束 *****/
    //清理已被取消的节点,则表示在doSignal中没有完成 =null的操作
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    //如果之前发生中断,则更具中断模式重放中断
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
</code></pre>
<p>ConditionObject#await()同ReentrantLock#lockInterruptibly()一样，都是可中断的：调用ConditionObject#await()后，当前线程将保持阻塞，直到收到信号或被中断。</p>
<h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#addConditionWaiter</p>
<p>创建节点, 并放入尾部</p>
<pre><code class="java">/**
 * Adds a new waiter to wait queue.
 * @return its new wait node
 */
private Node addConditionWaiter() {
    Node t = lastWaiter;
    // If lastWaiter is cancelled, clean out.
    // 维护队列状态
    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    //队列是否为空,初始化头节点
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}
</code></pre>
<p>需要提醒一下，尽管此处没有任何线程安全的保护，但实际使用时不会出现任何线程安全问题——因为<strong>条件队列的使用要求我们在调用await或signal时持有与该条件队列唯一相关的锁</strong>。(和AQS中的队列的操作相比,没有CAS操作)</p>
<p>到这里，得到两个ReentrantLock与ConditionObject在实现上的重要区别：</p>
<ul>
<li><p>ReentrantLock创建的节点，初始状态为0；而ConditionObject创建的节点，初始状态为<code>CONDITION==-2</code>。</p>
</li>
<li><p>ReentrantLock使用AQS内置的等待队列，由AQS维护；而每个ConditionObject都维护自己的等待队列。</p>
</li>
</ul>
<h5 id="fullyRelease-释放Lock"><a href="#fullyRelease-释放Lock" class="headerlink" title="fullyRelease(释放Lock)"></a>fullyRelease(释放Lock)</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer#fullyRelease</p>
<p>释放锁并保存释放前的状态,重入次数 (释放的是Lock,否则外部无法获取)</p>
<pre><code class="java">/**
 * Invokes release with current state value; returns saved state.
 * Cancels node and throws exception on failure.
 * @param node the condition node for this wait
 * @return previous sync state
 */
final long fullyRelease(Node node) {
    boolean failed = true;
    try {
        long savedState = getState();
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            //必须在Lock之后才能调用wait(),与unlock()同理
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}
</code></pre>
<p>release可以看之前的tryrelease分析,AQS#fullyRelease()返回后，调用ConditionObject#await()的线程就释放了锁(这里必须释放锁, 否则就会出现其他调用Lock的地方无法获取锁,阻塞)</p>
<h5 id="isOnSyncQueue-阻塞"><a href="#isOnSyncQueue-阻塞" class="headerlink" title="isOnSyncQueue(阻塞)"></a>isOnSyncQueue(阻塞)</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer#isOnSyncQueue</p>
<p>阻塞，直到收到信号或被中断</p>
<pre><code class="java">// Internal support methods for Conditions

/**
 * Returns true if a node, always one that was initially placed on
 * a condition queue, is now waiting to reacquire on sync queue.
 * @param node the node
 * @return true if is reacquiring
 */
final boolean isOnSyncQueue(Node node) {
    //如果是头节点 或者当前节点是CONDITION
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    if (node.next != null) // If has successor, it must be on queue
        return true;
    /*
     * node.prev can be non-null, but not yet on queue because
     * the CAS to place it on queue can fail. So we have to
     * traverse from tail to make sure it actually made it.  It
     * will always be near the tail in calls to this method, and
     * unless the CAS failed (which is unlikely), it will be
     * there, so we hardly ever traverse much.
     */
    return findNodeFromTail(node);
}
    /**
     * Returns true if node is on sync queue by searching backwards from tail.
     * Called only when needed by isOnSyncQueue.
     * @return true if present
     */
    private boolean findNodeFromTail(Node node) {
        Node t = tail;
        for (;;) {
            if (t == node)
                return true;
            if (t == null)
                return false;
            t = t.prev;
        }
    }
</code></pre>
<p><strong>先 跳转到 signal 的分析</strong></p>
<p>AQS#isOnSyncQueue()判断节点node是否已经被放入了AQS内部的等待队列，是的话返回true，否则返回false。主要分几种情况：</p>
<ul>
<li>如果<code>node.waitStatus == CONDITION</code>，则一定未放入。因为AQS#transferForSignal()6行还没来得及执行。</li>
<li>如果<code>node.prev == null</code>，则一定未放入。因为AQS#transferForSignal()6行执行完但9行未执行完。</li>
<li>如果<code>node.next != null</code>，则一定已放入。因为已经有了后继节点，则node本身肯定已经完成入队（ConditionObject内部的等待使用的后继指针为<code>nextWaiter</code>）。</li>
<li>否则，说明满足<code>node.waitStatus != CONDITION &amp;&amp; node.prev != null &amp;&amp; node.next == null</code>，该状态无法确定node处于“未放入”还是“已放入”的状态。回忆AQS#enq()可知，<code>node.prev != null</code>时，可能正在尝试CAS插入node，无法确定是在插入前还是插入后，也无法确定是否插入成功。AQS#findNodeFromTail()从尾节点开始遍历，如果能够遍历到node，则一定已放入（当然，next方向不一定满足一致性）；否则，当前时刻还未插入或未插入成功，即一定未放入。</li>
</ul>
<h5 id="checkInterruptWhileWaiting-检查是否被中断"><a href="#checkInterruptWhileWaiting-检查是否被中断" class="headerlink" title="checkInterruptWhileWaiting (检查是否被中断)"></a>checkInterruptWhileWaiting (检查是否被中断)</h5><p>判断是被中断(因为await是允许中断的,所以需要注意catch中断异常的处理)还是被唤醒</p>
<p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#checkInterruptWhileWaiting</p>
<ul>
<li>返回THROW_IE 如果中断发生在singnalled之前 ,抛出异常</li>
<li>返回REINTERRUPT 如果中断发生在signalled之后 , 只是简单设置状态</li>
<li>返回0 如果未发生过中断</li>
</ul>
<pre><code class="java">/**
 * Checks for interrupt, returning THROW_IE if interrupted
 * before signalled, REINTERRUPT if after signalled, or
 * 0 if not interrupted.
 */
private int checkInterruptWhileWaiting(Node node) {
    //是否发生了中断,否则返回0
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}

 final boolean transferAfterCancelledWait(Node node) {
        //发生在中断之前
        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
            enq(node);
            return true;
        }
        /*
         * If we lost out to a signal(), then we can&#39;t proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         */
        while (!isOnSyncQueue(node))
            Thread.yield();
        return false;
    }
</code></pre>
<p>首先，根据<code>Thread.interrupted()</code>判断是否发生了中断。<em>如果未发生中断</em>，则<code>Thread.interrupted()</code>返回false，<em>ConditionObject#checkInterruptWhileWaiting()最终返回0</em>。</p>
<p>否则，继续调用AQS#transferAfterCancelledWait()判断发生中断的时机。<em>如果是在收到信号前发生了中断</em>，AQS#transferForSignal()6行还没来得及执行，必然满足<code>node.waitStatus == CONDITION</code>，则CAS设置node.waitStatus并将node入队（等待后面调用AQS#acquireQueued()竞争锁），然后返回true，<em>ConditionObject#checkInterruptWhileWaiting()最终返回THROW_IE == -1</em>。</p>
<p>否则，一定是<em>在收到信号后发生了中断</em>，但可能AQS#transferForSignal()6行执行完但9行未执行完，即node未完成入队，因此，21-22行空等待至node完成入队，然后返回false，<em>ConditionObject#checkInterruptWhileWaiting()最终返回REINTERRUPT == 1</em>。</p>
<p>终于跳出了循环，要重新申请锁了。(与#lock方法类似的就不重复分析)</p>
<h6 id="信号前中断的特殊情况"><a href="#信号前中断的特殊情况" class="headerlink" title="信号前中断的特殊情况"></a>信号前中断的特殊情况</h6><p><strong>信号前中断会导致node同时处于AQS与ConditionObject两方的等待队列中</strong>（使用不同的指针连接节点）：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ayngc1x4j30rj0h1wfi.jpg" alt="AQSä¸ConditionObjectå±äº«èç¹"></p>
<p>而另外两种情况下，节点都被迁入了AQS内部等待队列。</p>
<p>因此，只要ConditionObject内部等待队列中的节点满足<code>node.waitStatus == SIGNAL</code>或<code>node.waitStatus == 0</code>，就可以判断其同时位于于AQS与ConditionObject两方的等待队列中，也就能断定该节点属于信号前中断唤醒。</p>
<blockquote>
<p>信号前中断唤醒的节点是无效的，需要被清理，可以用该条件找出这部分节点。该结论将在分析ConditionObject#unlinkCancelledWaiters()时派上用场。</p>
</blockquote>
<h5 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#unlinkCancelledWaiters</p>
<p>实际上，ConditionObject#unlinkCancelledWaiters()用于清理ConditionObject内部等待队列中的非CONDITION节点。具体来说：</p>
<ul>
<li>如果ConditionObject#await()时（更确切的说，AQS#fullyRelease()完全释放锁时）失败，节点转为CANCELLED状态，需要被清理。</li>
<li>分析AQS#transferAfterCancelledWait()有一个结论，<strong>信号前中断会导致node同时处于AQS与ConditionObject两方的等待队列中（使用不同的指针连接节点）</strong>。这些节点将随着AQS#acquireQueued()的执行转为SIGNAL或0状态。但由于ConditionObject#await()在收到信号前（更确切的说，在AQS#fullyRelease()完全释放锁后、收到信号前）被中断，因此上述节点也是无效的，需要被清理。</li>
</ul>
<p>而被信号唤醒或信号后中断唤醒的节点，将首先移出ConditionObject内部等待队列，再进行状态转换。</p>
<p>综上，只需要清理ConditionObject内部等待队列中的非CONDITION节点</p>
<pre><code class="java">/**
 * Unlinks cancelled waiter nodes from condition queue.
 * Called only while holding lock. This is called when
 * cancellation occurred during condition wait, and upon
 * insertion of a new waiter when lastWaiter is seen to have
 * been cancelled. This method is needed to avoid garbage
 * retention in the absence of signals. So even though it may
 * require a full traversal, it comes into play only when
 * timeouts or cancellations occur in the absence of
 * signals. It traverses all nodes rather than stopping at a
 * particular target to unlink all pointers to garbage nodes
 * without requiring many re-traversals during cancellation
 * storms.
 */
private void unlinkCancelledWaiters() {
    //当前节点
    Node t = firstWaiter;
    //上一个节点
    Node trail = null;
    while (t != null) {
        //下一个节点
        Node next = t.nextWaiter;
        //不是CONDITION,移除当前节点(就是把上个节点的nextWaiter执行下个节点)
        if (t.waitStatus != Node.CONDITION) {
            t.nextWaiter = null;
            //如果trail为空,说明是头节点,直接替换firstWaiter
            if (trail == null)
                firstWaiter = next;
            else   //否则把上一个节点指向下一个节点
                trail.nextWaiter = next;
            //设置尾节点
            if (next == null)
                lastWaiter = trail;
        }
        else  //保留当前节点为上个节点
            trail = t;
        //移动当前节点,开始下一轮
        t = next;
    }
}
</code></pre>
<h5 id="reportInterruptAfterWait"><a href="#reportInterruptAfterWait" class="headerlink" title="reportInterruptAfterWait"></a>reportInterruptAfterWait</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#reportInterruptAfterWait</p>
<pre><code class="java">/**
 * Throws InterruptedException, reinterrupts current thread, or
 * does nothing, depending on mode.
 */
private void reportInterruptAfterWait(int interruptMode)
    throws InterruptedException {
    if (interruptMode == THROW_IE)
        throw new InterruptedException();
    else if (interruptMode == REINTERRUPT)
        selfInterrupt();
}
</code></pre>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p>唤醒一个等待在Conditon上的线程,该线程从等待方法返回前必须获得与Condition相关联的锁</p>
<pre><code class="java">    /**
     * Moves the longest-waiting thread, if one exists, from the
     * wait queue for this condition to the wait queue for the
     * owning lock.
     *
     * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
     *     returns {@code false}
     */
    public final void signal() {
      if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
      Node first = firstWaiter;
      //表示有节点进入了条件队列内部的等待队列，需要被唤醒
      if (first != null)
        doSignal(first);
    }
    /**
     * Removes and transfers nodes until hit non-cancelled one or
     * null. Split out from signal in part to encourage compilers
     * to inline the case of no waiters.
     * @param first (non-null) the first node on condition queue
     */
    private void doSignal(Node first) {
      do {
        //firstWaiter后移一位
        if ((firstWaiter = first.nextWaiter) == null)
          lastWaiter = null;
        first.nextWaiter = null;
      //试将条件队列内部的等待节点转换为AQS内部的等待节点，如果当前节点转换失败，就继续尝试下一节点
      } while (!transferForSignal(first) &amp;&amp;(first = firstWaiter) != null);
    }
</code></pre>
<h5 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h5><pre><code class="java">/**
 * Transfers a node from a condition queue onto sync queue.
 * Returns true if successful.
 * @param node the node
 * @return true if successfully transferred (else the node was
 * cancelled before signal)
 */
final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    //入队，返回旧的队尾节点，也就是新节点node的前继节点。
    Node p = enq(node);

    //只有正在执行AQS#acquireQueued()的线程T1能够与正在执行到这里的线程T2发生竞争。
    int ws = p.waitStatus;
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre>
<p>回到ConditionObject#doSignal()与ConditionObject#signal()，成功结束。对于用户而言，线程此时已经被唤醒，尽管其大概率还在AQS内部阻塞排队，等待<strong>重新</strong>获得锁。</p>
<p>实际上，<em>就算去掉10-12行也是满足正确性要求的</em>。因为线程T2释放锁后，依然会将从队头开始的第一个非取消节点唤醒，该节点会继续ConditionObject#await()中的工作</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>await可以简单认为是用于维护ConditionObject队列,可以分为阻塞前和阻塞后操作</p>
<p> 阻塞前: 插入内部等待队列</p>
<p> 阻塞后: 根据是否中断(一致性问题),来维护状态</p>
<p>signal可以简单的认为 将ConditionObject队列中的节点移动到AQS队列</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 951488791@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>JDK_ReentrantLock</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">6.6k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="zhengyumin">zhengyumin</a></p>
    <p><span class="copy-title">发布时间:</span>2019-08-24, 18:48:54</p>
    <p><span class="copy-title">最后更新:</span>2020-01-12, 23:08:21</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/08/24/JDK-ReentrantLock/" title="JDK_ReentrantLock">http://yoursite.com/2019/08/24/JDK-ReentrantLock/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 zhengyumin</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/js/jquery.pjax.js?v=1.0.1"></script>

<script src="/js/script.js?v=1.0.1"></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#week','#hide','#jdk','#packages','#utils','#java','#note','#jvm','#juc','#classLoader','#hotspot','#j2ee','#spring','#distributed','#kafka','#framework','#redis','#netty','#nio','#zookeeper','#Spec','#thread','#mysql','#tomcat','#lang','#summary','#io','#serialization','#file','#gc','#ejb','#elasticsearch','#servlet','#collections','#map','#spring-mvc','#spring-webflux','#doc',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
