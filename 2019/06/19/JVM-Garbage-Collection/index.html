<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="jvm,gc">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM_Garbage Collection">
<meta property="og:url" content="http://yoursite.com/2019/06/19/JVM-Garbage-Collection/index.html">
<meta property="og:site_name" content="Zyumin">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g4c1nxma40j30u00gwdig.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/006tNc79gy1g466cazspsj30f309w74j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006tNc79gy1g466krgf27j30co03hq2w.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006tNc79gy1g467ufa9uoj30fo04rwem.jpg">
<meta property="og:image" content="https://media.licdn.com/dms/image/C4E12AQH4VHeTMCfxmA/article-cover_image-shrink_720_1280/0?e=1566432000&v=beta&t=ECo_SPDpBCkQlyNbEXoIgmVeTTaxLrfz7pC66OJ2mlc">
<meta property="og:updated_time" content="2019-06-24T06:57:42.923Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM_Garbage Collection">
<meta name="twitter:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g4c1nxma40j30u00gwdig.jpg">






  <link rel="canonical" href="http://yoursite.com/2019/06/19/JVM-Garbage-Collection/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JVM_Garbage Collection | Zyumin</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemsope="" itemtype="http://schema.org/WPHeader">
	  <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zyumin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">自驱和热情</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/Zyumin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/19/JVM-Garbage-Collection/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhengyumin">
      <meta itemprop="description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zyumin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JVM_Garbage Collection

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-19 00:28:10" itemprop="dateCreated datePublished" datetime="2019-06-19T00:28:10+08:00">2019-06-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-24 14:57:42" itemprop="dateModified" datetime="2019-06-24T14:57:42+08:00">2019-06-24</time>
              
            
          </span>

          

          
            
            
          

          
          
            <span id="/2019/06/19/JVM-Garbage-Collection/" class="leancloud_visitors" data-flag-title="JVM_Garbage Collection">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4c1nxma40j30u00gwdig.jpg" alt="https://image.ipaiban.com/upload-ueditor-image-20190616-1560688476336071298.jpg"></p>
<a id="more"></a>
<p>基于<a href="https://docs.oracle.com/en/java/javase/12/gctuning/hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" target="_blank" rel="noopener">HotSpot Virtual Machine Garbage Collection Tuning Guide</a>的整理( ´ー`) , jDK12</p>
<p>Or <a href="https://docs.oracle.com/en/java/javase/12/gctuning/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/gctuning/index.html</a></p>
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote>
<p>The <em>Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection<br>Tuning Guide</em> describes the garbage collection methods included in the Java HotSpot<br>Virtual Machine (Java HotSpot VM) and helps you determine which one is the best for<br>your needs.</p>
</blockquote>
<p>介绍HotSpot虚拟机垃圾回收算法、 以及怎么选择最合适的一个算法</p>
<h2 id="Introduction-to-Garbage-Collection-Tuning"><a href="#Introduction-to-Garbage-Collection-Tuning" class="headerlink" title="Introduction to Garbage Collection Tuning"></a>Introduction to Garbage Collection Tuning</h2><blockquote>
<p>Java SE selects the most appropriate garbage collector based on the class of the computer on which the application is run.<br>However, this selection may not be optimal for every application. </p>
<p>Users, developers,and administrators with strict performance goals or other requirements may need to<br>explicitly select the garbage collector and tune certain parameters to achieve the<br>desired level of performance.</p>
</blockquote>
<p>通常需要选择合适的垃圾收集器、并调整某些参数以实现所需的性能级别(吞吐和停顿)</p>
<p>Topics</p>
<ul>
<li>What Is a Garbage Collector?  </li>
<li>Why Does the Choice of Garbage Collector Matter? </li>
<li>Supported Operating Systems in Documentation</li>
</ul>
<p>简单介绍了</p>
<ul>
<li>什么是垃圾回收、以及使用什么优化技术(分代、并发、压缩)</li>
<li>为什么选择垃圾回收算法很重要</li>
<li>支持的操作系统</li>
</ul>
<h2 id="Ergonomics"><a href="#Ergonomics" class="headerlink" title="Ergonomics"></a>Ergonomics</h2><p>简单介绍如何提高性能,从吞吐、响应时间、堆空间</p>
<p>Topics</p>
<ol>
<li>Garbage Collector, Heap, and Runtime Compiler Default Selections </li>
<li>Behavior-Based Tuning <ul>
<li>Maximum Pause-Time Goal </li>
<li>Throughput Goal  </li>
<li>Footprint </li>
</ul>
</li>
<li>Tuning Strategy </li>
</ol>
<h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><ul>
<li>Garbage-First (G1) collector </li>
<li>The maximum number of GC threads is limited by heap size and available CPU </li>
<li>resources </li>
<li>Initial heap size of 1/64 of physical memory </li>
<li>Maximum heap size of 1/4 of physical memory </li>
<li>Tiered compiler, using both C1 and C2 </li>
</ul>
<h3 id="基于特性调整"><a href="#基于特性调整" class="headerlink" title="基于特性调整"></a>基于特性调整</h3><ul>
<li><p>Maximum Pause-Time Goal</p>
<ul>
<li><p>These adjustments may cause garbage collection to occur more frequently, reducing the overall throughput of the application.</p>
</li>
<li><p>command-line option -XX:MaxGCPauseMillis=<em><nnn></nnn></em></p>
</li>
</ul>
</li>
<li><p>Throughput Goal</p>
<ul>
<li>If the throughput goal isn’t being met, then one possible action for the garbage<br>  collector is to increase the size of the heap so that the time spent in the application<br>  between collection pauses can be longer.</li>
<li><p>command-line option -XX:GCTimeRatio=<em>nnn</em>  (The ratio of</p>
<p>  garbage collection time to application time is 1/ (1+<em>nnn</em>))</p>
</li>
</ul>
</li>
<li>Footprint(占用空间 -堆大小)<ul>
<li>If the throughput and maximum pause-time goals have been met, then the garbage<br>  collector reduces the size of the heap until one of the goals (invariably the throughput<br>  goal) can’t be met.</li>
</ul>
</li>
</ul>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>​    The heap grows or shrinks to a size that supports the chosen throughput goal. Learn about heap tuning strategies such as choosing a maximum heap size, and choosing maximum pause-time goal. </p>
<p>​    <strong>Don’t choose a maximum value for the heap unless you know that you need a heap greater than the default maximum heap size</strong> </p>
<p>​    <strong>If the heap grows to its maximum size and the throughput goal isn’t being met, then</strong><br><strong>the maximum heap size is too small for the throughput goal.</strong></p>
<p>​    <strong>If the throughput goal can be met, but pauses are too long, then select a maximum</strong><br><strong>pause-time goal</strong></p>
<h2 id="Garbage-Collector-Implementation"><a href="#Garbage-Collector-Implementation" class="headerlink" title="Garbage Collector Implementation"></a>Garbage Collector Implementation</h2><blockquote>
<p>However, when garbage collection is the principal bottleneck, it’s useful to understand<br>some aspects of the implementation. Garbage collectors make assumptions about the<br>way applications use objects, and these are reflected in tunable parameters that can<br>be adjusted for improved performance without sacrificing the power of the abstraction.</p>
</blockquote>
<p>当垃圾收集成为虚拟机瓶颈的时候,了解其具体实现细节就很重要了</p>
<p><strong>Topics</strong> </p>
<ul>
<li>Generational Garbage Collection </li>
<li>Generations </li>
<li>Performance Considerations </li>
<li>Throughput and Footprint Measurement </li>
</ul>
<h3 id="垃圾回收分代策略"><a href="#垃圾回收分代策略" class="headerlink" title="垃圾回收分代策略"></a>垃圾回收分代策略</h3><p>The Java HotSpot VM incorporates a number of different garbage collection algorithms that all use a technique called generational collection.</p>
<p>每次都遍历每个可到到达对象,这种效率是不可取的,所以需要选择合适的回收策略</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g466cazspsj30f309w74j.jpg" alt="Description of Figure 3-1 follows"></p>
<p><strong><em>Typical Distribution for Lifetimes of Objects</em></strong></p>
<p>从上图可以发现,大多数对象都是年轻对象 (x轴为当前生命周期存活的大小,y轴为对象内存分配分代位置)</p>
<h3 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h3><blockquote>
<p>To optimize for this scenario, memory is managed in generations (memory pools holding objects of different ages). Garbage collection occurs in each generation when the generation fills up.<br>The vast majority of objects are allocated in a pool dedicated to young objects (the young generation), and most objects die there.</p>
</blockquote>
<p>为了解决对象都是 朝生夕灭,这种问题,对堆内存使用了分代管理</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g466krgf27j30co03hq2w.jpg" alt="Description of Figure 3-2 follows"></p>
<p><strong>Young</strong></p>
<p>The young generation consists of eden and two survivor spaces.</p>
<p>One survivor space is empty at any time, and serves as the destination of live objects in eden and the other survivor space during garbage collection; </p>
<p>after garbage collection, eden and the source survivor space are empty</p>
<p><strong>Old</strong></p>
<p>Objects are copied between survivor spaces in this way until they’ve<br>been copied a certain number of times or there isn’t enough space left there.</p>
<p>These objects are copied into the old region.</p>
<h3 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h3><p>In general, choosing the size for a particular generation is a trade-off between these considerations. For example, a very large young generation may maximize throughput, but does so at the expense of footprint, promptness, and pause times.  Young generation pauses can be minimized by using a small young generation at the expense of throughput. The sizing of one generation doesn’t affect the collection frequency and pause times for another generation.</p>
<p>年轻一代越大,吞吐越高,minor gc 越少,总gc时间变少</p>
<p>但是同时会导致 内存占用变高,单次需要收集垃圾的时间变长,响应时间变长</p>
<h3 id="吞吐和占用空间测量"><a href="#吞吐和占用空间测量" class="headerlink" title="吞吐和占用空间测量"></a>吞吐和占用空间测量</h3><p>The command-line option -verbose:gc prints information about the heap and garbage collection at each collection.</p>
<p>可以通过打印gc日志,看gc情况</p>
<h2 id="Factors-Affecting-Garbage-Collection-Performance"><a href="#Factors-Affecting-Garbage-Collection-Performance" class="headerlink" title="Factors Affecting Garbage Collection Performance"></a>Factors Affecting Garbage Collection Performance</h2><blockquote>
<p>The two most important factors affecting garbage collection performance are <strong>total</strong><br><strong>available memory and proportion of the heap dedicated to the young generation.</strong></p>
</blockquote>
<p>影响垃圾收集性能的两个重要因素 堆总大小和年轻代堆堆比例</p>
<p><strong>Topics</strong> </p>
<ul>
<li>Total Heap <ul>
<li>–  Heap Options Affecting Generation Size </li>
<li>–  Default Option Values for Heap Size </li>
<li>–  Conserving Dynamic Footprint by Minimizing Java Heap Size </li>
</ul>
</li>
<li>The Young Generation <ul>
<li>–  Young Generation Size Options </li>
<li>–  Survivor Space Sizing </li>
</ul>
</li>
</ul>
<h3 id="堆总大小"><a href="#堆总大小" class="headerlink" title="堆总大小"></a>堆总大小</h3><p>Because collections occur when generations fill up, throughput is inversely proportional to the amount of memory available.</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g467ufa9uoj30fo04rwem.jpg" alt="Description of Figure 4-1 follows"></p>
<p><strong>Heap Options</strong></p>
<p>其中图中的Virtual 表示 -Xms 小于 -Xmx 的部分</p>
<h4 id="默认配置-1"><a href="#默认配置-1" class="headerlink" title="默认配置"></a>默认配置</h4><p><strong><em>Default Options for 64-Bit Solaris Operating System</em></strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Option</th>
<th style="text-align:left">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:MinHeapFreeRatio</code></td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:MaxHeapFreeRatio</code></td>
<td style="text-align:left">70</td>
</tr>
<tr>
<td style="text-align:left"><code>-Xms</code></td>
<td style="text-align:left">6656 KB</td>
</tr>
<tr>
<td style="text-align:left"><code>-Xmx</code></td>
<td style="text-align:left">calculated</td>
</tr>
</tbody>
</table>
<p>The following are general guidelines regarding heap sizes for server applications:</p>
<ul>
<li><p>Unless you have problems with pauses, try granting as much memory as possible to the virtual machine. The default size is often too small. </p>
</li>
<li><p>Setting -Xms and -Xmx to the same value increases predictability by removing the most important sizing decision from the virtual machine. However, the virtual machine is then unable to compensate if you make a poor choice. </p>
</li>
<li><p>In general, increase the memory as you increase the number of processors, because allocation can be made parallel. </p>
</li>
</ul>
<p>​    </p>
<h4 id="动态缩小堆空间"><a href="#动态缩小堆空间" class="headerlink" title="动态缩小堆空间"></a>动态缩小堆空间</h4><p>Lowering - XX:MaxHeapFreeRatio to as low as 10% and -XX:MinHeapFreeRatio has shown to successfully reduce the heap size without too much performance degradation; </p>
<p>In addition, you can specify -XX:-ShrinkHeapInSteps, which immediately reduces the Java heap to the target size (specified by the parameter -XX:MaxHeapFreeRatio) </p>
<h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><blockquote>
<p>The bigger the young generation, the less often minor collections occur. However, for a bounded heap size, a larger young generation implies a smaller old generation, which will increase the frequency of major collections. The optimal choice depends on the lifetime distribution of the objects allocated by the application.</p>
</blockquote>
<p>年轻代越大,需要minor GC的次数越少,  major GC的次数越多 ,实际使用取决于应用内对象的生命周期分布</p>
<table>
<thead>
<tr>
<th style="text-align:left">Option</th>
<th style="text-align:left">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:NewRatio</code></td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:NewSize</code></td>
<td style="text-align:left">1310 MB</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:MaxNewSize</code></td>
<td style="text-align:left">not limited</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:SurvivorRatio</code></td>
<td style="text-align:left">8</td>
</tr>
</tbody>
</table>
<p><strong><em>Default Option Values for Survivor Space Sizing</em></strong></p>
<p>The following are general guidelines for server applications:</p>
<ul>
<li>First decide on the maximum heap size that you can afford to give the virtual machine. Then, plot your performance metric against the young generation sizes to find the best setting.<ul>
<li>Note that the maximum heap size should always be smaller than the amount of memory installed on the machine to avoid excessive page faults and thrashing.</li>
</ul>
</li>
<li>If the total heap size is fixed, then increasing the young generation size requires reducing the old generation size. Keep the old generation large enough to hold all the live data used by the application at any given time, plus some amount of slack space (10 to 20% or more).</li>
<li>Subject to the previously stated constraint on the old generation:<ul>
<li>Grant plenty of memory to the young generation.</li>
<li>Increase the young generation size as you increase the number of processors because allocation can be parallelized.</li>
</ul>
</li>
</ul>
<p>好吧,感觉这个准则在讲废话</p>
<h2 id="Available-Collectors"><a href="#Available-Collectors" class="headerlink" title="Available Collectors"></a>Available Collectors</h2><p>介绍垃圾收集器,和怎么挑选合适的垃圾收集器</p>
<p><strong>Topics</strong> </p>
<ul>
<li><p>Serial Collector </p>
</li>
<li><p>Parallel Collector </p>
</li>
<li><p>The Mostly Concurrent Collectors </p>
</li>
<li><p>Selecting a Collector </p>
</li>
</ul>
<p>​    </p>
<h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>It’s best-suited to single processor machines because it can’t take advantage of multiprocessor hardware, although it can be useful on multiprocessors for applications with small data sets (up to approximately 100 MB).  </p>
<p>收集过程,不会执行用户线程,一般适用于单处理器机器,也可以用于多处理器的小内存应用(100MB左右)</p>
<h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><p>The parallel collector is also known as <em>throughput collector</em>, it’s a generational collector similar to the serial collector. The primary difference between the serial and parallel collectors is that the parallel collector has multiple threads that are used to speed up garbage collection. </p>
<p>The parallel collector is intended for applications with medium-sized to large-sized data sets that are run on multiprocessor or multithreaded hardware. You can enable it by using the -XX:+UseParallelGC option. </p>
<p>也称为吞吐量收集器,与串行类型,不同的是多线程并行</p>
<h3 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h3><ul>
<li><p>G1 garbage collector: This server-style collector is for multiprocessor machines with a large amount of memory. It meets garbage collection pause-time goals with high probability, while achieving high throughput. </p>
<p>  G1 is selected by default on certain hardware and operating system configurations, or can be explicitly enabled using-XX:+UseG1GC . </p>
</li>
<li><p>CMS collector : This collector is for applications that prefer shorter garbage collection pauses and can afford to share processor resources with the garbage collection. </p>
<p>  Use the option -XX:+UseConcMarkSweepGC to enable the CMS collector </p>
<p>  The CMS collector is deprecated as of JDK 9. </p>
</li>
</ul>
<p>并发收集器指在垃圾收集的过程同时还可以执行用户线程(会有短暂停止)</p>
<h3 id="Z收集器"><a href="#Z收集器" class="headerlink" title="Z收集器"></a>Z收集器</h3><p>The Z Garbage Collector (ZGC) is a scalable low latency garbage collector. ZGC performs all expensive work concurrently, without stopping the execution of application threads. </p>
<p>ZGC is intended for applications which require low latency (less than 10 ms pauses) and/or use a very large heap (multi-terabytes). You can enable is by using the -XX: +UseZGC option. </p>
<p>ZGC is available as an experimental feature, starting with JDK 11. </p>
<p>适用于低延迟(10ms)和大堆的应用程序</p>
<h3 id="选择收集器"><a href="#选择收集器" class="headerlink" title="选择收集器"></a>选择收集器</h3><blockquote>
<p>Unless your application has rather strict pause-time requirements, first run your application and allow the VM to select a collector.If necessary, adjust the heap size to improve performance. </p>
</blockquote>
<p>除非有严格的短暂时间要求,否则使用默认的收集器.(或者调整堆大小)</p>
<p>If the performance still doesn’t meet your goals, then use the following guidelines as a starting point for selecting a collector:</p>
<ul>
<li><p>If the application has a small data set (up to approximately 100 MB), then select the serial collector with the option -XX:+UseSerialGC. </p>
</li>
<li><p>If the application will be run on a single processor and there are no pause-time requirements, then select the serial collector with the option -XX:+UseSerialGC. </p>
</li>
<li><p>If (a) peak application performance is the first priority and (b) there are no pause- time requirements or pauses of one second or longer are acceptable, then let the VM select the collector or select the parallel collector with -XX:+UseParallelGC. </p>
</li>
<li><p>If response time is more important than overall throughput and garbage collection pauses must be kept shorter than approximately one second, then select a mostly concurrent collector with -XX:+UseG1GC or -XX:+UseConcMarkSweepGC. </p>
</li>
<li><p>If response time is a high priority, and/or you are using a very large heap, then select a fully concurrent collector with -XX:UseZGC. </p>
</li>
</ul>
<p>选择合适的垃圾收集器只是一个起点, 仍需要通过调整VM参数 来达到需要的性能</p>
<h2 id="Collectors-Implementation"><a href="#Collectors-Implementation" class="headerlink" title="Collectors  Implementation"></a>Collectors  Implementation</h2><h3 id="The-Parallel-Collector"><a href="#The-Parallel-Collector" class="headerlink" title="The Parallel Collector"></a>The Parallel Collector</h3><blockquote>
<p>The parallel collector is enabled with the command-line option -XX:+UseParallelGC.<br>By default, with this option, both minor and major collections are run in parallel to<br>further reduce garbage collection overhead.</p>
</blockquote>
<p><strong>Topics</strong> </p>
<ul>
<li><p>Number of Parallel Collector Garbage Collector Threads </p>
</li>
<li><p>Arrangement of Generations in Parallel Collectors </p>
</li>
<li><p>Parallel Collector Ergonomics </p>
<ul>
<li><p>–  Options to Specify Parallel Collector Behaviors </p>
<ul>
<li><p>–  Priority of Parallel Collector Goals </p>
</li>
<li><p>–  Parallel Collector Generation Size Adjustments </p>
</li>
<li><p>–  Parallel Collector Default Heap Size </p>
</li>
</ul>
<p>* Specification of Parallel Collector Initial and Maximum Heap Sizes </p>
</li>
</ul>
</li>
<li><p>Excessive Parallel Collector Time and OutOfMemoryError </p>
</li>
<li><p>Parallel Collector Measurements </p>
</li>
</ul>
<h3 id="The-Mostly-Concurrent-Collectors"><a href="#The-Mostly-Concurrent-Collectors" class="headerlink" title="The Mostly Concurrent Collectors"></a>The Mostly Concurrent Collectors</h3><blockquote>
<p>On an <em>N</em> processor system, the concurrent part of the collection uses <em>K</em>/<em>N</em> of the available processors, where 1 &lt;= <em>K</em> &lt;= ceiling<em>{N/4</em>}. </p>
<p>In addition to the use of processors during concurrent phases, additional overhead is incurred to enable concurrency. Thus, while garbage collection pauses are typically much shorter with the concurrent collector, application throughput also tends to be slightly lower than with the other collectors. </p>
<p>As <em>N</em> increases, the reduction in processor resources due to concurrent garbage collection becomes smaller, and the benefit from concurrent collection increases. </p>
<p>Because at least one processor is used for garbage collection during the concurrent phases, the concurrent collectors don’t normally provide any benefit on a uniprocessor (single-core) machine.</p>
</blockquote>
<p>在多核处理器上,垃圾收集线程为 1 &lt;= <em>K</em> &lt;= ceiling<em>{N/4</em>} , 随着N的增多收益越大 , 同时注意在单核上并不适用</p>
<h4 id="Concurrent-Mark-Sweep-CMS-Collector"><a href="#Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="Concurrent Mark Sweep (CMS) Collector"></a>Concurrent Mark Sweep (CMS) Collector</h4><blockquote>
<p>The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer<br>shorter garbage collection pauses and that can afford to share processor resources<br>with the garbage collector while the application is running.</p>
</blockquote>
<p><strong>Topics</strong> </p>
<ul>
<li>Concurrent Mark Sweep Collector Performance and Structure </li>
<li>Concurrent Mode Failure </li>
<li>Excessive GC Time and OutOfMemoryError </li>
<li>Concurrent Mark Sweep Collector and Floating Garbage </li>
<li>Concurrent Mark Sweep Collector Pauses </li>
<li>Concurrent Mark Sweep Collector Concurrent Phases </li>
<li>Starting a Concurrent Collection Cycle </li>
<li>Scheduling Pauses </li>
<li>Concurrent Mark Sweep Collector Measurements </li>
</ul>
<h5 id="CMS-性能和结构"><a href="#CMS-性能和结构" class="headerlink" title="CMS 性能和结构"></a>CMS 性能和结构</h5><p><img src="https://media.licdn.com/dms/image/C4E12AQH4VHeTMCfxmA/article-cover_image-shrink_720_1280/0?e=1566432000&amp;v=beta&amp;t=ECo_SPDpBCkQlyNbEXoIgmVeTTaxLrfz7pC66OJ2mlc" alt="JVM"></p>
<p>标记和清除,更多细节参考如下</p>
<blockquote>
<p><a href="https://www.linkedin.com/pulse/jvm-why-cms-garbage-collector-deprecating-kunal-saxena" target="_blank" rel="noopener">why-cms-garbage-collector-deprecating</a></p>
<p><a href="https://juejin.im/post/5c152fefe51d45366873544a" target="_blank" rel="noopener">CMS七个阶段</a></p>
</blockquote>
<h5 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h5><blockquote>
<p>As described previously, in normal operation, the CMS collector does most of its<br>tracing and sweeping work with the application threads still running, so only brief<br>pauses are seen by the application threads. However, if the CMS collector is unable to<br>finish reclaiming the unreachable objects before the old generation fills up, or if an<br>allocation cannot be satisfied with the available free space blocks in the old<br>generation, then the application is paused and the collection is completed with all the<br>application threads stopped. </p>
<p>If a concurrent collection is interrupted by an explicit garbage<br>collection (System.gc()) or for a garbage collection needed to provide information<br>for diagnostic tools, then a concurrent mode interruption is reported.</p>
</blockquote>
<p>CMS在并发标记阶段收集失败时候(用户线程并发运行,所以会产生垃圾,如果这时候old区满了,会stop the world,退化成单线程) 至于为什么用单线程,这个是个历史遗留问题,<a href="https://www.zhihu.com/question/50398881" target="_blank" rel="noopener">传送门</a></p>
<p>如果在并发标记阶段被其他打断(System.gc()),会被报告</p>
<h5 id="GC时间过长和OutOfMemoryError"><a href="#GC时间过长和OutOfMemoryError" class="headerlink" title="GC时间过长和OutOfMemoryError"></a>GC时间过长和OutOfMemoryError</h5><p>The CMS collector throws an OutOfMemoryError if too much time is being spent in<br>garbage collection: If more than 98% of the total time is spent in garbage collection<br>and less than 2% of the heap is recovered, then an OutOfMemoryError is thrown.</p>
<h5 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h5><blockquote>
<p>Because application threads and the garbage collector thread run concurrently during a major collection, objects that are traced by the garbage collector thread may subsequently become unreachable by the time collection process ends. Such unreachable objects that haven’t yet been reclaimed are referred to as <em>floating garbage</em>.</p>
</blockquote>
<p>因为存在垃圾收集线程和工作线程并发标记的阶段, 所以在这个阶段,新产生的垃圾就无法回收,称之为浮动垃圾</p>
<p>CMS解决这个问题的方式是通过设置 多少次cms收集后运行一次压缩</p>
<p>关于Remake 为什么没办法回收浮动垃圾</p>
<blockquote>
<p><strong>重新标记（Remark）</strong> 的作用在于：<br>之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 <strong>从 GC Roots 不可达</strong> 的对象，因为用户程序的（并发）运行，<strong>又可达</strong> 了，<strong>Remark</strong> 的作用就是将这部分对象又标记为 <strong>可达对象</strong>。</p>
<p>至于 “浮动垃圾”，因为 <strong>CMS</strong> 在 <strong>并发标记</strong> 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 <strong>重新标记</strong> 的作用只是修改之前 <strong>并发标记</strong> 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。</p>
</blockquote>
<h5 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h5><blockquote>
<p>The CMS collector pauses an application twice during a concurrent collection cycle. The first pause is to mark as live the objects directly reachable from the roots (for example, object references from application thread stacks and registers, static objects, and so on) and from elsewhere in the heap (for example, the young generation). </p>
<p>This first pause is referred to as the <em>initial mark pause</em>. The second pause comes at the end of the concurrent tracing phase and finds objects that were missed by the concurrent tracing due to updates by the application threads of references in an object after the CMS collector had finished tracing that object. This second pause is referred to as the <em>remark pause</em>. </p>
</blockquote>
<ul>
<li>初始标记 <ul>
<li>初始标记 只是简单标记roots可以直接到达的对象,暂停时间短</li>
</ul>
</li>
<li>重新标记<ul>
<li>重新标记 在并发标记阶段 遗漏的对象,暂停时间会初始标记久</li>
</ul>
</li>
</ul>
<h5 id="回收时机"><a href="#回收时机" class="headerlink" title="回收时机"></a>回收时机</h5><blockquote>
<p>There are several ways to start a concurrent collection.</p>
<p>Based on recent history, the CMS collector maintains estimates of the time remaining<br>before the old generation will be exhausted and of the time needed for a concurrent<br>collection cycle. Using these dynamic estimates, a concurrent collection cycle is<br>started with the aim of completing the collection cycle before the old generation is<br>exhausted. These estimates are padded for safety because concurrent mode failure<br>can be very costly.</p>
<p>A concurrent collection also starts if the occupancy of the old generation exceeds an<br>initiating occupancy (a percentage of the old generation). The default value for this<br>initiating occupancy threshold is approximately 92%, but the value is subject to change<br>from release to release. This value can be manually adjusted using the command-line<br>option -XX:CMSInitiatingOccupancyFraction=<n>, where <n> is an integral<br>percentage (0 to 100) of the old generation size.</n></n></p>
</blockquote>
<p>根据最近的历史记录，CMS收集器维护对旧一代用尽之前剩余时间的估计以及并发收集周期所需的时间。</p>
<p>Old区使用率占比 </p>
<h5 id="暂停调度"><a href="#暂停调度" class="headerlink" title="暂停调度"></a>暂停调度</h5><blockquote>
<p>The pauses for the young generation collection and the old generation collection occur independently.<br>They don’t overlap, but may occur in quick succession such that the pause from one collection, immediately followed by one from the other collection, can appear to be a single, longer pause. To avoid this, the CMS collector attempts to schedule the remark pause roughly midway between the previous and next young generation pauses. This scheduling is currently not done for the initial mark pause, which is usually much shorter than the remark pause.</p>
</blockquote>
<p>因为old区和young区的收集是独立的,所以可以同时发生,这样会导致长暂停</p>
<p>为了避免这个问题, remake pause 会安排在两次young gc中间</p>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[121,834s][info][gc] GC(657) Pause Initial Mark 191M-&gt;191M(485M) (121,831s, 121,834s) 3,433ms</span><br><span class="line">[121,835s][info][gc] GC(657) Concurrent Mark (121,835s)</span><br><span class="line">[121,889s][info][gc] GC(657) Concurrent Mark (121,835s, 121,889s) 54,330ms</span><br><span class="line">[121,889s][info][gc] GC(657) Concurrent Preclean (121,889s)</span><br><span class="line">[121,892s][info][gc] GC(657) Concurrent Preclean (121,889s, 121,892s) 2,781ms</span><br><span class="line">[121,892s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s)</span><br><span class="line">[121,949s][info][gc] GC(658) Pause Young (Allocation Failure) 324M-&gt;199M(485M) (121,929s, 121,949s) 19,705ms</span><br><span class="line">[122,068s][info][gc] GC(659) Pause Young (Allocation Failure) 333M-&gt;200M(485M) (122,043s, 122,068s) 24,892ms</span><br><span class="line">[122,075s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s, 122,075s) 182,989ms</span><br><span class="line">[122,087s][info][gc] GC(657) Pause Remark 209M-&gt;209M(485M) (122,076s, 122,087s) 11,373ms</span><br><span class="line">[122,087s][info][gc] GC(657) Concurrent Sweep (122,087s)</span><br><span class="line">[122,193s][info][gc] GC(660) Pause Young (Allocation Failure) 301M-&gt;165M(485M) (122,181s, 122,193s) 12,151ms</span><br><span class="line">[122,254s][info][gc] GC(657) Concurrent Sweep (122,087s, 122,254s) 166,758ms</span><br><span class="line">[122,254s][info][gc] GC(657) Concurrent Reset (122,254s)</span><br><span class="line">[122,255s][info][gc] GC(657) Concurrent Reset (122,254s, 122,255s) 0,952ms</span><br><span class="line">[122,297s][info][gc] GC(661) Pause Young (Allocation Failure) 259M-&gt;128M(485M) (122,291s, 122,297s) 5,797ms</span><br></pre></td></tr></table></figure>
<p>The output for the CMS collection (GC ID 657) is interspersed with the output from the minor collections (GC IDs 658, 659 and 660);</p>
<p>The initial mark pause is typically short relative to the minor collection pause time. The concurrent phases (concurrent mark, concurrent preclean, and concurrent sweep) normally last significantly longer than a minor collection pause, as indicated in the CMS collector output example</p>
<p>从gc log 可以看到young gc 是会并存的,同时cms的主要耗时是  Concurrent phases</p>
<p>同时注意每次stop the world 算一次full gc</p>
<h4 id="Garbage-First-Garbage-Collector"><a href="#Garbage-First-Garbage-Collector" class="headerlink" title="Garbage-First Garbage Collector"></a>Garbage-First Garbage Collector</h4><p>This section describes the Garbage-First (G1) Garbage Collector (GC).</p>
<p>Topics</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42" target="_blank" rel="noopener">Introduction to Garbage-First Garbage Collector</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-CE6F94B6-71AF-45D5-829E-DEADD9BA929D" target="_blank" rel="noopener">Enabling G1</a></li>
<li>Basic Concepts<ul>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-15921907-B297-43A4-8C48-DC88035BC7CF" target="_blank" rel="noopener">Heap Layout</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180" target="_blank" rel="noopener">Garbage Collection Cycle</a></li>
</ul>
</li>
<li>Garbage-First Internals<ul>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3" target="_blank" rel="noopener">Determining Initiating Heap Occupancy</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-AC383806-7FA7-4698-8B92-4FD092B9F368" target="_blank" rel="noopener">Marking</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-BE157AF6-29E7-461A-82CF-50C1978785DA" target="_blank" rel="noopener">Behavior in Very Tight Heap Situations</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3" target="_blank" rel="noopener">Determining Initiating Heap Occupancy</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-D74F3CC7-CC9F-45B5-B03D-510AEEAC2DAC" target="_blank" rel="noopener">Humongous Objects</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-C268549C-7D95-499C-9B24-A6670B44E49C" target="_blank" rel="noopener">Young-Only Phase Generation Sizing</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-6D6B18B1-063B-48FF-99E3-5AF059C43CE8" target="_blank" rel="noopener">Space-Reclamation Phase Generation Sizing</a></li>
</ul>
</li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016" target="_blank" rel="noopener">Ergonomic Defaults for G1 GC</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-98E80C82-24D8-41D4-BC39-B2583F04F1FF" target="_blank" rel="noopener">Comparison to Other Collectors</a></li>
</ul>
<p>与CMS类似 , 但长时间运行后受碎片化影响的CMS，G1会增量式的整理/压缩堆里的数据，避免受碎片化影响</p>
<h5 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h5><p>​    将堆分为多个Region, G1 preferentially collects regions with the least amount of live data, or “garbage first”,即收集垃圾最多的Region ,”incremental collection”</p>
<h5 id="CardTable"><a href="#CardTable" class="headerlink" title="CardTable"></a>CardTable</h5><p>​    因为G1只回收一部分Region, 所以回收的时候需要知道哪些其他Region的对象引用着自己Region的对象，因为采用的copying算法需要移动对象，所以要更新引用为对象的新地址</p>
<p>​    在普通的分代收集中也是如此，分代收集中年轻代收集需要老年代到年轻代的引用的记录，通常叫做remembered set(简称RS)</p>
<p> concurrent mode failure后的并行化</p>
<p><a href="http://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/307" target="_blank" rel="noopener">JEP 307: Parallel Full GC for G1</a></p>
<h4 id="Garbage-First-Garbage-Collector-Tuning"><a href="#Garbage-First-Garbage-Collector-Tuning" class="headerlink" title="Garbage-First Garbage Collector Tuning"></a>Garbage-First Garbage Collector Tuning</h4><p>This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.</p>
<p>Topics</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6" target="_blank" rel="noopener">General Recommendations for G1</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-E26056D1-02A5-4367-94EF-72C66D314AF7" target="_blank" rel="noopener">Moving to G1 from Other Collectors</a></li>
<li>Improving G1 Performance<ul>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC" target="_blank" rel="noopener">Observing Full Garbage Collections</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-2428DA90-B93D-48E6-B336-A849ADF1C552" target="_blank" rel="noopener">Humongous Object Fragmentation</a></li>
<li>Tuning for Latency<ul>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658" target="_blank" rel="noopener">Unusual System or Real-Time Usage</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74" target="_blank" rel="noopener">Reference Object Processing Takes Too Long</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C" target="_blank" rel="noopener">Young-Only Collections Within the Young-Only Phase Take Too Long</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469" target="_blank" rel="noopener">Mixed Collections Take Too Long</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F" target="_blank" rel="noopener">High Update RS and Scan RS Times</a></li>
</ul>
</li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9" target="_blank" rel="noopener">Tuning for Throughput</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-0770AB01-E334-4E23-B307-FD2114B16E0E" target="_blank" rel="noopener">Tuning for Heap Size</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" target="_blank" rel="noopener">Tunable Defaults</a></li>
</ul>
</li>
</ul>
<h3 id="The-Z-Garbage-Collector"><a href="#The-Z-Garbage-Collector" class="headerlink" title="The Z Garbage Collector"></a>The Z Garbage Collector</h3><p>The Z Garbage Collector is available as an experimental feature, and is enabled with the command-line options <code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>.</p>
<h4 id="Setting-the-Heap-Size"><a href="#Setting-the-Heap-Size" class="headerlink" title="Setting the Heap Size"></a>Setting the Heap Size</h4><p>In general, the more memory you give to ZGC the better. But at the same time, wasting memory is undesirable, so it’s all about finding a balance between memory usage and how often the GC needs to run.</p>
<h4 id="Setting-Number-of-Concurrent-GC-Threads"><a href="#Setting-Number-of-Concurrent-GC-Threads" class="headerlink" title="Setting Number of Concurrent GC Threads"></a>Setting Number of Concurrent GC Threads</h4><p>-XX:ConcGCThreads</p>
<p>This option essentially dictates how much CPU-time the GC should be given. </p>
<h2 id="Other-Considerations"><a href="#Other-Considerations" class="headerlink" title="Other Considerations"></a>Other Considerations</h2><p>This section covers other situations that affect garbage collection.</p>
<p>Topics</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-A7B0991C-661F-47BE-AEDB-74C6BDBDE181" target="_blank" rel="noopener">Finalization and Weak, Soft, and Phantom References</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-9E3E5371-20F5-4B70-A003-9D7851B115AF" target="_blank" rel="noopener">Explicit Garbage Collection</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-BFB89453-60C0-42AC-81CA-87D59B0ACE2E" target="_blank" rel="noopener">Soft References</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-B29C9153-3530-4C15-9154-E74F44E3DAD9" target="_blank" rel="noopener">Class Metadata</a></li>
</ul>
<blockquote>
<p>These features can create performance artifacts at the Java programming language level. An example of this is relying on finalization to close file descriptors, which makes an external resource (descriptors) dependent on garbage collection promptness. Relying on garbage collection to manage resources other than memory is almost always a bad idea.</p>
<p>In previous releases of Java Hotspot VM, the class metadata was allocated in the so-called permanent generation. Starting with JDK 8, the permanent generation was removed and the class metadata is allocated in native memory</p>
</blockquote>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jvm/" rel="tag"># jvm</a>
          
            <a href="/tags/gc/" rel="tag"># gc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/16/J-U-C-InterruptedException/" rel="next" title="J.U.C_InterruptedException">
                <i class="fa fa-chevron-left"></i> J.U.C_InterruptedException
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/24/J-U-C-ConcurrentHashMap/" rel="prev" title="J.U.C_ConcurrentHashMap">
                J.U.C_ConcurrentHashMap <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MzM0Ny8xOTg4OA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="zhengyumin">
            
              <p class="site-author-name" itemprop="name">zhengyumin</p>
              <div class="site-description motion-element" itemprop="description">为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Zyumin" title="GitHub &rarr; https://github.com/Zyumin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Preface"><span class="nav-number">1.</span> <span class="nav-text">Preface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction-to-Garbage-Collection-Tuning"><span class="nav-number">2.</span> <span class="nav-text">Introduction to Garbage Collection Tuning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ergonomics"><span class="nav-number">3.</span> <span class="nav-text">Ergonomics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认配置"><span class="nav-number">3.1.</span> <span class="nav-text">默认配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于特性调整"><span class="nav-number">3.2.</span> <span class="nav-text">基于特性调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#策略"><span class="nav-number">3.3.</span> <span class="nav-text">策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Garbage-Collector-Implementation"><span class="nav-number">4.</span> <span class="nav-text">Garbage Collector Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收分代策略"><span class="nav-number">4.1.</span> <span class="nav-text">垃圾回收分代策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代"><span class="nav-number">4.2.</span> <span class="nav-text">分代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能注意事项"><span class="nav-number">4.3.</span> <span class="nav-text">性能注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#吞吐和占用空间测量"><span class="nav-number">4.4.</span> <span class="nav-text">吞吐和占用空间测量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Factors-Affecting-Garbage-Collection-Performance"><span class="nav-number">5.</span> <span class="nav-text">Factors Affecting Garbage Collection Performance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆总大小"><span class="nav-number">5.1.</span> <span class="nav-text">堆总大小</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#默认配置-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">默认配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态缩小堆空间"><span class="nav-number">5.1.2.</span> <span class="nav-text">动态缩小堆空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#年轻代"><span class="nav-number">5.2.</span> <span class="nav-text">年轻代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Available-Collectors"><span class="nav-number">6.</span> <span class="nav-text">Available Collectors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#串行收集器"><span class="nav-number">6.1.</span> <span class="nav-text">串行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行收集器"><span class="nav-number">6.2.</span> <span class="nav-text">并行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发收集器"><span class="nav-number">6.3.</span> <span class="nav-text">并发收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Z收集器"><span class="nav-number">6.4.</span> <span class="nav-text">Z收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择收集器"><span class="nav-number">6.5.</span> <span class="nav-text">选择收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors-Implementation"><span class="nav-number">7.</span> <span class="nav-text">Collectors  Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Parallel-Collector"><span class="nav-number">7.1.</span> <span class="nav-text">The Parallel Collector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Mostly-Concurrent-Collectors"><span class="nav-number">7.2.</span> <span class="nav-text">The Mostly Concurrent Collectors</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Concurrent-Mark-Sweep-CMS-Collector"><span class="nav-number">7.2.1.</span> <span class="nav-text">Concurrent Mark Sweep (CMS) Collector</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS-性能和结构"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">CMS 性能和结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Concurrent-Mode-Failure"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">Concurrent Mode Failure</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GC时间过长和OutOfMemoryError"><span class="nav-number">7.2.1.3.</span> <span class="nav-text">GC时间过长和OutOfMemoryError</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#浮动垃圾"><span class="nav-number">7.2.1.4.</span> <span class="nav-text">浮动垃圾</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#暂停"><span class="nav-number">7.2.1.5.</span> <span class="nav-text">暂停</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回收时机"><span class="nav-number">7.2.1.6.</span> <span class="nav-text">回收时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#暂停调度"><span class="nav-number">7.2.1.7.</span> <span class="nav-text">暂停调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#日志"><span class="nav-number">7.2.1.8.</span> <span class="nav-text">日志</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Garbage-First-Garbage-Collector"><span class="nav-number">7.2.2.</span> <span class="nav-text">Garbage-First Garbage Collector</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Region"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">Region</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CardTable"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">CardTable</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Garbage-First-Garbage-Collector-Tuning"><span class="nav-number">7.2.3.</span> <span class="nav-text">Garbage-First Garbage Collector Tuning</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Z-Garbage-Collector"><span class="nav-number">7.3.</span> <span class="nav-text">The Z Garbage Collector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Setting-the-Heap-Size"><span class="nav-number">7.3.1.</span> <span class="nav-text">Setting the Heap Size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Setting-Number-of-Concurrent-GC-Threads"><span class="nav-number">7.3.2.</span> <span class="nav-text">Setting Number of Concurrent GC Threads</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Other-Considerations"><span class="nav-number">8.</span> <span class="nav-text">Other Considerations</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhengyumin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">463k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">7:01</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  
    <script>
  window.livereOptions = {
    refer: '2019/06/19/JVM-Garbage-Collection/'
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

  


  




  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'D2GGMftjnaihnt6xGsBOCK1T-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'D2GGMftjnaihnt6xGsBOCK1T-gzGzoHsz',
                'X-LC-Key': '42G22rkOJK422bv0XSJhBrW6',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
