<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>Documentation-Spring_Core_IOC | Zyumin</title>
  <meta name="keywords" content=" spring , doc ">
  <meta name="description" content="Documentation-Spring_Core_IOC | Zyumin">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta name="keywords" content="java">
<meta property="og:type" content="website">
<meta property="og:title" content="tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="Zyumin">
<meta property="og:description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-23T07:09:56.946Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tags">
<meta name="twitter:description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/github-gist.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1.0.1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.png">
</a>
<div class="author">
    <span>zhengyumin</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/Zyumin" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"/>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=60037019" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"/>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(43)</small></div></li>
    
        
            
            <li><div data-rel="jdk">jdk<small>(13)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="java">java<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="spring">spring<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="mysql">mysql<small>(2)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="43">
<input type="hidden" id="yelog_site_word_count" value="132.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="以 in: 开头进行全文搜索" autocomplete="off" id="local-search-input">
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none">
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">week</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">hide</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">jdk</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">packages</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">utils</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">note</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">jvm</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">distributed</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">kafka</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">framework</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">netty</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">nio</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">zookeeper</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">redis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Spec</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">thread</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">tomcat</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">mysql</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">juc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">classLoader</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">hotspot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">j2ee</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">summary</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">lang</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">elasticsearch</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">servlet</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">io</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">serialization</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">file</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">ejb</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">gc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">collections</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">map</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">doc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">spring-mvc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">spring-webflux</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a id="top" class="java " href="/2019/02/02/Overview_java/" data-tag="summary" data-author="">
            <span class="post-title" title="Overview_java">Overview_java</span>
            <span class="post-date" title="2019-02-02 20:43:14">2019/02/02</span>
        </a>
        
        <a id="top" class="spring " href="/2019/03/02/Overview_Spring/" data-tag="framework,spring" data-author="">
            <span class="post-title" title="Overview-Spring">Overview-Spring</span>
            <span class="post-date" title="2019-03-02 12:29:06">2019/03/02</span>
        </a>
        
        <a id="top" class="jdk " href="/2019/06/13/Overview_JDK/" data-tag="jdk,hotspot" data-author="">
            <span class="post-title" title="Overview_JDK">Overview_JDK</span>
            <span class="post-date" title="2019-06-13 19:36:54">2019/06/13</span>
        </a>
        
        <a class="spring " href="/2019/12/02/spring-Q-A/" data-tag="spring" data-author="">
            <span class="post-title" title="spring Q&amp;A">spring Q&amp;A</span>
            <span class="post-date" title="2019-12-02 18:20:38">2019/12/02</span>
        </a>
        
        <a class="spring " href="/2019/10/29/Documentation-Spring-Core-IOC/" data-tag="spring,doc" data-author="">
            <span class="post-title" title="Documentation-Spring_Core_IOC">Documentation-Spring_Core_IOC</span>
            <span class="post-date" title="2019-10-29 21:51:07">2019/10/29</span>
        </a>
        
        <a class="jdk " href="/2019/09/26/JDK-Packages-java-nio/" data-tag="jdk,packages,nio" data-author="">
            <span class="post-title" title="JDK_Packages_java_nio">JDK_Packages_java_nio</span>
            <span class="post-date" title="2019-09-26 10:39:22">2019/09/26</span>
        </a>
        
        <a class="jdk " href="/2019/09/23/JDK-Packages-java-io/" data-tag="jdk,packages,io,serialization,file" data-author="">
            <span class="post-title" title="JDK_Packages_java_io">JDK_Packages_java_io</span>
            <span class="post-date" title="2019-09-23 16:07:43">2019/09/23</span>
        </a>
        
        <a class="jdk " href="/2019/08/31/JDK-Class/" data-tag="jdk" data-author="">
            <span class="post-title" title="JDK_Class">JDK_Class</span>
            <span class="post-date" title="2019-08-31 19:38:34">2019/08/31</span>
        </a>
        
        <a class="jdk " href="/2019/08/31/JDK-Thread/" data-tag="jdk,jvm,hotspot" data-author="">
            <span class="post-title" title="JDK_Thread">JDK_Thread</span>
            <span class="post-date" title="2019-08-31 18:16:08">2019/08/31</span>
        </a>
        
        <a class="java " href="/2019/08/29/JVM-main方法分析/" data-tag="java,jvm" data-author="">
            <span class="post-title" title="JVM_main方法分析">JVM_main方法分析</span>
            <span class="post-date" title="2019-08-29 23:38:13">2019/08/29</span>
        </a>
        
        <a class="jdk " href="/2019/08/24/JDK-ReentrantLock/" data-tag="jdk,juc" data-author="">
            <span class="post-title" title="JDK_ReentrantLock">JDK_ReentrantLock</span>
            <span class="post-date" title="2019-08-24 18:48:54">2019/08/24</span>
        </a>
        
        <a class="java " href="/2019/08/17/JVM-Synchronized/" data-tag="jvm" data-author="">
            <span class="post-title" title="JVM_Synchronized">JVM_Synchronized</span>
            <span class="post-date" title="2019-08-17 17:01:54">2019/08/17</span>
        </a>
        
        <a class="java " href="/2019/08/11/Overview-Java-Virtual-Machine/" data-tag="jvm" data-author="">
            <span class="post-title" title="Overview_Java Virtual Machine">Overview_Java Virtual Machine</span>
            <span class="post-date" title="2019-08-11 19:05:38">2019/08/11</span>
        </a>
        
        <a class="jdk " href="/2019/08/11/JDK-Packages-java-lang/" data-tag="jdk,packages,lang" data-author="">
            <span class="post-title" title="JDK_Packages_java_lang">JDK_Packages_java_lang</span>
            <span class="post-date" title="2019-08-11 19:04:56">2019/08/11</span>
        </a>
        
        <a class="jdk " href="/2019/08/11/JDK-Packages-java-utils/" data-tag="jdk,packages,utils" data-author="">
            <span class="post-title" title="JDK_Packages_java_utils">JDK_Packages_java_utils</span>
            <span class="post-date" title="2019-08-11 19:04:25">2019/08/11</span>
        </a>
        
        <a class="jdk " href="/2019/08/10/JDK-The-Concurrent-Framework/" data-tag="jdk,juc" data-author="">
            <span class="post-title" title="JDK_The Concurrent Framework">JDK_The Concurrent Framework</span>
            <span class="post-date" title="2019-08-10 19:45:39">2019/08/10</span>
        </a>
        
        <a class="jdk " href="/2019/07/29/JDK-The-Collections-Framework/" data-tag="jdk,collections" data-author="">
            <span class="post-title" title="JDK_The Collections Framework">JDK_The Collections Framework</span>
            <span class="post-date" title="2019-07-29 15:26:01">2019/07/29</span>
        </a>
        
        <a class="" href="/2019/07/10/Note-码农翻身/" data-tag="java,note" data-author="">
            <span class="post-title" title="Note_码农翻身">Note_码农翻身</span>
            <span class="post-date" title="2019-07-10 22:18:56">2019/07/10</span>
        </a>
        
        <a class="jdk " href="/2019/07/06/JDK-ClassLoader/" data-tag="jdk,classLoader" data-author="">
            <span class="post-title" title="JDK_ClassLoader">JDK_ClassLoader</span>
            <span class="post-date" title="2019-07-06 23:12:51">2019/07/06</span>
        </a>
        
        <a class="" href="/2019/06/26/Overview_Elasticsearch/" data-tag="framework,elasticsearch" data-author="">
            <span class="post-title" title="Overview_Elasticsearch">Overview_Elasticsearch</span>
            <span class="post-date" title="2019-06-26 18:06:48">2019/06/26</span>
        </a>
        
        <a class="jdk " href="/2019/06/24/J-U-C-ConcurrentHashMap/" data-tag="juc,map" data-author="">
            <span class="post-title" title="J.U.C_ConcurrentHashMap">J.U.C_ConcurrentHashMap</span>
            <span class="post-date" title="2019-06-24 19:03:29">2019/06/24</span>
        </a>
        
        <a class="java " href="/2019/06/19/JVM-Garbage-Collection/" data-tag="jvm,gc" data-author="">
            <span class="post-title" title="JVM_Garbage Collection">JVM_Garbage Collection</span>
            <span class="post-date" title="2019-06-19 00:28:10">2019/06/19</span>
        </a>
        
        <a class="jdk " href="/2019/06/16/J-U-C-InterruptedException/" data-tag="juc" data-author="">
            <span class="post-title" title="J.U.C_InterruptedException">J.U.C_InterruptedException</span>
            <span class="post-date" title="2019-06-16 16:09:43">2019/06/16</span>
        </a>
        
        <a class="java " href="/2019/06/14/Spec-JSR133/" data-tag="jvm,Spec,thread" data-author="">
            <span class="post-title" title="Spec_JSR133">Spec_JSR133</span>
            <span class="post-date" title="2019-06-14 19:26:57">2019/06/14</span>
        </a>
        
        <a class="java " href="/2019/06/13/Spec-Java-Virtual-Machine/" data-tag="jvm,Spec" data-author="">
            <span class="post-title" title="Spec_Java Virtual Machine">Spec_Java Virtual Machine</span>
            <span class="post-date" title="2019-06-13 17:25:17">2019/06/13</span>
        </a>
        
        <a class="" href="/2019/06/12/Overview_Kafka/" data-tag="kafka,framework" data-author="">
            <span class="post-title" title="kafka深入浅出">kafka深入浅出</span>
            <span class="post-date" title="2019-06-12 20:05:37">2019/06/12</span>
        </a>
        
        <a class="" href="/2019/06/10/Overview_Redis/" data-tag="framework,redis" data-author="">
            <span class="post-title" title="redis深入浅出">redis深入浅出</span>
            <span class="post-date" title="2019-06-10 18:33:40">2019/06/10</span>
        </a>
        
        <a class="" href="/2019/06/06/Note_java并发编程的艺术/" data-tag="java,note,juc" data-author="">
            <span class="post-title" title="Note_java并发编程的艺术">Note_java并发编程的艺术</span>
            <span class="post-date" title="2019-06-06 19:05:01">2019/06/06</span>
        </a>
        
        <a class="" href="/2019/06/05/Overview_Netty/" data-tag="framework,netty,nio" data-author="">
            <span class="post-title" title="Netty深入浅出">Netty深入浅出</span>
            <span class="post-date" title="2019-06-05 22:01:31">2019/06/05</span>
        </a>
        
        <a class="" href="/2019/06/05/Note_深入理解java虚拟机/" data-tag="java,note,jvm" data-author="">
            <span class="post-title" title="Note_深入理解java虚拟机">Note_深入理解java虚拟机</span>
            <span class="post-date" title="2019-06-05 21:12:25">2019/06/05</span>
        </a>
        
        <a class="mysql " href="/2019/06/04/Overview_MySQL/" data-tag="mysql" data-author="">
            <span class="post-title" title="MySQL深入浅出">MySQL深入浅出</span>
            <span class="post-date" title="2019-06-04 22:02:31">2019/06/04</span>
        </a>
        
        <a class="" href="/2019/06/03/Overview_Zookeeper/" data-tag="distributed,framework,zookeeper" data-author="">
            <span class="post-title" title="Zookeeper深入浅出">Zookeeper深入浅出</span>
            <span class="post-date" title="2019-06-03 21:15:05">2019/06/03</span>
        </a>
        
        <a class="" href="/2019/06/03/Overview_Distributed/" data-tag="distributed" data-author="">
            <span class="post-title" title="分布式理论基础">分布式理论基础</span>
            <span class="post-date" title="2019-06-03 20:34:37">2019/06/03</span>
        </a>
        
        <a class="spring " href="/2019/04/10/spring-api-1-0/" data-tag="spring" data-author="">
            <span class="post-title" title="spring-api-1.0">spring-api-1.0</span>
            <span class="post-date" title="2019-04-10 09:45:25">2019/04/10</span>
        </a>
        
        <a class="" href="/2019/04/01/3月第四周知识点记录/" data-tag="week,hide" data-author="">
            <span class="post-title" title="3月第四周知识点记录">3月第四周知识点记录</span>
            <span class="post-date" title="2019-04-01 09:51:07">2019/04/01</span>
        </a>
        
        <a class="mysql " href="/2019/03/30/记一次mysql查询in的思考/" data-tag="mysql" data-author="">
            <span class="post-title" title="记一次mysql查询in的思考">记一次mysql查询in的思考</span>
            <span class="post-date" title="2019-03-30 20:39:49">2019/03/30</span>
        </a>
        
        <a class="" href="/2019/03/26/记一次Broken-pipe问题的思考/" data-tag="tomcat" data-author="">
            <span class="post-title" title="记一次Broken pipe问题的思考">记一次Broken pipe问题的思考</span>
            <span class="post-date" title="2019-03-26 10:53:37">2019/03/26</span>
        </a>
        
        <a class="" href="/2019/03/24/3月第三周知识点记录/" data-tag="week,hide" data-author="">
            <span class="post-title" title="3月第三周知识点记录">3月第三周知识点记录</span>
            <span class="post-date" title="2019-03-24 20:55:31">2019/03/24</span>
        </a>
        
        <a class="" href="/2019/03/10/Note_Expert One-on-One-J2EE-Development-without-EJB/" data-tag="spring,j2ee,ejb" data-author="">
            <span class="post-title" title="Expert One-on-One J2EE Development without EJB">Expert One-on-One J2EE Development without EJB</span>
            <span class="post-date" title="2019-03-10 19:45:57">2019/03/10</span>
        </a>
        
        <a class="" href="/2019/03/10/Note_Expert-One-on-One-J2EE-Design-and-Development/" data-tag="spring,j2ee" data-author="">
            <span class="post-title" title="Expert One-on-One J2EE Design and Development">Expert One-on-One J2EE Design and Development</span>
            <span class="post-date" title="2019-03-10 19:45:18">2019/03/10</span>
        </a>
        
        <a class="spring " href="/2019/02/03/spring-mvc/" data-tag="spring,servlet,spring-mvc,spring-webflux" data-author="">
            <span class="post-title" title="servlet_spring-mvc">servlet_spring-mvc</span>
            <span class="post-date" title="2019-02-03 15:50:16">2019/02/03</span>
        </a>
        
        <a class="" href="/2019/02/03/Overview_Tomcat/" data-tag="tomcat,servlet" data-author="">
            <span class="post-title" title="servlet_tomcat">servlet_tomcat</span>
            <span class="post-date" title="2019-02-03 15:49:08">2019/02/03</span>
        </a>
        
        <a class="" href="/2019/02/02/Spec_Servlet/" data-tag="j2ee,servlet" data-author="">
            <span class="post-title" title="j2ee_servlet">j2ee_servlet</span>
            <span class="post-date" title="2019-02-02 18:05:54">2019/02/02</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-Documentation-Spring-Core-IOC" class="article article-type-post" itemscope="" itemprop="blogPost">
    
        <h1 class="article-title">Documentation-Spring_Core_IOC</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="spring">spring</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color2">spring</a>
            
            <a href="javascript:" class="color4">doc</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title="更新时间: 2019-12-22 17:31:36">2019-10-29 21:51</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:11.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟introduction-（介绍）"><span class="toc-text">🌟introduction （介绍）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory"><span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext"><span class="toc-text">ApplicationContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Beans"><span class="toc-text">Beans</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Container-overview-（容器预览）"><span class="toc-text">🌟Container overview （容器预览）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#configuration-metadata-配置元信息"><span class="toc-text">configuration metadata (配置元信息)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instantiating-a-Container-实例化容器"><span class="toc-text">Instantiating a Container (实例化容器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-the-Container-使用容器"><span class="toc-text">Using the Container (使用容器)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Bean-Overview-bean-预览"><span class="toc-text">🌟Bean Overview (bean 预览)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#beanDefinition-bean定义"><span class="toc-text">beanDefinition(bean定义)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#naming-bean-bean命名"><span class="toc-text">naming  bean (bean命名)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Aliasing-a-Bean-outside-the-Bean-Definition"><span class="toc-text">Aliasing a Bean outside the Bean Definition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instantiating-bean-bean构造方式"><span class="toc-text">Instantiating bean (bean构造方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Instantiation-with-a-Constructor"><span class="toc-text">Instantiation with a Constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instantiation-with-a-Static-Factory-Method"><span class="toc-text">Instantiation with a Static Factory Method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instantiation-by-Using-an-Instance-Factory-Method"><span class="toc-text">Instantiation by Using an Instance Factory Method</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Dependencies-依赖"><span class="toc-text">🌟Dependencies (依赖)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependency-Injection-DI"><span class="toc-text">Dependency Injection(DI)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Constructor-based-Dependency-Injection-构造注入"><span class="toc-text">Constructor-based Dependency Injection(构造注入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Setter-based-Dependency-Injection-Setter注入"><span class="toc-text">Setter-based Dependency Injection(Setter注入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dependency-Resolution-Process-依赖解析过程"><span class="toc-text">Dependency Resolution Process (依赖解析过程)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Circular-dependencies-循环依赖问题"><span class="toc-text">Circular dependencies (循环依赖问题)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pre-instantiate-预实例化可以提早发现错误"><span class="toc-text">pre-instantiate (预实例化可以提早发现错误)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#collaborating-被装载的是完整实例"><span class="toc-text">collaborating (被装载的是完整实例)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Examples-of-Dependency-Injection"><span class="toc-text">Examples of Dependency Injection</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependencies-and-Configuration-in-Detail"><span class="toc-text">Dependencies and Configuration in Detail</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-depends-on-使用-depends-on"><span class="toc-text">Using depends-on (使用 depends-on)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lazy-initialized-Beans-懒加载"><span class="toc-text">Lazy-initialized Beans (懒加载)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowiring-Collaborators-自动装配"><span class="toc-text">Autowiring Collaborators(自动装配)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Limitations-and-Disadvantages-of-Autowiring-自动装配的局限性和缺点"><span class="toc-text">Limitations and Disadvantages of Autowiring (自动装配的局限性和缺点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Excluding-a-Bean-from-Autowiring-从自动装配中排除Bean"><span class="toc-text">Excluding a Bean from Autowiring(从自动装配中排除Bean)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-Injection-方法注入"><span class="toc-text">Method Injection (方法注入)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lookup-Method-Injection"><span class="toc-text">Lookup Method Injection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arbitrary-任意的-Method-Replacement"><span class="toc-text">Arbitrary (任意的)Method Replacement</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Bean-Scopes-（作用域）"><span class="toc-text">🌟Bean Scopes  （作用域）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Singleton-Scope"><span class="toc-text">The Singleton Scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Prototype-Scope"><span class="toc-text">The Prototype Scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Singleton-Beans-with-Prototype-bean-Dependencies"><span class="toc-text">Singleton Beans with Prototype-bean Dependencies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-Session-Application-and-WebSocket-Scopes"><span class="toc-text">Request, Session, Application, and WebSocket Scopes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Request-scope"><span class="toc-text">Request scope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-Scope"><span class="toc-text">Session Scope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application-Scope"><span class="toc-text">Application Scope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scoped-Beans-as-Dependencies"><span class="toc-text">Scoped Beans as Dependencies</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Scopes"><span class="toc-text">Custom Scopes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Customizing-the-Nature-of-a-Bean-bean扩展点"><span class="toc-text">🌟Customizing the Nature of a Bean(bean扩展点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lifecycle-Callbacks-生命周期回调"><span class="toc-text">Lifecycle Callbacks (生命周期回调)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Initialization-Callbacks"><span class="toc-text">Initialization Callbacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Destruction-Callbacks"><span class="toc-text">Destruction Callbacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Default-Initialization-and-Destroy-Methods"><span class="toc-text">Default Initialization and Destroy Methods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combining-Lifecycle-Mechanisms"><span class="toc-text">Combining Lifecycle Mechanisms</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Startup-and-Shutdown-Callbacks"><span class="toc-text">Startup and Shutdown Callbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Lifecycle"><span class="toc-text">Lifecycle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LifecycleProcessor"><span class="toc-text">LifecycleProcessor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Phased"><span class="toc-text">Phased</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><span class="toc-text">Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContextAware-and-BeanNameAware"><span class="toc-text">ApplicationContextAware and BeanNameAware</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContextAware"><span class="toc-text">ApplicationContextAware</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanNameAware"><span class="toc-text">BeanNameAware</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-Aware-Interfaces"><span class="toc-text">Other Aware Interfaces</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean-Definition-Inheritance-定义继承"><span class="toc-text">Bean Definition Inheritance (定义继承)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Container-Extension-Points-（容器扩展点）"><span class="toc-text">🌟Container Extension Points （容器扩展点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Customizing-Beans-by-Using-a-BeanPostProcessor"><span class="toc-text">Customizing Beans by Using a BeanPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor"><span class="toc-text">Customizing Configuration Metadata with a BeanFactoryPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertySourcesPlaceholderConfigurer"><span class="toc-text">PropertySourcesPlaceholderConfigurer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertyOverrideConfigurer"><span class="toc-text">PropertyOverrideConfigurer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Customizing-Instantiation-Logic-with-a-FactoryBean"><span class="toc-text">Customizing Instantiation Logic with a FactoryBean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Annotation-based-Container-Configuration-（基于注释的容器配置）"><span class="toc-text">🌟Annotation-based Container Configuration （基于注释的容器配置）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Required"><span class="toc-text">@Required</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Autowired"><span class="toc-text">Using @Autowired</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Order"><span class="toc-text">@Order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java8-amp-spring-5-0"><span class="toc-text">Java8 &amp; spring 5.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fine-tuning-微调-Annotation-based-Autowiring-with-Primary"><span class="toc-text">Fine-tuning(微调) Annotation-based Autowiring with @Primary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fine-tuning-Annotation-based-Autowiring-with-Qualifiers"><span class="toc-text">Fine-tuning Annotation-based Autowiring with Qualifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Generics-as-Autowiring-Qualifiers"><span class="toc-text">Using Generics as Autowiring Qualifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-CustomAutowireConfigurer"><span class="toc-text">Using CustomAutowireConfigurer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Injection-with-Resource-JSR-250-amp-name"><span class="toc-text">Injection with @Resource (JSR-250 &amp; name)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Value"><span class="toc-text">Using @Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-PostConstruct-and-PreDestroy-JSR-250"><span class="toc-text">Using @PostConstruct and @PreDestroy (JSR-250)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Classpath-Scanning-and-Managed-Components"><span class="toc-text">🌟Classpath Scanning and Managed Components</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Component-and-Further-Stereotype-Annotations-模式注解"><span class="toc-text">@Component and Further Stereotype Annotations (模式注解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Meta-annotations-and-Composed-Annotations-元注解"><span class="toc-text">Using Meta-annotations and Composed Annotations(元注解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Automatically-Detecting-Classes-and-Registering-Bean-Definitions-自动检测类并注册Bean定义"><span class="toc-text">Automatically Detecting Classes and Registering Bean Definitions(自动检测类并注册Bean定义)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Filters-to-Customize-Scanning"><span class="toc-text">Using Filters to Customize Scanning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-Bean-Metadata-within-Components-在组件中定义Bean元数据"><span class="toc-text">Defining Bean Metadata within Components(在组件中定义Bean元数据)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naming-Autodetected-Components-命名自动检测的组件"><span class="toc-text">Naming Autodetected Components(命名自动检测的组件)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Providing-a-Scope-for-Autodetected-Components-提供自动检测组件的作用域"><span class="toc-text">Providing a Scope for Autodetected Components(提供自动检测组件的作用域)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Providing-Qualifier-Metadata-with-Annotations"><span class="toc-text">Providing Qualifier Metadata with Annotations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generating-an-Index-of-Candidate-Components-生成候选组件的索引"><span class="toc-text">Generating an Index of Candidate Components(生成候选组件的索引)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Using-JSR-330-Standard-Annotations"><span class="toc-text">🌟Using JSR 330 Standard Annotations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependency-Injection-with-Inject-and-Named"><span class="toc-text">Dependency Injection with @Inject and @Named</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation-Component注解的比较"><span class="toc-text">@Named and @ManagedBean: Standard Equivalents to the @Component Annotation(@Component注解的比较)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Limitations-of-JSR-330-Standard-Annotations"><span class="toc-text">Limitations of JSR-330 Standard Annotations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Java-based-Container-Configuration-基于Java的容器配置"><span class="toc-text">🌟Java-based Container Configuration(基于Java的容器配置)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Concepts-Bean-and-Configuration"><span class="toc-text">Basic Concepts: @Bean and @Configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext"><span class="toc-text">Instantiating the Spring Container by Using AnnotationConfigApplicationContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-the-Bean-Annotation"><span class="toc-text">Using the @Bean Annotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-the-Configuration-annotation"><span class="toc-text">Using the @Configuration annotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composing-Java-based-Configurations"><span class="toc-text">Composing Java-based Configurations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-the-Import-Annotation"><span class="toc-text">Using the @Import Annotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conditionally-Include-Configuration-Classes-or-Bean-Methods"><span class="toc-text">Conditionally Include @Configuration Classes or @Bean Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combining-Java-and-XML-Configuration"><span class="toc-text">Combining Java and XML Configuration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML-centric-Use-of-Configuration-Classes"><span class="toc-text">XML-centric Use of @Configuration Classes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurationClass-centric-Use-of-XML-with-ImportResource"><span class="toc-text">@ConfigurationClass-centric Use of XML with@ImportResource</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Environment-Abstraction-（环境抽象）"><span class="toc-text">🌟Environment Abstraction （环境抽象）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-Definition-Profiles"><span class="toc-text">Bean Definition Profiles</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-Profile"><span class="toc-text">Using @Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML-Bean-Definition-Profiles"><span class="toc-text">XML Bean Definition Profiles</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Activating-a-Profile"><span class="toc-text">Activating a Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Default-Profile"><span class="toc-text">Default Profile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PropertySource-Abstraction"><span class="toc-text">PropertySource Abstraction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-PropertySource"><span class="toc-text">Using @PropertySource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Placeholder-Resolution-in-Statements"><span class="toc-text">Placeholder Resolution in Statements</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Registering-a-LoadTimeWeaver"><span class="toc-text">🌟Registering a LoadTimeWeaver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟Additional-Capabilities-of-the-ApplicationContext-BeanFactory的扩展"><span class="toc-text">🌟Additional Capabilities of the ApplicationContext (BeanFactory的扩展)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Internationalization-using-MessageSource"><span class="toc-text">Internationalization using MessageSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Standard-and-Custom-Events"><span class="toc-text">Standard and Custom Events</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Annotation-based-Event-Listeners"><span class="toc-text">Annotation-based Event Listeners</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Asynchronous-Listeners"><span class="toc-text">Asynchronous Listeners</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ordering-Listeners"><span class="toc-text">Ordering Listeners</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generic-Events"><span class="toc-text">Generic Events</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Convenient-Access-to-Low-level-Resources"><span class="toc-text">Convenient Access to Low-level Resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Convenient-ApplicationContext-Instantiation-for-Web-Applications"><span class="toc-text">Convenient ApplicationContext Instantiation for Web Applications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deploying-a-Spring-ApplicationContext-as-a-Java-EE-RAR-File"><span class="toc-text">Deploying a Spring ApplicationContext as a Java EE RAR File</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🌟The-BeanFactory"><span class="toc-text">🌟The BeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory-or-ApplicationContext"><span class="toc-text">BeanFactory or ApplicationContext?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总览"><span class="toc-text">总览</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关键字:  bean(定义-关系、 加载方式(创建、解析)  、扩展)、application(容器、resource、加载、扩展)、注解、环境(Environment)</p>
<p>Tips: 在看官方文档时候的一些摘抄、总结(建议直接阅读官方文档</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans</a></p>
<p>Version 5.2.1.RELEASE  ) </p>
<p>IOC 容器(DI 查找和注入)</p>
<p>​    —&gt; Bean管理 (关系、作用域、生命周期、扩展点)</p>
<p>​    —&gt; Bean元信息(属性值)</p>
<p>基础设施扩展 (资源管理 类型 事件等)</p>
<a id="more"></a>
<!--toc-->
<h2 id="🌟introduction-（介绍）"><a href="#🌟introduction-（介绍）" class="headerlink" title="🌟introduction （介绍）"></a>🌟introduction （介绍）</h2><p>关键词: BeanFactory、ApplicationContext (App internationalization 、event 、web)、beans</p>
<p>This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle.</p>
<p> IoC is also known as dependency injection (DI)</p>
<p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis for Spring Framework’s IoC container. </p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>The <a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener"><code>BeanFactory</code></a> interface provides an advanced configuration mechanism capable of managing any type of object</p>
<p>提供了一种能够管理任何类型对象的高级配置机制</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener"><code>ApplicationContext</code></a> </p>
<ul>
<li>Easier integration with Spring’s AOP features (和AOP更好集成)</li>
<li>Message resource handling (for use in internationalization)</li>
<li>Event publication (事件发布机制)</li>
<li>Application-layer specific contexts such as the <code>WebApplicationContext</code> for use in web applications.</li>
</ul>
<h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h3><p>A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container.</p>
<p>Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p>
<p>bean是由Spring IoC容器实例化、组装和管理的对象。</p>
<p>bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>
<h2 id="🌟Container-overview-（容器预览）"><a href="#🌟Container-overview-（容器预览）" class="headerlink" title="🌟Container overview （容器预览）"></a>🌟Container overview （容器预览）</h2><p>关键词: configuration metadata、Instantiating</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8fetrcx4vj30du088mxd.jpg" alt="container magic"></p>
<h3 id="configuration-metadata-配置元信息"><a href="#configuration-metadata-配置元信息" class="headerlink" title="configuration metadata (配置元信息)"></a>configuration metadata (配置元信息)</h3><p>The configuration metadata is represented in XML, Java annotations, or Java code. </p>
<p>annotations </p>
<ul>
<li>spring 2.5   annotation-based</li>
<li>spring 3.0   java-based  Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the @Configuration, @Bean, @Import, and @DependsOn annotations.</li>
</ul>
<h3 id="Instantiating-a-Container-实例化容器"><a href="#Instantiating-a-Container-实例化容器" class="headerlink" title="Instantiating a Container (实例化容器)"></a>Instantiating a Container (实例化容器)</h3><!--The location path or paths supplied to an `ApplicationContext` constructor are resource strings that let the container load configuration metadata from a variety of external resources, such as the local file system, the Java `CLASSPATH`, and so on.-->
<p>提供给“ApplicationContext”构造函数的位置路径是资源字符串，它允许容器从各种外部资源(如本地文件系统、Java“CLASSPATH”等)加载配置元数据。</p>
<h3 id="Using-the-Container-使用容器"><a href="#Using-the-Container-使用容器" class="headerlink" title="Using the Container (使用容器)"></a>Using the Container (使用容器)</h3><pre><code class="java">// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);

// retrieve configured instance
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);

// use configured instance
List&lt;String&gt; userList = service.getUsernameList();
</code></pre>
<h2 id="🌟Bean-Overview-bean-预览"><a href="#🌟Bean-Overview-bean-预览" class="headerlink" title="🌟Bean Overview (bean 预览)"></a>🌟Bean Overview (bean 预览)</h2><p>bean的一个介绍</p>
<p>关键词: beanDefinition、instantiating、Naming  </p>
<h3 id="beanDefinition-bean定义"><a href="#beanDefinition-bean定义" class="headerlink" title="beanDefinition(bean定义)"></a>beanDefinition(bean定义)</h3><p>Within the container itself, these bean definitions are represented as <code>BeanDefinition</code> objects, which contain (among other information) the following metadata:</p>
<ul>
<li>A package-qualified class name: typically, the actual implementation class of the bean being defined.(名字)</li>
<li>Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth). (状态、行为)</li>
<li>References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies. (依赖关系)</li>
<li>Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">Explained in…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Class</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class" target="_blank" rel="noopener">Instantiating Beans</a></td>
</tr>
<tr>
<td style="text-align:left">Name</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beanname" target="_blank" rel="noopener">Naming Beans</a></td>
</tr>
<tr>
<td style="text-align:left">Scope</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes" target="_blank" rel="noopener">Bean Scopes</a></td>
</tr>
<tr>
<td style="text-align:left">Constructor arguments</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators" target="_blank" rel="noopener">Dependency Injection</a></td>
</tr>
<tr>
<td style="text-align:left">Properties</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators" target="_blank" rel="noopener">Dependency Injection</a></td>
</tr>
<tr>
<td style="text-align:left">Autowiring mode</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire" target="_blank" rel="noopener">Autowiring Collaborators</a></td>
</tr>
<tr>
<td style="text-align:left">Lazy initialization mode</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init" target="_blank" rel="noopener">Lazy-initialized Beans</a></td>
</tr>
<tr>
<td style="text-align:left">Initialization method</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener">Initialization Callbacks</a></td>
</tr>
<tr>
<td style="text-align:left">Destruction method</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener">Destruction Callbacks</a></td>
</tr>
</tbody>
</table>
<h3 id="naming-bean-bean命名"><a href="#naming-bean-bean命名" class="headerlink" title="naming  bean (bean命名)"></a>naming  bean (bean命名)</h3><h4 id="Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="Aliasing a Bean outside the Bean Definition"></a>Aliasing a Bean outside the Bean Definition</h4><h3 id="Instantiating-bean-bean构造方式"><a href="#Instantiating-bean-bean构造方式" class="headerlink" title="Instantiating bean (bean构造方式)"></a>Instantiating bean (bean构造方式)</h3><p>You can use the <code>Class</code> property in one of two ways:</p>
<ul>
<li>Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code with the <code>new</code> operator.</li>
<li>To specify the actual class containing the <code>static</code> factory method that is invoked to create the object, in the less common case where the container invokes a <code>static</code> factory method on a class to create the bean. The object type returned from the invocation of the <code>static</code> factory method may be the same class or another class entirely.</li>
</ul>
<h4 id="Instantiation-with-a-Constructor"><a href="#Instantiation-with-a-Constructor" class="headerlink" title="Instantiation with a Constructor"></a>Instantiation with a Constructor</h4><!--The Spring IoC container can manage virtually any class you want it to manage. It is not limited to managing true JavaBeans.-->
 <!--Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container.--> 
<!--You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.-->
<p>Spring IoC容器几乎可以管理您希望它管理的任何类。它不仅限于管理真正的javabean。</p>
<p>大多数Spring用户更喜欢实际的javabean，它只有一个默认的(无参数的)构造函数，以及根据容器中的属性建模的适当的setter和getter方法。</p>
<p>您还可以在容器中包含更多非bean风格的类。例如，如果您需要使用完全不符合JavaBean规范的遗留连接池，Spring也可以管理它。</p>
<h4 id="Instantiation-with-a-Static-Factory-Method"><a href="#Instantiation-with-a-Static-Factory-Method" class="headerlink" title="Instantiation with a Static Factory Method"></a>Instantiation with a Static Factory Method</h4><!--One use for such a bean definition is to call `static` factories in legacy code.-->
<p>这种bean定义的一个用途是在遗留代码中调用“静态”工厂。</p>
<h4 id="Instantiation-by-Using-an-Instance-Factory-Method"><a href="#Instantiation-by-Using-an-Instance-Factory-Method" class="headerlink" title="Instantiation by Using an Instance Factory Method"></a>Instantiation by Using an Instance Factory Method</h4><!--Similar to instantiation through a [static factory method](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class-static-factory-method), instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean.--> 
<p>与通过静态工厂方法实例化类似，使用实例工厂方法实例化将从容器中调用现有bean的非静态方法来创建新bean。</p>
<blockquote>
<p>In Spring documentation, “factory bean” refers to a bean that is configured in the Spring container and that creates objects through an <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class-instance-factory-method" target="_blank" rel="noopener">instance</a> or <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class-static-factory-method" target="_blank" rel="noopener">static</a> factory method. By contrast, <code>FactoryBean</code> (notice the capitalization) refers to a Spring-specific <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension-factorybean" target="_blank" rel="noopener"><code>FactoryBean</code></a>.</p>
</blockquote>
<p>在Spring文档中，“工厂bean”指的是在Spring容器中配置的bean，它通过实例或静态工厂方法创建对象。相反，FactoryBean(注意大小写)指的是特定于spring的FactoryBean。</p>
<h2 id="🌟Dependencies-依赖"><a href="#🌟Dependencies-依赖" class="headerlink" title="🌟Dependencies (依赖)"></a>🌟Dependencies (依赖)</h2><p>更多描述的是bean之间的关系</p>
<p>关键词: IOC、DI、collaborate(协作者)、 construct-b(type index name)、 setter-b 、解析过程、循环依赖、提前实例、自动装配、方法注入</p>
<!--A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application.--> 
<!--This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.-->
<p>典型的企业应用程序不包含单个对象(或Spring中的bean)。即使是最简单的应用程序也有几个对象一起工作，以呈现最终用户所看到的一致的应用程序。</p>
<p>下一节将解释如何从定义许多独立的bean定义过渡到一个完全实现的应用程序，其中对象通过协作实现目标。</p>
<h3 id="Dependency-Injection-DI"><a href="#Dependency-Injection-DI" class="headerlink" title="Dependency Injection(DI)"></a>Dependency Injection(DI)</h3><!--Code is cleaner with the DI principle, and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies and does not know the location or class of the dependencies.-->
<!--DI exists in two major variants: Constructor-based dependency and Setter-based dependency injection. -->
<p>使用DI原则，代码更简洁，并且当对象提供其依赖项时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类。</p>
<h4 id="Constructor-based-Dependency-Injection-构造注入"><a href="#Constructor-based-Dependency-Injection-构造注入" class="headerlink" title="Constructor-based Dependency Injection(构造注入)"></a>Constructor-based Dependency Injection(构造注入)</h4><ul>
<li>Constructor argument type matching</li>
<li>Constructor argument index</li>
<li>Constructor argument name</li>
</ul>
<h4 id="Setter-based-Dependency-Injection-Setter注入"><a href="#Setter-based-Dependency-Injection-Setter注入" class="headerlink" title="Setter-based Dependency Injection(Setter注入)"></a>Setter-based Dependency Injection(Setter注入)</h4><!--Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or a no-argument `static` factory method to instantiate your bean.-->
 <!--You configure the dependencies in the form of a `BeanDefinition`, which you use in conjunction with `PropertyEditor` instances to convert properties from one format to another.--> 
<!--However, most Spring users do not work with these classes directly (that is, programmatically) but rather with XML `bean` definitions, annotated components (that is, classes annotated with `@Component`, `@Controller`, and so forth), or `@Bean` methods in Java-based `@Configuration` classes.--> 
<!--These sources are then converted internally into instances of `BeanDefinition` and used to load an entire Spring IoC container instance.-->
<p>基于setter的DI是在调用无参数构造函数或无参数“静态”工厂方法来实例化bean之后，通过容器调用bean上的setter方法来完成的。</p>
<p>您可以将依赖项配置为“BeanDefinition”的形式，并将其与“PropertyEditor”实例结合使用，将属性从一种格式转换为另一种格式。</p>
<p>但是，大多数Spring用户并不直接使用这些类(也就是说，以编程的方式)，而是使用XML ‘ bean ‘定义、带注释的组件(也就是说，使用’ @Component ‘、’ @Controller ‘等注释的类)或基于java的’ @Configuration ‘类中的’ @Bean ‘方法。</p>
<p>然后，这些源在内部转换为“BeanDefinition”实例，并用于加载整个Spring IoC容器实例。</p>
<p><strong>Constructor-based or setter-based DI?</strong></p>
<blockquote>
<p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation" target="_blank" rel="noopener">@Required</a> annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.</p>
<p>The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not <code>null</code>. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#jmx" target="_blank" rel="noopener">JMX MBeans</a> is therefore a compelling use case for setter injection.</p>
</blockquote>
<h4 id="Dependency-Resolution-Process-依赖解析过程"><a href="#Dependency-Resolution-Process-依赖解析过程" class="headerlink" title="Dependency Resolution Process (依赖解析过程)"></a>Dependency Resolution Process (依赖解析过程)</h4><p>ApplicationContext(configuration metadata)  -&gt; 注入方式 -&gt; 注入value初始化 -&gt; value-type</p>
<p>The container performs bean dependency resolution as follows:</p>
<ul>
<li>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.(配置元信息)</li>
<li>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created. (注入方式)</li>
<li>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.(value)</li>
<li>Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as <code>int</code>, <code>long</code>, <code>String</code>, <code>boolean</code>, and so forth.(value-type)</li>
</ul>
<h5 id="Circular-dependencies-循环依赖问题"><a href="#Circular-dependencies-循环依赖问题" class="headerlink" title="Circular dependencies (循环依赖问题)"></a>Circular dependencies (循环依赖问题)</h5><blockquote>
<p>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.</p>
<p>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. </p>
<p>If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a <code>BeanCurrentlyInCreationException</code>.</p>
<p>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. </p>
<p>In other words, although it is not recommended, you can configure circular dependencies with setter injection.</p>
</blockquote>
<p>如果主要使用构造函数注入，可能会创建无法解析的循环依赖场景。</p>
<p>例如:类A需要一个类B通过构造函数注入的实例，而类B需要一个类A通过构造函数注入的实例。</p>
<p>如果您将bean配置为类A和B相互注入，Spring IoC容器会在运行时检测到这个循环引用，并抛出一个“BeanCurrentlyInCreationException”。</p>
<p>一种可能的解决方案是编辑某些类的源代码，由setter而不是构造函数来配置。另外，避免构造函数注入，只使用setter注入。</p>
<p>换句话说，尽管不建议这样做，但您可以使用setter注入配置循环依赖项。</p>
<h5 id="pre-instantiate-预实例化可以提早发现错误"><a href="#pre-instantiate-预实例化可以提早发现错误" class="headerlink" title="pre-instantiate (预实例化可以提早发现错误)"></a>pre-instantiate (预实例化可以提早发现错误)</h5><!--This potentially delayed visibility of some configuration issues is why `ApplicationContext` implementations by default pre-instantiate singleton beans.--> 
<!--At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the `ApplicationContext` is created, not later-->
<p>这可能会延迟某些配置问题的可见性，这就是为什么默认情况下ApplicationContext实现会预先实例化单例bean的原因。</p>
<p>在实际需要使用这些bean之前要花一些前期时间和内存，您会在创建ApplicationContext时发现配置问题，而不是稍后。</p>
<h5 id="collaborating-被装载的是完整实例"><a href="#collaborating-被装载的是完整实例" class="headerlink" title="collaborating (被装载的是完整实例)"></a>collaborating (被装载的是完整实例)</h5><!--If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean.-->
 <!--This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A.--> 
<!--In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a [configured init method](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) or the [InitializingBean callback method](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)) are invoked.-->
<p>如果不存在循环依赖项，那么当一个或多个协作bean被注入一个依赖bean时，每个协作bean在被注入依赖bean之前都要完全配置好。</p>
<p>这意味着，如果bean A依赖于bean B，那么Spring IoC容器将在调用bean A的setter方法之前完全配置bean B。</p>
<p>换句话说，bean被实例化(如果它不是一个预实例化的单例对象)，它的依赖项被设置，相关的生命周期方法(例如配置的init方法或InitializingBean回调方法)被调用。</p>
<h4 id="Examples-of-Dependency-Injection"><a href="#Examples-of-Dependency-Injection" class="headerlink" title="Examples of Dependency Injection"></a><del>Examples of Dependency Injection</del></h4><h3 id="Dependencies-and-Configuration-in-Detail"><a href="#Dependencies-and-Configuration-in-Detail" class="headerlink" title="Dependencies and Configuration in Detail"></a><del>Dependencies and Configuration in Detail</del></h3><h3 id="Using-depends-on-使用-depends-on"><a href="#Using-depends-on-使用-depends-on" class="headerlink" title="Using depends-on (使用 depends-on)"></a>Using depends-on (使用 depends-on)</h3><!--The depends-on attribute can specify both an initialization-time dependency and, in the case of singleton beans only, a corresponding destruction-time dependency. Dependent beans that define a depends-on relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus, depends-on can also control shutdown order.-->
<p>能控制加载顺序</p>
<h3 id="Lazy-initialized-Beans-懒加载"><a href="#Lazy-initialized-Beans-懒加载" class="headerlink" title="Lazy-initialized Beans (懒加载)"></a>Lazy-initialized Beans (懒加载)</h3><!--By default, `ApplicationContext` implementations eagerly create and configure all singleton beans as part of the initialization process.--> 
<!--Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later.--> 
<!--When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.-->
<p>默认情况下，“ApplicationContext”实现会在初始化过程中创建并配置所有的单例bean。</p>
<p>通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几小时甚至几天之后。</p>
<p>当此行为不可取时，您可以通过将bean定义标记为延迟初始化来防止单例bean的预实例化。延迟初始化的bean告诉IoC容器在第一次请求时创建bean实例，而不是在启动时。</p>
<!--However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized, the `ApplicationContext` creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.-->
<!--You can also control lazy-initialization at the container level by using the `default-lazy-init` attribute on the `<beans/>` element-->
<p>但是，如果延迟初始化的bean是未延迟初始化的单例bean的依赖项，则ApplicationContext会在启动时创建延迟初始化的bean，因为它必须满足单例的依赖项。延迟初始化的bean被注入到其他未延迟初始化的单例bean中。</p>
<p>另外还可以容器级别的配置懒加载</p>
<p>注:使用@Lazy , 在需要注入到其他not lazy的bean的时候 使用@Autowire的话 在上面标注@Lazy 会延迟初始化</p>
<pre><code class="java">@Lazy
@Component
class LazyBean{
   @PostConstruct
           public void init(){
               System.out.prinlt(&quot;init...&quot;);
           }
}
@Component
class NotLazyBean{
       @Lazy
       @Autowise
               LazyBean lazyBean;
}
</code></pre>
<p>会在实际使用lazyBean的时候才实例</p>
<h3 id="Autowiring-Collaborators-自动装配"><a href="#Autowiring-Collaborators-自动装配" class="headerlink" title="Autowiring Collaborators(自动装配)"></a>Autowiring Collaborators(自动装配)</h3><p> Autowiring has the following advantages:</p>
<ul>
<li>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-child-bean-definitions" target="_blank" rel="noopener">discussed elsewhere in this chapter</a> are also valuable in this regard.)</li>
<li>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</li>
</ul>
<p>译:</p>
<ul>
<li>自动装配可以大大减少指定属性或构造函数参数的需要。(其他机制，如bean模板<a href="https://docs.spring.io/spring-framework/docs/current/spring-framereference/core.html #beans-child-bean-definitions" target="_blank" rel="noopener">在本章其他地方讨论过</a>在这方面也很有价值。)</li>
<li>自动装配可以随着对象的演化更新配置。例如，如果需要向类添加依赖项，则可以自动满足该依赖项，而不需要修改配置。因此，自动装配在开发过程中特别有用，当代码库变得更加稳定时，自动装配可以避免切换到显式连接的选项。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Mode</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>no</code></td>
<td style="text-align:left">(Default) No autowiring. Bean references must be defined by <code>ref</code> elements. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.</td>
</tr>
<tr>
<td style="text-align:left"><code>byName</code></td>
<td style="text-align:left">Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a <code>master</code> property (that is, it has a <code>setMaster(..)</code> method), Spring looks for a bean definition named <code>master</code> and uses it to set the property.</td>
</tr>
<tr>
<td style="text-align:left"><code>byType</code></td>
<td style="text-align:left">Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use <code>byType</code> autowiring for that bean. If there are no matching beans, nothing happens (the property is not set).</td>
</tr>
<tr>
<td style="text-align:left"><code>constructor</code></td>
<td style="text-align:left">Analogous to <code>byType</code> but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.</td>
</tr>
</tbody>
</table>
<h4 id="Limitations-and-Disadvantages-of-Autowiring-自动装配的局限性和缺点"><a href="#Limitations-and-Disadvantages-of-Autowiring-自动装配的局限性和缺点" class="headerlink" title="Limitations and Disadvantages of Autowiring (自动装配的局限性和缺点)"></a>Limitations and Disadvantages of Autowiring (自动装配的局限性和缺点)</h4><p>Consider the limitations and disadvantages of autowiring:</p>
<ul>
<li>Explicit dependencies in <code>property</code> and <code>constructor-arg</code> settings always override autowiring. You cannot autowire simple properties such as primitives, <code>Strings</code>, and <code>Classes</code> (and arrays of such simple properties). This limitation is by-design.</li>
<li>Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results. The relationships between your Spring-managed objects are no longer documented explicitly.</li>
<li>Wiring information may not be available to tools that may generate documentation from a Spring container.</li>
<li>Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or <code>Map</code> instances, this is not necessarily a problem. However, for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.</li>
</ul>
<p>In the latter scenario, you have several options:</p>
<ul>
<li>Abandon autowiring in favor of explicit wiring.</li>
<li>Avoid autowiring for a bean definition by setting its <code>autowire-candidate</code> attributes to <code>false</code>, as described in the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire-candidate" target="_blank" rel="noopener">next section</a>.</li>
<li>Designate a single bean definition as the primary candidate by setting the <code>primary</code> attribute of its <code>&lt;bean/&gt;</code> element to <code>true</code>.</li>
<li>Implement the more fine-grained control available with annotation-based configuration, as described in <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-annotation-config" target="_blank" rel="noopener">Annotation-based Container Configuration</a>.</li>
</ul>
<p>使用自动装配 ,可能不那么精确, 会导致一些问题</p>
<h4 id="Excluding-a-Bean-from-Autowiring-从自动装配中排除Bean"><a href="#Excluding-a-Bean-from-Autowiring-从自动装配中排除Bean" class="headerlink" title="Excluding a Bean from Autowiring(从自动装配中排除Bean)"></a>Excluding a Bean from Autowiring(从自动装配中排除Bean)</h4><!--On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the `autowire-candidate` attribute of the `<bean/>` element to `false`. The container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as [`@Autowired`](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-annotation)).-->
<p>在每个bean的基础上，可以将bean排除在自动装配之外。在Spring的XML格式中，将“”元素的“autowire-candidate”属性设置为“false”。容器使特定的bean定义对自动装配基础设施不可用(包括注释样式配置，如<a href="https://docs.spring.io/spring-framework/docs/current/spring-framereference/core.html #beans-autowired-annotation" target="_blank" rel="noopener">‘ @Autowired ‘</a>)。</p>
<h3 id="Method-Injection-方法注入"><a href="#Method-Injection-方法注入" class="headerlink" title="Method Injection (方法注入)"></a>Method Injection (方法注入)</h3><!--Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties.--> 
<!--A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean("B") call to the container ask for (a typically new) bean B instance every time bean A needs it.-->
<p>假设单例bean A需要使用非单例(原型)bean B，可能是在A的每个方法调用上。容器只创建一次单例bean A，因此只有一次机会来设置属性。</p>
<p>解决的办法是放弃一些控制反转。您可以通过实现applicationcontext - ware接口，并在每次bean A需要时调用容器的getBean(“B”)来请求(通常是一个新的)bean B实例，从而使bean A知道容器。</p>
<h4 id="Lookup-Method-Injection"><a href="#Lookup-Method-Injection" class="headerlink" title="Lookup Method Injection"></a>Lookup Method Injection</h4><!--Lookup method injection is the ability of the container to override methods on container-managed beans and return the lookup result for another named bean in the container.--> 
<!--The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to dynamically generate a subclass that overrides the method.-->
<p>查找方法注入是容器覆盖容器管理bean上的方法 并返回容器中另一个命名bean的查找结果的能力。</p>
<p>Spring框架通过使用来自CGLIB库的字节码生成来动态生成覆盖该方法的子类，从而实现了这种方法注入。</p>
<p>ex</p>
<h4 id="Arbitrary-任意的-Method-Replacement"><a href="#Arbitrary-任意的-Method-Replacement" class="headerlink" title="Arbitrary (任意的)Method Replacement"></a><del>Arbitrary (任意的)Method Replacement</del></h4><!--A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation.--> 
<p>与查找方法注入相比，一种不太有用的方法注入形式是能够用另一种方法实现替换托管bean中的任意方法。</p>
<h2 id="🌟Bean-Scopes-（作用域）"><a href="#🌟Bean-Scopes-（作用域）" class="headerlink" title="🌟Bean Scopes  （作用域）"></a>🌟Bean Scopes  （作用域）</h2><p>关键词: singleton、prototype、request、session、application、websocket 、cglib public</p>
<!--You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition but also control the scope of the objects created from a particular bean definition-->
<p>您不仅可以控制要插入到由特定bean定义创建的对象中的各种依赖项和配置值，还可以控制由特定bean定义创建的对象的范围</p>
<table>
<thead>
<tr>
<th style="text-align:left">Scope</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a></td>
<td style="text-align:left">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype" target="_blank" rel="noopener">prototype</a></td>
<td style="text-align:left">Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-request" target="_blank" rel="noopener">request</a></td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-session" target="_blank" rel="noopener">session</a></td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-application" target="_blank" rel="noopener">application</a></td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#websocket-stomp-websocket-scope" target="_blank" rel="noopener">websocket</a></td>
<td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody>
</table>
<h3 id="The-Singleton-Scope"><a href="#The-Singleton-Scope" class="headerlink" title="The Singleton Scope"></a>The Singleton Scope</h3><!--To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition.--> 
<!--This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that named bean return the cached object-->
<p>换句话说，当您定义一个bean定义并将其定义为一个单例对象时，Spring IoC容器只创建该bean定义定义的对象的一个实例。</p>
<p>此单一实例存储在此类单例bean的缓存中，该指定bean的所有后续请求和引用都将返回缓存的对象</p>
<!--Spring’s concept of a singleton bean differs from the singleton pattern as defined in the Gang of Four (GoF) patterns book.-->
 <!--The GoF singleton hard-codes the scope of an object such that one and only one instance of a particular class is created per ClassLoader-->
<p>Spring的单例bean概念与Gang of Four(GoF)模式书中定义的单例模式不同。</p>
<p>单例对象对对象的作用域进行硬编码，这样每个类装入器只能创建一个特定类的实例</p>
<h3 id="The-Prototype-Scope"><a href="#The-Prototype-Scope" class="headerlink" title="The Prototype Scope"></a>The Prototype Scope</h3><!--As a rule, you should use the prototype scope for all stateful beans and the singleton scope for stateless beans.-->
<!--In some respects, the Spring container’s role in regard to a prototype-scoped bean is a replacement for the Java `new` operator.--> 
<p>通常，您应该为所有有状态bean使用原型范围，为无状态bean使用单例范围。</p>
<p>在某些方面，Spring容器在原型作用域bean方面的作用是替代Java“new”操作符。</p>
<h3 id="Singleton-Beans-with-Prototype-bean-Dependencies"><a href="#Singleton-Beans-with-Prototype-bean-Dependencies" class="headerlink" title="Singleton Beans with Prototype-bean Dependencies"></a><del>Singleton Beans with Prototype-bean Dependencies</del></h3><h3 id="Request-Session-Application-and-WebSocket-Scopes"><a href="#Request-Session-Application-and-WebSocket-Scopes" class="headerlink" title="Request, Session, Application, and WebSocket Scopes"></a>Request, Session, Application, and WebSocket Scopes</h3><h4 id="Request-scope"><a href="#Request-scope" class="headerlink" title="Request scope"></a>Request scope</h4><!--You can change the internal state of the instance that is created as much as you want, because other instances created from the same `loginAction` bean definition do not see these changes in state.--> 
<p>您可以随意更改创建的实例的内部状态，因为从相同的“loginAction”bean定义创建的其他实例在状态中看不到这些更改。</p>
<h4 id="Session-Scope"><a href="#Session-Scope" class="headerlink" title="Session Scope"></a>Session Scope</h4> <!--As with request-scoped beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP `Session` instances that are also using instances created from the same `userPreferences` bean definition do not see these changes in state, because they are particular to an individual HTTP `Session`.-->
<p>与请求范围内bean一样,你可以改变内部状态的实例创建尽可能多的你想要的,知道其他HTTP会话的实例也使用相同的实例创建的userPreferences bean定义看不到这些变化状态,因为他们是特定的一个单独的HTTP会话的。</p>
<h4 id="Application-Scope"><a href="#Application-Scope" class="headerlink" title="Application Scope"></a>Application Scope</h4><!--This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton per `ServletContext`, not per Spring 'ApplicationContext' (for which there may be several in any given web application), and it is actually exposed and therefore visible as a `ServletContext` attribute.-->
<p>这有点类似于spring单例bean,但在两个重要方面不同: 它是一个单例每ServletContext,不是每个spring ApplicationContext的(可能有几个在任何给定的web应用程序),它实际上是暴露,因此可见“ServletContext”属性。</p>
<h4 id="Scoped-Beans-as-Dependencies"><a href="#Scoped-Beans-as-Dependencies" class="headerlink" title="Scoped Beans as Dependencies"></a>Scoped Beans as Dependencies</h4><!--The Spring IoC container manages not only the instantiation of your objects (beans), but also the wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request-scoped bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in place of the scoped bean.-->
<p>Spring IoC容器不仅管理对象(bean)的实例化，还管理协作者(或依赖项)的连接。如果您想将(例如)一个HTTP请求作用域的bean注入到另一个更长的作用域的bean中，您可以选择注入一个AOP代理来代替作用域的bean。</p>
<p>Choosing the Type of Proxy to Create</p>
<blockquote>
<p>CGLIB proxies intercept only public method calls! Do not call non-public methods on such a proxy. They are not delegated to the actual scoped target object.</p>
</blockquote>
<h3 id="Custom-Scopes"><a href="#Custom-Scopes" class="headerlink" title="Custom Scopes"></a><del>Custom Scopes</del></h3><h2 id="🌟Customizing-the-Nature-of-a-Bean-bean扩展点"><a href="#🌟Customizing-the-Nature-of-a-Bean-bean扩展点" class="headerlink" title="🌟Customizing the Nature of a Bean(bean扩展点)"></a>🌟Customizing the Nature of a Bean(bean扩展点)</h2><p>关键词: lifecycle callback; aware; </p>
<p>The Spring Framework provides a number of interfaces you can use to customize the nature of a bean. This section groups them as follows:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle" target="_blank" rel="noopener">Lifecycle Callbacks</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aware-list" target="_blank" rel="noopener">Other <code>Aware</code> Interfaces</a></li>
</ul>
<h3 id="Lifecycle-Callbacks-生命周期回调"><a href="#Lifecycle-Callbacks-生命周期回调" class="headerlink" title="Lifecycle Callbacks (生命周期回调)"></a>Lifecycle Callbacks (生命周期回调)</h3><!--Internally, the Spring Framework uses `BeanPostProcessor` implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not by default offer, you can implement a `BeanPostProcessor` yourself. For more information, see [Container Extension Points](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension).-->
<p>在内部，Spring框架使用“BeanPostProcessor”实现来处理它能找到并调用适当方法的任何回调接口。如果您需要自定义特性或Spring默认不提供的其他生命周期行为，您可以自己实现一个“BeanPostProcessor”。有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/current/spring-framereference/core.html #beans-factory-extension" target="_blank" rel="noopener">容器扩展点</a>。</p>
<ul>
<li>spring 接口 耦合  <code>InitializingBean</code>，<code>DisposableBean</code></li>
<li>JSR-250 @PostConstruct 或 init-method   @PreDestroy或 destroy-method</li>
<li><code>Lifecycle</code></li>
</ul>
<h4 id="Initialization-Callbacks"><a href="#Initialization-Callbacks" class="headerlink" title="Initialization Callbacks"></a>Initialization Callbacks</h4><pre><code>public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}
</code></pre><h4 id="Destruction-Callbacks"><a href="#Destruction-Callbacks" class="headerlink" title="Destruction Callbacks"></a>Destruction Callbacks</h4><pre><code>public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
</code></pre><h4 id="Default-Initialization-and-Destroy-Methods"><a href="#Default-Initialization-and-Destroy-Methods" class="headerlink" title="Default Initialization and Destroy Methods"></a>Default Initialization and Destroy Methods</h4><ul>
<li>default-init-method</li>
<li>default-destroy-method</li>
</ul>
<h4 id="Combining-Lifecycle-Mechanisms"><a href="#Combining-Lifecycle-Mechanisms" class="headerlink" title="Combining Lifecycle Mechanisms"></a>Combining Lifecycle Mechanisms</h4><p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior:</p>
<ul>
<li>The <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener"><code>InitializingBean</code></a> and <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener"><code>DisposableBean</code></a> callback interfaces</li>
<li>Custom <code>init()</code> and <code>destroy()</code> methods</li>
<li>The <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations" target="_blank" rel="noopener"><code>@PostConstruct</code> and <code>@PreDestroy</code> annotations</a>. You can combine these mechanisms to control a given bean.</li>
</ul>
<h4 id="Startup-and-Shutdown-Callbacks"><a href="#Startup-and-Shutdown-Callbacks" class="headerlink" title="Startup and Shutdown Callbacks"></a>Startup and Shutdown Callbacks</h4><h5 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h5><pre><code class="java">public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}
</code></pre>
<h5 id="LifecycleProcessor"><a href="#LifecycleProcessor" class="headerlink" title="LifecycleProcessor"></a>LifecycleProcessor</h5><pre><code class="java">public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}
</code></pre>
<h5 id="Phased"><a href="#Phased" class="headerlink" title="Phased"></a>Phased</h5><!--The order of startup and shutdown invocations can be important. If a “depends-on” relationship exists between any two objects, the dependent side starts after its dependency, and it stops before its dependency. However, at times, the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type.-->
<p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在“依赖关系”，依赖方在依赖后开始，在依赖前停止。然而，有时，直接依赖关系是未知的。您可能只知道某种类型的对象应该先于另一种类型的对象启动。</p>
<pre><code class="java">public interface Phased {

    int getPhase();
}
</code></pre>
<h4 id="Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><a href="#Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications" class="headerlink" title="Shutting Down the Spring IoC Container Gracefully in Non-Web Applications"></a>Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h4><!--If you use Spring’s IoC container in a non-web application environment (for example, in a rich client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. You must still configure and implement these destroy callbacks correctly.-->
<p>如果您在非web应用程序环境(例如，在客户机桌面环境中)中使用Spring的IoC容器，请向JVM注册一个关闭挂钩。这样做可以确保优雅地关闭并调用单例bean上的相关销毁方法，以便释放所有资源。您仍然必须正确配置和实现这些销毁回调。</p>
<p>registerShutdownHook()</p>
<h3 id="ApplicationContextAware-and-BeanNameAware"><a href="#ApplicationContextAware-and-BeanNameAware" class="headerlink" title="ApplicationContextAware and BeanNameAware"></a><code>ApplicationContextAware</code> and <code>BeanNameAware</code></h3><h4 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h4><pre><code class="java">public interface ApplicationContextAware {

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}
</code></pre>
<h4 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h4><pre><code class="java">public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}
</code></pre>
<h3 id="Other-Aware-Interfaces"><a href="#Other-Aware-Interfaces" class="headerlink" title="Other Aware Interfaces"></a>Other <code>Aware</code> Interfaces</h3><table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:left">Injected Dependency</th>
<th style="text-align:left">Explained in…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ApplicationContextAware</code></td>
<td style="text-align:left">Declaring <code>ApplicationContext</code>.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>ApplicationEventPublisherAware</code></td>
<td style="text-align:left">Event publisher of the enclosing <code>ApplicationContext</code>.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-introduction" target="_blank" rel="noopener">Additional Capabilities of the <code>ApplicationContext</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>BeanClassLoaderAware</code></td>
<td style="text-align:left">Class loader used to load the bean classes.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class" target="_blank" rel="noopener">Instantiating Beans</a></td>
</tr>
<tr>
<td style="text-align:left"><code>BeanFactoryAware</code></td>
<td style="text-align:left">Declaring <code>BeanFactory</code>.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>BeanNameAware</code></td>
<td style="text-align:left">Name of the declaring bean.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>BootstrapContextAware</code></td>
<td style="text-align:left">Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in JCA-aware <code>ApplicationContext</code> instances.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#cci" target="_blank" rel="noopener">JCA CCI</a></td>
</tr>
<tr>
<td style="text-align:left"><code>LoadTimeWeaverAware</code></td>
<td style="text-align:left">Defined weaver for processing class definition at load time.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-aj-ltw" target="_blank" rel="noopener">Load-time Weaving with AspectJ in the Spring Framework</a></td>
</tr>
<tr>
<td style="text-align:left"><code>MessageSourceAware</code></td>
<td style="text-align:left">Configured strategy for resolving messages (with support for parametrization and internationalization).</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-introduction" target="_blank" rel="noopener">Additional Capabilities of the <code>ApplicationContext</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>NotificationPublisherAware</code></td>
<td style="text-align:left">Spring JMX notification publisher.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#jmx-notifications" target="_blank" rel="noopener">Notifications</a></td>
</tr>
<tr>
<td style="text-align:left"><code>ResourceLoaderAware</code></td>
<td style="text-align:left">Configured loader for low-level access to resources.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#resources" target="_blank" rel="noopener">Resources</a></td>
</tr>
<tr>
<td style="text-align:left"><code>ServletConfigAware</code></td>
<td style="text-align:left">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">Spring MVC</a></td>
</tr>
<tr>
<td style="text-align:left"><code>ServletContextAware</code></td>
<td style="text-align:left">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td>
<td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">Spring MVC</a></td>
</tr>
</tbody>
</table>
<!--Note again that using these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As a result, we recommend them for infrastructure beans that require programmatic access to the container.-->
<p>再次注意，使用这些接口将您的代码绑定到Spring API，并且不遵循控制反转样式。因此，我们建议将它们用于需要对容器进行编程访问的基础设施bean。</p>
<h2 id="Bean-Definition-Inheritance-定义继承"><a href="#Bean-Definition-Inheritance-定义继承" class="headerlink" title="Bean Definition Inheritance (定义继承)"></a><del>Bean Definition Inheritance (定义继承)</del></h2><h2 id="🌟Container-Extension-Points-（容器扩展点）"><a href="#🌟Container-Extension-Points-（容器扩展点）" class="headerlink" title="🌟Container Extension Points （容器扩展点）"></a>🌟Container Extension Points （容器扩展点）</h2><p>关键词 : bean; beanPostProcessor;Metadata ;BeanFactoryPostProcessor;FactoryBean; scoped per-container</p>
<h3 id="Customizing-Beans-by-Using-a-BeanPostProcessor"><a href="#Customizing-Beans-by-Using-a-BeanPostProcessor" class="headerlink" title="Customizing Beans by Using a BeanPostProcessor"></a>Customizing Beans by Using a BeanPostProcessor</h3><p>//一般用于自定义构造bean, 处理注解 (通用注解 和 自定义注解)</p>
<!--The `BeanPostProcessor` interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth.--> 
<!--If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom `BeanPostProcessor` implementations.-->
<!--You can configure multiple `BeanPostProcessor` instances, and you can control the order in which these `BeanPostProcessor` instances execute by setting the `order` property. You can set this property only if the `BeanPostProcessor` implements the `Ordered` interface.--> 
<p>BeanPostProcessor接口定义了回调方法，您可以实现这些回调方法来提供自己的(或覆盖容器的默认)实例化逻辑、依赖项解析逻辑等等。</p>
<p>如果希望在Spring容器完成实例化、配置和初始化bean之后实现一些自定义逻辑，可以插入一个或多个自定义BeanPostProcessor实现。</p>
<p>您可以配置多个BeanPostProcessor实例，并且可以通过设置order属性来控制这些BeanPostProcessor实例的执行顺序。只有在BeanPostProcessor实现有序接口时才能设置此属性。</p>
<!--the `org.springframework.beans.factory.config.BeanPostProcessor` interface consists of exactly two callback methods-->
<!--When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as `InitializingBean.afterPropertiesSet()` or any declared `init` method) are called, and after any bean initialization callbacks.-->
<!--The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces, or it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.-->
<p>org.springframework.beans.factory.config。BeanPostProcessor接口正好由两个回调方法组成。</p>
<p>当这样一个类注册为后处理器的容器,每个容器创建bean实例,后处理器从容器之前得到一个回调容器初始化方法(如InitializingBean.afterPropertiesSet()或任何宣布init方法),任何bean初始化后回调。</p>
<p>后处理器可以对bean实例采取任何操作，包括完全忽略回调。bean后处理器通常检查回调接口，或者使用代理包装bean。为了提供代理包装逻</p>
<p><code>BeanPostProcessor</code> instances and AOP auto-proxying</p>
<!--Classes that implement the `BeanPostProcessor` interface are special and are treated differently by the container.--> 
<!--All `BeanPostProcessor` instances and beans that they directly reference are instantiated on startup, as part of the special startup phase of the `ApplicationContext`.--> 
<!--Next, all `BeanPostProcessor` instances are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a `BeanPostProcessor` itself, neither `BeanPostProcessor` instances nor the beans they directly reference are eligible for auto-proxying and, thus, do not have aspects woven into them.-->
<!--For any such bean, you should see an informational log message: `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`.-->
<p>实现“BeanPostProcessor”接口的类是特殊的，容器会以不同的方式对待它们。</p>
<p>它们直接引用的所有“BeanPostProcessor”实例和bean在启动时实例化，作为“ApplicationContext”的特殊启动阶段的一部分。</p>
<p>接下来，以排序的方式注册所有’ BeanPostProcessor ‘实例，并将其应用于容器中所有后续的bean。因为AOP自动代理是作为“BeanPostProcessor”本身实现的，所以无论是“BeanPostProcessor”实例还是它们直接引用的bean都没有资格进行自动代理，因此没有将方面融入到它们之中。</p>
<p>对于任何这样的bean，您应该看到一条信息日志消息:“bean someBean不适合被所有BeanPostProcessor接口处理(例如: not eligible for auto-proxying)”。</p>
<pre><code class="java">public interface BeanPostProcessor {

   @Nullable
   default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

   @Nullable
   default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }

}
</code></pre>
<h3 id="Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor"><a href="#Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor" class="headerlink" title="Customizing Configuration Metadata with a BeanFactoryPostProcessor"></a>Customizing Configuration Metadata with a BeanFactoryPostProcessor</h3><p>//一般应用用于配置文件的解析 , 占位符的替换 </p>
<!--The semantics of this interface are similar to those of the `BeanPostProcessor`, with one major difference: `BeanFactoryPostProcessor` operates on the bean configuration metadata.--> 
<!--That is, the Spring IoC container lets a `BeanFactoryPostProcessor` read the configuration metadata and potentially change it *before* the container instantiates any beans other than `BeanFactoryPostProcessor` instances.-->
<!--You can configure multiple `BeanFactoryPostProcessor` instances, and you can control the order in which these `BeanFactoryPostProcessor` instances run by setting the `order` property. However, you can only set this property if the `BeanFactoryPostProcessor` implements the `Ordered` interface.-->
<p>这个接口的语义与“BeanPostProcessor”的语义类似，但有一个主要区别:“BeanFactoryPostProcessor”操作bean配置元数据。</p>
<p>也就是说，Spring IoC容器允许“BeanFactoryPostProcessor”读取配置元数据，并可能在容器实例化除“BeanFactoryPostProcessor”实例之外的任何bean之前更改它。</p>
<p>您可以配置多个’ BeanFactoryPostProcessor ‘实例，并且可以通过设置’ order ‘属性来控制这些’ BeanFactoryPostProcessor ‘实例的运行顺序。但是，只有在’ BeanFactoryPostProcessor ‘实现’ Ordered ‘接口时才能设置此属性。</p>
<pre><code class="java">@FunctionalInterface
public interface BeanFactoryPostProcessor {

   /**
    * Modify the application context&#39;s internal bean factory after its standard
    * initialization. All bean definitions will have been loaded, but no beans
    * will have been instantiated yet. This allows for overriding or adding
    * properties even to eager-initializing beans.
    * @param beanFactory the bean factory used by the application context
    * @throws org.springframework.beans.BeansException in case of errors
    */
   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}
</code></pre>
<p>Spring includes a number of predefined bean factory post-processors, such as <code>PropertyOverrideConfigurer</code> and <code>PropertySourcesPlaceholderConfigurer</code>. </p>
<h4 id="PropertySourcesPlaceholderConfigurer"><a href="#PropertySourcesPlaceholderConfigurer" class="headerlink" title="PropertySourcesPlaceholderConfigurer"></a>PropertySourcesPlaceholderConfigurer</h4><!--At runtime, a `PropertySourcesPlaceholderConfigurer` is applied to the metadata that replaces some properties of the DataSource.-->
<!--The `PropertySourcesPlaceholderConfigurer` not only looks for properties in the `Properties` file you specify. By default, if it cannot find a property in the specified properties files, it checks against Spring `Environment` properties and regular Java `System` properties.-->
<p>在运行时，’ PropertySourcesPlaceholderConfigurer ‘应用于替代数据源的某些属性的元数据。</p>
<p>‘ PropertySourcesPlaceholderConfigurer ‘不仅在您指定的’ properties ‘文件中查找属性。默认情况下，如果在指定的属性文件中找不到属性，它会检查Spring的“Environment”属性和常规的Java“System”属性。</p>
<h4 id="PropertyOverrideConfigurer"><a href="#PropertyOverrideConfigurer" class="headerlink" title="PropertyOverrideConfigurer"></a>PropertyOverrideConfigurer</h4><!--The `PropertyOverrideConfigurer`, another bean factory post-processor, resembles the `PropertySourcesPlaceholderConfigurer`, but unlike the latter, the original definitions can have default values or no values at all for bean properties.--> 
<!--If an overriding `Properties` file does not have an entry for a certain bean property, the default context definition is used.-->
<p>另一个bean工厂后处理器’ PropertyOverrideConfigurer ‘类似于’ PropertySourcesPlaceholderConfigurer ‘，但与后者不同，原始定义可以有缺省值，也可以没有bean属性的值。</p>
<p>如果覆盖的“属性”文件没有某个bean属性的条目，则使用默认的上下文定义。</p>
<h3 id="Customizing-Instantiation-Logic-with-a-FactoryBean"><a href="#Customizing-Instantiation-Logic-with-a-FactoryBean" class="headerlink" title="Customizing Instantiation Logic with a FactoryBean"></a>Customizing Instantiation Logic with a FactoryBean</h3><!--The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation logic.--> 
<!--If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container.-->
<p>FactoryBean接口是一个可插入Spring IoC容器实例化逻辑的点。</p>
<p>如果您有复杂的初始化代码，用Java表示比(可能的)冗长的XML更好，那么您可以创建自己的FactoryBean，在该类中编写复杂的初始化，然后将定制的FactoryBean插入容器中。</p>
<p>The <code>FactoryBean</code> interface provides three methods:</p>
<ul>
<li><code>Object getObject()</code>: Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.</li>
<li><code>boolean isSingleton()</code>: Returns <code>true</code> if this <code>FactoryBean</code> returns singletons or <code>false</code> otherwise.</li>
<li><code>Class getObjectType()</code>: Returns the object type returned by the <code>getObject()</code> method or <code>null</code> if the type is not known in advance.</li>
</ul>
<!--When you need to ask a container for an actual `FactoryBean` instance itself instead of the bean it produces, preface the bean’s `id` with the ampersand symbol (`&`) when calling the `getBean()` method of the `ApplicationContext`.-->
<p>当您需要向容器请求实际的“FactoryBean”实例本身而不是它所生成的bean时，</p>
<p>在调用“ApplicationContext”的“getBean()”方法时，在bean的“id”前面加上与符号(“&amp;”)。</p>
<h2 id="🌟Annotation-based-Container-Configuration-（基于注释的容器配置）"><a href="#🌟Annotation-based-Container-Configuration-（基于注释的容器配置）" class="headerlink" title="🌟Annotation-based Container Configuration （基于注释的容器配置）"></a>🌟Annotation-based Container Configuration （基于注释的容器配置）</h2><p>🔑关键词: configuration metadata; @Autowired ;@Order;@Primary;@Qulifier;@Resources;BeanPostProcessor</p>
<p>🕙Timeline:</p>
<ul>
<li>Spring 2.0 @required</li>
<li>Spring 2.5   @Autowired ,also JSR-250 annotations, such as <code>@PostConstruct</code> and <code>@PreDestroy</code>. </li>
<li>Spring 3.0  JSR-330 (Dependency Injection for Java) annotations contained in the <code>javax.inject</code> package such as <code>@Inject</code> and <code>@Named</code>. </li>
</ul>
<p>how to provide a lot of the configuration metadata through source-level annotations.</p>
<p>如何通过源级别的注解提供许多配置元数据。</p>
<p>can also be implicitly registered by including the following tag in an XML-based Spring configuration</p>
<pre><code class="xml">&lt;beans xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       ...&gt;
    &lt;context:annotation-config/&gt;
&lt;/beans&gt;
</code></pre>
<p>The implicitly registered post-processors include</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>AutowiredAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>CommonAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>PersistenceAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>RequiredAnnotationBeanPostProcessor</code></a></li>
</ul>
<!--Annotation injection is performed before XML injection. Thus, the XML configuration overrides the annotations for properties wired through both approaches.-->
<p>注解注入在XML注入之前执行。 因此，XML配置将覆盖通过两种方法连接的属性的注释。</p>
<h3 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h3><!--The `@Required` annotation is formally deprecated(弃用) as of Spring Framework 5.1, in favor of using constructor injection for required settings (or a custom implementation of `InitializingBean.afterPropertiesSet()` along with bean property setter methods).-->
<p>从Spring Framework 5.1开始，正式弃用了@Required批注（弃用），以便使用构造函数注入进行必需的设置（或InitializingBean.afterPropertiesSet（）的自定义实现以及bean属性设置器方法）。</p>
<h3 id="Using-Autowired"><a href="#Using-Autowired" class="headerlink" title="Using @Autowired"></a>Using @Autowired</h3><ul>
<li>apply the <code>@Autowired</code> annotation to constructors</li>
<li>apply the <code>@Autowired</code> annotation to <em>traditional</em> setter methods</li>
<li>apply the annotation to methods with arbitrary names and multiple arguments</li>
<li>apply <code>@Autowired</code> to fields as well and even mix it with constructors</li>
</ul>
<!--As of Spring Framework 4.3, an `@Autowired` annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available, at least one must be annotated with `@Autowired` in order to instruct the container which one to use.-->
<p>从Spring Framework 4.3开始，如果目标bean仅定义一个构造函数作为开始，则不再需要在此类构造函数上使用@Autowired批注。 </p>
<p>但是，如果有几个构造函数可用，则至少一个必须用@Autowired注释，以指示容器使用哪个构造函数。</p>
<p>⚠️Ps:  自动装配注意 no type match found ,需要确保类型唯一</p>
<h4 id="Order"><a href="#Order" class="headerlink" title="@Order"></a>@<strong>Order</strong></h4><!--You can declare the `@Order` annotation at the target class level and on `@Bean` methods, potentially for individual bean definitions (in case of multiple definitions that use the same bean class). `@Order` values may influence priorities at injection points, but be aware that they do not influence singleton startup order, which is an orthogonal concern determined by dependency relationships and `@DependsOn` declarations.-->
<!--Note that the standard `javax.annotation.Priority` annotation is not available at the `@Bean` level, since it cannot be declared on methods. Its semantics can be modeled through `@Order` values in combination with `@Primary` on a single bean for each type.-->
<p>您可以在目标类级别和@Bean方法上声明@Order批注，这可能适用于单个bean定义（如果使用同一bean类的多个定义）。 @Order值可能会影响注入点的优先级，但请注意它们不会影响单例启动顺序，这是由依赖关系和@DependsOn声明确定的正交关注点 。</p>
<p>注意，标准javax.annotation.Priority注释在@Bean级别不可用，因为无法在方法上声明它。 它的语义可以通过@Order值与@Primary结合在每种类型的单个bean上进行建模。</p>
<h4 id="Java8-amp-spring-5-0"><a href="#Java8-amp-spring-5-0" class="headerlink" title="Java8 &amp; spring 5.0"></a><strong>Java8 &amp; spring 5.0</strong></h4><p>express the non-required nature of a particular dependency through Java 8’s <code>java.util.Optional</code></p>
<p>As of Spring Framework 5.0, you can also use a <code>@Nullable</code> annotation (of any kind in any package — for example, <code>javax.annotation.Nullable</code> from JSR-305)</p>
<!--the `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring `BeanPostProcessor` implementations.-->
 <!--This means that you cannot apply these annotations within your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any).-->
<p>Spring BeanPostProcessor实现处理@ Autowired，@ Inject，@ Value和@Resource批注。</p>
<p>  这意味着您不能在自己的BeanPostProcessor或BeanFactoryPostProcessor类型（如果有）中应用这些注释。</p>
<h3 id="Fine-tuning-微调-Annotation-based-Autowiring-with-Primary"><a href="#Fine-tuning-微调-Annotation-based-Autowiring-with-Primary" class="headerlink" title="Fine-tuning(微调) Annotation-based Autowiring with @Primary"></a>Fine-tuning(微调) Annotation-based Autowiring with @Primary</h3><p>当可以确定一个主要候选者时，@ Primary是在几种情况下按类型使用自动装配的有效方法。</p>
<h3 id="Fine-tuning-Annotation-based-Autowiring-with-Qualifiers"><a href="#Fine-tuning-Annotation-based-Autowiring-with-Qualifiers" class="headerlink" title="Fine-tuning Annotation-based Autowiring with Qualifiers"></a>Fine-tuning Annotation-based Autowiring with Qualifiers</h3><!--That said, if you intend to express annotation-driven injection by name, do not primarily use `@Autowired`, even if it is capable of selecting by bean name among type-matching candidates.--> 
<!--Instead, use the JSR-250 `@Resource` annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process.-->
<p>就是说，如果您打算按名称表示注释驱动的注入，则即使它能够在类型匹配的候选对象中按bean名称进行选择，也不要主要使用<code>@ Autowired</code>。</p>
<p>相反，请使用JSR-250<code>@ Resource</code>注释，该注释在语义上定义为通过其唯一名称标识特定目标组件，而声明的类型与匹配过程无关。</p>
<h3 id="Using-Generics-as-Autowiring-Qualifiers"><a href="#Using-Generics-as-Autowiring-Qualifiers" class="headerlink" title="Using Generics as Autowiring Qualifiers"></a>Using Generics as Autowiring Qualifiers</h3><!--In addition to the @Qualifier annotation, you can use Java generic types as an implicit form of qualification-->
<p>除了@Qualifier批注之外，您还可以使用Java泛型类型作为资格的隐式形式</p>
<h3 id="Using-CustomAutowireConfigurer"><a href="#Using-CustomAutowireConfigurer" class="headerlink" title="Using CustomAutowireConfigurer"></a>Using <code>CustomAutowireConfigurer</code></h3><!--[`CustomAutowireConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html) is a `BeanFactoryPostProcessor` that lets you register your own custom qualifier annotation types, even if they are not annotated with Spring’s `@Qualifier` annotation.-->
<p>CustomAutowireConfigurer是BeanFactoryPostProcessor，即使您没有使用Spring的@Qualifier批注进行批注，也可以让您注册自己的自定义批注批注类型。</p>
<p>@see org.springframework.beans.factory.annotation.CustomAutowireConfigurer</p>
<h3 id="Injection-with-Resource-JSR-250-amp-name"><a href="#Injection-with-Resource-JSR-250-amp-name" class="headerlink" title="Injection with @Resource (JSR-250 &amp; name)"></a>Injection with @Resource (JSR-250 &amp; name)</h3><!--Spring also supports injection by using the JSR-250 `@Resource` annotation (`javax.annotation.Resource`) on fields or bean property setter methods.-->
<!--`@Resource` takes a name attribute. By default, Spring interprets that value as the bean name to be injected.--> 
<p>Spring还通过在字段或bean属性设置器方法上使用JSR-250<code>@ Resource</code>批注（javax.annotation.Resource`）支持注入。</p>
<p>@Resource具有名称属性。 默认情况下，Spring将该值解释为要注入的Bean名称。</p>
<h3 id="Using-Value"><a href="#Using-Value" class="headerlink" title="Using @Value"></a>Using <code>@Value</code></h3><!--A default lenient embedded value resolver is provided by Spring. It will try to resolve the property value and if it cannot be resolved, the property name (for example `${catalog.name}`) will be injected as the value.-->
 <!--If you want to maintain strict control over nonexistent values, you should declare a `PropertySourcesPlaceholderConfigurer` bean-->
<p>Spring提供了一个默认的宽松内嵌值解析器。 它将尝试解析属性值，如果无法解析，则将属性名称（例如$ {catalog.name}）作为值注入。 </p>
<p>如果要严格控制不存在的值，则应声明一个PropertySourcesPlaceholderConfigurer bean</p>
<!--Using the above configuration ensures Spring initialization failure if any ${} placeholder could not be resolved. It is also possible to use methods like setPlaceholderPrefix, setPlaceholderSuffix, or setValueSeparator to customize placeholders.-->
<p>如果无法解析任何$ {}占位符，则使用上述配置可确保Spring初始化失败。 也可以使用setPlaceholderPrefix，setPlaceholderSuffix或setValueSeparator之类的方法来自定义占位符。</p>
<!--When configuring a `PropertySourcesPlaceholderConfigurer` using JavaConfig, the `@Bean` method must be `static`.-->
<!--Spring Boot configures by default a PropertySourcesPlaceholderConfigurer bean that will get properties from application.properties and application.yml files.-->
<p>当使用JavaConfig配置<code>PropertySourcesPlaceholderConfigurer</code>时，@Bean方法必须是静态的。</p>
<p>Spring Boot默认配置一个PropertySourcesPlaceholderConfigurer bean，它将从application.properties和application.yml文件获取属性。</p>
<!--A Spring `BeanPostProcessor` uses a `ConversionService` behind the scene to handle the process for converting the String value in `@Value` to the target type. If you want to provide conversion support for your own custom type, you can provide your own `ConversionService` bean instance-->
<p>Spring  BeanPostProcessor使用ConversionService来处理将@Value中的String值转换为目标类型的过程。 如果要为自己的自定义类型提供转换支持，则可以提供自己的<code>ConversionService</code> bean实例</p>
<p><strong>相关类</strong>:</p>
<p>@see org.springframework.core.convert.ConversionService</p>
<p>@see org.springframework.context.support.PropertySourcesPlaceholderConfigurer</p>
<h3 id="Using-PostConstruct-and-PreDestroy-JSR-250"><a href="#Using-PostConstruct-and-PreDestroy-JSR-250" class="headerlink" title="Using @PostConstruct and @PreDestroy (JSR-250)"></a>Using <code>@PostConstruct</code> and <code>@PreDestroy</code> (JSR-250)</h3><p>The <code>CommonAnnotationBeanPostProcessor</code> not only recognizes the <code>@Resource</code> annotation but also the JSR-250 lifecycle annotations: <code>javax.annotation.PostConstruct</code> and <code>javax.annotation.PreDestroy</code>.</p>
<h2 id="🌟Classpath-Scanning-and-Managed-Components"><a href="#🌟Classpath-Scanning-and-Managed-Components" class="headerlink" title="🌟Classpath Scanning and Managed Components"></a>🌟Classpath Scanning and Managed Components</h2><p>🔑关键词: @Component ;Stereotype Annotations; @ComponentScan; spring-context-indexer</p>
<!--Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the `@Configuration`, `@Bean`, `@Import`, and `@DependsOn` annotations for examples of how to use these new features.-->
<p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能是核心Spring Framework的一部分。这使您可以使用Java而不是使用传统的XML文件来定义bean。请看一下@ Configuration，@ Bean，@ Import和@DependsOn注释，以获取有关如何使用这些新功能的示例。</p>
<h3 id="Component-and-Further-Stereotype-Annotations-模式注解"><a href="#Component-and-Further-Stereotype-Annotations-模式注解" class="headerlink" title="@Component and Further Stereotype Annotations (模式注解)"></a><code>@Component</code> and Further Stereotype Annotations (模式注解)</h3><!--Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the `@Configuration`, `@Bean`, `@Import`, and `@DependsOn` annotations for examples of how to use these new features.-->
<p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能是核心Spring Framework的一部分。这使您可以使用Java而不是使用传统的XML文件来定义bean。请看一下@ Configuration，@ Bean，@ Import和@DependsOn注释，以获取有关如何使用这些新功能的示例。</p>
<!--The @Repository annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). Among the uses of this marker is the automatic translation of exceptions, as described in Exception Translation.-->
<!--Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers, respectively).--> 
<!--Therefore, you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework.--> 
<!--Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.-->
<p>@Repository批注是实现存储库的角色或构造型（也称为数据访问对象或DAO）的任何类的标记。该标记的用途包括自动翻译异常，如“异常翻译”中所述。</p>
<p>Spring提供了进一步的构造型注释：@ Component，@ Service和@Controller。 @Component是任何Spring托管组件的通用构造型。 @ Repository，@ Service和@Controller是@Component的特化，用于更特定的用例（分别在持久层，服务层和表示层中）。</p>
<p>因此，您可以使用@Component来注释组件类，但是通过使用@ Repository，@ Service或@Controller来注释组件类，您的类更适合通过工具进行处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 @ Repository，@ Service和@Controller在Spring框架的将来版本中也可以带有其他语义。</p>
<p>因此，如果在服务层使用@Component或@Service之间进行选择，则@Service显然是更好的选择。同样，如前所述，@ Repository已被支持作为持久层中自动异常转换的标记。</p>
<h3 id="Using-Meta-annotations-and-Composed-Annotations-元注解"><a href="#Using-Meta-annotations-and-Composed-Annotations-元注解" class="headerlink" title="Using Meta-annotations and Composed Annotations(元注解)"></a>Using Meta-annotations and Composed Annotations(元注解)</h3><!--Many of the annotations provided by Spring can be used as meta-annotations in your own code. A meta-annotation is an annotation that can be applied to another annotation.For example, the @Service annotation mentioned earlier is meta-annotated with @Component-->
<p>Spring提供的许多注释都可以在您自己的代码中用作元注释。 元注释是可以应用于另一个注释的注释。 例如，前面提到的@Service注释使用@Component进行元注释。</p>
<h3 id="Automatically-Detecting-Classes-and-Registering-Bean-Definitions-自动检测类并注册Bean定义"><a href="#Automatically-Detecting-Classes-and-Registering-Bean-Definitions-自动检测类并注册Bean定义" class="headerlink" title="Automatically Detecting Classes and Registering Bean Definitions(自动检测类并注册Bean定义)"></a>Automatically Detecting Classes and Registering Bean Definitions(自动检测类并注册Bean定义)</h3><!--To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, where the basePackages attribute is a common parent package for the two classes.-->
<p>要自动检测这些类并注册相应的bean，您需要将@ComponentScan添加到@Configuration类中，其中basePackages属性是这两个类的公共父包。 （或者，您可以指定一个逗号分隔，分号分隔或空格分隔的列表，其中包括每个类的父包。）</p>
<p>The use of <code>&lt;context:component-scan&gt;</code> implicitly enables the functionality of <code>&lt;context:annotation-config&gt;</code>. There is usually no need to include the <code>&lt;context:annotation-config&gt;</code> element when using <code>&lt;context:component-scan&gt;</code>.</p>
<h3 id="Using-Filters-to-Customize-Scanning"><a href="#Using-Filters-to-Customize-Scanning" class="headerlink" title="Using Filters to Customize Scanning"></a>Using Filters to Customize Scanning</h3><p>Add them as <code>includeFilters</code> or <code>excludeFilters</code> attributes of the <code>@ComponentScan</code> annotation (or as <code>or</code> child elements of the <code></code> element in XML configuration). Each filter element requires the <code>type</code> and <code>expression</code> attributes. </p>
<p>Filter Type</p>
<ul>
<li><p>annotation (default)</p>
</li>
<li><p>assignable</p>
</li>
<li><p>aspectj</p>
</li>
<li><p>regex</p>
</li>
<li><p>custom</p>
</li>
</ul>
<h3 id="Defining-Bean-Metadata-within-Components-在组件中定义Bean元数据"><a href="#Defining-Bean-Metadata-within-Components-在组件中定义Bean元数据" class="headerlink" title="Defining Bean Metadata within Components(在组件中定义Bean元数据)"></a>Defining Bean Metadata within Components(在组件中定义Bean元数据)</h3><!--You may declare @Bean methods as static, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans (for example, of type BeanFactoryPostProcessor or BeanPostProcessor), since such beans get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point.-->
<p>您可以将@Bean方法声明为静态方法，从而允许在不将其包含配置类创建为实例的情况下调用它们。在定义后处理器Bean（例如BeanFactoryPostProcessor或BeanPostProcessor类型）时，这特别有意义，因为此类Bean在容器生命周期的早期进行了初始化，并且应避免在那时触发配置的其他部分。</p>
<!--Calls to static @Bean methods never get intercepted by the container, not even within @Configuration classes (as described earlier in this section), due to technical limitations: CGLIB subclassing can override only non-static methods. As a consequence, a direct call to another @Bean method has standard Java semantics, resulting in an independent instance being returned straight from the factory method itself.-->
<p>由于技术限制，对静态@Bean方法的调用永远不会被容器拦截，即使在@Configuration类中也是如此（如本节前面所述），由于技术限制：CGLIB子类只能覆盖非静态方法。结果，直接调用另一个@Bean方法具有标准的Java语义，从而导致直接从工厂方法本身直接返回一个独立的实例。</p>
<!--The Java language visibility of @Bean methods does not have an immediate impact on the resulting bean definition in Spring’s container. You can freely declare your factory methods as you see fit in non-@Configuration classes and also for static methods anywhere. However, regular @Bean methods in @Configuration classes need to be overridable — that is, they must not be declared as private or final.-->
<p>@Bean方法的Java语言可见性不会对Spring容器中的最终bean definition 产生直接影响。您可以在非@Configuration类中自由声明自己的工厂方法，也可以在任何地方声明静态方法。但是，@ Configuration类中的常规@Bean方法必须是可重写的—即，不得将它们声明为private或final。</p>
<h3 id="Naming-Autodetected-Components-命名自动检测的组件"><a href="#Naming-Autodetected-Components-命名自动检测的组件" class="headerlink" title="Naming Autodetected Components(命名自动检测的组件)"></a>Naming Autodetected Components(命名自动检测的组件)</h3><!--When a component is autodetected as part of the scanning process, its bean name is generated by the `BeanNameGenerator` strategy known to that scanne-->
 <!--If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the `BeanNameGenerator` interface, and be sure to include a default no-arg constructor.--> 
<p>当在扫描过程中自动检测到组件时，其bean名称由该scanne已知的<code>BeanNameGenerator</code>策略生成。</p>
<p>  如果您不想依赖默认的Bean命名策略，则可以提供自定义Bean命名策略。 首先，实现<code>BeanNameGenerator</code> 接口，并确保包含默认的无参数构造函数。</p>
<h4 id="Providing-a-Scope-for-Autodetected-Components-提供自动检测组件的作用域"><a href="#Providing-a-Scope-for-Autodetected-Components-提供自动检测组件的作用域" class="headerlink" title="Providing a Scope for Autodetected Components(提供自动检测组件的作用域)"></a>Providing a Scope for Autodetected Components(提供自动检测组件的作用域)</h4><!--To provide a custom strategy for scope resolution rather than relying on the annotation-based approach, you can implement the ScopeMetadataResolver interface.
Be sure to include a default no-arg constructor.--> 
<p>要提供用于范围解析的自定义策略，而不是依赖于基于注释的方法，可以实现ScopeMetadataResolver接口。<br>确保包括默认的无参数构造函数。</p>
<h4 id="Providing-Qualifier-Metadata-with-Annotations"><a href="#Providing-Qualifier-Metadata-with-Annotations" class="headerlink" title="Providing Qualifier Metadata with Annotations"></a>P<del>roviding Qualifier Metadata with Annotations</del></h4><h4 id="Generating-an-Index-of-Candidate-Components-生成候选组件的索引"><a href="#Generating-an-Index-of-Candidate-Components-生成候选组件的索引" class="headerlink" title="Generating an Index of Candidate Components(生成候选组件的索引)"></a>Generating an Index of Candidate Components(生成候选组件的索引)</h4><p>While classpath scanning is very fast, it is possible to improve the startup performance of large applications by creating a static list of candidates at compilation time. In this mode, all modules that are target of component scan must use this mechanism.</p>
<p>加快扫描速度</p>
<h2 id="🌟Using-JSR-330-Standard-Annotations"><a href="#🌟Using-JSR-330-Standard-Annotations" class="headerlink" title="🌟Using JSR 330 Standard Annotations"></a>🌟Using JSR 330 Standard Annotations</h2><p>🔑关键词: javax.inject ; @Inject; @Named</p>
<h3 id="Dependency-Injection-with-Inject-and-Named"><a href="#Dependency-Injection-with-Inject-and-Named" class="headerlink" title="Dependency Injection with @Inject and @Named"></a>Dependency Injection with <code>@Inject</code> and <code>@Named</code></h3><p>If you would like to use a qualified name for the dependency that should be injected, you should use the <code>@Named</code> annotation</p>
<p>如果您想对注入的依赖项使用限定名称，则应使用@Named注解</p>
<h3 id="Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation-Component注解的比较"><a href="#Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation-Component注解的比较" class="headerlink" title="@Named and @ManagedBean: Standard Equivalents to the @Component Annotation(@Component注解的比较)"></a>@Named and @ManagedBean: Standard Equivalents to the @Component Annotation(@Component注解的比较)</h3><!--In contrast to @Component, the JSR-330 @Named and the JSR-250 ManagedBean annotations are not composable.--> 
<!--You should use Spring’s stereotype model for building custom component annotations.-->
<p>与@Component相反，JSR-330 @Named和JSR-250 ManagedBean注释是不可组合的。</p>
<p>您应该使用Spring的原型模型来构建自定义组件注释。</p>
<h3 id="Limitations-of-JSR-330-Standard-Annotations"><a href="#Limitations-of-JSR-330-Standard-Annotations" class="headerlink" title="Limitations of JSR-330 Standard Annotations"></a>Limitations of JSR-330 Standard Annotations</h3><table>
<thead>
<tr>
<th style="text-align:left">Spring</th>
<th style="text-align:left">javax.inject.*</th>
<th style="text-align:left">javax.inject restrictions / comments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@Autowired</td>
<td style="text-align:left">@Inject</td>
<td style="text-align:left"><code>@Inject</code> has no ‘required’ attribute. Can be used with Java 8’s <code>Optional</code> instead.</td>
</tr>
<tr>
<td style="text-align:left">@Component</td>
<td style="text-align:left">@Named / @ManagedBean</td>
<td style="text-align:left">JSR-330 does not provide a composable model, only a way to identify named components.</td>
</tr>
<tr>
<td style="text-align:left">@Scope(“singleton”)</td>
<td style="text-align:left">@Singleton</td>
<td style="text-align:left">The JSR-330 default scope is like Spring’s <code>prototype</code>. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a <code>singleton</code> by default. In order to use a scope other than <code>singleton</code>, you should use Spring’s <code>@Scope</code> annotation. <code>javax.inject</code> also provides a <a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html" target="_blank" rel="noopener">@Scope</a> annotation. Nevertheless, this one is only intended to be used for creating your own annotations.</td>
</tr>
<tr>
<td style="text-align:left">@Qualifier</td>
<td style="text-align:left">@Qualifier / @Named</td>
<td style="text-align:left"><code>javax.inject.Qualifier</code> is just a meta-annotation for building custom qualifiers. Concrete <code>String</code> qualifiers (like Spring’s <code>@Qualifier</code> with a value) can be associated through <code>javax.inject.Named</code>.</td>
</tr>
<tr>
<td style="text-align:left">@Value</td>
<td style="text-align:left">-</td>
<td style="text-align:left">no equivalent</td>
</tr>
<tr>
<td style="text-align:left">@Required</td>
<td style="text-align:left">-</td>
<td style="text-align:left">no equivalent</td>
</tr>
<tr>
<td style="text-align:left">@Lazy</td>
<td style="text-align:left">-</td>
<td style="text-align:left">no equivalent</td>
</tr>
<tr>
<td style="text-align:left">ObjectFactory</td>
<td style="text-align:left">Provider</td>
<td style="text-align:left"><code>javax.inject.Provider</code> is a direct alternative to Spring’s <code>ObjectFactory</code>, only with a shorter <code>get()</code> method name. It can also be used in combination with Spring’s <code>@Autowired</code> or with non-annotated constructors and setter methods.</td>
</tr>
</tbody>
</table>
<h2 id="🌟Java-based-Container-Configuration-基于Java的容器配置"><a href="#🌟Java-based-Container-Configuration-基于Java的容器配置" class="headerlink" title="🌟Java-based Container Configuration(基于Java的容器配置)"></a>🌟Java-based Container Configuration(基于Java的容器配置)</h2><p>🔑关键词: @Bean; @Configuration;AnnotationConfigApplicationContext;lite vs full;@Import; @ImportResource;@Condition</p>
<p>This section covers how to use annotations in your Java code to configure the Spring container. It includes the following topics:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts" target="_blank" rel="noopener">Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-instantiating-container" target="_blank" rel="noopener">Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation" target="_blank" rel="noopener">Using the <code>@Bean</code> Annotation</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-configuration-annotation" target="_blank" rel="noopener">Using the <code>@Configuration</code> annotation</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-composing-configuration-classes" target="_blank" rel="noopener">Composing Java-based Configurations</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-definition-profiles" target="_blank" rel="noopener">Bean Definition Profiles</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction" target="_blank" rel="noopener"><code>PropertySource</code> Abstraction</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-using-propertysource" target="_blank" rel="noopener">Using <code>@PropertySource</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-placeholder-resolution-in-statements" target="_blank" rel="noopener">Placeholder Resolution in Statements</a></li>
</ul>
<h3 id="Basic-Concepts-Bean-and-Configuration"><a href="#Basic-Concepts-Bean-and-Configuration" class="headerlink" title="Basic Concepts: @Bean and @Configuration"></a>Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></h3><!--Annotating a class with `@Configuration` indicates that its primary purpose is as a source of bean definitions. Furthermore, `@Configuration` classes let inter-bean dependencies be defined by calling other `@Bean` methods in the same class.-->
<p>@Configuration: 用@Configuration注释类表示该类的主要目的是作为Bean定义的来源。 此外，@Configuration类允许通过调用同一类中的其他@Bean方法 来定义Bean间的依赖关系。</p>
<p>@Bean : Indicates that a method produces a bean to be managed by the Spring container.</p>
<p><strong>Full @Configuration vs “lite” @Bean mode?</strong></p>
<p>在<code>lite @Bean mode</code>模式下， <code>@Bean</code>方法不会被CGLIB代理 ,所以尽量使用Full @Configuration模式</p>
<h3 id="Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext"><a href="#Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext" class="headerlink" title="Instantiating the Spring Container by Using AnnotationConfigApplicationContext"></a>Instantiating the Spring Container <strong>by</strong> Using AnnotationConfigApplicationContext</h3><!--This versatile `ApplicationContext` implementation is capable of accepting not only `@Configuration` classes as input but also plain `@Component` classes and classes annotated with JSR-330 metadata.-->
<p>这种通用的ApplicationContext实现不仅能够接受@Configuration类作为输入，</p>
<p>而且还可以接受普通的@Component类和带有JSR-330元数据注释的类。</p>
<p><strong>scan &amp; register</strong></p>
<pre><code class="java">package org.springframework.context.annotation;

/**
 * Common interface for annotation config application contexts,
 * defining {@link #register} and {@link #scan} methods.
 *
 * @author Juergen Hoeller
 * @since 4.1
 */
public interface AnnotationConfigRegistry {

   /**
    * Register one or more annotated classes to be processed.
    * &lt;p&gt;Calls to {@code register} are idempotent; adding the same
    * annotated class more than once has no additional effect.
    * @param annotatedClasses one or more annotated classes,
    * e.g. {@link Configuration @Configuration} classes
    */
   void register(Class&lt;?&gt;... annotatedClasses);

   /**
    * Perform a scan within the specified base packages.
    * @param basePackages the packages to check for annotated classes
    */
   void scan(String... basePackages);

}
</code></pre>
<p>more details: @see org.springframework.context.annotation.AnnotationConfigApplicationContext</p>
<p><strong>Support for Web Applications with <code>AnnotationConfigWebApplicationContext</code></strong></p>
<h3 id="Using-the-Bean-Annotation"><a href="#Using-the-Bean-Annotation" class="headerlink" title="Using the @Bean Annotation"></a>Using the <code>@Bean</code> Annotation</h3><ul>
<li>Declaring a Bean</li>
<li>Bean Dependencies</li>
<li>Receiving Lifecycle Callbacks</li>
<li>Specifying Bean Scope</li>
<li>Customizing Bean Naming</li>
<li>Bean Aliasing</li>
<li>Bean Description</li>
</ul>
<p>@see org.springframework.context.annotation.Bean</p>
<h3 id="Using-the-Configuration-annotation"><a href="#Using-the-Configuration-annotation" class="headerlink" title="Using the @Configuration annotation"></a>Using the <code>@Configuration</code> annotation</h3><p><strong>Injecting Inter-bean Dependencies(注入bean间的依赖关系)</strong></p>
<p><strong>Lookup Method Injection</strong></p>
<p><strong>Further Information About How Java-based Configuration Works Internally</strong></p>
<!--This is where the magic comes in: All `@Configuration` classes are subclassed at startup-time with `CGLIB`.In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance-->
<h3 id="Composing-Java-based-Configurations"><a href="#Composing-Java-based-Configurations" class="headerlink" title="Composing Java-based Configurations"></a>Composing Java-based Configurations</h3><h3 id="Using-the-Import-Annotation"><a href="#Using-the-Import-Annotation" class="headerlink" title="Using the @Import Annotation"></a>Using the <code>@Import</code> Annotation</h3><!--As of Spring Framework 4.2, `@Import` also supports references to regular component classes, analogous to the `AnnotationConfigApplicationContext.register` method.--> 
<!--This is particularly useful if you want to avoid component scanning, by using a few configuration classes as entry points to explicitly define all your components.-->
<p>从Spring Framework 4.2开始，@ Import还支持对常规组件类的引用，类似于AnnotationConfigApplicationContext.register方法。 </p>
<p>如果要通过使用一些配置类作为入口点来显式定义所有组件，从而避免组件扫描，则此功能特别有用。</p>
<h3 id="Conditionally-Include-Configuration-Classes-or-Bean-Methods"><a href="#Conditionally-Include-Configuration-Classes-or-Bean-Methods" class="headerlink" title="Conditionally Include @Configuration Classes or @Bean Methods"></a>Conditionally Include <code>@Configuration</code> Classes or <code>@Bean</code> Methods</h3><p>The <code>@Profile</code> annotation is actually implemented by using a much more flexible annotation called <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html" target="_blank" rel="noopener"><code>@Conditional</code></a>. </p>
<p>The <code>@Conditional</code> annotation indicates specific <code>org.springframework.context.annotation.Condition</code> implementations that should be consulted before a <code>@Bean</code> is registered.</p>
<p><strong>@Profile</strong></p>
<pre><code class="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(ProfileCondition.class)
public @interface Profile {

    /**
     * The set of profiles for which the annotated component should be registered.
     */
    String[] value();

}

</code></pre>
<p><strong>ProfileCondition</strong></p>
<pre><code class="java">class ProfileCondition implements Condition {
  @Override
  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
      for (Object value : attrs.get(&quot;value&quot;)) {
        if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) {
          return true;
        }
      }
      return false;
    }
    return true;
  }
}
</code></pre>
<p><strong>Condition</strong></p>
<pre><code class="java">@FunctionalInterface
public interface Condition {

   /**
    * Determine if the condition matches.
    * @param context the condition context
    * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class}
    * or {@link org.springframework.core.type.MethodMetadata method} being checked
    * @return {@code true} if the condition matches and the component can be registered,
    * or {@code false} to veto the annotated component&#39;s registration
    */
   boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);

}
</code></pre>
<h3 id="Combining-Java-and-XML-Configuration"><a href="#Combining-Java-and-XML-Configuration" class="headerlink" title="Combining Java and XML Configuration"></a>Combining Java and XML Configuration</h3><p>Spring’s <code>@Configuration</code> class support does not aim to be a 100% complete replacement for Spring XML.</p>
<h4 id="XML-centric-Use-of-Configuration-Classes"><a href="#XML-centric-Use-of-Configuration-Classes" class="headerlink" title="XML-centric Use of @Configuration Classes"></a>XML-centric Use of <code>@Configuration</code> Classes</h4><p><strong>Declaring @Configuration classes as plain Spring &lt;bean/ &gt; elements</strong></p>
<pre><code class="xml">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;
&lt;context:annotation-config/&gt;
&lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;
</code></pre>
<p>&lt;context:annotation-config /&gt; <strong>仅能够在已经在已经注册过的bean上面起作用,所以需要手动注册</strong></p>
<p>Using &lt;context:component-scan/ &gt; to pick up @Configuration classes**</p>
<pre><code class="xml">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;
 &lt;context:component-scan base-package=&quot;com.acme&quot;/&gt;
</code></pre>
<h4 id="ConfigurationClass-centric-Use-of-XML-with-ImportResource"><a href="#ConfigurationClass-centric-Use-of-XML-with-ImportResource" class="headerlink" title="@ConfigurationClass-centric Use of XML with@ImportResource"></a>@Configuration<code>Class-centric Use of XML with</code>@ImportResource</h4><p><strong>@ImportResource</strong></p>
<pre><code class="java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface ImportResource {

    /**
     * Alias for {@link #locations}.
     * @see #locations
     * @see #reader
     */
    @AliasFor(&quot;locations&quot;)
    String[] value() default {};

    /**
     * Resource locations from which to import.
     * &lt;p&gt;Supports resource-loading prefixes such as {@code classpath:},
     * {@code file:}, etc.
     * &lt;p&gt;Consult the Javadoc for {@link #reader} for details on how resources
     * will be processed.
     * @since 4.2
     * @see #value
     * @see #reader
     */
    @AliasFor(&quot;value&quot;)
    String[] locations() default {};

    /**
     * {@link BeanDefinitionReader} implementation to use when processing
     * resources specified via the {@link #value} attribute.
     * &lt;p&gt;By default, the reader will be adapted to the resource path specified:
     * {@code &quot;.groovy&quot;} files will be processed with a
     * {@link org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader GroovyBeanDefinitionReader};
     * whereas, all other resources will be processed with an
     * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader XmlBeanDefinitionReader}.
     * @see #value
     */
    Class&lt;? extends BeanDefinitionReader&gt; reader() default BeanDefinitionReader.class;

}
</code></pre>
<h2 id="🌟Environment-Abstraction-（环境抽象）"><a href="#🌟Environment-Abstraction-（环境抽象）" class="headerlink" title="🌟Environment Abstraction （环境抽象）"></a>🌟Environment Abstraction （环境抽象）</h2><p>🔑关键词: Environment; profiles; properties;PropertySources;PropertySourcesPlaceholderConfigurer</p>
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/core/env/Environment.html" target="_blank" rel="noopener"><code>Environment</code></a> interface is an abstraction integrated in the container that models two key aspects of the application environment: <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-definition-profiles" target="_blank" rel="noopener">profiles</a> and <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction" target="_blank" rel="noopener">properties</a>.</p>
<p>Environment接口是集成在容器中的抽象，它对应用程序环境的两个关键方面进行建模：profiles和properties</p>
<p>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. </p>
<p>The role of the <code>Environment</code> object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.</p>
<p>Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc <code>Properties</code> objects, <code>Map</code> objects, and so on.</p>
<p> The role of the <code>Environment</code> object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.</p>
<h3 id="Bean-Definition-Profiles"><a href="#Bean-Definition-Profiles" class="headerlink" title="Bean Definition Profiles"></a>Bean Definition Profiles</h3><h4 id="Using-Profile"><a href="#Using-Profile" class="headerlink" title="Using @Profile"></a>Using <code>@Profile</code></h4><h4 id="XML-Bean-Definition-Profiles"><a href="#XML-Bean-Definition-Profiles" class="headerlink" title="XML Bean Definition Profiles"></a>XML Bean Definition Profiles</h4><h4 id="Activating-a-Profile"><a href="#Activating-a-Profile" class="headerlink" title="Activating a Profile"></a>Activating a Profile</h4><p>spring.profiles.active</p>
<h4 id="Default-Profile"><a href="#Default-Profile" class="headerlink" title="Default Profile"></a>Default Profile</h4><p>default</p>
<h3 id="PropertySource-Abstraction"><a href="#PropertySource-Abstraction" class="headerlink" title="PropertySource Abstraction"></a><code>PropertySource</code> Abstraction</h3><p>For a common <code>StandardServletEnvironment</code>, the full hierarchy is as follows, with the highest-precedence entries at the top:</p>
<ul>
<li>ServletConfig parameters (if applicable — for example, in case of a <code>DispatcherServlet</code> context)</li>
<li>ServletContext parameters (web.xml context-param entries)</li>
<li>JNDI environment variables (<code>java:comp/env/</code> entries)</li>
<li>JVM system properties (<code>-D</code> command-line arguments)</li>
<li>JVM system environment (operating system environment variables)</li>
</ul>
<pre><code class="java">ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
</code></pre>
<h3 id="Using-PropertySource"><a href="#Using-PropertySource" class="headerlink" title="Using @PropertySource"></a>Using <code>@PropertySource</code></h3><p>The <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code></a> annotation provides a convenient and declarative mechanism for adding a <code>PropertySource</code> to Spring’s <code>Environment</code>.</p>
<h3 id="Placeholder-Resolution-in-Statements"><a href="#Placeholder-Resolution-in-Statements" class="headerlink" title="Placeholder Resolution in Statements"></a>Placeholder Resolution in Statements</h3><p>Historically, the value of placeholders in elements could be resolved only against JVM system properties or environment variables. This is no longer the case.</p>
<p>Because the <code>Environment</code> abstraction is integrated throughout the container, it is easy to route resolution of placeholders through it. </p>
<p>This means that you may configure the resolution process in any way you like.</p>
<p> You can change the precedence of searching through system properties and environment variables or remove them entirely.</p>
<p>@See org.springframework.context.support.PropertySourcesPlaceholderConfigurer</p>
<h2 id="🌟Registering-a-LoadTimeWeaver"><a href="#🌟Registering-a-LoadTimeWeaver" class="headerlink" title="🌟Registering a LoadTimeWeaver"></a><del>🌟Registering a <code>LoadTimeWeaver</code></del></h2><p>weaving(编织 编译时、加载时、运行时) 这里是类加载时</p>
<p>The <code>LoadTimeWeaver</code> is used by Spring to dynamically transform classes as they are loaded into the Java virtual machine (JVM).</p>
<p>@See <a href="https://www.cnblogs.com/wade-luffy/p/6073702.html" target="_blank" rel="noopener">https://www.cnblogs.com/wade-luffy/p/6073702.html</a></p>
<h2 id="🌟Additional-Capabilities-of-the-ApplicationContext-BeanFactory的扩展"><a href="#🌟Additional-Capabilities-of-the-ApplicationContext-BeanFactory的扩展" class="headerlink" title="🌟Additional Capabilities of the ApplicationContext (BeanFactory的扩展)"></a>🌟Additional Capabilities of the <code>ApplicationContext</code> (BeanFactory的扩展)</h2><p>🔑关键词:BeanFactory;ResourceLoader;MessageSource;ResourceBundleMessageSource;Environment;EventPublisher;</p>
<p>@EventListener;ContextLoaderListener;</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g949aex83ij31d80fotac.jpg" alt="image-20191120093906082"></p>
<p>To enhance <code>BeanFactory</code> functionality in a more framework-oriented style, the context package also provides the following functionality:</p>
<ul>
<li>Access to messages in i18n-style, through the <code>MessageSource</code> interface.</li>
<li>Access to resources, such as URLs and files, through the <code>ResourceLoader</code> interface.</li>
<li>Event publication, namely to beans that implement the <code>ApplicationListener</code> interface, through the use of the <code>ApplicationEventPublisher</code> interface.</li>
<li>Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such as the web layer of an application, through the <code>HierarchicalBeanFactory</code> interface.</li>
</ul>
<h3 id="Internationalization-using-MessageSource"><a href="#Internationalization-using-MessageSource" class="headerlink" title="Internationalization using MessageSource"></a>Internationalization using <code>MessageSource</code></h3><h3 id="Standard-and-Custom-Events"><a href="#Standard-and-Custom-Events" class="headerlink" title="Standard and Custom Events"></a>Standard and Custom Events</h3><table>
<thead>
<tr>
<th style="text-align:left">Event</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ContextRefreshedEvent</code></td>
<td style="text-align:left">Published when the <code>ApplicationContext</code> is initialized or refreshed (for example, by using the <code>refresh()</code> method on the <code>ConfigurableApplicationContext</code> interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the <code>ApplicationContext</code> object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen <code>ApplicationContext</code> actually supports such “hot” refreshes. For example, <code>XmlWebApplicationContext</code> supports hot refreshes, but <code>GenericApplicationContext</code> does not.</td>
</tr>
<tr>
<td style="text-align:left"><code>ContextStartedEvent</code></td>
<td style="text-align:left">Published when the <code>ApplicationContext</code> is started by using the <code>start()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “started” means that all <code>Lifecycle</code> beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization).</td>
</tr>
<tr>
<td style="text-align:left"><code>ContextStoppedEvent</code></td>
<td style="text-align:left">Published when the <code>ApplicationContext</code> is stopped by using the <code>stop()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “stopped” means that all <code>Lifecycle</code> beans receive an explicit stop signal. A stopped context may be restarted through a <code>start()</code> call.</td>
</tr>
<tr>
<td style="text-align:left"><code>ContextClosedEvent</code></td>
<td style="text-align:left">Published when the <code>ApplicationContext</code> is being closed by using the <code>close()</code> method on the <code>ConfigurableApplicationContext</code> interface or via a JVM shutdown hook. Here, “closed” means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.</td>
</tr>
<tr>
<td style="text-align:left"><code>RequestHandledEvent</code></td>
<td style="text-align:left">A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s <code>DispatcherServlet</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>ServletRequestHandledEvent</code></td>
<td style="text-align:left">A subclass of <code>RequestHandledEvent</code> that adds Servlet-specific context information.</td>
</tr>
</tbody>
</table>
<h4 id="Annotation-based-Event-Listeners"><a href="#Annotation-based-Event-Listeners" class="headerlink" title="Annotation-based Event Listeners"></a>Annotation-based Event Listeners</h4><p> As of Spring 4.2, the event infrastructure has been significantly improved and offers an <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-functionality-events-annotation" target="_blank" rel="noopener">annotation-based model</a> as well as the ability to publish any arbitrary event (that is, an object that does not necessarily extend from <code>ApplicationEvent</code>). When such an object is published, we wrap it in an event for you.</p>
<h4 id="Asynchronous-Listeners"><a href="#Asynchronous-Listeners" class="headerlink" title="Asynchronous Listeners"></a>Asynchronous Listeners</h4><p>Be aware of the following limitations when using asynchronous events:</p>
<ul>
<li>If an asynchronous event listener throws an <code>Exception</code>, it is not propagated to the caller. See <code>AsyncUncaughtExceptionHandler</code> for more details.</li>
<li>Asynchronous event listener methods cannot publish a subsequent event by returning a value. If you need to publish another event as the result of the processing, inject an <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html" target="_blank" rel="noopener"><code>ApplicationEventPublisher</code></a> to publish the event manually.</li>
</ul>
<h4 id="Ordering-Listeners"><a href="#Ordering-Listeners" class="headerlink" title="Ordering Listeners"></a>Ordering Listeners</h4><p>@Order</p>
<h4 id="Generic-Events"><a href="#Generic-Events" class="headerlink" title="Generic Events"></a><del>Generic Events</del></h4><p>@see org.springframework.core.ResolvableTypeProvider</p>
<h3 id="Convenient-Access-to-Low-level-Resources"><a href="#Convenient-Access-to-Low-level-Resources" class="headerlink" title="Convenient Access to Low-level Resources"></a>Convenient Access to Low-level Resources</h3><p>An application context is a <code>ResourceLoader</code>, which can be used to load <code>Resource</code> objects. A <code>Resource</code> is essentially a more feature rich version of the JDK <code>java.net.URL</code> class</p>
<h3 id="Convenient-ApplicationContext-Instantiation-for-Web-Applications"><a href="#Convenient-ApplicationContext-Instantiation-for-Web-Applications" class="headerlink" title="Convenient ApplicationContext Instantiation for Web Applications"></a>Convenient ApplicationContext Instantiation for Web Applications</h3><p>You can register an <code>ApplicationContext</code> by using the <code>ContextLoaderListener</code></p>
<pre><code class="xml">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h3 id="Deploying-a-Spring-ApplicationContext-as-a-Java-EE-RAR-File"><a href="#Deploying-a-Spring-ApplicationContext-as-a-Java-EE-RAR-File" class="headerlink" title="Deploying a Spring ApplicationContext as a Java EE RAR File"></a>Deploying a Spring <code>ApplicationContext</code> as a Java EE RAR File</h3><p>Such RAR deployment units are usually self-contained. They do not expose components to the outside world, not even to other modules of the same application. </p>
<h2 id="🌟The-BeanFactory"><a href="#🌟The-BeanFactory" class="headerlink" title="🌟The BeanFactory"></a>🌟The <code>BeanFactory</code></h2><p>🔑关键词: DefaultListableBeanFactory ; extensions</p>
<p>Note that the core <code>BeanFactory</code> API level and its <code>DefaultListableBeanFactory</code> implementation do not make assumptions about the configuration format or any component annotations to be used. All of these flavors come in through extensions (such as <code>XmlBeanDefinitionReader</code> and <code>AutowiredAnnotationBeanPostProcessor</code>) and operate on shared <code>BeanDefinition</code> objects as a core metadata representation.</p>
<p> This is the essence of what makes Spring’s container so flexible and extensible.</p>
<h3 id="BeanFactory-or-ApplicationContext"><a href="#BeanFactory-or-ApplicationContext" class="headerlink" title="BeanFactory or ApplicationContext?"></a><code>BeanFactory</code> or <code>ApplicationContext</code>?</h3><p>For many extended container features, such as annotation processing and AOP proxying, the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp" target="_blank" rel="noopener"><code>BeanPostProcessor</code> extension point</a> is essential. </p>
<p>If you use only a plain <code>DefaultListableBeanFactory</code>, such post-processors do not get detected and activated by default. This situation could be confusing, because nothing is actually wrong with your bean configuration. </p>
<p>Rather, in such a scenario, the container needs to be fully bootstrapped through additional setup.</p>
<p>The following table lists features provided by the <code>BeanFactory</code> and <code>ApplicationContext</code> interfaces and implementations.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left"><code>BeanFactory</code></th>
<th style="text-align:left"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Bean instantiation/wiring</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Integrated lifecycle management</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Automatic <code>BeanPostProcessor</code> registration</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Automatic <code>BeanFactoryPostProcessor</code> registration</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Convenient <code>MessageSource</code> access (for internalization)</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Built-in <code>ApplicationEvent</code> publication mechanism</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>顶级接口</p>
<ul>
<li>BeanFactory <ul>
<li>bean (beanDefined); </li>
<li>状态(作用域)/行为(回调,bean extends)/关系(依赖) </li>
<li>contains extension (BPF/BBPF/FactoryBean)</li>
</ul>
</li>
<li>ApplicationContext <ul>
<li>Messagesource</li>
<li>Event</li>
<li>layer (AOP /web /auto registration )</li>
</ul>
</li>
</ul>
<p> Core (core/asm/cglib/util) </p>
<ul>
<li>Env</li>
<li>IO</li>
<li>Type : Core support package for type introspection.(内省)</li>
<li><p>@AliasFor / @Order</p>
<p>Annotaion(2.5 / 3.0/ 4.0/ 5.0)</p>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 951488791@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>Documentation-Spring_Core_IOC</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">11.4k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="zhengyumin">zhengyumin</a></p>
    <p><span class="copy-title">发布时间:</span>2019-10-29, 21:51:07</p>
    <p><span class="copy-title">最后更新:</span>2019-12-22, 17:31:36</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/10/29/Documentation-Spring-Core-IOC/" title="Documentation-Spring_Core_IOC">http://yoursite.com/2019/10/29/Documentation-Spring-Core-IOC/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 zhengyumin</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/js/jquery.pjax.js?v=1.0.1"></script>

<script src="/js/script.js?v=1.0.1"></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#week','#hide','#jdk','#packages','#utils','#java','#note','#jvm','#distributed','#kafka','#framework','#netty','#nio','#zookeeper','#redis','#Spec','#thread','#spring','#tomcat','#mysql','#juc','#classLoader','#hotspot','#j2ee','#summary','#lang','#elasticsearch','#servlet','#io','#serialization','#file','#ejb','#gc','#collections','#map','#doc','#spring-mvc','#spring-webflux',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
