<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Overview_Hbase</title>
      <link href="/2020/03/18/Overview-Hbase/"/>
      <url>/2020/03/18/Overview-Hbase/</url>
      
        <content type="html"><![CDATA[<h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h1><p><strong>逻辑结构</strong> </p><p>行  row key+多个cloum</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfpq9aqej31cq0o2qlr.jpg" alt="image-20200318220931027" style="zoom:67%;"></p><p><strong>存储结构</strong> </p><p>​        每列一行列式存储,存储的是列信息.  (Rowkey  famili  info   ts  type  value  (按照时间戳 返回最大的数据 cell))</p><p><img src="http://tva1.sinaimg.cn/large/00831rSTly1gcyfsebdyej31dg0p4ne6.jpg" alt="image-20200318221204674" style="zoom:67%;"></p><p><strong>职责架构</strong>        </p><p>​        Region server 管理. Dml (data multi)</p><p>​            data :get put delete  (store-&gt; store file)</p><p>​            region : splitRegion compactRegion</p><p>​        Master的作用 ddl(data defined)</p><p>​            Table : create delete alter</p><p>​            RegionServer:分配regions到每个RegionServer,监控每个RegionServer的状态</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyflf95zvj31p60u044s.jpg" alt="image-20200315175244476"></p><h1 id="2-写流程"><a href="#2-写流程" class="headerlink" title="2.写流程"></a>2.写流程</h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfli8kvoj31ee0ngq6o.jpg" alt="image-20200315180535234"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyflfp8d7j31p60u044s.jpg" alt="image-20200315181610036">    </p><p>写wal 内存</p><p>​    写内存</p><p>​    wal同步</p><p>​    成功-&gt;提交</p><p>​    不成功-&gt;回滚</p><h1 id="3-flush流程"><a href="#3-flush流程" class="headerlink" title="3.flush流程"></a>3.flush流程</h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyflggz2zj31p60u044s.jpg" alt="image-20200315182048399"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyflgu4lfj318l0u0q75.jpg" alt="image-20200315182225365"></p><h1 id="4-读流程"><a href="#4-读流程" class="headerlink" title="4.读流程"></a>4.读流程</h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyflha60ej31e60nwwi7.jpg" alt="image-20200315185530449"></p><h1 id="5-删除流程"><a href="#5-删除流程" class="headerlink" title="5.删除流程"></a>5.删除流程</h1><p>Flush (同个文件)和 compact (major)</p><p>删除标记 </p><p>Flush不会</p><p>compact会</p><h1 id="6-Split流程"><a href="#6-Split流程" class="headerlink" title="6.Split流程"></a>6.Split流程</h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyflja59rj31ge0o0qna.jpg" alt="image-20200315220805448"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyflhrv2mj31cs0mq420.jpg" alt="image-20200315220835884"></p><p>预分区、不建议过多列簇(速度不一致,小文件)</p><h1 id="7-Compact流程"><a href="#7-Compact流程" class="headerlink" title="7.Compact流程"></a>7.Compact流程</h1><p> Minor compact只是进行文件merge操作，</p><p>而Major compact除了做文件Merge操作，还会将其中的delete项删除。</p><p>hbase为了防止小文件（被刷到磁盘的menstore）过多，以保证保证查询效率，hbase需要在必要的时候将这些小的store file合并成相对较大的store file，这个过程就称之为compaction。在hbase中，主要存在两种类型的compaction：minor compaction和major compaction。</p><p>major compaction 的功能是将所有的store file合并成一个，触发major compaction的可能条件有：major_compact 命令、majorCompact() API、region server自动运行（相关参数：hbase.hregion.majoucompaction 默认为24 小时、hbase.hregion.majorcompaction.jetter 默认值为0.2 防止region server 在同一时间进行major compaction）。hbase.hregion.majorcompaction.jetter参数的作用是：对参数hbase.hregion.majoucompaction 规定的值起到浮动的作用，假如两个参数都为默认值24和0,2，那么major compact最终使用的数值为：19.2~28.8 这个范围。</p><p>minor compaction的运行机制要复杂一些，它由一下几个参数共同决定：</p><p>hbase.hstore.compaction.min :默认值为 3，表示至少需要三个满足条件的store file时，minor compaction才会启动</p><p>hbase.hstore.compaction.max 默认值为10，表示一次minor compaction中最多选取10个store file</p><p>hbase.hstore.compaction.min.size 表示文件大小小于该值的store file 一定会加入到minor compaction的store file中</p><p>hbase.hstore.compaction.max.size 表示文件大小大于该值的store file 一定会被minor compaction排除</p><p>hbase.hstore.compaction.ratio 将store file 按照文件年龄排序（older to younger），minor compaction总是从older store file开始选择，如果该文件的size 小于它后面hbase.hstore.compaction.max 个store file size 之和乘以 该ratio，则该store file 也将加入到minor compaction 中。</p><p>如果对minor compaction过程还是不了解，可以去看hbase中关于minor compaction 的源码，或者：<a href="http://www.linuxidc.com/Linux/2013-05/83675.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-05/83675.htm</a></p><p>优化: rowkey设计 预分区</p><p><strong>写入优化</strong><br>写也是Hbase常有的操作之一，并且Hbase在写入操作上有着其他NoSQL无法比拟的优势，下面讲如何优化写入操作<br><strong>关闭写WAL日志</strong><br>一般为了保证系统的高可用性，WAL日志默认是开启状态，WAL主要用于灾难恢复的，如果应用可以容忍一定的数据丢失风险，可以在写数据的时候，关闭写WAL。<br><strong>风险：</strong> 当RegionServer宕机时，写入的数据出现丢失，且无法恢复。</p><p><strong>设置AutoFlush</strong><br>Htable有一个属性是AutoFlush，该属性用于支持客户端的批量更新，默认是true，当客户端每收到一条数据，立刻发送到服务端，如果设置为false，当客户端提交put请求时候，先将该请求在客户端缓存，到达阈值的时候或者执行hbase.flushcommits()，才向RegionServer提交请求。<br><strong>风险</strong> 在请求未发送到RegionServer之前客户端崩溃，数据也会丢失<br>table.setAutoFlush(false);<br>table.setWriteBufferSize( 12 <em> 1024 </em> 1024 );</p><p><strong>预创建Region</strong><br>一般表刚开始只有一个Region，插入该表的数据都会保存在此Region中，插入该表的所有塑化剂都会保存在该Region中，当到达一定的阈值时，才发生分裂。 这样开始时刻针对该表的写操作都集中在某台服务器上，造成这台服务器的压力很紧张，同时对整个集群资源的浪费。<br>建议刚开始的时候预创建Region，可以使用Hbase自带的RegionSplitter<br><strong>延迟日志flush</strong><br>默认写入操作，首先写入WAL，并且在1S内写入HDFS，这个时间默认是1S，可以通过参数配置<br>hbase.regionserver.optionallogflushinterval可以配置大一点的值，比如5s，这段时间数据会保留在内存中，直到RegionServer周期性的执行flush操作。<br>希望能帮助大家。</p><p>参考：<a href="http://www.linuxidc.com/Linux/2013-05/83674.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-05/83674.htm</a></p><p>参考:<a href="https://www.bilibili.com/video/av65591724?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av65591724?p=1</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> distributed </tag>
            
            <tag> hbase </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview_Spark</title>
      <link href="/2020/03/18/Overview-Spark/"/>
      <url>/2020/03/18/Overview-Spark/</url>
      
        <content type="html"><![CDATA[<p>spark入门,看到一篇不错的文章记录下</p><a id="more"></a><p>Spark 是专为大规模数据处理而设计的快速通用的计算引擎，是apache的一个开源项目。是一种跟hadoop相似的通用分布式并行计算框架，但是两者之间还存在一些不同之处。spark是一种基于内存计算的分布式执行框架，在执行速度上大大优于hadoop.</p><h1 id="1-spark的历史"><a href="#1-spark的历史" class="headerlink" title="1. spark的历史"></a>1. spark的历史</h1><ul><li>2009年，spark诞生于加州大学伯克利分校AMPLab.</li><li>2010和2012年关于spark的两篇论文发表：<br>  M. Zaharia, M. Chowdhury, M. J. Franklin, S. Shenker, and I. Stoica, “Spark: cluster computing with working sets,” in Proceedings of the 2nd USENIX conference on Hot topics in cloud computing, 2010, pp. 10–10.<br>   M. Zaharia, M. Chowdhury, T. Das, A. Dave, J. Ma, M. McCauley, M. J. Franklin, S. Shenker, and I. Stoica, “Resilient distributed datasets: A fault-tolerant abstraction for in- memory cluster computing,” in Proceedings of the 9th USENIX conference on Networked Systems Design and Implementation, 2012, pp. 2–2.</li><li>2013年，在GitHub上成立了Spark开发社区并成为Apache孵化项目。</li><li>2014年2月，该项目成为Apache顶级项目。</li><li>2014年5月30日，Spark 1.0.0版正式上线。</li><li>至2016年底，spark的最新版本2.1.0已发布上线。</li><li>截止目前，Spark官方维护运营公司Databricks已经组织并举办了四年Spark Summit技术峰会。</li></ul><h1 id="2-spark的特点"><a href="#2-spark的特点" class="headerlink" title="2. spark的特点"></a>2. spark的特点</h1><ul><li>处理速度快<br>  随着信息技术的发展，数据也以惊人的数据在增长，而数据处理的速度也成为人们越来越关注的话题。由于spark支持内存级计算功能，因此spark执行速度要远远高于hadoop</li><li>多语言、多API支持<br>  Spark支持多语言。Spark允许Java、Scala、Python及R，这允许更多的开发者在自己熟悉的语言环境下进行工作，普及了Spark的应用范围。</li><li>多业务场景支持<br>  提供了对etl、流处理、机器学习和图计算等几种主流数据处理场景的支持</li><li>开源生态环境支持<br>  拥有广泛的开源生态环境的支持，底层数据源部分包括hdfs、cassandra、hbase以及alluxio等等，拥有yarn、mesos等分布式框架的支持，如下图所示：</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfkedaiyj30fe08u74u.jpg" alt="image-20190716100546382"></p><p>图1. Spark开源生态系统</p><h1 id="3-spark的体系结构"><a href="#3-spark的体系结构" class="headerlink" title="3. spark的体系结构"></a>3. spark的体系结构</h1><p>Spark主要包括Spark Core和在Spark Core基础之上建立的应用框架Spark SQL、Spark Streaming、MLlib和GraphX.<br> 　　Core库中主要包括上下文（Spark Context）、抽象数据集（RDD、DataFrame和DataSet）、调度器（Scheduler）、洗牌（shuffle）和序列化器（Serializer）等。Spark系统中的计算、IO、调度和shuffle等系统基本功能都在其中。<br> 　　在Core库之上就根据业务需求分为用于交互式查询的SQL、实时流处理Streaming、机器学习Mllib和图计算GraphX四大框架，除此外还有一些其他实验性项目如Tachyon、BlinkDB和Tungsten等。Hdfs是Spark主要应用的持久化存储系统。Spark 体系结构如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfkcrer9j30ej07jwey.jpg" alt="image-20190716100603919"></p><p>图2. Spark 体系结构</p><h1 id="4-spark-执行框架"><a href="#4-spark-执行框架" class="headerlink" title="4. spark 执行框架"></a>4. spark 执行框架</h1><p>spark应用程序运行在分布式集群上，通过集群管理器（cluster manger）将驱动程序（driver program）节点跟工作节点（work node）相连，实现分布式并行工作。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfkddpbdj30cf061jrj.jpg" alt="image-20190716100625041"></p><p>​                                                                            图3. spark 执行流程</p><p>创建spark应用程序时，首先要创建sparkContext，SparkContext 允许驱动程序（spark driver）通过资源管理器访问集群。同时sparkContext还存有来自sparkConf的配置信息。这些配置信息用于分配集群资源，比如worker节点运行的executors 的number, memory 大小和cores等等。驱动程序将这些配置信息通知给集群管理器（cluster manager），集群管理器收到配置信息后，在集群上根据程序配置的executor number给应用程序寻找相应个数的工作节点（work node）。并在每个工作节点创建一个executor（作为单个执行单元），每个executor根据程序的配置信息分配响应的内存空间（如shuffle内存和存储内存等等）。<br> 　　程序执行时，根据rdd（弹性分布式数据集—spark程序中数据的基本类型）中分区的数量将每个stag（程序的每个执行步骤，以shuffle为边界）分成相同数目的task，分到各个executor中去执行。每个executor中一次执行的task数量是由程序调用时给executor配置的核数决定的。</p><h1 id="５-spark的基本数据类型"><a href="#５-spark的基本数据类型" class="headerlink" title="５. spark的基本数据类型"></a>５. spark的基本数据类型</h1><p>RDD、DataFrame和DataSet可以说是spark独有的三种基本的数据类型。Spark的核心概念是RDD (resilientdistributed dataset)，指的是一个只读的，可分区的分布式数据集，这个数据集的全部或部分可以缓存在内存中，在多次计算间重用。DataFrame是一个以RDD为基础的，但却是一种类似二维数据表的一种分布式数据集。与RDD不同的是，前者带有schema元信息，即DataFrame所表示的二维表数据集的每一列都带有名称和类型。这样，spark就可以使用sql操作dataframe，像操作数据库中的表一样。目前，spark sql支持大多数的sql数据库的操作。Dataset可以认为是DataFrame的一个特例，主要区别是Dataset每一个record存储的是一个强类型值而不是一个Row。后面版本DataFrame会继承DataSet，DataFrame和DataSet可以相互转化，df.as[ElementType]这样可以把DataFrame转化为DataSet，ds.toDF()这样可以把DataSet转化为DataFrame。创建Dataframe的代码如下所示：</p><pre><code>val df = spark.read.json(&quot;examples/src/main/resources/people.json&quot;)// Displays the content of the DataFrame to stdoutdf.show()// +----+-------+// | age|   name|// +----+-------+// |null|Michael|// |  30|   Andy|// |  19| Justin|// +----+-------+</code></pre><p>创建Ｄataset的代码如下所示：</p><pre><code>// Note: Case classes in Scala 2.10 can support only up to 22 fields. To work around this limit,// you can use custom classes that implement the Product interfacecase class Person(name: String, age: Long)// Encoders are created for case classesval caseClassDS = Seq(Person(&quot;Andy&quot;, 32)).toDS()caseClassDS.show()// +----+---+// |name|age|// +----+---+// |Andy| 32|// +----+---+// Encoders for most common types are automatically provided by importing spark.implicits._val primitiveDS = Seq(1, 2, 3).toDS()primitiveDS.map(_ + 1).collect() // Returns: Array(2, 3, 4)// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by nameval path = &quot;examples/src/main/resources/people.json&quot;val peopleDS = spark.read.json(path).as[Person]peopleDS.show()// +----+-------+// | age|   name|// +----+-------+// |null|Michael|// |  30|   Andy|// |  19| Justin|// +----+-------+</code></pre><h1 id="6-spark-scheduler（spark任务调度）"><a href="#6-spark-scheduler（spark任务调度）" class="headerlink" title="6. spark scheduler（spark任务调度）"></a>6. spark scheduler（spark任务调度）</h1><p>(1) 在使用spark-summit提交spark程序后，根据提交时指定（deploy-mode）的位置，创建driver进程，driver进程根据sparkconf中的配置，初始化sparkcontext。Sparkcontext的启动后，创建DAG Scheduler（将DAG图分解成stage）和Task Scheduler（提交和监控task）两个调度模块。<br> 　　(2) driver进程根据配置参数向resource manager（资源管理器）申请资源（主要是用来执行的executor），resource manager接到到了Application的注册请求之后，会使用自己的资源调度算法，在spark集群的worker上，通知worker为application启动多个Executor。<br> 　　(3) executor创建后，会向resource manager进行资源及状态反馈，以便resource manager对executor进行状态监控，如监控到有失败的executor，则会立即重新创建。<br> 　　(4) Executor会向taskScheduler反向注册，以便获取taskScheduler分配的task。<br> 　　(5) Driver完成SparkContext初始化，继续执行application程序，当执行到Action时，就会创建Job。并且由DAGScheduler将Job划分多个Stage,每个Stage 由TaskSet 组成，并将TaskSet提交给taskScheduler,taskScheduler把TaskSet中的task依次提交给Executor, Executor在接收到task之后，会使用taskRunner（封装task的线程池）来封装task,然后，从Executor的线程池中取出一个线程来执行task。<br> 　　　就这样Spark的每个Stage被作为TaskSet提交给Executor执行，每个Task对应一个RDD的partition,执行我们的定义的算子和函数。直到所有操作执行完为止。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfkdvbb8j30cu081q3b.jpg" alt="image-20190716101520996"></p><p>图4. Spark 任务调度流程</p><h1 id="7-Spark作业调度中stage划分"><a href="#7-Spark作业调度中stage划分" class="headerlink" title="7. Spark作业调度中stage划分"></a>7. Spark作业调度中stage划分</h1><p>Spark在接收到提交的作业后，DAGScheduler会根据RDD之间的依赖关系将作业划分成多个stage，DAGSchedule在将划分的stage提交给TASKSchedule，TASKSchedule将每个stage分成多个task，交给executor执行。task的个数等于stage末端的RDD的分区个数。因此对了解stage的划分尤为重要。<br> 　　在spark中，RDD之间的依赖关系有两种：一种是窄依赖，一种是宽依赖。窄依赖的描述是：父RDD的分区最多只会被子RDD的一个分区使用。宽依赖是：父RDD的一个分区会被子RDD的多个分区使用。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfkf8ftlj30cq07ugm9.jpg" alt="image-20190716101534397"></p><p>图5. RDD的两种依赖关系</p><p>　　上图中，以一竖线作为分界，左边是窄依赖，右边是宽依赖。<br> 　　Stage的划分不仅根据RDD的依赖关系，还有一个原则是将依赖链断开，每个stage内部可以并行运行，整个作业按照stage顺序依次执行，最终完成整个Job。</p><p>实际划分时，DAGScheduler就是根据DAG图，从图的末端逆向遍历整个依赖链，一般是以一次shuffle为边界来划分的。一般划分stage是从程序执行流程的最后往前划分，遇到宽依赖就断开，遇到窄依赖就将将其加入当前stage中。一个典型的RDD Graph如下图所示：其中实线框是RDD，RDD内的实心矩形是各个分区，实线箭头表示父子分区间依赖关系，虚线框表示stage。针对下图流程首先根据最后一步join（宽依赖）操作来作为划分stage的边界，再往左走，A和B之间有个group by也为宽依赖，也可作为stage划分的边界，所以我们将下图划分为三个stage。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyfkevj9bj30av07jdgc.jpg" alt="image-20190716101544528"></p><p>spark stream<br><a href="https://blog.csdn.net/wzqllwy/article/details/78869889" target="_blank" rel="noopener">https://blog.csdn.net/wzqllwy/article/details/78869889</a><br><a href="https://mp.weixin.qq.com/s/YpP4a8Xcu23lhYRjWOFbdQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YpP4a8Xcu23lhYRjWOFbdQ</a><br><a href="https://bbs.csdn.net/topics/391038024" target="_blank" rel="noopener">https://bbs.csdn.net/topics/391038024</a><br><a href="https://blog.csdn.net/legotime/article/details/51836040" target="_blank" rel="noopener">https://blog.csdn.net/legotime/article/details/51836040</a><br><a href="http://dblab.xmu.edu.cn/blog/1733-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1733-2/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> distributed </tag>
            
            <tag> framework </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群篇</title>
      <link href="/2020/02/28/Redis%E9%9B%86%E7%BE%A4%E7%AF%87/"/>
      <url>/2020/02/28/Redis%E9%9B%86%E7%BE%A4%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li>Redis 主从复制的配置和原理</li><li>Redis 哨兵机制(Sentinel)原理和实战</li><li>Redis 分布式的各种方案对比，包括客户端 Sharding、代理 Proxy 和 Redis Cluster</li></ul><h2 id="为什么需要-Redis-集群"><a href="#为什么需要-Redis-集群" class="headerlink" title="为什么需要 Redis 集群"></a>为什么需要 Redis 集群</h2><h3 id="为什么需要集群"><a href="#为什么需要集群" class="headerlink" title="为什么需要集群?"></a>为什么需要集群?</h3><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>Redis 本身的 QPS 已经很高了，但是如果在一些并发量非常高的情况下，性能还是 会受到影响。这个时候我们希望有更多的 Redis 服务来完成工作</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>第二个是出于存储的考虑。因为 Redis 所有的数据都放在内存中，如果数据量大， 很容易受到硬件的限制。升级硬件收效和成本比太低，所以我们需要有一种横向扩展的 方法。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>第三个是可用性和安全的问题。如果只有一个 Redis 服务，一旦服务宕机，那么所有的客户端都无法访问，会对业务造成很大的影响。另一个，如果硬件发生故障，而单 机的数据无法恢复的话，带来的影响也是灾难性的。</p><h2 id="Redis-主从复制-replication"><a href="#Redis-主从复制-replication" class="headerlink" title="Redis 主从复制(replication)"></a>Redis 主从复制(replication)</h2><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><h4 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h4><p>1、slave node 启动时(执行 slaveof 命令)，会在自己本地保存 master node 的 信息，包括 master node 的 host 和 ip。</p><p>2、slave node 内部有个定时任务 replicationCron(源码 replication.c)，每隔 1 秒钟检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接，如果连接成功，从节点为该 socket 建立一个专门处理复制工作的文件 事件处理器，负责后续的复制工作，如接收 RDB 文件、接收命令传播等。</p><p>当从节点变成了主节点的一个客户端之后，会给主节点发送 ping 请求。</p><h4 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h4><p>3、master node 第一次执行全量复制，通过 bgsave 命令在本地生成一份 RDB 快 照，将 RDB 快照文件发给 slave node(如果超时会重连，可以调大 repl-timeout 的值)。 slave node 首先清除自己的旧数据，然后用 RDB 文件加载数据。</p><p><strong>问题:生成 RDB 期间，master 接收到的命令怎么处理?</strong></p><p>开始生成 RDB 文件时，master 会把所有新的写命令缓存在内存中。在 slave node保存了 RDB 之后，再将新的写命令复制给 slave node。</p><h4 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h4><p>4、master node 持续将写命令，异步复制给 slave node</p><p>延迟是不可避免的，只能通过优化网络。</p><p>repl-disable-tcp-nodelay no</p><p>当设置为 yes 时，TCP 会对包进行合并从而减少带宽，但是发送的频率会降低，从 节点数据延迟增加，一致性变差;具体发送频率与 Linux 内核的配置有关，默认配置为 40ms。当设置为 no 时，TCP 会立马将主节点的数据发送给从节点，带宽增加但延迟变 小。</p><p>一般来说，只有当应用对 Redis 数据不一致的容忍度较高，且主从节点之间网络状 况不好时，才会设置为 yes;多数情况使用默认值 no。</p><p><strong>问题:如果从节点有一段时间断开了与主节点的连接是不是要重新全量复制一遍? 如果可以增量复制，怎么知道上次复制到哪里?</strong></p><p>通过 master_repl_offset 记录的偏移量</p><p>redis&gt; info replication</p><p><strong>主从同步细节</strong></p><p><a href="https://zhuanlan.zhihu.com/p/56579802?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56579802?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p><p>部分重同步功能由以下 3 部分组成：</p><ul><li>主从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区</li><li>服务器的运行 id（run id）</li></ul><h3 id="主从复制的不足"><a href="#主从复制的不足" class="headerlink" title="主从复制的不足"></a>主从复制的不足</h3><p>主从模式解决了数据备份和性能(通过读写分离)的问题，但是还是存在一些不足:</p><p>1、RDB 文件过大的情况下，同步非常耗时。</p><p>2、在一主一从或者一主多从的情况下，如果主服务器挂了，对外提供的服务就不可 用了，单点问题没有得到解决。如果每次都是手动把之前的从服务器切换成主服务器， 这个比较费时费力，还会造成一定时间的服务不可用。</p><h2 id="可用性保证之-Sentinel"><a href="#可用性保证之-Sentinel" class="headerlink" title="可用性保证之 Sentinel"></a>可用性保证之 Sentinel</h2><h3 id="Sentinel原理"><a href="#Sentinel原理" class="headerlink" title="Sentinel原理"></a>Sentinel原理</h3><p>如何实现主从的自动切换?我们的思路:</p><p>创建一台监控服务器来监控所有 Redis 服务节点的状态，比如，master 节点超过一 定时间没有给监控服务器发送心跳报文，就把 master 标记为下线，然后把某一个 slave 变成 master。应用每一次都是从这个监控服务器拿到 master 的地址。</p><p>Redis 的 Sentinel 就是这种思路:通过运行监控服务器来保证服务的可用性。</p><p>官网:</p><p><a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">https://redis.io/topics/sentinel</a></p><p>从 Redis2.8 版本起，提供了一个稳定版本的 Sentinel(哨兵)，用来解决高可用的 问题。它是一个特殊状态的 redis 实例。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc1hj285qj30zu0kq4bx.jpg" alt="image-20200228131448520" style="zoom:67%;"></p><p>为了保证监控服务器的可用性，我们会对 Sentinel 做集群的部署。Sentinel 既监控 所有的 Redis 服务，Sentinel 之间也相互监控。</p><p>注意:Sentinel 本身没有主从之分，只有 Redis 服务节点有主从之分。</p><p>概念梳理:master，slave(redis group)，sentinel，sentinel 集合</p><h3 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h3><p>Sentinel 默认以每秒钟 1 次的频率向 Redis 服务节点发送 PING 命令。如果在 down-after-milliseconds 内都没有收到有效回复，Sentinel 会将该服务器标记为下线 (主观下线)。</p><p>这个时候 Sentinel 节点会继续询问其他的 Sentinel 节点，确认这个节点是否下线， 如果多数 Sentinel 节点都认为 master 下线，master 才真正确认被下线(客观下线)， 这个时候就需要重新选举 master。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>大体上有两个步骤:领导选举，数据复制。</p><p>Raft 是一个共识算法(consensus algorithm)。比如比特币之类的加密货币，就 需要共识算法。Spring Cloud 的注册中心解决方案 Consul 也用到了 Raft 协议。</p><p>如果 master 被标记为下线，就会开始故障转移流程。<br> 既然有这么多的 Sentinel 节点，由谁来做故障转移的事情呢? 故障转移流程的第一步就是在 Sentinel 集群选择一个 Leader，由 Leader 完成故障转移流程。Sentinle 通过 Raft 算法，实现 Sentinel 选举。</p><h4 id="Ratf-算法"><a href="#Ratf-算法" class="headerlink" title="Ratf 算法"></a>Ratf 算法</h4><p>Raft 的核心思想:先到先得，少数服从多数。 Raft 算法演示:</p><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><h4 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h4><p><strong>问题:怎么让一个原来的 slave 节点成为主节点?</strong></p><p>1、选出 Sentinel Leader 之后，由 Sentinel Leader 向某个节点发送 slaveof no one 命令，让它成为独立节点。</p><p>2、然后向其他节点发送 slaveof x.x.x.x xxxx(本机服务)，让它们成为这个节点的 子节点，故障转移完成。</p><p><strong>问题:这么多从节点，选谁成为主节点?</strong></p><p>关于从节点选举，一共有四个因素影响选举的结果，分别是断开连接时长、优先级 排序、复制数量、进程 id。</p><p>如果与哨兵连接断开的比较久，超过了某个阈值，就直接失去了选举权。如果拥有 选举权，那就看谁的优先级高，这个在配置文件里可以设置(replica-priority 100)， 数值越小优先级越高。</p><p>如果优先级相同，就看谁从 master 中复制的数据最多(复制偏移量最大)，选最多 的那个，如果复制数量也相同，就选择进程 id 最小的那个。</p><h3 id="Sentinel的功能总结"><a href="#Sentinel的功能总结" class="headerlink" title="Sentinel的功能总结"></a>Sentinel的功能总结</h3><p>监控:Sentinel 会不断检查主服务器和从服务器是否正常运行。 </p><p>通知:如果某一个被监控的实例出现问题，Sentinel 可以通过 API 发出通知。</p><p>自动故障转移(failover):如果主服务器发生故障，Sentinel 可以启动故障转移 程。把某台服务器升级为主服务器，并发出通知。</p><p>配置管理:客户端连接到 Sentinel，获取当前的 Redis 主服务器的地址。</p><h3 id="哨兵机制的不足"><a href="#哨兵机制的不足" class="headerlink" title="哨兵机制的不足"></a>哨兵机制的不足</h3><p>主从切换的过程中会丢失数据，因为只有一个 master。 </p><p>只能单点写，没有解决水平扩容的问题。 </p><p>如果数据量非常大，这个时候我们需要多个 master-slave 的 group，把数据分布到不同的 group 中。 问题来了，数据怎么分片?分片之后，怎么实现路由?</p><h2 id="Redis-分布式方案"><a href="#Redis-分布式方案" class="headerlink" title="Redis 分布式方案"></a><strong>Redis</strong> 分布式方案</h2><p>如果要实现 Redis 数据的分片，我们有三种方案。</p><p>第一种是在客户端实现相关的逻辑，例如用取模或者一致性哈希对 key 进行分片，查询和修改都先判断 key 的路由。</p><p>第二种是把做分片处理的逻辑抽取出来，运行一个独立的代理服务，客户端连接到 这个代理服务，代理服务做请求的转发。</p><p>第三种就是基于服务端实现。</p><h3 id="客户端-Sharding"><a href="#客户端-Sharding" class="headerlink" title="客户端 Sharding"></a>客户端 Sharding</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc7qn7pvuj30pu0fsjv9.jpg" alt="image-20200228165110433" style="zoom:67%;"></p><p>使用 ShardedJedis 之类的客户端分片代码的优势是配置简单，不依赖于其他中间 件，分区的逻辑可以自定义，比较灵活。但是基于客户端的方案，不能实现动态的服务 增减，每个客户端需要自行维护分片策略，存在重复代码。</p><p>第二种思路就是把分片的代码抽取出来，做成一个公共服务，所有的客户端都连接 到这个代理层。由代理层来实现请求和转发。</p><h3 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc7rva7kbj30tq0f6tfg.jpg" alt="image-20200228165221320" style="zoom:67%;"></p><p>典型的代理分区方案有 Twitter 开源的 Twemproxy 和国内的豌豆荚开源的 Codis。</p><h4 id="Twemproxy"><a href="#Twemproxy" class="headerlink" title="Twemproxy"></a>Twemproxy</h4><p>two-em-proxy</p><p><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">https://github.com/twitter/twemproxy</a></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc84wz2nhj30rq0jaq9s.jpg" alt="image-20200228170453482" style="zoom:67%;"></p><p>Twemproxy 的优点:比较稳定，可用性高。<br> 不足: 1、出现故障不能自动转移，架构复杂，需要借助其他组件(LVS/HAProxy +</p><p>Keepalived)实现 HA 2、扩缩容需要修改配置，不能实现平滑地扩缩容(需要重新分布数据)。</p><h4 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h4><p><a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">https://github.com/CodisLabs/codis</a></p><p>Codis 是一个代理中间件，用 Go 语言开发的。 功能:客户端连接 Codis 跟连接 Redis 没有区别。</p><table><thead><tr><th></th><th>Codis</th><th>Tewmproxy</th><th>Redis Cluster</th></tr></thead><tbody><tr><td>重新分片不需要重启</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>pipeline</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>多 key  操作的 hash tags {}</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>重新分片时的多 key 操作</td><td>Yes</td><td>-</td><td>No</td></tr><tr><td>客户端支持</td><td>所有</td><td>所有</td><td>支持 cluster 协议的客户 端</td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc862xcvqj315c0q6tmu.jpg" alt="image-20200228170600698" style="zoom:67%;"></p><p>分片原理:Codis 把所有的 key 分成了 N 个槽(例如 1024)，每个槽对应一个分组， 一个分组对应于一个或者一组 Redis 实例。Codis 对 key 进行 CRC32 运算，得到一个 32 位的数字，然后模以 N(槽的个数)，得到余数，这个就是 key 对应的槽，槽后面就 是 Redis 的实例。</p><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p><a href="https://redis.io/topics/cluster-tutorial/" target="_blank" rel="noopener">https://redis.io/topics/cluster-tutorial/</a></p><p>Redis Cluster 是在 Redis 3.0 的版本正式推出的，用来解决分布式的需求，同时也 可以实现高可用。跟 Codis 不一样，它是去中心化的，客户端可以连接到任意一个可用 节点。</p><p>数据分片有几个关键的问题需要解决: </p><p>1、数据怎么相对均匀地分片</p><p> 2、客户端怎么访问到相应的节点和数据</p><p> 3、重新分片的过程，怎么保证正常服务</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>​    Redis Cluster 可以看成是由多个 Redis 实例组成的数据集合。客户端不需要关注数 据的子集到底存储在哪个节点，只需要关注这个集合整体。</p><p>以 3 主 3 从为例，节点之间两两交互，共享数据分片、节点状态等信息。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc8a6qjukj30wq0mmqi5.jpg" alt="image-20200228170956874" style="zoom:67%;"></p><h4 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h4><h5 id="哈希后取模"><a href="#哈希后取模" class="headerlink" title="哈希后取模"></a>哈希后取模</h5><p>​    例如，hash(key)%N，根据余数，决定映射到那一个节点。这种方式比较简单，属 于静态的分片规则。但是一旦节点数量变化，新增或者减少，由于取模的 N 发生变化， 数据需要重新分布。为了解决这个问题，我们又有了一致性哈希算法。</p><h5 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h5><p>一致性哈希的原理:</p><p>把所有的哈希值空间组织成一个虚拟的圆环(哈希环)，整个空间按顺时针方向组 织。因为是环形空间，0 和 2^32-1 是重叠的。</p><p>谷歌的 MurmurHash 就是一致性哈希算法。在分布式系统中，负载均衡、分库分表 等场景中都有应用。</p><p>一致性哈希解决了动态增减节点时，所有数据都需要重新分布的问题，它只会影响 到下一个相邻的节点，对其他节点没有影响。</p><p>但是这样的一致性哈希算法有一个缺点，因为节点不一定是均匀地分布的，特别是 在节点数比较少的情况下，所以数据不能得到均匀分布。解决这个问题的办法是引入虚拟节点(Virtual Node)。</p><h6 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h6><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc8j761vfj30pg0ga7cs.jpg" alt="image-20200228171836576" style="zoom:50%;"></p><h6 id="Redis-虚拟槽分区"><a href="#Redis-虚拟槽分区" class="headerlink" title="Redis 虚拟槽分区"></a>Redis 虚拟槽分区</h6><p>Redis 既没有用哈希取模，也没有用一致性哈希，而是用虚拟槽来实现的。</p><p>Redis 创建了 16384 个槽(slot)，每个节点负责一定区间的 slot。比如 Node1 负 责 0-5460，Node2 负责 5461-10922，Node3 负责 10923-16383。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcc8n2jkl6j318y0jo12k.jpg" alt="image-20200228172220767" style="zoom:67%;"></p><p>注意:key 与 slot 的关系是永远不会变的，会变的只有 slot 和 Redis 节点的关系。</p><p><strong>问题:怎么让相关的数据落到同一个节点上?</strong></p><p>在 key 里面加入{hash tag}即可。Redis 在计算槽编号的时候只会获取{}之间的字符 串进行槽编号计算，这样由于上面两个不同的键，{}里面的字符串是相同的，因此他们可 以被计算出相同的槽。</p><p><strong>问题:客户端连接到哪一台服务器?访问的数据不在当前节点上，怎么办?</strong></p><h4 id="客户端重定向"><a href="#客户端重定向" class="headerlink" title="客户端重定向"></a>客户端重定向</h4><p>比如在 7291 端口的 Redis 的 redis-cli 客户端操作:</p><pre><code>127.0.0.1:7291&gt; set qs 1 (error) MOVED 13724 127.0.0.1:7293</code></pre><p>服务端返回 MOVED，也就是根据 key 计算出来的 slot 不归 7191 端口管理，而是 归 7293 端口管理，服务端返回 MOVED 告诉客户端去 7293 端口操作。</p><p><strong>问题:新增或下线了 Master 节点，数据怎么迁移(重新分配)?</strong></p><h4 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h4><p>因为 key 和 slot 的关系是永远不会变的，当新增了节点的时候，需要把原有的 slot 分配给新的节点负责，并且把相关的数据迁移过来。</p><p><strong>问题:只有主节点可以写，一个主节点挂了，从节点怎么变成主节点?</strong></p><h4 id="高可用和主从切换原理"><a href="#高可用和主从切换原理" class="headerlink" title="高可用和主从切换原理"></a>高可用和主从切换原理</h4><p>当 slave 发现自己的 master 变为 FAIL 状态时，便尝试进行 Failover，以期成为新 的 master。由于挂掉的 master 可能会有多个 slave，从而存在多个 slave 竞争成为 master 节点的过程， 其过程如下:</p><p>1.slave 发现自己的 master 变为 FAIL<br>2.将自己记录的集群 currentEpoch 加 1，并广播 FAILOVER_AUTH_REQUEST 信息 </p><p>3.其他节点收到该信息，只有 master 响应，判断请求者的合法性，并发送</p><p>FAILOVER_AUTH_ACK，对每一个 epoch 只发送一次 ack </p><p>4.尝试 failover 的 slave 收集 FAILOVER_AUTH_ACK </p><p>5.超过半数后变成新 Master</p><p>6.广播 Pong 通知其他集群节点。</p><p>Redis Cluster 既能够实现主从的角色分配，又能够实现主从切换，相当于集成了 Replication 和 Sentinal 的功能。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>优势</p><ol><li>无中心架构。</li><li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。 </li><li>可扩展性，可线性扩展到 1000 个节点(官方推荐不超过 1000 个)，节点可动态添加或删除。</li><li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制 完成 Slave 到 Master 的角色提升。</li><li>降低运维成本，提高系统的扩展性和可用性。</li></ol><p>不足</p><p>1.Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时 更新，提高了开发难度，客户端的不成熟影响业务的稳定性。</p><p>2.节点会因为某些原因发生阻塞(阻塞时间大于 clutser-node-timeout)，被判断 下线，这种 failover 是没有必要的。</p><ol start="3"><li>数据通过异步复制，不保证数据的强一致性。</li><li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容 易出现相互影响的情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战篇</title>
      <link href="/2020/02/28/Redis%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2020/02/28/Redis%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li>Redis客户端</li><li>数据一致性</li><li>高并发问题</li></ul><h2 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h2><h3 id="客户端通信原理"><a href="#客户端通信原理" class="headerlink" title="客户端通信原理"></a>客户端通信原理</h3><p>客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。 客户端和服务器发送的命令或数据一律以 \r\n (CRLF 回车+换行)结尾。</p><p>客户端跟 Redis 之间 使用一种特殊的编码格式(在 AOF 文件里面我们看到了)，叫 做 Redis Serialization Protocol (Redis 序列化协议)。特点:容易实现、解析快、可读 性强。客户端发给服务端的消息需要经过编码，服务端收到之后会按约定进行解码，反之亦然。</p><p><a href="https://redis.io/clients#java" target="_blank" rel="noopener">https://redis.io/clients#java</a></p><p>官方推荐的客户端</p><table><thead><tr><th>客户端</th><th>描述</th></tr></thead><tbody><tr><td>Jedis</td><td>A blazingly small and sane redis java client</td></tr><tr><td>lettuce</td><td>Advanced Redis client for thread-safe sync, async, and reactive usage. Supports Cluster, Sentinel, Pipelining, and codecs.</td></tr><tr><td>Redisson</td><td>distributed and scalable Java data structures on top of Redis server</td></tr></tbody></table><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>Jedis 是我们最熟悉和最常用的客户端。轻量，简洁，便于集成和改造。</p><p>Jedis 多个线程使用一个连接的时候线程不安全。可以使用连接池，为每个请求创建 不同的连接，基于 Apache common pool 实现。跟数据库一样，可以设置最大连接数 等参数。</p><p>Jedis 有 4 种工作模式:单节点、分片、哨兵、集群。</p><p>3 种请求模式:Client、Pipeline、事务。</p><h4 id="Jedis-实现分布式锁"><a href="#Jedis-实现分布式锁" class="headerlink" title="Jedis 实现分布式锁"></a>Jedis 实现分布式锁</h4><p>原文地址:<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></p><p>中文地址:<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">http://redis.cn/topics/distlock.html</a> 分布式锁的基本特性或者要求:</p><p>1、互斥性:只有一个客户端能够持有锁。</p><p>2、不会产生死锁:即使持有锁的客户端崩溃，也能保证后续其他客户端可以获 取锁。</p><p>3、只有持有这把锁的客户端才能解锁。</p><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><pre><code class="java">public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {    // set 支持多个参数 NX(not exist) XX(exist) EX(seconds) PX(million seconds)    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);     if (LOCK_SUCCESS.equals(result)) {            return true;    }    return false;}</code></pre><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><pre><code class="java">public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {    String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;   Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));    if (RELEASE_SUCCESS.equals(result)) {        return true; }    return false; }</code></pre><h3 id="Luttece"><a href="#Luttece" class="headerlink" title="Luttece"></a>Luttece</h3><p>与 Jedis 相比，Lettuce 则完全克服了其线程不安全的缺点:Lettuce 是一个可伸缩 的线程安全的 Redis 客户端，支持同步、异步和响应式模式(Reactive)。多个线程可 以共享一个连接实例，而不必担心多线程并发问题。</p><p>它基于 Netty 框架构建，支持 Redis 的高级功能，如 Pipeline、发布订阅，事务、 Sentinel，集群，支持连接池。</p><p>Lettuce 是 Spring Boot 2.x 默认的客户端，替换了 Jedis。集成之后我们不需要单 独使用它，直接调用 Spring 的 RedisTemplate 操作，连接和创建和关闭也不需要我们 操心。</p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p><a href="https://redisson.org/" target="_blank" rel="noopener">https://redisson.org/</a></p><p><a href="https://github.com/redisson/redisson/wiki/目录" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/目录</a></p><p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格(In-MemoryData Grid)，提供了分布式和可扩展的 Java 数据结构。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>基于 Netty 实现，采用非阻塞 IO，性能高<br>支持异步请求<br>支持连接池、pipeline、LUA Scripting、Redis Sentinel、Redis Cluster 不支持事务，官方建议以 LUA Scripting 代替事务 </p><p>主从、哨兵、集群都支持。Spring 也可以配置和注入 RedissonClient</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>Redisson 的分布式锁是怎么实现的呢?</p><p>在加锁的时候，在 Redis 写入了一个 HASH，key 是锁名称，field 是线程名称，value 是 1(表示锁的重入次数)。</p><p>tryLock()——tryAcquire()——tryAcquireAsync()——tryLockInnerAsync()</p><p>最终也是调用了一段 Lua 脚本。里面有一个参数，两个参数的值。</p><pre><code class="lua">// KEYS[1] 锁名称 updateAccount // ARGV[1] key 过期时间 10000ms // ARGV[2] 线程名称// 锁名称不存在if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then// 创建一个 hash，key=锁名称，field=线程名，value=1 redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1);// 设置 hash 的过期时间redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);return nil;end;// 锁名称存在，判断是否当前线程持有的锁if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then// 如果是，value+1，代表重入次数+1 redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1);// 重新获得锁，需要重新设置 Key 的过期时间 redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);return nil;end;// 锁存在，但是不是当前线程持有，返回过期时间(毫秒) return redis.call(&#39;pttl&#39;, KEYS[1]);</code></pre><p>释放锁，源码:</p><p>unlock——unlockInnerAsync</p><pre><code class="lua">// KEYS[1] 锁的名称 updateAccount// KEYS[2] 频道名称 redisson_lock__channel:{updateAccount} // ARGV[1] 释放锁的消息 0// ARGV[2] 锁释放时间 10000// ARGV[3] 线程名称// 锁不存在(过期或者已经释放了)if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then// 发布锁已经释放的消息 redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); return 1;end;// 锁存在，但是不是当前线程加的锁if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) thenreturn nil; end;// 锁存在，是当前线程加的锁// 重入次数-1local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1);// -1 后大于 0，说明这个线程持有这把锁还有其他的任务需要执行 if (counter &gt; 0) then// 重新设置锁的过期时间 redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); return 0;else// -1 之后等于 0，现在可以删除锁了 redis.call(&#39;del&#39;, KEYS[1]);// 删除之后发布释放锁的消息 redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); return 1;end; // 其他情况返回 nil return nil;</code></pre><p>Redisson 跟 Jedis 定位不同，它不是一个单纯的 Redis 客户端，而是基于 Redis 实 现的分布式的服务，如果有需要用到一些分布式的数据结构，比如我们还可以基于 Redisson 的分布式队列实现分布式事务，就可以引入 Redisson 的依赖实现。</p><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><h3 id="缓存使用场景"><a href="#缓存使用场景" class="headerlink" title="缓存使用场景"></a>缓存使用场景</h3><p>针对读多写少的高并发场景，我们可以使用缓存来提升查询速度。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gccbe2d9alj31b207oab5.jpg" alt="image-20200227212914120">             </p><h3 id="一致性问题的定义"><a href="#一致性问题的定义" class="headerlink" title="一致性问题的定义"></a>一致性问题的定义</h3><p>当数据变化的时候, 现在我们有两种选择:</p><p>1、先操作 Redis 的数据再操作数据库的数据</p><p>2、先操作数据库的数据再操作 Redis 的数据</p><h3 id="方案的选择"><a href="#方案的选择" class="headerlink" title="方案的选择"></a>方案的选择</h3><p>Redis:删除还是更新?</p><p>这两种方案怎么选择呢?这里我们主要考虑更新缓存的代价。更新缓存之前，是不是要经过其他表的查询、接口调用、计算才能得到最新的数据， 而不是直接从数据库拿到的值。如果是的话，建议直接删除缓存，这种方案更加简单， 而且避免了数据库的数据和缓存不一致的情况。在一般情况下，我们也推荐使用删除的 方案。</p><p>这一点明确之后，现在我们就剩一个问题: </p><p>1、到底是先更新数据库，再删除缓存</p><p>2、还是先删除缓存，再更新数据库</p><h4 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h4><p>异常情况:</p><p> 1、更新数据库失败，程序捕获异常，不会走到下一步，所以数据不会出现不一致。 </p><p>2、更新数据库成功，删除缓存失败。数据库是新数据，缓存是旧数据，发生了不一</p><p>致的情况。</p><h5 id="重试的机制。"><a href="#重试的机制。" class="headerlink" title="重试的机制。"></a>重试的机制。</h5><p>如果删除缓存失败，我们捕获这个异常，把需要删除的 key 发送到消息队列。 让后自己创建一个消费者消费，尝试再次删除这个 key。</p><h5 id="异步更新缓存"><a href="#异步更新缓存" class="headerlink" title="异步更新缓存"></a>异步更新缓存</h5><p>因为更新数据库时会往 binlog 写入日志，所以我们可以通过一个服务来监听 binlog 的变化(比如阿里的 canal)，然后在客户端完成删除 key 的操作。如果删除失败的话， 再发送到消息队列。</p><p>总之，对于后删除缓存失败的情况，我们的做法是不断地重试删除，直到成功。</p><h4 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h4><p>异常情况: </p><p>1、删除缓存，程序捕获异常，不会走到下一步，所以数据不会出现不一致。</p><p> 2、删除缓存成功，更新数据库失败。 因为以数据库的数据为准，所以不存在数据不一致的情况。</p><p>看起来好像没问题，但是如果有程序并发操作的情况下:</p><p>1)线程 A 需要更新数据，首先删除了 Redis 缓存</p><p> 2)线程 B 查询数据，发现缓存不存在，到数据库查询旧值，写入 Redis，返回 </p><p>3)线程 A 更新了数据库</p><p>这个时候，Redis 是旧的值，数据库是新的值，发生了数据不一致的情况。</p><p>所以我们有一种延时双删的策略，在写入数据之后，再删除一次缓存。</p><p>1)删除缓存</p><p>2)更新数据库</p><p>3)休眠 500ms(这个时间，依据读取数据的耗时而定) </p><p>4)再次删除缓存</p><h2 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h2><p>在 Redis 存储的所有数据中，有一部分是被频繁访问的。</p><p>有两种情况可能会导致热点问题的产生</p><p>一个是用户集中访问的数据，比如抢购的商品，明星结婚和明星出轨的 微博。</p><p>还有一种就是在数据进行分片的情况下，负载不均衡，超过了单个服务器的承受 能力。热点问题可能引起缓存服务的不可用，最终造成压力堆积到数据库。</p><p>出于存储和流量优化的角度，我们必须要找到这些热点数据。</p><h3 id="热点数据发现"><a href="#热点数据发现" class="headerlink" title="热点数据发现"></a>热点数据发现</h3><p>除了自动的缓存淘汰机制之外，怎么找出那些访问频率高的 key 呢?或者说，我们 可以在哪里记录 key 被访问的情况呢</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>第一个当然是在客户端了，比如我们可不可以在所有调用了 get、set 方法的地方，</p><p>加上 key 的计数。但是这样的话，每一个地方都要修改，重复的代码也多。</p><p>但是这种方式有几个问题:<br> 1、不知道要存多少个 key，可能会发生内存泄露的问题。 </p><p>2、会对客户端的代码造成入侵。 </p><p>3、只能统计当前客户端的热点 key。</p><h4 id="代理层"><a href="#代理层" class="headerlink" title="代理层"></a>代理层</h4><p>第二种方式就是在代理端实现，比如 TwemProxy 或者 Codis，但是不是所有的项目 都使用了代理的架构。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>第三种就是在服务端统计，Redis 有一个 monitor 的命令，可以监控到所有 Redis 执行的命令。</p><p>Facebook 的 开 源 项 目 redis-faina (<a href="https://github.com/facebookarchive/redis-faina.git)就是基于这个原理实现的。" target="_blank" rel="noopener">https://github.com/facebookarchive/redis-faina.git)就是基于这个原理实现的。</a> 它是一个 python 脚本，可以分析 monitor 的数据。</p><p>redis-cli -p 6379 monitor | head -n 100000 | ./redis-faina.py</p><p>这种方法也会有两个问题:</p><p>1)monitor 命令在高并发的场景下，会影响性能，所以 不适合长时间使用。</p><p>2)只能统计一个 Redis 节点的热点 key。</p><h4 id="机器层面"><a href="#机器层面" class="headerlink" title="机器层面"></a>机器层面</h4><p>还有一种方法就是机器层面的，通过对 TCP 协议进行抓包，也有一些开源的方案， 比如 ELK 的 packetbeat 插件。</p><p>当我们发现了热点 key 之后，我们来看下热点数据在高并发的场景下可能会出现的 问题，以及怎么去解决。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩?"></a>什么是缓存雪崩?</h4><p>缓存雪崩就是 Redis 的大量热点数据同时过期(失效)，因为设置了相同的过期时间，刚好这个时候 Redis 请求的并发量又很大，就会导致所有的请求落到数据库</p><h4 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h4><p>1)加互斥锁或者使用队列，针对同一个 key 只允许一个线程到数据库查询</p><p> 2)缓存定时预先更新，避免同时失效</p><p> 3)通过加随机数，使 key 在不同的时间过期</p><p>4)缓存永不过期</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="缓存穿透何时发生"><a href="#缓存穿透何时发生" class="headerlink" title="缓存穿透何时发生"></a>缓存穿透何时发生</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gccbe1xc2oj318k08ut9w.jpg" alt="image-20200227214450175"></p><p>我们有没有什么办法避免应用到数据库查询呢?</p><p>(1)缓存空数据 (2)缓存特殊字符串，比如&amp;&amp;</p><p>(缓存不存在的key 黑名单,对于恶意key) </p><h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><p>如何在海量元素中(例如 10 亿无序、不定长、不重复)快速判断一个元素是否存在?</p><h4 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h4><p><a href="https://hur.st/bloomfilter/?n=1000000&amp;p=0.03&amp;m=&amp;k=" target="_blank" rel="noopener">https://hur.st/bloomfilter/?n=1000000&amp;p=0.03&amp;m=&amp;k=</a></p><p>首先，布隆过滤器的本质就是我们刚才分析的，一个位数组，和若干个哈希函数。</p><p>从容器的角度来说:</p><p>1、如果布隆过滤器判断元素在集合中存在，不一定存在</p><p>2、如果布隆过滤器判断不存在，一定不存在</p><h4 id="Guava-的实现"><a href="#Guava-的实现" class="headerlink" title="Guava 的实现"></a>Guava 的实现</h4><pre><code class="xml">&lt;dependency&gt;     &lt;groupId&gt;com.google.guava&lt;/groupId&gt;     &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;21.0&lt;/version&gt; &lt;/dependency&gt;</code></pre><p>布隆过滤器把误判率默认设置为 0.03，也可以在创建的时候指定。</p><pre><code class="java">public static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? super T&gt; funnel, long expectedInsertions) { return create(funnel, expectedInsertions, 0.03D);}</code></pre><p>存储 100 万个元素只占用了 0.87M 的内存，生成了 5 个哈希函数。</p><h4 id="隆过滤器在项目中的使用"><a href="#隆过滤器在项目中的使用" class="headerlink" title="隆过滤器在项目中的使用"></a>隆过滤器在项目中的使用</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcbasivz6fj30rc0qmqid.jpg" alt="image-20200227215112288" style="zoom:50%;"></p><h4 id="布隆过滤器的其他应用场景"><a href="#布隆过滤器的其他应用场景" class="headerlink" title="布隆过滤器的其他应用场景"></a>布隆过滤器的其他应用场景</h4><p>比如爬数据的爬虫，爬过的 url 我们不需要重复爬，那么在几十亿的 url 里面，怎么 判断一个 url 是不是已经爬过了?</p><p>还有我们的邮箱服务器，发送垃圾邮件的账号我们把它们叫做 spamer，在这么多的邮箱账号里面，怎么判断一个账号是不是 spamer 等等一些场景，我们都可以用到布隆 过滤器。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis原理篇</title>
      <link href="/2020/02/28/Redis%E5%8E%9F%E7%90%86%E7%AF%87/"/>
      <url>/2020/02/28/Redis%E5%8E%9F%E7%90%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>掌握 Redis 的底层原理，包括单线程工作机制、内存回收、持久化</p><h2 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快?"></a>Redis 为什么这么快?</h2><p>考虑以下几个问题</p><ul><li>Redis到底有多快?</li><li>Redis为什么这么快?</li><li>Redis为什么是单线程的?</li><li>单线程为什么这么快?</li></ul><h3 id="Redis到底有多快"><a href="#Redis到底有多快" class="headerlink" title="Redis到底有多快?"></a>Redis到底有多快?</h3><p><a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">https://redis.io/topics/benchmarks</a></p><p>机器配置</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gca7nzan38j30f20c2dhf.jpg" alt="image-20200226231728618" style="zoom:70%;"></p><p>普通命令</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gccbdsztpbj30y202kt95.jpg" alt="image-20200226231245939"></p><p>Pipeline</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gccbdrg7a4j310e02et97.jpg" alt="image-20200226231323246"></p><p>根据官方的数据，Redis 的 QPS 可以达到 10 万左右(每秒请求数)。</p><h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快?"></a>Redis为什么这么快?</h3><ul><li>纯内存结构</li><li>单线程</li><li>多路复用线程模型</li></ul><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>​    KV 结构的内存数据库，时间复杂度 O(1)。</p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>单线程有什么好处呢?<br> 1、没有创建线程、销毁线程带来的消耗 </p><p>2、避免了上线文切换导致的 CPU 消耗 </p><p>3、避免了线程之间带来的竞争问题，例如加锁释放锁死锁等等</p><h4 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h4><p>异步非阻塞 I/O，多路复用处理并发连接。</p><h3 id="Redis为什么是单线程的"><a href="#Redis为什么是单线程的" class="headerlink" title="Redis为什么是单线程的?"></a>Redis为什么是单线程的?</h3><p><a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener">https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores</a></p><p>因为单线程已经够用了，CPU 不是 redis 的瓶颈。Redis 的瓶颈最有可能是机器内存 或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单 线程的方案了。</p><h3 id="单线程为什么这么快"><a href="#单线程为什么这么快" class="headerlink" title="单线程为什么这么快?"></a>单线程为什么这么快?</h3><h4 id="虚拟存储器-虚拟内存-Vitual-Memory"><a href="#虚拟存储器-虚拟内存-Vitual-Memory" class="headerlink" title="虚拟存储器(虚拟内存 Vitual Memory)"></a>虚拟存储器(虚拟内存 Vitual Memory)</h4><p>名词解释:主存:内存;辅存:磁盘(硬盘)</p><p>计算机主存(内存)可看作一个由 M 个连续的字节大小的单元组成的数组，每个字 节有一个唯一的地址，这个地址叫做物理地址(PA)。早期的计算机中，如果 CPU 需要 内存，使用物理寻址，直接访问主存储器。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gca7uf4eopj30ii0gkq5g.jpg" alt="image-20200226232340065" style="zoom:80%;"></p><p>这种方式有几个弊端:</p><p>1、在多用户多任务操作系统中，所有的进程共享主存，如果每个进程都独占一块物 理地址空间，主存很快就会被用完。我们希望在不同的时刻，不同的进程可以共用同一 块物理地址空间。</p><p>2、如果所有进程都是直接访问物理内存，那么一个进程就可以修改其他进程的内存 数据，导致物理地址空间被破坏，程序运行就会出现异常。</p><p>为了解决这些问题，我们就想了一个办法，在 CPU 和主存之间增加一个中间层。CPU 不再使用物理地址访问，而是访问一个虚拟地址，由这个中间层把地址转换成物理地址， 最终获得数据。这个中间层就叫做虚拟存储器(Virtual Memory)。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gccbds4h6uj30ws0mawg2.jpg" alt="image-20200226232511628"></p><h4 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h4><p>为了避免用户进程直接操作内核，保证内核安全，操作系统将虚拟内存划分为两部 分，一部分是内核空间(Kernel-space)/ˈkɜːnl /，一部分是用户空间(User-space)</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gce8xiu750j316o0qywne.jpg" alt="image-20200301110328173" style="zoom:67%;"></p><p>​    内核是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也 有访问底层硬件设备的权限。</p><p>​    内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中，都是对物理地址的 映射。在 Linux 系统中, 内核进程和用户进程所占的虚拟内存比例是 1:3。</p><p>当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。</p><p>​    进程在内核空间以执行任意命令，调用系统的一切资源;在用户空间只能执行简单 的运算，不能直接调用系统资源，必须通过系统接口(又称 system call)，才能向内核 发出指令。</p><p>top 命令:us 代表 CPU 消耗在 User space 的时间百分比; sy 代表 CPU 消耗在 Kernel space 的时间百分比。</p><h4 id="进程切换-上下文切换"><a href="#进程切换-上下文切换" class="headerlink" title="进程切换(上下文切换)"></a>进程切换(上下文切换)</h4><p>​    多任务操作系统是怎么实现运行远大于 CPU 数量的任务个数的?当然，这些任务实 际上并不是真的在同时运行，而是因为系统通过时间片分片算法，在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。</p><p>​    为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂 起的某个进程的执行。这种行为被称为进程切换。</p><p>什么叫上下文?</p><p>​    在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是 说，需要系统事先帮它设置好 CPU 寄存器和程序计数器(ProgramCounter)，这个叫做 CPU 的上下文。</p><p>​    而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加 载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p><strong>在切换上下文的时候，需要完成一系列的工作，这是一个很消耗资源的操作。</strong></p><h4 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h4><p>正在运行的进程由于提出系统服务请求(如 I/O 操作)，但因为某种原因未得到操 作系统的立即响应，该进程只能把自己变成阻塞状态，等待相应的事件出现后才被唤醒。 进程在阻塞状态不占用 CPU 资源。</p><h4 id="文件描述符-FD"><a href="#文件描述符-FD" class="headerlink" title="文件描述符 FD"></a>文件描述符 FD</h4><p>Linux 系统将所有设备都当作文件来处理，而 Linux 用文件描述符来标识每个文件 对象。</p><p>文件描述符(File Descriptor)是内核为了高效管理已被打开的文件所创建的索引， 用于指向被打开的文件，所有执行 I/O 操作的系统调用都通过文件描述符;文件描述符 是一个简单的非负整数，用以表明每个被进程打开的文件。</p><p>Linux 系统里面有三个标准文件描述符。 0:标准输入(键盘);1:标准输出(显示器);2:标准错误输出(显示器)。</p><h4 id="传统-I-O-数据拷贝"><a href="#传统-I-O-数据拷贝" class="headerlink" title="传统 I/O 数据拷贝"></a>传统 I/O 数据拷贝</h4><p>当应用程序执行 read 系统调用读取文件描述符(FD)的时候，如果这块数据已经 存在于用户进程的页内存中，就直接从内存中读取数据。如果数据不存在，则先将数据 从磁盘加载数据到内核缓冲区中，再从内核缓冲区拷贝到用户进程的页内存中。(两次 拷贝，两次 user 和 kernel 的上下文切换)。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gce91w299uj30xu0pa457.jpg" alt="image-20200301110742887" style="zoom:50%;"></p><h4 id="Blocking-I-O"><a href="#Blocking-I-O" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h4><p>当使用 read 或 write 对某个文件描述符进行过读写时，如果当前 FD 不可读，系统 就不会对其他的操作做出响应。从设备复制数据到内核缓冲区是阻塞的，从内核缓冲区 拷贝到用户空间，也是阻塞的，直到 copy complete，内核返回结果，用户进程才解除 block 的状态。</p><p>为了解决阻塞的问题，我们有几个思路。</p><p>1、在服务端创建多个线程或者使用线程池，但是在高并发的情况下需要的线程会很 多，系统无法承受，而且创建和释放线程都需要消耗资源。</p><p>2、由请求方定期轮询，在数据准备完毕后再从内核缓存缓冲区复制数据到用户空间 (非阻塞式 I/O)，这种方式会存在一定的延迟。</p><p> 能不能用一个线程处理多个客户端请求?</p><h4 id="I-O-多路复用-I-O-Multiplexing"><a href="#I-O-多路复用-I-O-Multiplexing" class="headerlink" title="I/O 多路复用(I/O Multiplexing)"></a>I/O 多路复用(I/O Multiplexing)</h4><p>I/O 指的是网络 I/O。</p><p>多路指的是多个 TCP 连接(Socket 或 Channel)。 </p><p>复用指的是复用一个或多个线程。 </p><p>它的基本原理就是不再由应用程序自己监视连接，而是由内核替应用程序监视文件描述符。</p><p>客户端在操作的时候，会产生具有不同事件类型的 socket。在服务端，I/O 多路复 用程序(I/O Multiplexing Module)会把消息放入队列中，然后通过文件事件分派器(File event Dispatcher)，转发到不同的事件处理器中。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gce93zbhetj31700ikn5u.jpg" alt="image-20200301110943552" style="zoom:50%;"></p><p>多路复用有很多的实现，以 select 为例，当用户进程调用了多路复用器，进程会被阻塞。内核会监视多路复用器负责的所有 socket，当任何一个 socket 的数据准备好了， 多路复用器就会返回。</p><p><strong>这时候用户进程再调用 read 操作，把数据从内核缓冲区拷贝到用户空间</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gce95b9c0ij31cu0sagys.jpg" alt="image-20200301111059974" style="zoom:50%;"></p><p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符， 而这些文件描述符(套接字描述符)其中的任意一个进入读就绪(readable)状态，select() 函数就可以返回。</p><p>Redis 的多路复用， 提供了 select, epoll, evport, kqueue 几种选择，在编译的时 候来选择一种。</p><p>evport 是 Solaris 系统内核提供支持的;<br> epoll 是 LINUX 系统内核提供支持的;<br> kqueue 是 Mac 系统提供支持的;<br> select 是 POSIX 提供的，一般的操作系统都有支撑(保底方案); </p><p>源码 ae_epoll.c、ae_select.c、ae_kqueue.c、ae_evport.c</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>Reids 所有的数据都是存储在内存中的，在某些情况下需要对占用的内存空间进行回 收。内存回收主要分为两类，一类是 key 过期，一类是内存使用达到上限(max_memory) 触发内存淘汰。</p><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h4 id="定时过期-主动淘汰"><a href="#定时过期-主动淘汰" class="headerlink" title="定时过期(主动淘汰)"></a>定时过期(主动淘汰)</h4><h4 id="惰性过期-被动淘汰"><a href="#惰性过期-被动淘汰" class="headerlink" title="惰性过期(被动淘汰)"></a>惰性过期(被动淘汰)</h4><h4 id="定期过期"><a href="#定期过期" class="headerlink" title="定期过期"></a>定期过期</h4><p>Redis 中同时使用了惰性过期和定期过期两种过期策略。</p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><h4 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a>最大内存设置</h4><h4 id="淘汰策略-1"><a href="#淘汰策略-1" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><p>LRU</p><p>LFU</p><p>random</p><h4 id="LRU-淘汰原理"><a href="#LRU-淘汰原理" class="headerlink" title="LRU 淘汰原理"></a>LRU 淘汰原理</h4><p>如果淘汰策略是 LRU，则根据配置的采样值 maxmemory_samples(默认是 5 个),随机从数据库中选择 m 个 key, 淘汰其中热度最低的 key 对应的缓存数据。</p><p>为什么不用常规的哈希表+双向链表的方式实现?需要额外的数据结构，消耗资源。 而 Redis LRU 算法在 sample 为 10 的情况下，已经能接近传统 LRU 算法了。</p><p>如何找出热度最低的数据?</p><p>Redis 中所有对象结构都有一个 lru 字段, 且使用了 unsigned 的低 24 位，这个字段 用来记录对象的热度。对象被创建时会记录 lru 值。在被访问的时候也会更新 lru 的值。 但是不是获取系统当前的时间戳，而是设置为全局变量 server.lruclock 的值</p><p><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">https://redis.io/topics/lru-cache</a></p><h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB 是 Redis 默认的持久化方案。当满足一定条件的时候，会把当前内存中的数 据写入磁盘，生成一个快照文件 dump.rdb。Redis 重启会通过加载 dump.rdb 文件恢 复数据。</p><h4 id="RDB-触发"><a href="#RDB-触发" class="headerlink" title="RDB 触发"></a>RDB 触发</h4><h4 id="RDB-数据的恢复-演示"><a href="#RDB-数据的恢复-演示" class="headerlink" title="RDB 数据的恢复(演示)"></a>RDB 数据的恢复(演示)</h4><h4 id="RDB-文件的优势和劣势"><a href="#RDB-文件的优势和劣势" class="headerlink" title="RDB 文件的优势和劣势"></a>RDB 文件的优势和劣势</h4><p>一、优势<br> 1.RDB 是一个非常紧凑(compact)的文件，它保存了 redis 在某个时间点上的数据</p><p>集。这种文件非常适合用于进行备份和灾难恢复。<br> 2.生成 RDB 文件的时候，redis 主进程会 fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘 IO 操作。<br> 3.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。<br> 二、劣势<br> 1、RDB 方式数据没办法做到实时持久化/秒级持久化。因为 bgsave 每次运行都要执行 fork 操作创建子进程，频繁执行成本过高。 </p><p>2、在一定间隔时间做一次备份，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照之后的所有修改(数据有丢失)。 如果数据相对来说比较重要，希望将损失降到最小，则可以使用 AOF 方式进行持久化。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>Append Only File<br> AOF:Redis 默认不开启。AOF 采用日志的形式来记录每个写操作，并<strong>追加</strong>到文件中。开启后，执行更改 Redis 数据的命令时，就会把命令写入到 AOF 文件中。<br> Redis 重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。</p><p>那么对于 AOF 和 RDB 两种持久化方式，我们应该如何选择呢?</p><p>如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照(snapshot)非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要 比 AOF 恢复的速度要快。</p><p>否则就使用 AOF 重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下,当 redis 重启的时候会优先载入 AOF 文件来恢复原始 的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p><h4 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>appendonly</td><td>Redis 默认只开启 RDB 持久化，开启 AOF 需要修改为 yes</td></tr><tr><td>appendfilename “appendonly.aof”</td><td>路径也是通过 dir 参数配置 config get dir</td></tr></tbody></table><p>数据都是实时持久化到磁盘吗?</p><p>AOF 持久化策略(硬盘缓存到磁盘)，默认 everysec<br>  no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不太安全;  always表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低;<br>  everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据。通常选择 everysec ，兼顾安全性和效率。</p><p>文件越来越大，怎么办?</p><p>为了解决这个问题，Redis 新增了重写机制，当 AOF 文件的大小超过所设定的阈值 时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集</p><p>AOF 优势与劣势</p><p>优点:</p><p>1、AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步 一次，Redis 最多也就丢失 1 秒的数据而已。</p><p>缺点:</p><p>1、对于具有相同数据的的 Redis，AOF 文件通常会比 RDF 文件体积更大(RDB 存的是数据快照)。</p><p>2、虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较 高的性能。在高并发的情况下，RDB 比 AOF 具好更好的性能保证。</p><p>那么对于 AOF 和 RDB 两种持久化方式，我们应该如何选择呢?</p><p>如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照(snapshot)非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要 比 AOF 恢复的速度要快。</p><p>否则就使用 AOF 重写。但是一般情况下建议不要单独使用某一种持久化机制，而 是应该两种一起用，在这种情况下,当 redis 重启的时候会优先载入 AOF 文件来恢复原始 的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整</p><p>重写的时候会写成RDB后面通过AOF的方式追加</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-aop</title>
      <link href="/2020/01/23/spring-aop/"/>
      <url>/2020/01/23/spring-aop/</url>
      
        <content type="html"><![CDATA[<p>先来看下提纲</p><ul><li>AOP 概念、目标</li><li>AOP实现分析、源码细节</li><li>示例</li><li>总结</li></ul><p>基于5.1.3.RELEASE分析</p><h2 id="AOP-概念、目标"><a href="#AOP-概念、目标" class="headerlink" title="AOP 概念、目标"></a>AOP 概念、目标</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>​    在软件业，AOP为Aspect Oriented Programming的缩写，意为：<a href="https://baike.baidu.com/item/面向切面编程/6016335" target="_blank" rel="noopener">面向切面编程</a>，通过<a href="https://baike.baidu.com/item/预编译/3191547" target="_blank" rel="noopener">预编译</a>方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p><p>​    AOP是<a href="https://baike.baidu.com/item/OOP" target="_blank" rel="noopener">OOP</a>的延续，是软件开发中的一个热点，也是<a href="https://baike.baidu.com/item/Spring" target="_blank" rel="noopener">Spring</a>框架中的一个重要内容，是<a href="https://baike.baidu.com/item/函数式编程/4035031" target="_blank" rel="noopener">函数式编程</a>的一种衍生范型。</p><p>​    利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href="https://baike.baidu.com/item/耦合度/2603938" target="_blank" rel="noopener">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。(日志记录，性能统计，安全控制，事务处理，<a href="https://baike.baidu.com/item/异常处理" target="_blank" rel="noopener">异常处理</a>等等)</p><p>(来源百度百科)</p><h3 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a>Spring中的AOP</h3><p>参考官网文档简单翻译一下</p><h4 id="Concepts-概念"><a href="#Concepts-概念" class="headerlink" title="Concepts(概念)"></a>Concepts(概念)</h4><p>先来了解下涉及的相关概念</p><h5 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect (切面)"></a>Aspect (切面)</h5><p>​    关注点的模块化，跨多个类。事务管理是企业Java应用程序中横切关注的一个很好的例子。在Spring AOP中，切面是通过使用类(xml配置)或使用带有@Aspect注解的类来实现的。(通常是一个功能,一个类)</p><h5 id="Join-point-连接点"><a href="#Join-point-连接点" class="headerlink" title="Join point(连接点)"></a>Join point(连接点)</h5><p>​    程序执行过程中的一个点，例如方法的执行或异常的处理。在Spring AOP中，切点始终代表方法的执行。(通常为需要拦截的方法)</p><h5 id="Advice-通知"><a href="#Advice-通知" class="headerlink" title="Advice(通知)"></a>Advice(通知)</h5><p>​    在连接点的行为, 可以简单认为是拦截器.</p><p>拦截类型</p><ul><li>Before advice 执行前拦截</li><li>After returning advice 执行后拦截</li><li>After throwing advice 异常时拦截</li><li>After (finally) advice    返回前最终拦截</li><li>Around advice    自定义拦截</li></ul><h5 id="Pointcut-切点"><a href="#Pointcut-切点" class="headerlink" title="Pointcut(切点)"></a>Pointcut(切点)</h5><p>​    简单理解为一个集合体(连接点的), 通知是面向切点,看代码好理解点</p><pre><code class="java">@Pointcut(value=&quot;execution(* aop.ServerImpl.*(..))&quot;)private void pointCut(){}@Before(value=&quot;pointCut()&quot;)public void before(JoinPoint joinPoint){  System.out.println(&quot;@Before前置通知:&quot;+ Arrays.toString(joinPoint.getArgs()));}</code></pre><h5 id="Target-object-目标对象"><a href="#Target-object-目标对象" class="headerlink" title="Target object(目标对象)"></a>Target object(目标对象)</h5><p>​    连接点(需要拦截的)方法所在的类</p><h4 id="AOP-proxy-AOP代理"><a href="#AOP-proxy-AOP代理" class="headerlink" title="AOP proxy(AOP代理)"></a>AOP proxy(AOP代理)</h4><p>​    一个对象用于实现切面的功能(代理),在spring 中通常有两种呢实现JDK代理和CGLIB代理</p><h4 id="Weaving-编织"><a href="#Weaving-编织" class="headerlink" title="Weaving(编织)"></a>Weaving(编织)</h4><p>​    完成通知(advice)和连接点(Join point)的编织, 这个动作可以在编译期(AspectJ compiler)、加载期(类加载)、运行时. SpringAOP的实现是通过动态代理的方式(运行时)</p><h3 id="Capabilities-能力"><a href="#Capabilities-能力" class="headerlink" title="Capabilities(能力)"></a>Capabilities(能力)</h3><blockquote><p>Spring AOP currently supports only method execution join points (advising the execution of methods on Spring beans). </p><p>Field interception is not implemented, although support for field interception could be added without breaking the core Spring AOP APIs. </p><p>If you need to advise field access and update join points, consider a language such as AspectJ.</p></blockquote><p>spring AOP的粒度只支持方法级别,不支持字段级别(如果需要使用AspectJ)</p><h3 id="goals-目标"><a href="#goals-目标" class="headerlink" title="goals(目标)"></a>goals(目标)</h3><blockquote><p>Spring AOP’s approach to AOP differs from that of most other AOP frameworks. </p><p>The aim is not to provide the most complete AOP implementation (although Spring AOP is quite capable).</p><p>Rather, the aim is to provide a close integration between AOP implementation and Spring IoC, to help solve common problems in enterprise applications.</p></blockquote><p>目的不是提供最完整的AOP实现（尽管Spring AOP相当强大）。</p><p>相反，其目的是在AOP实现和Spring IoC之间提供紧密的集成，以帮助解决企业应用程序中的常见问题。(OOP的补充)</p><h3 id="Packages-overView-包预览"><a href="#Packages-overView-包预览" class="headerlink" title="Packages overView(包预览)"></a>Packages overView(包预览)</h3><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/aopalliance/aop/package-summary.html" target="_blank" rel="noopener">org.aopalliance.aop</a></td><td>The core AOP Alliance advice marker.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/aopalliance/intercept/package-summary.html" target="_blank" rel="noopener">org.aopalliance.intercept</a></td><td>The AOP Alliance reflective interception abstraction.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/package-summary.html" target="_blank" rel="noopener">org.springframework.aop</a></td><td>Core Spring AOP interfaces, built on AOP Alliance AOP interoperability interfaces.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/aspectj/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.aspectj</a></td><td>AspectJ integration package.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/aspectj/annotation/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.aspectj.annotation</a></td><td>Classes enabling AspectJ 5 @Annotated classes to be used in Spring AOP.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/aspectj/autoproxy/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.aspectj.autoproxy</a></td><td>Base classes enabling auto-proxying based on AspectJ.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/config/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.config</a></td><td>Support package for declarative AOP configuration, with XML schema being the primary configuration format.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/framework/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.framework</a></td><td>Package containing Spring’s basic AOP infrastructure, compliant with the <a href="http://aopalliance.sourceforge.net/" target="_blank" rel="noopener">AOP Alliance</a> interfaces.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/framework/adapter/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.framework.adapter</a></td><td>SPI package allowing Spring AOP framework to handle arbitrary advice types.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/framework/autoproxy/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.framework.autoproxy</a></td><td>Bean post-processors for use in ApplicationContexts to simplify AOP usage by automatically creating AOP proxies without the need to use a ProxyFactoryBean.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/framework/autoproxy/target/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.framework.autoproxy.target</a></td><td></td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/interceptor/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.interceptor</a></td><td>Provides miscellaneous interceptor implementations.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/scope/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.scope</a></td><td>Support for AOP-based scoping of target objects, with configurable backend.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/support/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.support</a></td><td>Convenience classes for using Spring’s AOP API.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/support/annotation/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.support.annotation</a></td><td>Annotation support for AOP pointcuts.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/target/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.target</a></td><td></td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/aop/target/dynamic/package-summary.html" target="_blank" rel="noopener">org.springframework.aop.target.dynamic</a></td></tr></tbody></table><h2 id="AOP实现分析"><a href="#AOP实现分析" class="headerlink" title="AOP实现分析"></a>AOP实现分析</h2><p>​    接下来我们来看下AOP在Spring 中是怎么实现的,我们简单分为两个方面,创建和执行</p><h3 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h3><p>​    根据之前BeanFactory的分析, 我们都知道bean的创建流程. Spring AOP的实现就是通过Bean的后置通知实现的, 而在核心类 AnnotationAwareAspectJAutoProxyCreator中,它又把advisor和proxy的创建委派给其他类(ReflectiveAspectJAdvisorFactory,DefaultAopProxyFactory)</p><h4 id="核心类预览"><a href="#核心类预览" class="headerlink" title="核心类预览"></a>核心类预览</h4><h5 id="AnnotationAwareAspectJAutoProxyCreator类图"><a href="#AnnotationAwareAspectJAutoProxyCreator类图" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator类图"></a>AnnotationAwareAspectJAutoProxyCreator类图</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6xobu7vuj31ou0r2wje.jpg" alt="image-20200123210402304"></p><p>需要关注的方法</p><ul><li>AbstractAutoProxyCreator#wrapIfNecessary (判断是否需要包装)</li><li>AbstractAutoProxyCreator#getAdvicesAndAdvisorsForBean (获取通知(advices),包装为advisors)</li><li>AbstractAutoProxyCreator#createProxy(编织,创建代理类)</li></ul><h5 id="ReflectiveAspectJAdvisorFactory类图"><a href="#ReflectiveAspectJAdvisorFactory类图" class="headerlink" title="ReflectiveAspectJAdvisorFactory类图"></a>ReflectiveAspectJAdvisorFactory类图</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6xoc6icqj31ou0r2wje.jpg" alt="image-20200123211728249"></p><p>AspectJAdvisorFactory相关源码如下</p><pre><code class="java">/** * Interface for factories that can create Spring AOP Advisors from classes * annotated with AspectJ annotation syntax. * * @author Rod Johnson * @author Juergen Hoeller * @since 2.0 * @see AspectMetadata * @see org.aspectj.lang.reflect.AjTypeSystem */public interface AspectJAdvisorFactory {   boolean isAspect(Class&lt;?&gt; clazz);   void validate(Class&lt;?&gt; aspectClass) throws AopConfigException;   List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory);   @Nullable   Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,int declarationOrder, String aspectName);   /**    * Build a Spring AOP Advice for the given AspectJ advice method.    * @param candidateAdviceMethod the candidate advice method    * @param expressionPointcut the AspectJ expression pointcut    * @param aspectInstanceFactory the aspect instance factory    * @param declarationOrder the declaration order within the aspect    * @param aspectName the name of the aspect    * @return {@code null} if the method is not an AspectJ advice method    * or if it is a pointcut that will be used by other advice but will not    * create a Spring advice in its own right    * @see org.springframework.aop.aspectj.AspectJAroundAdvice    * @see org.springframework.aop.aspectj.AspectJMethodBeforeAdvice    * @see org.springframework.aop.aspectj.AspectJAfterAdvice    * @see org.springframework.aop.aspectj.AspectJAfterReturningAdvice    * @see org.springframework.aop.aspectj.AspectJAfterThrowingAdvice    */   @Nullable   Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName);}</code></pre><h5 id="DefaultAopProxyFactory类图"><a href="#DefaultAopProxyFactory类图" class="headerlink" title="DefaultAopProxyFactory类图"></a>DefaultAopProxyFactory类图</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6xofqnwfj30zu08a0tm.jpg" alt="image-20200123212809125"></p><p>AopProxyFactory base on org.springframework.aop.framework.AdvisedSupport</p><pre><code class="java">public interface AopProxyFactory {   /**    * Create an {@link AopProxy} for the given AOP configuration.    * @param config the AOP configuration in the form of an    * AdvisedSupport object    * @return the corresponding AOP proxy    * @throws AopConfigException if the configuration is invalid    */   AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException;}</code></pre><h4 id="时序图及源码分析"><a href="#时序图及源码分析" class="headerlink" title="时序图及源码分析"></a>时序图及源码分析</h4><p>我们可以创建流程分为3部分,回调类,advisor创建,代理类创建</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6xof16exj32080o60zy.jpg" alt="image-20200123220926562"></p><h5 id="AnnotationAwareAspectJAutoProxyCreator执行流程"><a href="#AnnotationAwareAspectJAutoProxyCreator执行流程" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator执行流程"></a>AnnotationAwareAspectJAutoProxyCreator执行流程</h5><p>入口是AbstractAutoProxyCreator</p><p>因为实现了SmartInstantiationAwareBeanPostProcessor ,所以重写了两个方法</p><h6 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="#postProcessBeforeInstantiation"></a>#postProcessBeforeInstantiation</h6><p>在AspectJAwareAdvisorAutoProxyCreator#shouldSkip方法中初始化了advisor</p><pre><code class="java">@Overrideprotected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) {   // TODO: Consider optimization by caching the list of the aspect names   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();   for (Advisor advisor : candidateAdvisors) {      if (advisor instanceof AspectJPointcutAdvisor &amp;&amp;            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {         return true;      }   }   return super.shouldSkip(beanClass, beanName);}</code></pre><p>在AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors中的调用就到了advisor的创建流程</p><h6 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="#postProcessAfterInitialization"></a>#postProcessAfterInitialization</h6><p>返回代理对象</p><pre><code class="java">    /**     * Create a proxy with the configured interceptors if the bean is     * identified as one to proxy by the subclass.     * @see #getAdvicesAndAdvisorsForBean     */    @Override    public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {        if (bean != null) {            Object cacheKey = getCacheKey(bean.getClass(), beanName);            if (!this.earlyProxyReferences.contains(cacheKey)) {                return wrapIfNecessary(bean, beanName, cacheKey);            }        }        return bean;    }  protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {     if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) {        return bean;     }     if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {        return bean;     }     if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {        this.advisedBeans.put(cacheKey, Boolean.FALSE);        return bean;     }     // Create proxy if we have advice. 如果有adive创建代理     Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);     if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.put(cacheKey, Boolean.TRUE);        Object proxy = createProxy(              bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;     }     this.advisedBeans.put(cacheKey, Boolean.FALSE);     return bean;  }</code></pre><p>​    上面的方法简单来说做了一些判断, 主要是获取advice,并创建代理</p><h5 id="Advisor创建流程"><a href="#Advisor创建流程" class="headerlink" title="Advisor创建流程"></a>Advisor创建流程</h5><p>BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors</p><pre><code class="java">/** * Look for AspectJ-annotated aspect beans in the current bean factory, * and return to a list of Spring AOP Advisors representing them. * &lt;p&gt;Creates a Spring Advisor for each AspectJ advice method. * @return the list of {@link org.springframework.aop.Advisor} beans * @see #isEligibleBean */public List&lt;Advisor&gt; buildAspectJAdvisors() {   List&lt;String&gt; aspectNames = this.aspectBeanNames;   //初次创建aspectNames为null,否则从缓存中获取   if (aspectNames == null) {     //double check      synchronized (this) {         aspectNames = this.aspectBeanNames;         if (aspectNames == null) {            List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();            aspectNames = new ArrayList&lt;&gt;();            String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(                  this.beanFactory, Object.class, true, false);            //遍历查找所有bean            for (String beanName : beanNames) {               if (!isEligibleBean(beanName)) {                  continue;               }               // We must be careful not to instantiate beans eagerly as in this case they               // would be cached by the Spring container but would not have been weaved.               Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);               if (beanType == null) {                  continue;               }               //是否是Aspect的类(带了@Aspect注解)               if (this.advisorFactory.isAspect(beanType)) {                  aspectNames.add(beanName);                  AspectMetadata amd = new AspectMetadata(beanType, beanName);                  if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {                     MetadataAwareAspectInstanceFactory factory =                           new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);                    //获取advice的包装类advisors,并放置在缓存中                     List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);                     if (this.beanFactory.isSingleton(beanName)) {                        this.advisorsCache.put(beanName, classAdvisors);                     }else {                        this.aspectFactoryCache.put(beanName, factory);                     }                     advisors.addAll(classAdvisors);                  }                  else {                     // Per target or per this.                     if (this.beanFactory.isSingleton(beanName)) {                        throw new IllegalArgumentException(&quot;Bean with name &#39;&quot; + beanName +                              &quot;&#39; is a singleton, but aspect instantiation model is not singleton&quot;);                     }                     MetadataAwareAspectInstanceFactory factory =                           new PrototypeAspectInstanceFactory(this.beanFactory, beanName);                     this.aspectFactoryCache.put(beanName, factory);                     advisors.addAll(this.advisorFactory.getAdvisors(factory));                  }               }            }            this.aspectBeanNames = aspectNames;            return advisors;         }      }   }  //从缓存中获取  ...   return advisors;}</code></pre><p>遍历beanFactory,找出切面(Aspect)类,获取通知(advice)的包装类(advisors)</p><p>ReflectiveAspectJAdvisorFactory#getAdvisors</p><pre><code class="java">  public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {     Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();     String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();     validate(aspectClass);     // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator     // so that it will only instantiate once.     MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =           new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);     List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();     for (Method method : getAdvisorMethods(aspectClass)) {        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);        if (advisor != null) { advisors.add(advisor); }     }     // If it&#39;s a per target aspect, emit the dummy instantiating aspect.     ...     // Find introduction fields.     ...     return advisors;  }    private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) {        final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();        ReflectionUtils.doWithMethods(aspectClass, method -&gt; {            // Exclude pointcuts            if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {                methods.add(method);            }        });        methods.sort(METHOD_COMPARATOR);        return methods;    }    @Override    @Nullable    public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,            int declarationOrderInAspect, String aspectName) {        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());        AspectJExpressionPointcut expressionPointcut = getPointcut(                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());        if (expressionPointcut == null) {            return null;        }        return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,                this, aspectInstanceFactory, declarationOrderInAspect, aspectName);    }</code></pre><p>​    所以我们可以知道Advisor 对应的类为InstantiationModelAwarePointcutAdvisorImpl</p><p>另外, 这里会有个细节就是顺序(影响后续的调用链chain的执行顺序),在getAdvisorMethods中</p><pre><code class="java">private static final Comparator&lt;Method&gt; METHOD_COMPARATOR;static {   Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(         new InstanceComparator&lt;&gt;(               Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),         (Converter&lt;Method, Annotation&gt;) method -&gt; {            AspectJAnnotation&lt;?&gt; annotation =               AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);            return (annotation != null ? annotation.getAnnotation() : null);         });   Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);   METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);}</code></pre><p>​    按照如下顺序 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class 排序(从小到大),而在 AbstractAdvisorAutoProxyCreator#sortAdvisors 中会对所有通知(advice) 根据Order 再次排序(从大到小)</p><h5 id="Proxy创建流程"><a href="#Proxy创建流程" class="headerlink" title="Proxy创建流程"></a>Proxy创建流程</h5><p>在DefaultAopProxyFactory中</p><pre><code class="java">package org.springframework.aop.framework;import java.io.Serializable;import java.lang.reflect.Proxy;import org.springframework.aop.SpringProxy;/** * Default {@link AopProxyFactory} implementation, creating either a CGLIB proxy * or a JDK dynamic proxy. * * &lt;p&gt;Creates a CGLIB proxy if one the following is true for a given * {@link AdvisedSupport} instance: * &lt;ul&gt; * &lt;li&gt;the {@code optimize} flag is set * &lt;li&gt;the {@code proxyTargetClass} flag is set * &lt;li&gt;no proxy interfaces have been specified * &lt;/ul&gt; * * &lt;p&gt;In general, specify {@code proxyTargetClass} to enforce a CGLIB proxy, * or specify one or more interfaces to use a JDK dynamic proxy. * * @author Rod Johnson * @author Juergen Hoeller * @since 12.03.2004 * @see AdvisedSupport#setOptimize * @see AdvisedSupport#setProxyTargetClass * @see AdvisedSupport#setInterfaces */@SuppressWarnings(&quot;serial&quot;)public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {   @Override   public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {      if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {         Class&lt;?&gt; targetClass = config.getTargetClass();         if (targetClass == null) {            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +                  &quot;Either an interface or a target is required for proxy creation.&quot;);         }         if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {            return new JdkDynamicAopProxy(config);         }         return new ObjenesisCglibAopProxy(config);      }      else {         return new JdkDynamicAopProxy(config);      }   }   /**    * Determine whether the supplied {@link AdvisedSupport} has only the    * {@link org.springframework.aop.SpringProxy} interface specified    * (or no proxy interfaces specified at all).    */   private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {      Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();      return (ifcs.length == 0 ||               (ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0])));   }}</code></pre><p>三种情况下使用cglib(默认使用jdk)</p><ul><li>the {@code optimize} flag is set</li><li>the {@code proxyTargetClass} flag is set</li><li>no proxy interfaces have been specified</li></ul><p>其中当targetClass 为接口或者是代理类时,使用jdk代理</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>注意这里,执行流程是按照代码分析的</p><h4 id="核心类预览-1"><a href="#核心类预览-1" class="headerlink" title="核心类预览"></a>核心类预览</h4><h5 id="JdkDynamicAopProxy类图"><a href="#JdkDynamicAopProxy类图" class="headerlink" title="JdkDynamicAopProxy类图"></a>JdkDynamicAopProxy类图</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6wu5onp8j30uk0acgmf.jpg" alt="image-20200123232546312" style="zoom:50%;"></p><h5 id="ReflectiveMethodInvocation类图"><a href="#ReflectiveMethodInvocation类图" class="headerlink" title="ReflectiveMethodInvocation类图"></a>ReflectiveMethodInvocation类图</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6wusrs3wj30n00ncq4e.jpg" alt="image-20200123232624501" style="zoom:50%;"></p><h5 id="MethodInterceptor类图"><a href="#MethodInterceptor类图" class="headerlink" title="MethodInterceptor类图"></a>MethodInterceptor类图</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6xocz27pj31im0gyq6c.jpg" alt="image-20200123233448201"></p><h4 id="时序图及源码分析-1"><a href="#时序图及源码分析-1" class="headerlink" title="时序图及源码分析"></a>时序图及源码分析</h4><p> 整个时序图流程非常简单, 首先JdkDynamicAopProxy 实现invoke,之后执行chain 调用链</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6xodbywlj314c0u0798.jpg" alt="image-20200123231701249"></p><p>JdkDynamicAopProxy 实现了InvocationHandler(代理实现需要), 重写了invoke方法</p><pre><code class="java">    /**     * Implementation of {@code InvocationHandler.invoke}.     * &lt;p&gt;Callers will see exactly the exception thrown by the target,     * unless a hook method throws an exception.     */    @Override    @Nullable    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        // Get the interception chain for this method.            List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);            // Check whether we have any advice. If we don&#39;t, we can fallback on direct            // reflective invocation of the target, and avoid creating a MethodInvocation.            if (chain.isEmpty()) {                // We can skip creating a MethodInvocation: just invoke the target directly                // Note that the final invoker must be an InvokerInterceptor so we know it does                // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);            }            else {                // We need to create a method invocation...                invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);                // Proceed to the joinpoint through the interceptor chain.                retVal = invocation.proceed();            }        //...    }</code></pre><p>​    可以发现只是简单的取出调用链,并将实际操作委派给ReflectiveMethodInvocation ,注意这里根据join PointCut,去匹配命中的方法, 找出对应的调用链</p><p><strong>ReflectiveMethodInvocation</strong></p><pre><code class="java">@Override@Nullablepublic Object proceed() throws Throwable {   // We start with an index of -1 and increment early.   if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {      return invokeJoinpoint();   }   Object interceptorOrInterceptionAdvice =         this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);   if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {      // Evaluate dynamic method matcher here: static part will already have      // been evaluated and found to match.      InterceptorAndDynamicMethodMatcher dm =            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;      Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());      if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {         return dm.interceptor.invoke(this);      }      else {         // Dynamic matching failed.         // Skip this interceptor and invoke the next in the chain.         return proceed();      }   }   else {      // It&#39;s an interceptor, so we just invoke it: The pointcut will have      // been evaluated statically before this object was constructed.      return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);   }}</code></pre><p>依次执行dvice,即切面中的各个通知, 通过反射实现方法调用,实例是通过工厂方法创建LazySingletonAspectInstanceFactoryDecorator</p><p>org.springframework.aop.interceptor.ExposeInvocationInterceptor</p><p>org.springframework.aop.aspectj.AspectJAfterThrowingAdvice</p><p>org.springframework.aop.aspectj.AspectJAfterAdvice</p><p>org.springframework.aop.aspectj.AspectJMethodBeforeAdvice</p><p>最后用反射调用方法</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h4 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h4><p>注意这里为了简单,所以只写了三个通知(advice)</p><pre><code class="java">package aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.context.annotation.EnableAspectJAutoProxy;import org.springframework.stereotype.Component;import java.util.Arrays;/** * @author zhengyumin * @description 切面demo * @date 2020-01-22 9:46 PM * EnableAspectJAutoProxy 等同于xml中 &lt;aop:aspectj-autoproxy&gt; * proxyTargetClass为true时 开启cglib(比较规范是写在一个配置类里) */@Aspect@Component@EnableAspectJAutoProxy(proxyTargetClass = false)public class AspectInterceptor {    @Pointcut(value=&quot;execution(* aop.ServerImpl.*(..))&quot;)    private void pointCut(){        //定义一个切入点 后面的通知直接引入切入点方法pointCut即可        // ServerImpl下面的所有方法    }    /**     * 前置通知（进入环绕后执行，下一步执行方法）     * @param joinPoint     */    @Before(value=&quot;pointCut()&quot;)    public void before(JoinPoint joinPoint){        System.out.println(&quot;@Before前置通知:&quot;+ Arrays.toString(joinPoint.getArgs()));    }    /**     * 异常通知（出错时执行）     * @param joinPoint     * @param ex     */    @AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;ex&quot;)    public void doAfterThrow(JoinPoint joinPoint,Throwable ex){        System.out.println(&quot;@AfterThrowing例外通知(异常通知)&quot;+Arrays.toString(joinPoint.getArgs()));        System.out.println(&quot;@AfterThrowing异常信息：&quot;+ex);    }    /**     * 后置通知(返回之前执行)     */    @After(value=&quot;pointCut()&quot;)    public void after(){        System.out.println(&quot;@After后置通知...&quot;);    }}</code></pre><h4 id="目标对象接口"><a href="#目标对象接口" class="headerlink" title="目标对象接口"></a>目标对象接口</h4><pre><code class="java">/** * @author zhengyumin * @description target Object * @date 2020-01-22 9:52 PM */public interface Server {     void doSomething();}</code></pre><h4 id="目标接口实现类"><a href="#目标接口实现类" class="headerlink" title="目标接口实现类"></a>目标接口实现类</h4><pre><code class="java">/** * @author zhengyumin * @description target Object Impl * @date 2020-01-22 9:53 PM */@Componentpublic class ServerImpl implements Server {    @Override    public void doSomething() {        System.out.println(&quot;do something.....&quot;);    }}</code></pre><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><pre><code class="java">package aop;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * @author zhengyumin * @description 启动器类 * @date 2020-01-14 9:25 PM * @see AspectInterceptor */public class AopStarter {    public static void main(String[] args) {        //scan package &#39;aop&#39;        AnnotationConfigApplicationContext applicationContext =                new AnnotationConfigApplicationContext(&quot;aop&quot;);        //构建代理        Server server = (Server) applicationContext.getBean(&quot;serverImpl&quot;);        //执行拦截的方法        server.doSomething();    }}</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb6xoe1vkcj32ek0nyn87.jpg" alt="image-20200123234554918">总结</h2><p> 通过以上分析,我们知道了Aop的实现是通过代理的方式实现的,这里我们分为两部分讨论</p><p>一是代理类的创建</p><p>​    代理类的创建是通过BeanPostProcess(具体子类)的回调实现的,主要是从BeanFactory中找出切面(Aspect)类,并获取类中的通知(advice), 根据配置、目标类(是否接口、代理类)决定代理方式</p><p>二是代理类执行(我们以jdk代理的分析)</p><p>​    执行主要是实现了InvocationHandler,并按顺序执行chain调用链(advice),最后执行方法本身(join point)</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-ApplicationContext</title>
      <link href="/2020/01/16/Spring-ApplicationContext/"/>
      <url>/2020/01/16/Spring-ApplicationContext/</url>
      
        <content type="html"><![CDATA[<p>spring源码版本 5.1.5.RELEASE</p><p>ApplicationContext</p><ul><li>ApplicationContext和BeanFactory的关系?</li><li>Spring 中 ApplicationContext是怎么启动? 具体子类?</li><li>Spring web容器和Spring容器的关系?</li><li>SpringBoot中 ApplicationContext是怎么启动? 具体子类?</li></ul><p><strong>基础容器接口</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8wofkgu7j31je0redjh.jpg" alt="image-20200115153732296"></p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>​    先来看看ApplicationContext接口的定义</p><pre><code class="java">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,      MessageSource, ApplicationEventPublisher, ResourcePatternResolver {     ...}</code></pre><p>​    ApplicationContext和BeanFactory的关系是? 从下面的接口定义中,似乎就是简单的继承,除了BeanFactory相关的接口 还新增了</p><ul><li>ResourceLoader (资源加载)、 EnvironmentCapable   (统称为资源管理)</li><li>ApplicationEventPublisher (事件发布)</li><li>MessageSource(国际化)</li></ul><h3 id="资源管理相关"><a href="#资源管理相关" class="headerlink" title="资源管理相关"></a>资源管理相关</h3><h4 id="Enviroment"><a href="#Enviroment" class="headerlink" title="Enviroment"></a>Enviroment</h4><p>@since 3.1 , 主要包含两部分 Profiles 和 properties </p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8ws05s1lj31je0readp.jpg" alt="image-20200116162730961"></p><p>spring容器的初始化流程</p><ul><li>AbstractApplicationContext#getEnvironment</li><li>AbstractRefreshableWebApplicationContext#createEnvironment</li><li>AbstractRefreshableWebApplicationContext#customizePropertySources</li><li>MutablePropertySources#addLast</li></ul><p>更多细节:</p><p>@see org.springframework.core.env.PropertySource</p><p>​    PropertySources</p><p>​    MutablePropertySources</p><p>@see org.springframework.core.env.PropertyResolver </p><p>​    PropertySourcesPropertyResolver 完成 <strong>占位符的解析和类型转换</strong></p><p>​    类型转换又是委托 <a href="https://www.cnblogs.com/binarylei/p/10263589.html" target="_blank" rel="noopener">ConversionService</a> 完成的</p><p>@see org.springframework.context.support.PropertySourcesPlaceholderConfigurer</p><p>​     Bean 属性的占位符替换，需要注册 <a href="https://www.cnblogs.com/binarylei/p/8428211.html" target="_blank" rel="noopener">https://www.cnblogs.com/binarylei/p/8428211.html</a></p><p>扩展可参考: <a href="https://blog.csdn.net/zollty/article/details/86137826" target="_blank" rel="noopener">https://blog.csdn.net/zollty/article/details/86137826</a></p><p>在SpringBoot中是通过ConfigFileApplicationListener,加载相关</p><pre><code class="java">private void load(String location, String name, Profile profile,      DocumentFilterFactory filterFactory, DocumentConsumer consumer) {   if (!StringUtils.hasText(name)) {      for (PropertySourceLoader loader : this.propertySourceLoaders) {         if (canLoadFileExtension(loader, location)) {            load(loader, location, profile,                  filterFactory.getDocumentFilter(profile), consumer);            return;         }      }   }   Set&lt;String&gt; processed = new HashSet&lt;&gt;();   for (PropertySourceLoader loader : this.propertySourceLoaders) {      for (String fileExtension : loader.getFileExtensions()) {         if (processed.add(fileExtension)) {            loadForFileExtension(loader, location + name, &quot;.&quot; + fileExtension,                  profile, filterFactory, consumer);         }      }   }}</code></pre><p>通过 org.springframework.boot.env.PropertySourceLoader 来加载</p><pre><code class="java">public interface PropertySourceLoader {   /**    * Returns the file extensions that the loader supports (excluding the &#39;.&#39;).    * @return the file extensions    */   String[] getFileExtensions();   /**    * Load the resource into one or more property sources. Implementations may either    * return a list containing a single source, or in the case of a multi-document format    * such as yaml a source for each document in the resource.    * @param name the root name of the property source. If multiple documents are loaded    * an additional suffix should be added to the name for each source loaded.    * @param resource the resource to load    * @return a list property sources    * @throws IOException if the source cannot be loaded    */   List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource) throws IOException;}</code></pre><p>org.springframework.boot.env.PropertiesPropertySourceLoader </p><pre><code>@Overridepublic List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource)      throws IOException {   Map&lt;String, ?&gt; properties = loadProperties(resource);   if (properties.isEmpty()) {      return Collections.emptyList();   }   return Collections         .singletonList(new OriginTrackedMapPropertySource(name, properties));}</code></pre><p>最后生成 OriginTrackedMapPropertySource</p><h4 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h4><p>Resource接口有很多实现类，而ResourceLoader接口用于实现不同的Resource加载策略，即将不同Resource实例的创建交给ResourceLoader来计算。</p><h4 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h4><p>使用Resource加载BeanDefinition</p><pre><code class="java">public interface BeanDefinitionReader {   BeanDefinitionRegistry getRegistry();   @Nullable   ResourceLoader getResourceLoader();   @Nullable   ClassLoader getBeanClassLoader();   BeanNameGenerator getBeanNameGenerator();   //加载配置   int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;   int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException;     int loadBeanDefinitions(String location) throws BeanDefinitionStoreException;   int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;}</code></pre><pre><code class="java">@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {    // 1. 创建 XmlBeanDefinitionReader    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);    // 2. 对 beanDefinitionReader 进行环境变量的设置    beanDefinitionReader.setEnvironment(this.getEnvironment());    beanDefinitionReader.setResourceLoader(this);    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));    // 3. 对 beanDefinitionReader 进行设置，默认可以覆盖    initBeanDefinitionReader(beanDefinitionReader);    loadBeanDefinitions(beanDefinitionReader);}</code></pre><h2 id="传统Spring中容器的启动流程"><a href="#传统Spring中容器的启动流程" class="headerlink" title="传统Spring中容器的启动流程"></a>传统Spring中容器的启动流程</h2><h3 id="传统Spring启动方式"><a href="#传统Spring启动方式" class="headerlink" title="传统Spring启动方式"></a>传统Spring启动方式</h3><p>​    传统的Spring容器的启动流程,  是依托于Servlet容器 , Servlet容器初始化完后,通过注册监听器, 实现回调</p><p>通常在 WEB-INF/web.xml 下会有如下配置</p><pre><code class="xml">&lt;listener&gt;   &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><p>在 org.springframework.web.context.ContextLoaderListener#contextInitialized 中</p><pre><code class="java">public void contextInitialized(ServletContextEvent event) {   this.contextLoader = createContextLoader();   if (this.contextLoader == null) {      this.contextLoader = this;   }   this.contextLoader.initWebApplicationContext(event.getServletContext());}</code></pre><h3 id="传统Spring启动流程"><a href="#传统Spring启动流程" class="headerlink" title="传统Spring启动流程"></a>传统Spring启动流程</h3><pre><code class="java">/** * Initialize Spring&#39;s web application context for the given servlet context, * using the application context provided at construction time, or creating a new one * according to the &quot;{@link #CONTEXT_CLASS_PARAM contextClass}&quot; and * &quot;{@link #CONFIG_LOCATION_PARAM contextConfigLocation}&quot; context-params. * @param servletContext current servlet context * @return the new WebApplicationContext * @see #ContextLoader(WebApplicationContext) * @see #CONTEXT_CLASS_PARAM * @see #CONFIG_LOCATION_PARAM */public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {      //重复初始化检查      if (servletContext.getAttribute(         WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {      throw new IllegalStateException(            &quot;Cannot initialize context because there is already a root application context present - check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);   }   Log logger = LogFactory.getLog(ContextLoader.class);   long startTime = System.currentTimeMillis();   try {      // Store context in local instance variable, to guarantee that      // it is available on ServletContext shutdown.      //创建容器      if (this.context == null) {         this.context = createWebApplicationContext(servletContext);      }      if (this.context instanceof ConfigurableWebApplicationContext) {         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;         if (!cwac.isActive()) {            // The context has not yet been refreshed -&gt; provide services such as            // setting the parent context, setting the application context id, etc            if (cwac.getParent() == null) {               // The context instance was injected without an explicit parent -&gt;               // determine parent for root web application context, if any.               ApplicationContext parent = loadParentContext(servletContext);               cwac.setParent(parent);            }           //refresh操作            configureAndRefreshWebApplicationContext(cwac, servletContext);         }      }      servletContext.setAttribute(WebApplicationContext.                                  ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);      ClassLoader ccl = Thread.currentThread().getContextClassLoader();      if (ccl == ContextLoader.class.getClassLoader()) {         currentContext = this.context;      }      else if (ccl != null) {         currentContextPerThread.put(ccl, this.context);      }      return this.context;   }   catch (RuntimeException ex) {      logger.error(&quot;Context initialization failed&quot;, ex);      servletContext.setAttribute(WebApplicationContext.                                  ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);      throw ex;   }   catch (Error err) {      logger.error(&quot;Context initialization failed&quot;, err);      servletContext.setAttribute(WebApplicationContext.                                  ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);      throw err;   }}</code></pre><h4 id="ApplicationContext子类型"><a href="#ApplicationContext子类型" class="headerlink" title="ApplicationContext子类型"></a>ApplicationContext子类型</h4><p>➡️ContextLoader#createWebApplicationContext(javax.servlet.ServletContext)</p><p>​        ➡️ ContextLoader#determineContextClass</p><p>​                ➡️ defaultStrategies.getProperty(WebApplicationContext.class.getName());</p><p>其中defaultStrategies的值在static中初始化了,DEFAULT_STRATEGIES_PATH的定义为ContextLoader.properties</p><pre><code class="java">static {   // Load default strategy implementations from properties file.   // This is currently strictly internal and not meant to be customized   // by application developers.   try {      ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);      defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);   }   catch (IOException ex) {      throw new IllegalStateException(&quot;Could not load &#39;ContextLoader.properties&#39;: &quot; + ex.getMessage());   }}</code></pre><p>在org/springframework/web/context/ContextLoader.properties路径下</p><pre><code class="properties"># Default WebApplicationContext implementation class for ContextLoader.# Used as fallback when no explicit context implementation has been specified as context-param.# Not meant to be customized by application developers.org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext</code></pre><p>所以我们的子类型就是XmlWebApplicationContext</p><h4 id="XmlWebApplicationContext相关类分析"><a href="#XmlWebApplicationContext相关类分析" class="headerlink" title="XmlWebApplicationContext相关类分析"></a>XmlWebApplicationContext相关类分析</h4><p>在XmlWebApplicationContext的doc中</p><pre><code class="java">/* @see #setNamespace* @see #setConfigLocations* @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader* @see org.springframework.web.context.ContextLoader#initWebApplicationContext* @see org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext*/</code></pre><h5 id="setConfigLocations"><a href="#setConfigLocations" class="headerlink" title="setConfigLocations"></a>setConfigLocations</h5><p>setConfigLocations 在web.xml中配置 , 用于获取目录</p><pre><code class="xml">&lt;!--Spring --&gt;&lt;context-param&gt;   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;   &lt;param-value&gt;      classpath*:/config-spring/spring-*.xml   &lt;/param-value&gt;&lt;/context-param&gt;</code></pre><h5 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h5><pre><code class="java">@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {   // Create a new XmlBeanDefinitionReader for the given BeanFactory.   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);   // Configure the bean definition reader with this context&#39;s   // resource loading environment.   beanDefinitionReader.setEnvironment(getEnvironment());   beanDefinitionReader.setResourceLoader(this);   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));   // Allow a subclass to provide custom initialization of the reader,   // then proceed with actually loading the bean definitions.   initBeanDefinitionReader(beanDefinitionReader);   loadBeanDefinitions(beanDefinitionReader);}</code></pre><h4 id="🌟ApplicationContext启动流程"><a href="#🌟ApplicationContext启动流程" class="headerlink" title="🌟ApplicationContext启动流程"></a>🌟ApplicationContext启动流程</h4><p>关注refresh的部分,发现逻辑都在 AbstractApplicationContext</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8ws2uxhbj31k40h0djd.jpg" alt="image-20200115164804998"></p><p>org.springframework.web.context.ContextLoader#configureAndRefreshWebApplicationContext</p><p>AbstractRefreshableWebApplicationContext(ConfigurableWebApplicationContext,servletContext相关)</p><p>➡️AbstractRefreshableConfigApplicationContext(setConfigLocation)</p><p>​        ➡️AbstractRefreshableApplicationContext ( loadBeanDefinitions、refreshBeanFactory)</p><p>​                ➡️AbstractApplicationContext</p><pre><code class="java">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {   if (ObjectUtils.identityToString(wac).equals(wac.getId())) {      // The application context id is still set to its original default value      // -&gt; assign a more useful id based on available information      String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);      if (idParam != null) {         wac.setId(idParam);      }      else {         // Generate default id...         wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +               ObjectUtils.getDisplayString(sc.getContextPath()));      }   }   wac.setServletContext(sc);   String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);   if (configLocationParam != null) {      wac.setConfigLocation(configLocationParam);   }   // The wac environment&#39;s #initPropertySources will be called in any case when the context   // is refreshed; do it eagerly here to ensure servlet property sources are in place for   // use in any post-processing or initialization that occurs below prior to #refresh   ConfigurableEnvironment env = wac.getEnvironment();   if (env instanceof ConfigurableWebEnvironment) {      ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);   }   customizeContext(sc, wac);  //刷新   wac.refresh();}</code></pre><p>refresh的定义在 org.springframework.context.ConfigurableApplicationContext#refresh</p><p>实现在org.springframework.context.support.AbstractApplicationContext#refresh</p><pre><code class="java">@Overridepublic void refresh() throws BeansException, IllegalStateException {   synchronized (this.startupShutdownMonitor) {      // Prepare this context for refreshing.      prepareRefresh();      // Tell the subclass to refresh the internal bean factory.      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      // Prepare the bean factory for use in this context.      prepareBeanFactory(beanFactory);      try {         // Allows post-processing of the bean factory in context subclasses.         postProcessBeanFactory(beanFactory);         // Invoke factory processors registered as beans in the context.         invokeBeanFactoryPostProcessors(beanFactory);         // Register bean processors that intercept bean creation.         registerBeanPostProcessors(beanFactory);         // Initialize message source for this context.         initMessageSource();         // Initialize event multicaster for this context.         initApplicationEventMulticaster();         // Initialize other special beans in specific context subclasses.         onRefresh();         // Check for listener beans and register them.         registerListeners();         // Instantiate all remaining (non-lazy-init) singletons.         finishBeanFactoryInitialization(beanFactory);         // Last step: publish corresponding event.         finishRefresh();      }      catch (BeansException ex) {         // Destroy already created singletons to avoid dangling resources.         destroyBeans();         // Reset &#39;active&#39; flag.         cancelRefresh(ex);         // Propagate exception to caller.         throw ex;      }      finally {         // Reset common introspection caches in Spring&#39;s core, since we         // might not ever need metadata for singleton beans anymore...         resetCommonCaches();      }   }}</code></pre><h5 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h5><p>刷新并获取beanFactory, 这里只是实例化</p><pre><code class="java">/** * Tell the subclass to refresh the internal bean factory. * @return the fresh BeanFactory instance * @see #refreshBeanFactory() * @see #getBeanFactory() */protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {   refreshBeanFactory();   return getBeanFactory();}</code></pre><h6 id="refreshBeanFactory"><a href="#refreshBeanFactory" class="headerlink" title="refreshBeanFactory"></a>refreshBeanFactory</h6><p>org.springframework.context.support.AbstractApplicationContext#refreshBeanFactory</p><p>实现org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</p><pre><code class="java">/** * This implementation performs an actual refresh of this context&#39;s underlying * bean factory, shutting down the previous bean factory (if any) and * initializing a fresh bean factory for the next phase of the context&#39;s lifecycle. */@Overrideprotected final void refreshBeanFactory() throws BeansException {   if (hasBeanFactory()) {      destroyBeans();      closeBeanFactory();   }   try {      DefaultListableBeanFactory beanFactory = createBeanFactory();      beanFactory.setSerializationId(getId());      customizeBeanFactory(beanFactory);      loadBeanDefinitions(beanFactory);      synchronized (this.beanFactoryMonitor) {         this.beanFactory = beanFactory;      }   }   catch (IOException ex) {      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);   }}</code></pre><p>所谓的refresh就是销毁bean close ,再重新创建和加载 (注意手动注册的bean 再refresh后,不会存在)</p><h6 id="getBeanFactory"><a href="#getBeanFactory" class="headerlink" title="getBeanFactory"></a>getBeanFactory</h6><p>org.springframework.context.support.AbstractApplicationContext#getBeanFactory</p><pre><code class="java">public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {      /** Bean factory for this context. */      @Nullable      private DefaultListableBeanFactory beanFactory;      @Override      public final ConfigurableListableBeanFactory getBeanFactory() {         synchronized (this.beanFactoryMonitor) {            if (this.beanFactory == null) {               throw new IllegalStateException(&quot;BeanFactory not initialized or already closed - &quot; +                     &quot;call &#39;refresh&#39; before accessing beans via the ApplicationContext&quot;);            }            return this.beanFactory;         }      }}</code></pre><p>可以发现ApplicationContext和BeanFactory是组合的方式, 把BeanFactory相关的操作都委派给beanFactory</p><h5 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h5><p>初始化BeanFactory, 配置相关回调(Aware), 内建依赖, 注册相关监听器,环境信息</p><pre><code class="java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {   // Tell the internal bean factory to use the context&#39;s class loader etc.   beanFactory.setBeanClassLoader(getClassLoader());   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));   // Configure the bean factory with context callbacks.   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);   // BeanFactory interface not registered as resolvable type in a plain factory.   // MessageSource registered (and found for autowiring) as a bean.   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);   beanFactory.registerResolvableDependency(ResourceLoader.class, this);   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);   beanFactory.registerResolvableDependency(ApplicationContext.class, this);   // Register early post-processor for detecting inner beans as ApplicationListeners.   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));   // Detect a LoadTimeWeaver and prepare for weaving, if found.   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));      // Set a temporary ClassLoader for type matching.      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));   }   // Register default environment beans.   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());   }   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());   }   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());   }}</code></pre><p>属性相关 org.springframework.beans.PropertyEditorRegistrySupport#createDefaultEditors</p><h5 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h5><p>当前容器(application)的后置处理,  允许BeanFactory初始化后, bean实例化前的修改</p><pre><code class="java">/** * Modify the application context&#39;s internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {}</code></pre><h5 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h5><p>注册并调用BeanFactoryPostProcessor</p><pre><code>protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));   }}</code></pre><p>具体细节见: org.springframework.context.support.PostProcessorRegistrationDelegate#</p><p>invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</p><h5 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h5><p>注册BeanPostProcess</p><pre><code class="java">public static void registerBeanPostProcessors(      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);   // Register BeanPostProcessorChecker that logs an info message when   // a bean is created during BeanPostProcessor instantiation, i.e. when   // a bean is not eligible for getting processed by all BeanPostProcessors.   int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;   beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));   // Separate between BeanPostProcessors that implement PriorityOrdered,   // Ordered, and the rest.   List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();   List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();   List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();   List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();   for (String ppName : postProcessorNames) {      if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);         priorityOrderedPostProcessors.add(pp);         if (pp instanceof MergedBeanDefinitionPostProcessor) {            internalPostProcessors.add(pp);         }      }      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {         orderedPostProcessorNames.add(ppName);      }      else {         nonOrderedPostProcessorNames.add(ppName);      }   }   // First, register the BeanPostProcessors that implement PriorityOrdered.   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);   // Next, register the BeanPostProcessors that implement Ordered.   List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());   for (String ppName : orderedPostProcessorNames) {      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);      orderedPostProcessors.add(pp);      if (pp instanceof MergedBeanDefinitionPostProcessor) {         internalPostProcessors.add(pp);      }   }   sortPostProcessors(orderedPostProcessors, beanFactory);   registerBeanPostProcessors(beanFactory, orderedPostProcessors);   // Now, register all regular BeanPostProcessors.   List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());   for (String ppName : nonOrderedPostProcessorNames) {      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);      nonOrderedPostProcessors.add(pp);      if (pp instanceof MergedBeanDefinitionPostProcessor) {         internalPostProcessors.add(pp);      }   }   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);   // Finally, re-register all internal BeanPostProcessors.   sortPostProcessors(internalPostProcessors, beanFactory);   registerBeanPostProcessors(beanFactory, internalPostProcessors);   // Re-register post-processor for detecting inner beans as ApplicationListeners,   // moving it to the end of the processor chain (for picking up proxies etc).   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));}</code></pre><h5 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h5><p>国际化(Initialize message source for this context.)</p><h5 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h5><p>事件播放器, 配合listener使用(Initialize event multicaster for this context.)</p><pre><code class="java">this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</code></pre><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8wrxh2gfj31ac0iimzf.jpg" alt="image-20200116102230785"></p><p>更多详情可以org.springframework.context.event.ApplicationEventMulticaster</p><p>实现细节org.springframework.context.event.SimpleApplicationEventMulticaster</p><p>#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</p><p>tips: 默认实现是同步的, 可以设置执行器实现异步</p><h5 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h5><p>模板方法 bean实例化前的操作(Initialize other special beans in specific context subclasses.) 专门留给子类初始化其它 bean 用，这是一个空的方法</p><h5 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h5><p>注册监听器(Check for listener beans and register them.)</p><pre><code class="java">/** * Add beans that implement ApplicationListener as listeners. * Doesn&#39;t affect other listeners, which can be added without being beans. */protected void registerListeners() {   // Register statically specified listeners first.   for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {      getApplicationEventMulticaster().addApplicationListener(listener);   }   // Do not initialize FactoryBeans here: We need to leave all regular beans   // uninitialized to let post-processors apply to them!   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);   for (String listenerBeanName : listenerBeanNames) {      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);   }   // Publish early application events now that we finally have a multicaster...   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;   this.earlyApplicationEvents = null;   if (earlyEventsToProcess != null) {      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {         getApplicationEventMulticaster().multicastEvent(earlyEvent);      }   }}</code></pre><p>1.注册静态添加的listener</p><p>2.注册bean中的listener</p><p>3.发布一些早期事件 (发布事件 event，如果多播器懒加载，还没有初始化则将该事件先放到 earlyApplicationEvents 容器中)</p><h5 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h5><p>实例化所有bean (Instantiate all remaining (non-lazy-init) singletons.)</p><p>更多: org.springframework.beans.factory.config.ConfigurableListableBeanFactory#preInstantiateSingletons</p><h5 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h5><p>发送相应事件 (publish corresponding event.)</p><pre><code class="java">/** * Finish the refresh of this context, invoking the LifecycleProcessor&#39;s * onRefresh() method and publishing the * {@link org.springframework.context.event.ContextRefreshedEvent}. */protected void finishRefresh() {   // Clear context-level resource caches (such as ASM metadata from scanning).   clearResourceCaches();   // Initialize lifecycle processor for this context.   initLifecycleProcessor();   // Propagate refresh to lifecycle processor first.   getLifecycleProcessor().onRefresh();   // Publish the final event.   publishEvent(new ContextRefreshedEvent(this));   // Participate in LiveBeansView MBean, if active.   LiveBeansView.registerApplicationContext(this);}</code></pre><p>1.关闭资源缓存</p><p>2.初始化生命周期处理器</p><p>3.触发生命周期处理器</p><p>4.发布容器refresh事件</p><p>5.LiveBeansView #getSnapshotAsJson()</p><p>live bean的一个snapshot</p><pre><code class="java">static void registerApplicationContext(ConfigurableApplicationContext applicationContext) {   String mbeanDomain = applicationContext.getEnvironment().getProperty(MBEAN_DOMAIN_PROPERTY_NAME);   if (mbeanDomain != null) {      synchronized (applicationContexts) {         if (applicationContexts.isEmpty()) {            try {               MBeanServer server = ManagementFactory.getPlatformMBeanServer();               applicationName = applicationContext.getApplicationName();               server.registerMBean(new LiveBeansView(),                     new ObjectName(mbeanDomain, MBEAN_APPLICATION_KEY, applicationName));            }            catch (Throwable ex) {               throw new ApplicationContextException(&quot;Failed to register LiveBeansView MBean&quot;, ex);            }         }         applicationContexts.add(applicationContext);      }   }}</code></pre><p>用console attach后</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8wrzq77qj31860u0n0y.jpg" alt="image-20200116111603497"></p><h3 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h3><p>​    当我们发起一次http请求时, 断点打在 AbstractApplicationContext#refresh 会发现又刷新了一次, </p><p>这是因为第一次刷新时spring容器(父容器), 而当第一次请求时,初始化springmvc容器 .并且刷新</p><pre><code class="java">  at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:651)  at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:602)  at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:665)  at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:521)  at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:462)  at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:136)  at javax.servlet.GenericServlet.init(GenericServlet.java:158)  at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1230)  - locked &lt;0x1bf7&gt; (a org.apache.catalina.core.StandardWrapper)  at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1174)  at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:1066)  at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:5370)  at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5668)  - locked &lt;0xc19&gt; (a org.apache.catalina.core.StandardContext)  at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)</code></pre><p>根据堆栈信息找到调用链</p><p>org.springframework.web.servlet.FrameworkServlet#initServletBean</p><p>​    org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</p><p>​            org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext</p><h2 id="SpringBoot中的启动流程"><a href="#SpringBoot中的启动流程" class="headerlink" title="SpringBoot中的启动流程"></a>SpringBoot中的启动流程</h2><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p>我们需要了解SpringBoot的启动方式SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)即可运行.无需再通过servlet容器的回调</p><pre><code class="java">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,      String[] args) {   return new SpringApplication(primarySources).run(args);}</code></pre><p>所以这里我们需要关注两部分, 构造函数,以及Run方法</p><pre><code class="java">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {   this.resourceLoader = resourceLoader;   Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);   this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));   this.webApplicationType = WebApplicationType.deduceFromClasspath();   setInitializers((Collection) getSpringFactoriesInstances(         ApplicationContextInitializer.class));   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));   this.mainApplicationClass = deduceMainApplicationClass();}</code></pre><p>从run说起</p><pre><code class="java">/** * Run the Spring application, creating and refreshing a new * {@link ApplicationContext}. * @param args the application arguments (usually passed from a Java main method) * @return a running {@link ApplicationContext} */public ConfigurableApplicationContext run(String... args) {   StopWatch stopWatch = new StopWatch();   stopWatch.start();   ConfigurableApplicationContext context = null;   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();   configureHeadlessProperty();   SpringApplicationRunListeners listeners = getRunListeners(args);   listeners.starting();   try {      ApplicationArguments applicationArguments = new DefaultApplicationArguments(            args);      ConfigurableEnvironment environment = prepareEnvironment(listeners,            applicationArguments);      configureIgnoreBeanInfo(environment);      Banner printedBanner = printBanner(environment);      context = createApplicationContext();      exceptionReporters = getSpringFactoriesInstances(            SpringBootExceptionReporter.class,            new Class[] { ConfigurableApplicationContext.class }, context);      prepareContext(context, environment, listeners, applicationArguments,            printedBanner);      refreshContext(context);      afterRefresh(context, applicationArguments);      stopWatch.stop();      if (this.logStartupInfo) {         new StartupInfoLogger(this.mainApplicationClass)               .logStarted(getApplicationLog(), stopWatch);      }      listeners.started(context);      callRunners(context, applicationArguments);   }   catch (Throwable ex) {      handleRunFailure(context, ex, exceptionReporters, listeners);      throw new IllegalStateException(ex);   }   try {      listeners.running(context);   }   catch (Throwable ex) {      handleRunFailure(context, ex, exceptionReporters, null);      throw new IllegalStateException(ex);   }   return context;}</code></pre><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>按照SpringApplicationRunListeners中的定义,可以稍微简单的分下步骤</p><ol><li>listeners.starting();</li><li>listeners.environmentPrepared(environment);</li><li>listeners.contextPrepared(context);</li><li>listeners.contextLoaded(context);</li><li>listeners.started(context);</li><li>listeners.running(context); </li></ol><p>运行失败的情况 会调用listeners.failed(context, exception);</p><h3 id="server容器的启动方式"><a href="#server容器的启动方式" class="headerlink" title="server容器的启动方式"></a>server容器的启动方式</h3><p>根据之前的分析,我们知道之前的传统spring的启动是通过servlet回调, 也就是先启动tomcat. </p><p>​    server容器 -&gt; Spring容器</p><p>SpringBoot中是自主启动 , 启动流程是 </p><p>​    SpringBoot应用 -&gt; server容器</p><h4 id="启动方式-1"><a href="#启动方式-1" class="headerlink" title="启动方式"></a>启动方式</h4><p>在分析Application的启动流程中 AbstractApplicationContext中留了个#onRefresh的方法, </p><p>而在其子类中ServletWebServerApplicationContext重写了onRefresh的方法</p><pre><code class="java">@Overrideprotected void onRefresh() {   super.onRefresh();   try {      createWebServer();   }   catch (Throwable ex) {      throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);   }}</code></pre><p>在createWebServer中</p><pre><code class="java">private void createWebServer() {   WebServer webServer = this.webServer;   ServletContext servletContext = getServletContext();   if (webServer == null &amp;&amp; servletContext == null) {      ServletWebServerFactory factory = getWebServerFactory();      this.webServer = factory.getWebServer(getSelfInitializer());   }   else if (servletContext != null) {      try {         getSelfInitializer().onStartup(servletContext);      }      catch (ServletException ex) {         throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;,               ex);      }   }   initPropertySources();}</code></pre><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>org.springframework.boot.web.servlet.server.ServletWebServerFactory</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8wrz9dipj31n20oeadd.jpg" alt="image-20200116155347978"></p><h4 id="Reactive"><a href="#Reactive" class="headerlink" title="Reactive"></a>Reactive</h4><p>org.springframework.boot.web.reactive.server.ReactiveWebServerFactory</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8wrysp1qj326o0nu784.jpg" alt="image-20200116155728319"></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> applicationContext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-BeanFactory</title>
      <link href="/2019/12/05/spring-BeanFactory/"/>
      <url>/2019/12/05/spring-BeanFactory/</url>
      
        <content type="html"><![CDATA[<p>今天来看看BeanFactory </p><ul><li><p>子接口都有哪些? 职责分别是哪些?</p></li><li><p>getBean 方法?Bean是怎么加载进来的?</p></li><li><p>BeanDefined的创建过程 ?BeanDefined的理解?</p></li><li><p>容器启动流程?</p></li></ul><p><strong>基础容器接口</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9m6s4c8c5j31c00hidhx.jpg" alt="image-20191205215235310"></p><p><strong>IOC时序图</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8ma8csfvj32ga0pk7bm.jpg" alt="image-20200125105144265"></p><p><strong>DI 时序图</strong></p><p><img src="/Users/zhengyumin/Library/Application Support/typora-user-images/image-20200125104717425.png" alt="image-20200125104717425"></p><h2 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h2><h3 id="HierarchicalBeanFactory"><a href="#HierarchicalBeanFactory" class="headerlink" title="HierarchicalBeanFactory"></a>HierarchicalBeanFactory</h3><p>新增继承关系的容器</p><pre><code class="java">public interface HierarchicalBeanFactory extends BeanFactory {   /**    * Return the parent bean factory, or {@code null} if there is none.    */   @Nullable   BeanFactory getParentBeanFactory();   /**    * Return whether the local bean factory contains a bean of the given name,    * ignoring beans defined in ancestor contexts.    * &lt;p&gt;This is an alternative to {@code containsBean}, ignoring a bean    * of the given name from an ancestor bean factory.    * @param name the name of the bean to query    * @return whether a bean with the given name is defined in the local factory    * @see BeanFactory#containsBean    */   boolean containsLocalBean(String name);}</code></pre><h3 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h3><p>扩展BeanFactory接口,提供所有bean 实例的枚举,不再需要客户端通过一个个bean name查找.BeanFactory实现类预加载bean定义(如通过实现xml的工厂)需要实现这个接口.</p><p>如果一样实现了HierarchicalBeanFactory,返回值不会考虑父类BeanFactory,只考虑当前factory定义的类.当然也可以使用BeanFactoryUtils辅助类来查找祖先工厂中的类.</p><p>这个接口中的方法只会考虑本factory定义的bean.这些方法会忽略ConfigurableBeanFactory的registerSingleton注册的单例bean,getBeanNamesOfType和getBeansOfType是例外,一样会考虑手动注册的单例.当然BeanFactory的getBean一样可以透明访问这些特殊bean.当然在典型情况下,所有的bean都是由external bean定义,所以应用不需要顾虑这些差别.</p><p>注意:getBeanDefinitionCount和containsBeanDefinition的实现方法因为效率比较低,并不是供频繁调用的.</p><p>来源:  <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/ListableBeanFactory.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/ListableBeanFactory.html</a> </p><pre><code class="java">public interface ListableBeanFactory extends BeanFactory {   boolean containsBeanDefinition(String beanName);   int getBeanDefinitionCount();   String[] getBeanDefinitionNames();   String[] getBeanNamesForType(ResolvableType type);   String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type);   String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit);   &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; type) throws BeansException;   &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; type, boolean includeNonSingletons, boolean allowEagerInit)         throws BeansException;   String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);   Map&lt;String, Object&gt; getBeansWithAnnotation(Class&lt;? extends Annotation&gt; annotationType) throws BeansException;   @Nullable   &lt;A extends Annotation&gt; A findAnnotationOnBean(String beanName, Class&lt;A&gt; annotationType)         throws NoSuchBeanDefinitionException;}</code></pre><h3 id="AutowireCapableBeanFactory"><a href="#AutowireCapableBeanFactory" class="headerlink" title="AutowireCapableBeanFactory"></a>AutowireCapableBeanFactory</h3><p>新增了生命周期的管理、依赖能力, 其他框架的集成代码可以利用此接口来连接和填充Spring无法控制其生命周期的现有bean实例。</p><p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/AutowireCapableBeanFactory.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/AutowireCapableBeanFactory.html</a></p><pre><code class="java">public interface AutowireCapableBeanFactory extends BeanFactory {    &lt;T&gt; T createBean(Class&lt;T&gt; beanClass) throws BeansException;    void autowireBean(Object existingBean) throws BeansException;    Object configureBean(Object existingBean, String beanName) throws BeansException;    Object createBean(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;    Object autowire(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;    void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)            throws BeansException;    void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;    Object initializeBean(Object existingBean, String beanName) throws BeansException;    Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)            throws BeansException;    Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)            throws BeansException;    void destroyBean(Object existingBean);    &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType) throws BeansException;    Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName) throws BeansException;    Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName,            Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException;}</code></pre><h3 id="ConfigurableBeanFactory"><a href="#ConfigurableBeanFactory" class="headerlink" title="ConfigurableBeanFactory"></a>ConfigurableBeanFactory</h3><p>主要用于配置 BeanFactory,(scope、classLoader、beanPostProcess) 这个接口里面定义的方法通常都是供框架内部使用的, 不适用于通常的应用程序, 源码如下</p><pre><code class="java">public interface ConfigurableBeanFactory extends HierarchicalBeanFactory,                                                 SingletonBeanRegistry {    String SCOPE_SINGLETON = &quot;singleton&quot;;    String SCOPE_PROTOTYPE = &quot;prototype&quot;;    void setParentBeanFactory(BeanFactory parentBeanFactory)      throws IllegalStateException;    // 设置 ClassLoader 的方法, 通常使用 setBeanClassLoader    void setBeanClassLoader(@Nullable ClassLoader beanClassLoader);    ClassLoader getBeanClassLoader();    void setTempClassLoader(@Nullable ClassLoader tempClassLoader);    ClassLoader getTempClassLoader();    // 是否缓存 bean 的源数据, 默认为 true    void setCacheBeanMetadata(boolean cacheBeanMetadata);    boolean isCacheBeanMetadata();    // 设置 SPEL 表达式解析器    void setBeanExpressionResolver(@Nullable BeanExpressionResolver resolver);    BeanExpressionResolver getBeanExpressionResolver();    void setConversionService(@Nullable ConversionService conversionService);    ConversionService getConversionService();    // 设置属性编辑器    void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar);    void registerCustomEditor(Class&lt;?&gt; requiredType,                              Class&lt;? extends PropertyEditor&gt; propertyEditorClass);    void copyRegisteredEditorsTo(PropertyEditorRegistry registry);    // 设置类型转换器    void setTypeConverter(TypeConverter typeConverter);    TypeConverter getTypeConverter();    void addEmbeddedValueResolver(StringValueResolver valueResolver);    boolean hasEmbeddedValueResolver();    String resolveEmbeddedValue(String value);    // 设置 bean 后置处理器    void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);    int getBeanPostProcessorCount();    // 注册 scope    void registerScope(String scopeName, Scope scope);    String[] getRegisteredScopeNames();    Scope getRegisteredScope(String scopeName);    AccessControlContext getAccessControlContext();    void copyConfigurationFrom(ConfigurableBeanFactory otherFactory);    // 为 bean 设置添加别名    void registerAlias(String beanName, String alias)      throws BeanDefinitionStoreException;    void resolveAliases(StringValueResolver valueResolver);    BeanDefinition getMergedBeanDefinition(String beanName)      throws NoSuchBeanDefinitionException;    boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException;    void setCurrentlyInCreation(String beanName, boolean inCreation);    boolean isCurrentlyInCreation(String beanName);    void registerDependentBean(String beanName, String dependentBeanName);    String[] getDependentBeans(String beanName);    String[] getDependenciesForBean(String beanName);    void destroyBean(String beanName, Object beanInstance);    void destroyScopedBean(String beanName);    void destroySingletons();}</code></pre><h3 id="ConfigurableListableBeanFactory"><a href="#ConfigurableListableBeanFactory" class="headerlink" title="ConfigurableListableBeanFactory"></a>ConfigurableListableBeanFactory</h3><p>​    大多数可列出的bean工厂都将实现配置接口。 除了ConfigurableBeanFactory，它还提供了用于分析和修改Bean定义以及预先实例化单例的工具。<br>​    BeanFactory的此子接口不能在常规应用程序代码中使用：在典型使用情况下，请坚持使用BeanFactory或ListableBeanFactory。 即使需要访问bean工厂配置方法，该接口也仅允许框架内部即插即用。</p><p>注意: ApplicationContext中使用的就是ConfigurableListableBeanFactory</p><pre><code class="java">public interface ConfigurableListableBeanFactory      extends ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory {        void ignoreDependencyType(Class&lt;?&gt; type);            void ignoreDependencyInterface(Class&lt;?&gt; ifc);            void registerResolvableDependency(Class&lt;?&gt; dependencyType, @Nullable Object autowiredValue);        boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)            throws NoSuchBeanDefinitionException;        Iterator&lt;String&gt; getBeanNamesIterator();        BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;        void clearMetadataCache();        void freezeConfiguration();        boolean isConfigurationFrozen();        void preInstantiateSingletons() throws BeansException;}</code></pre><h2 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h2><p>DefaultListableBeanFactory</p><pre><code class="java">public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory      implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {  ...}</code></pre><p>直接分析源码, 没什么目标会很迷茫 </p><p>所以我们带着各种问题来看看spring的源码</p><ul><li><p>spring是怎么解决循环依赖问题?</p></li><li><p>getBean 方法?Bean是怎么加载进来的?</p></li><li><p>BeanDefined的创建过程 ?BeanDefined的理解?</p></li><li><p>容器启动流程?</p></li></ul><p>先来看看继承体系</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9m63mhdewj31vs0tyjxb.jpg" alt="image-20191205172006709"></p><p>对以上类简单介绍下:</p><p>FactoryBeanRegistrySupport 支持了类实例、别名、FactoryBean的注册、循环依赖的解决</p><p>*BeanFactory : 实现各种BeanFactory接口</p><p>BeanDefinitionRegistry :BeanDefintion注册</p><h3 id="DefaultSingletonBeanRegistry"><a href="#DefaultSingletonBeanRegistry" class="headerlink" title="DefaultSingletonBeanRegistry"></a>DefaultSingletonBeanRegistry</h3><pre><code class="java">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {/** Cache of singleton objects: bean name to bean instance. */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);/** Cache of singleton factories: bean name to ObjectFactory. */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);/** Cache of early singleton objects: bean name to bean instance. */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);/** Set of registered singletons, containing the bean names in registration order. */private final Set&lt;String&gt; registeredSingletons = new LinkedHashSet&lt;&gt;(256);/** Names of beans that are currently in creation. */private final Set&lt;String&gt; singletonsCurrentlyInCreation =      Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));/** Names of beans currently excluded from in creation checks. */private final Set&lt;String&gt; inCreationCheckExclusions =            Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));}</code></pre><p>(仔细看看上面各种类型,spring是怎么处理并发问题的)</p><p>这里是3个map用于存放singleton bean</p><ul><li>singletonObjects :存放已经初始化完成的beanName 和bean的映射缓存(注意线程安全)</li><li>earlySingletonObjects : 提前暴露的beanName 和bean的映射缓存</li><li>singletonFactories: 存放beanName 和ObjectFactory的映射缓存</li></ul><p>同时三个set</p><ul><li>registeredSingletons :用于存放已经注册的bean</li><li>singletonsCurrentlyInCreation: 当前正在创建的bean</li><li>inCreationCheckExclusions : 不需要检查是否正常创建中的bean</li></ul><p>而我们的关键是看看earlySingletonObjects这个map</p><p>什么样的对象可以放进去? </p><p>什么时候放进去?</p><p>(另外: 为什么需要singletonFactories?)</p><h4 id="earlySingletonObjects"><a href="#earlySingletonObjects" class="headerlink" title="earlySingletonObjects"></a>earlySingletonObjects</h4><p>–&gt;先看看earlySingletonObjects 是什么时候put对象进去的</p><pre><code class="java">/** * Return the (raw) singleton object registered under the given name. * &lt;p&gt;Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or {@code null} if none found */@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) {   //是否在一级缓存中,有的话直接返回   Object singletonObject = this.singletonObjects.get(beanName);  //如果不在缓存中,并且正在创建中(什么时候放进去?)   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {     //锁住singletonObjects ,解决循环依赖中等待的问题      synchronized (this.singletonObjects) {         singletonObject = this.earlySingletonObjects.get(beanName);            //不在二级缓存中,并且允许提前初始化引用         if (singletonObject == null &amp;&amp; allowEarlyReference) {            ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);            if (singletonFactory != null) {               singletonObject = singletonFactory.getObject();               //将bean提前暴露,并从移除singletonFactories(什么时候放进singletonFactories?)               this.earlySingletonObjects.put(beanName, singletonObject);               this.singletonFactories.remove(beanName);            }         }      }   }   return singletonObject;}</code></pre><p>可以发现是#getSingleton方法, 思考两个问题</p><ul><li>什么时候放进去singletonsCurrentlyInCreation?</li><li>什么时候放进singletonFactories?</li></ul><p>问题1–&gt; 在#beforeSingletonCreation方法中可以看到</p><pre><code class="java">protected void beforeSingletonCreation(String beanName) {  //是否在不需要检查的集合中,并且不在正在创建的集合中(循环依赖检查)   if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) {      throw new BeanCurrentlyInCreationException(beanName);   }}</code></pre><p>该方法在其父类中调用.</p><h4 id="singletonFactories"><a href="#singletonFactories" class="headerlink" title="singletonFactories"></a>singletonFactories</h4><p>在#addSingletonFactory中</p><pre><code class="java">/** * Add the given singleton factory for building the specified singleton * if necessary. * &lt;p&gt;To be called for eager registration of singletons, e.g. to be able to * resolve circular references. * @param beanName the name of the bean * @param singletonFactory the factory for the singleton object */protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {   Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);   synchronized (this.singletonObjects) {      if (!this.singletonObjects.containsKey(beanName)) {         this.singletonFactories.put(beanName, singletonFactory);         this.earlySingletonObjects.remove(beanName);         this.registeredSingletons.add(beanName);      }   }}</code></pre><p>问题2–&gt;可以发现registeredSingletons , singletonFactories 都在这里调用, 该方法在org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean中调用</p><h4 id="singletonObjects"><a href="#singletonObjects" class="headerlink" title="singletonObjects"></a>singletonObjects</h4><p>我们再看下主角singletonObjects 是怎么初始化的</p><pre><code class="java">/** * Add the given singleton object to the singleton cache of this factory. * &lt;p&gt;To be called for eager registration of singletons. * @param beanName the name of the bean * @param singletonObject the singleton object */protected void addSingleton(String beanName, Object singletonObject) {   synchronized (this.singletonObjects) {      this.singletonObjects.put(beanName, singletonObject);      this.singletonFactories.remove(beanName);      this.earlySingletonObjects.remove(beanName);      this.registeredSingletons.add(beanName);   }}</code></pre><p>addSingleton的调用在#registerSingleton 以及 getSingleton(String,ObjectFactory&lt;?&gt;)</p><pre><code class="java">@Overridepublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {   Assert.notNull(beanName, &quot;Bean name must not be null&quot;);   Assert.notNull(singletonObject, &quot;Singleton object must not be null&quot;);   synchronized (this.singletonObjects) {      Object oldObject = this.singletonObjects.get(beanName);      if (oldObject != null) {         throw new IllegalStateException(&quot;Could not register object [&quot; + singletonObject +               &quot;] under bean name &#39;&quot; + beanName + &quot;&#39;: there is already object [&quot; + oldObject + &quot;] bound&quot;);      }      addSingleton(beanName, singletonObject);   }}</code></pre><p>至此,DefaultSingletonBeanRegistry 的分析差不多了.</p><p>更多细节:<a href="https://www.cnblogs.com/binarylei/p/10326046.html" target="_blank" rel="noopener">https://www.cnblogs.com/binarylei/p/10326046.html</a></p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>接下来我们来看下完整的调用顺序 从BeanFactory#getBean(java.lang.Class<t>)说起</t></p><h4 id="DefaultListableBeanFactory-getBean"><a href="#DefaultListableBeanFactory-getBean" class="headerlink" title="DefaultListableBeanFactory#getBean"></a>DefaultListableBeanFactory#getBean</h4><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)@Overridepublic &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, @Nullable Object... args) throws BeansException {   Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);   if (resolved == null) {      throw new NoSuchBeanDefinitionException(requiredType);   }   return (T) resolved;}</code></pre><h4 id="DefaultListableBeanFactory-resolveBean"><a href="#DefaultListableBeanFactory-resolveBean" class="headerlink" title="DefaultListableBeanFactory#resolveBean"></a>DefaultListableBeanFactory#resolveBean</h4><pre><code class="java">@Nullableprivate &lt;T&gt; T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {    //从当前容器中获取    NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);    if (namedBean != null) {        return namedBean.getBeanInstance();    }  //如果不存在,查询父容器是否存在    BeanFactory parent = getParentBeanFactory();    if (parent instanceof DefaultListableBeanFactory) {        return ((DefaultListableBeanFactory) parent).resolveBean(requiredType, args, nonUniqueAsNull);    }    else if (parent != null) {        ObjectProvider&lt;T&gt; parentProvider = parent.getBeanProvider(requiredType);        if (args != null) {            return parentProvider.getObject(args);        }        else {            return (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());        }    }    return null;}</code></pre><h4 id="DefaultListableBeanFactory-resolveNamedBean"><a href="#DefaultListableBeanFactory-resolveNamedBean" class="headerlink" title="DefaultListableBeanFactory#resolveNamedBean"></a>DefaultListableBeanFactory#resolveNamedBean</h4><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)@Nullableprivate &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(      ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {   Assert.notNull(requiredType, &quot;Required type must not be null&quot;);   //检查所有的bean definitions. (bean definitions 时候写入? )   String[] candidateNames = getBeanNamesForType(requiredType);   //过滤处理   if (candidateNames.length &gt; 1) {      List&lt;String&gt; autowireCandidates = new ArrayList&lt;&gt;(candidateNames.length);      for (String beanName : candidateNames) {         if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {            autowireCandidates.add(beanName);         }      }      if (!autowireCandidates.isEmpty()) {         candidateNames = StringUtils.toStringArray(autowireCandidates);      }   }   if (candidateNames.length == 1) {      String beanName = candidateNames[0];      //先只关注这里 ,只有一个候选的时候      return new NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));   }   else if (candidateNames.length &gt; 1) {      Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;&gt;(candidateNames.length);      for (String beanName : candidateNames) {         if (containsSingleton(beanName) &amp;&amp; args == null) {            Object beanInstance = getBean(beanName);            candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));         }         else {            candidates.put(beanName, getType(beanName));         }      }      String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());      if (candidateName == null) {         candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());      }      if (candidateName != null) {         Object beanInstance = candidates.get(candidateName);         if (beanInstance == null || beanInstance instanceof Class) {            beanInstance = getBean(candidateName, requiredType.toClass(), args);         }         return new NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);      }      if (!nonUniqueAsNull) {         throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());      }   }   return null;}</code></pre><p>先只关注只有一个候选者的情况</p><h4 id="AbstractBeanFactory-GetBean"><a href="#AbstractBeanFactory-GetBean" class="headerlink" title="AbstractBeanFactory#GetBean"></a>AbstractBeanFactory#GetBean</h4><pre><code class="java">/** * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve * @param requiredType the required type of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @return an instance of the bean * @throws BeansException if the bean could not be created */public &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object... args)      throws BeansException {   return doGetBean(name, requiredType, args, false);}</code></pre><h4 id="AbstractBeanFactory-doGetBean"><a href="#AbstractBeanFactory-doGetBean" class="headerlink" title="==AbstractBeanFactory#doGetBean=="></a>==AbstractBeanFactory#doGetBean==</h4><pre><code class="java">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,      @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {    //beanClass Name处理    final String beanName = transformedBeanName(name);    //缓存实例    // Eagerly check singleton cache for manually registered singletons.         Object sharedInstance = getSingleton(beanName);    ...     //如果存在缓存直接调用      if (sharedInstance != null &amp;&amp; args == null) {                   bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);     }else{      //循环依赖检查      // Fail if we&#39;re already creating this bean instance:            // We&#39;re assumably within a circular reference.            if (isPrototypeCurrentlyInCreation(beanName)) {                throw new BeanCurrentlyInCreationException(beanName);            }            //父工厂检查            // Check if bean definition exists in this factory.            BeanFactory parentBeanFactory = getParentBeanFactory();      //beanDefinition处理        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);            checkMergedBeanDefinition(mbd, beanName, args);       //dependsOn处理        // Guarantee initialization of beans that the current bean depends on.            String[] dependsOn = mbd.getDependsOn();      registerDependentBean(dep, beanName);            try {                 getBean(dep);            }                ...      //根据scope创建                // Create bean instance.                if (mbd.isSingleton()) {                    sharedInstance = getSingleton(beanName, () -&gt; {                        try {                            return createBean(beanName, mbd, args);                        }                        catch (BeansException ex) {         // Explicitly remove instance from singleton cache: It might have been put there         // eagerly by the creation process, to allow for circular reference resolution.         // Also remove any beans that received a temporary reference to the bean.                            destroySingleton(beanName);                            throw ex;                        }                    });                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);                }          }}</code></pre><p>#transformedBeanName : 名字处理</p><p>#getSingleton  : 循环依赖和缓存</p><p>​    第一次调用getSingleton,这里返回 null ,因为缓存中不存在</p><p>​    第二次,调用getSingleton  DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</p><p>​    (其中调用了#beforeSingletonCreation (正在实例化的bean添加进去))</p><p>#getParentBeanFactory :  父容器查找(当前容器不存在) </p><p>#getMergedLocalBeanDefinition : beanDefinition处理,dependsOn处理</p><p>#createBean 创建bean逻辑</p><p>#getSingleton缓存bean </p><h4 id="AbstractAutowireCapableBeanFactory-createBean"><a href="#AbstractAutowireCapableBeanFactory-createBean" class="headerlink" title="AbstractAutowireCapableBeanFactory#createBean"></a>AbstractAutowireCapableBeanFactory#createBean</h4><pre><code class="java">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args){    ...        Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.      try {      //InstantiationAwareBeanPostProcessor 去创建bean             Object bean = resolveBeforeInstantiation(beanName, mbdToUse);            if (bean != null) {                return bean;            }        }        catch (Throwable ex) {            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,                    &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);        }        try {            Object beanInstance = doCreateBean(beanName, mbdToUse, args);            if (logger.isTraceEnabled()) {                logger.trace(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);            }            return beanInstance;        }        catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {            // A previously detected exception with proper bean creation context already,            // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.            throw ex;        }        catch (Throwable ex) {            throw new BeanCreationException(                    mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);        }  }</code></pre><p>tips : InstantiationAwareBeanPostProcessor 前置处理器</p><h4 id="AbstractAutowireCapableBeanFactory-doCreateBean"><a href="#AbstractAutowireCapableBeanFactory-doCreateBean" class="headerlink" title="==AbstractAutowireCapableBeanFactory#doCreateBean=="></a>==AbstractAutowireCapableBeanFactory#doCreateBean==</h4><pre><code class="java">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)      throws BeanCreationException { // 实例化 Instantiate the bean.  在内存中创建了bean 属性还没填充 //instantiation strategy :factory method, constructor autowiring, or simple instantiation.    // 默认使用cglib        instanceWrapper = createBeanInstance(beanName, mbd, args);        // 允许后置处理器来修改这个BeanDefinition        synchronized (mbd.postProcessingLock) {            if (!mbd.postProcessed) {                try {                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);                }                catch (Throwable ex) {                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,                            &quot;Post-processing of merged bean definition failed&quot;, ex);                }                mbd.postProcessed = true;            }        }         //提前暴露解决循环依赖问题        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;                isSingletonCurrentlyInCreation(beanName));        if (earlySingletonExposure) {            if (logger.isTraceEnabled()) {                logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +                        &quot;&#39; to allow for resolving potential circular references&quot;);            }             addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));        }     // 初始化bean实例。   //通过beanDefinition 填充BeanWrapper 属性值        populateBean(beanName, mbd, instanceWrapper);   //进行一些初始化方法的调用，比如afterPropertiesSet等等。        exposedObject = initializeBean(beanName, exposedObject, mbd);      //提前暴露的类检查,防止非代理对象被提前暴露注入,导致两个bean不一致        if (earlySingletonExposure) {            Object earlySingletonReference = getSingleton(beanName, false);            if (earlySingletonReference != null) {                if (exposedObject == bean) {                    exposedObject = earlySingletonReference;                }                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {                    String[] dependentBeans = getDependentBeans(beanName);                    Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);                    for (String dependentBean : dependentBeans) {                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {                            actualDependentBeans.add(dependentBean);                        }                    }                    if (!actualDependentBeans.isEmpty()) {                        throw new BeanCurrentlyInCreationException(beanName,                                &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +                                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                                &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +                                &quot;wrapped. This means that said other beans do not use the final version of the &quot; +                                &quot;bean. This is often the result of over-eager type matching - consider using &quot; +                                &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);                    }                }            }        }       ...   // Register bean as disposable.        try {            registerDisposableBeanIfNecessary(beanName, bean, mbd);        }}</code></pre><p>这里调用了addSingletonFactory</p><p>在 bean 初始化完成还后还需要进行依赖的检查，这时因为提前暴露的这个 bean(即使用工厂方法或构造方法创建出来的对象) initializeBean 还可以进行增强(例如aop代理)，这样这两个 bean 就不是同一个了。Spring 默认是不允许这种情况发生的。</p><h4 id="AbstractAutowireCapableBeanFactory-createBeanInstance"><a href="#AbstractAutowireCapableBeanFactory-createBeanInstance" class="headerlink" title="AbstractAutowireCapableBeanFactory#createBeanInstance"></a>AbstractAutowireCapableBeanFactory#createBeanInstance</h4><p>实例化</p><p>方式 根据工厂方法、构造函数、默认方式 </p><p>方法:CGLIB/JDK</p><p>@see #instantiateUsingFactoryMethod<br>@see #autowireConstructor<br>@see #instantiateBean</p><h4 id="AbstractAutowireCapableBeanFactory-populateBean"><a href="#AbstractAutowireCapableBeanFactory-populateBean" class="headerlink" title="AbstractAutowireCapableBeanFactory#populateBean"></a>AbstractAutowireCapableBeanFactory#populateBean</h4><p>ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)</p><p>autowireByName(beanName, mbd, bw, newPvs) or autowireByType(beanName, mbd, bw, newPvs);</p><p>pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</p><p>applyPropertyValues(beanName, mbd, bw, pvs);</p><h4 id="AbstractAutowireCapableBeanFactory-initializeBean"><a href="#AbstractAutowireCapableBeanFactory-initializeBean" class="headerlink" title="AbstractAutowireCapableBeanFactory#initializeBean"></a>AbstractAutowireCapableBeanFactory#initializeBean</h4><p>invokeAwareMethods</p><ul><li>@see BeanNameAware</li><li>@see BeanClassLoaderAware</li><li>@see BeanFactoryAware</li></ul><p>@see #applyBeanPostProcessorsBeforeInitialization</p><p>@see #invokeInitMethods</p><p>@see #applyBeanPostProcessorsAfterInitialization</p><p>至此getBean调用结束,可以通过调试模拟下</p><p>代码:</p><p>BeanClass 用于被加载的class</p><pre><code class="java">public class BeanClass {    public BeanClass() {        System.out.println(&quot;init...&quot;);    }}</code></pre><p>BeanFactory引导类</p><pre><code class="java">public class ContainerStarter {    public static void main(String[] args) {        XmlBeanFactory xmlBeanFactory = new XmlBeanFactory(                new ClassPathResource(&quot;application.xml&quot;));        //获取Bean 实例        xmlBeanFactory.getBean(BeanClass.class);    }}</code></pre><p>resources目录下的xml配置文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;beanClass&quot; class=&quot;beanfatory.BeanClass&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="Bean初始化流程图"><a href="#Bean初始化流程图" class="headerlink" title="==Bean初始化流程图=="></a>==Bean初始化流程图==</h4><p>主要是在下面的两个类, 简单划分为两个阶段 </p><ul><li><p>准备阶段(AbstractBeanFactory#doGetBean)</p><ul><li>从缓存中获取</li><li>循环依赖检查</li><li>BeanDefinition检查、合并</li><li>依赖Bean检查、创建</li><li>根据scope创建</li></ul></li><li><p>实例化阶段(AbstractAutowireCapableBeanFactory#doCreateBean)</p><ul><li>允许InstantiationAwareBeanPostProcessor 返回代理 (代理也会回调BeanPostProcessor的处理)</li><li>实例化 (默认、工厂、构造函数)</li><li>MergedBeanDefinitionPostProcessor修改BeanDeinition</li><li>提前暴露Bean</li><li>属性填充</li><li>初始化(接口的回调)<ul><li>AwareMethods</li><li>BPP-Before</li><li>invokeMethods (afterProperts、init-method)</li><li>BBP-After</li></ul></li></ul></li></ul><p>  简单流程如下:</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazp1f340fj30zf02raa1.jpg" alt="Spirng 对 Bean 的处理"></p><p>详细的流程图可以参考某位大佬的:<a href="https://blog.csdn.net/zghwaicsdn/article/details/50910384" target="_blank" rel="noopener">https://blog.csdn.net/zghwaicsdn/article/details/50910384</a></p><h3 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h3><p>接下来看看BeanDefinition是什么,BeanDefinition是在哪里注册的,BeanDefinition是怎么来的</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><h5 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9m63lra9zj31ra0ja0ws.jpg" alt="image-20191205212750684"></p><h5 id="BeanDefinition信息"><a href="#BeanDefinition信息" class="headerlink" title="BeanDefinition信息"></a>BeanDefinition信息</h5><p>先来看看BeanDefinition,BeanDefinition描述了一个bean实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p><p>主要目的是允许 BeanFactoryPostProcessor,例如 PropertyPlaceholderConfigurer 内省和修改, 属性值和其他bean元数据。</p><p>获取上述的BeanClass 打印信息如下</p><pre><code class="java">Generic bean: class [beanfatory.BeanClass]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [application.xml]</code></pre><p>可以得知 它具有哪些属性,以及它是一个GenericBeanDefinition</p><pre><code class="java">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {    //scope值，单例还是非单例    String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;    String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;    //Bean角色：    //用户    int ROLE_APPLICATION = 0;    //某些复杂的配置    int ROLE_SUPPORT = 1;    //完全内部使用    int ROLE_INFRASTRUCTURE = 2;    //返回此bean定义的父bean定义的名称，如果有的话 &lt;bean parent=&quot;&quot;&gt;    String getParentName();    void setParentName(String parentName);    //获取bean对象className &lt;bean class=&quot;&quot;&gt;    String getBeanClassName();    void setBeanClassName(String beanClassName);    //定义创建该Bean对象的工厂类  &lt;bean factory-bean=&quot;&quot;&gt;    String getFactoryBeanName();    void setFactoryBeanName(String factoryBeanName);    //定义创建该Bean对象的工厂方法 &lt;bean factory-method=&quot;&quot;&gt;    String getFactoryMethodName();    void setFactoryMethodName(String factoryMethodName);    //&lt;bean scope=&quot;singleton/prototype&quot;&gt;    String getScope();    void setScope(String scope);    //懒加载 &lt;bean lazy-init=&quot;true/false&quot;&gt;    boolean isLazyInit();    void setLazyInit(boolean lazyInit);    //依赖对象  &lt;bean depends-on=&quot;&quot;&gt;    String[] getDependsOn();    void setDependsOn(String[] dependsOn);    //是否为被自动装配 &lt;bean autowire-candidate=&quot;true/false&quot;&gt;    boolean isAutowireCandidate();    void setAutowireCandidate(boolean autowireCandidate);    //是否为主候选bean    使用注解：@Primary    boolean isPrimary();    void setPrimary(boolean primary);    //返回此bean的构造函数参数值。    ConstructorArgumentValues getConstructorArgumentValues();    //获取普通属性集合    MutablePropertyValues getPropertyValues();    boolean isSingleton();    boolean isPrototype();    boolean isAbstract();    int getRole();    //返回对bean定义的可读描述。    String getDescription();    //返回该bean定义来自的资源的描述（用于在出现错误时显示上下文）    String getResourceDescription();    BeanDefinition getOriginatingBeanDefinition();}}</code></pre><h5 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a>AbstractBeanDefinition</h5><p>Base class for concrete, full-fledged {@link BeanDefinition} classes, factoring out common properties of {@link GenericBeanDefinition}, {@link RootBeanDefinition}, and {@link ChildBeanDefinition}.</p><pre><code class="java">public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor      implements BeanDefinition, Cloneable {  ...}</code></pre><p>BeanDefinition基础实现类,另外继承了BeanMetadataAttributeAccessor(元数据属性 )</p><pre><code class="java">public class BeanMetadataAttributeAccessor extends AttributeAccessorSupport implements BeanMetadataElement {    public void addMetadataAttribute(BeanMetadataAttribute attribute) {        super.setAttribute(attribute.getName(), attribute);    }    @Nullable    public BeanMetadataAttribute getMetadataAttribute(String name) {        return (BeanMetadataAttribute) super.getAttribute(name);    }  ....}public abstract class AttributeAccessorSupport implements AttributeAccessor, Serializable {    /** Map with String keys and Object values. */    private final Map&lt;String, Object&gt; attributes = new LinkedHashMap&lt;&gt;();  ...}</code></pre><p>在AttributeAccessorSupport 中维护了k-name ,v-BeanMetadata 的map</p><p>BeanMetadataAttribute: Holder for a key-value style attribute that is part of a bean definition.<br>Keeps track of the definition source in addition to the key-value pair.</p><p>再来看看三个实现类</p><ul><li>GenericBeanDefinition </li><li>RootBeanDefinition </li><li>ChildBeanDefinition</li></ul><h5 id="RootBeanDefinition"><a href="#RootBeanDefinition" class="headerlink" title="RootBeanDefinition"></a>RootBeanDefinition</h5><p><em>A root bean definition represents the merged bean definition that backs a specific bean in a Spring BeanFactory at runtime.It might have been created from multiple original bean definitions that inherit from each other, typically registered as GenericBeanDefinitions. A root bean definition is essentially the ‘unified’ bean definition view at runtime.Root bean definitions may also be used for registering individual bean definitions in the configuration phase.</em> </p><p><em>However, since Spring 2.5, the preferred way to register bean definitions programmatically is the GenericBeanDefinition class. GenericBeanDefinition has the advantage that it allows to dynamically define parent dependencies, not ‘hard-coding’ the role as a root bean definition.</em> </p><p>root bean定义表示在运行时支持Spring BeanFactory中特定bean 的merge dbean定义。它可能是由多个相互继承的原始bean定义创建的，通常注册为genericbeandefinition。root bean定义本质上是运行时的“统一”bean定义视图。root bean定义也可以用于在配置阶段注册各个bean定义。</p><p>但是，自spring2.5以来，以编程方式注册bean定义的首选方法是GenericBeanDefinition类。GenericBeanDefinition的优点是它允许动态定义父依赖项，而不是将角色“硬编码”为root bean。</p><pre><code class="java">public class RootBeanDefinition extends AbstractBeanDefinition {    @Override    public String getParentName() {        return null;    }    @Override    public void setParentName(@Nullable String parentName) {        if (parentName != null) {            throw new IllegalArgumentException(&quot;Root bean cannot be changed into a child bean with parent reference&quot;);        }    }  ...}</code></pre><h5 id="ChildBeanDefinition"><a href="#ChildBeanDefinition" class="headerlink" title="ChildBeanDefinition"></a>ChildBeanDefinition</h5><p><em>Bean definition for beans which inherit settings from their parent. Child bean definitions have a fixed dependency on a parent bean definition.</em><br><em>A child bean definition will inherit constructor argument values, property values and method overrides from the parent, with the option to add new values. If init method, destroy method and/or static factory method are specified, they will override the corresponding parent settings. The remaining settings will always be taken from the child definition: depends on, autowire mode, dependency check, singleton, lazy init.</em></p><p><em>NOTE: Since Spring 2.5, the preferred way to register bean definitions programmatically is the GenericBeanDefinition class, which allows to dynamically define parent dependencies through the GenericBeanDefinition.setParentName(java.lang.String) method. This effectively supersedes the ChildBeanDefinition class for most use cases.</em></p><p>Bean定义，用于从父类继承设置的Bean。子bean定义对父bean定义有固定的依赖关系。</p><p>子bean定义将继承父类的构造函数参数值、属性值和方法重写，并可选择添加新值。如果指定了init方法、destroy方法和/或静态工厂方法，它们将覆盖相应的父设置。</p><p>其余的设置将始终从子定义:依赖、自动装配模式、依赖项检查、单例、惰性初始化。</p><p>注意:自spring2.5以来，以编程方式注册bean定义的首选方法是GenericBeanDefinition类，它允许通过GenericBeanDefinition. setParentName (java.lang.String)方法动态定义父依赖项。对于大多数用例，这实际上取代了ChildBeanDefinition类。</p><pre><code class="java">public class ChildBeanDefinition extends AbstractBeanDefinition {        @Override    public void setParentName(@Nullable String parentName) {        this.parentName = parentName;    }    @Override    @Nullable    public String getParentName() {        return this.parentName;    }    @Override    public void validate() throws BeanDefinitionValidationException {        super.validate();        if (this.parentName == null) {            throw new BeanDefinitionValidationException(&quot;&#39;parentName&#39; must be set in ChildBeanDefinition&quot;);        }    }}</code></pre><p>可以看到从2.5开始 Child 和 Root 都被GenericBeanDefinition替代  ,其中重要的原因是允许动态定义父依赖</p><h5 id="GenericBeanDefinition"><a href="#GenericBeanDefinition" class="headerlink" title="GenericBeanDefinition"></a>GenericBeanDefinition</h5><p><em>GenericBeanDefinition is a one-stop shop for standard bean definition purposes. Like any bean definition, it allows for specifying a class plus optionally constructor argument values and property values. Additionally, deriving from a parent bean definition can be flexibly configured through the “parentName” property. In general, use this GenericBeanDefinition class for the purpose of registering user-visible bean definitions (which a post-processor might operate on, potentially even reconfiguring the parent name). Use RootBeanDefinition / ChildBeanDefinition where parent/child relationships happen to be pre-determined.</em></p><p>GenericBeanDefinition是标准bean定义的一站式服务。与任何bean定义一样，它允许指定一个类加上可选的构造函数参数值和属性值。此外，可以通过“parentName”属性灵活地配置来自父bean定义的派生。</p><p>通常，使用这个GenericBeanDefinition类的目的是注册用户可见的bean定义(后处理器可以对其进行操作，甚至可能重新配置父名称)。使用RootBeanDefinition / ChildBeanDefinition来预先确定父/子关系。</p><pre><code class="java">public class GenericBeanDefinition extends AbstractBeanDefinition {   @Nullable   private String parentName;   ...  /**     * Create a new GenericBeanDefinition, to be configured through its bean     * properties and configuration methods.     * @see #setBeanClass     * @see #setScope     * @see #setConstructorArgumentValues     * @see #setPropertyValues     */    public GenericBeanDefinition() {        super();    }}</code></pre><h5 id="ConfigurationClassBeanDefinition"><a href="#ConfigurationClassBeanDefinition" class="headerlink" title="ConfigurationClassBeanDefinition"></a>ConfigurationClassBeanDefinition</h5><pre><code class="java">class org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition extends RootBeanDefinition implements AnnotatedBeanDefinition(){}/** * Build and validate a configuration model based on the registry of * {@link Configuration} classes. */public void org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions(BeanDefinitionRegistry registry){}</code></pre><p>更多细节:</p><p>@see ConfigurationClassPostProcessor</p><p>@see ConfigurationClassBeanDefinitionReader</p><p>@see ConfigurationClassParser</p><h5 id="AbstractBeanFactory-getMergedBeanDefinition"><a href="#AbstractBeanFactory-getMergedBeanDefinition" class="headerlink" title="AbstractBeanFactory#getMergedBeanDefinition"></a>AbstractBeanFactory#getMergedBeanDefinition</h5><pre><code class="java">/** * Return a RootBeanDefinition for the given bean, by merging with the * parent if the given bean&#39;s definition is a child bean definition. * @param beanName the name of the bean definition * @param bd the original bean definition (Root/ChildBeanDefinition) * @param containingBd the containing bean definition in case of inner bean, * or {@code null} in case of a top-level bean * @return a (potentially merged) RootBeanDefinition for the given bean * @throws BeanDefinitionStoreException in case of an invalid bean definition */protected RootBeanDefinition getMergedBeanDefinition(      String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)      throws BeanDefinitionStoreException {   synchronized (this.mergedBeanDefinitions) {      RootBeanDefinition mbd = null;      // Check with full lock now in order to enforce the same merged instance.      if (containingBd == null) {         mbd = this.mergedBeanDefinitions.get(beanName);      }      if (mbd == null) {         if (bd.getParentName() == null) {            // Use copy of given root bean definition.            if (bd instanceof RootBeanDefinition) {               mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();            }            else {               mbd = new RootBeanDefinition(bd);            }         }         else {            // Child bean definition: needs to be merged with parent.            BeanDefinition pbd;            try {               String parentBeanName = transformedBeanName(bd.getParentName());               if (!beanName.equals(parentBeanName)) {                  pbd = getMergedBeanDefinition(parentBeanName);               }               else {                  BeanFactory parent = getParentBeanFactory();                  if (parent instanceof ConfigurableBeanFactory) {                     pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);                  }                  else {                     throw new NoSuchBeanDefinitionException(parentBeanName,                           &quot;Parent name &#39;&quot; + parentBeanName + &quot;&#39; is equal to bean name &#39;&quot; + beanName +                           &quot;&#39;: cannot be resolved without an AbstractBeanFactory parent&quot;);                  }               }            }            catch (NoSuchBeanDefinitionException ex) {               throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,                     &quot;Could not resolve parent bean definition &#39;&quot; + bd.getParentName() + &quot;&#39;&quot;, ex);            }            //进行深拷贝, 合并、 覆盖父类overridden方法             mbd = new RootBeanDefinition(pbd);            mbd.overrideFrom(bd);         }         // Set default singleton scope, if not configured before.         if (!StringUtils.hasLength(mbd.getScope())) {            mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);         }         // A bean contained in a non-singleton bean cannot be a singleton itself.         // Let&#39;s correct this on the fly here, since this might be the result of         // parent-child merging for the outer bean, in which case the original inner bean         // definition will not have inherited the merged outer bean&#39;s singleton status.         if (containingBd != null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) {            mbd.setScope(containingBd.getScope());         }         // Cache the merged bean definition for the time being         // (it might still get re-merged later on in order to pick up metadata changes)         if (containingBd == null &amp;&amp; isCacheBeanMetadata()) {            this.mergedBeanDefinitions.put(beanName, mbd);         }      }      return mbd;   }}</code></pre><ol><li>在mergedBeanDefinitions同步的情况下再次读取缓存，防止该BeanDefinition已经被合并过了。</li><li>检查是否有父类，若有父类，则必须递归去合并BeanDefinition。</li><li>将子类重写后的方法覆盖到定义的BeanDefinition中。</li><li>设置scope类型。</li><li>将生成的BeanDefinition缓存起来。</li></ol><h4 id="BeanDefinitionRegistry-1"><a href="#BeanDefinitionRegistry-1" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h4><pre><code class="java">public interface BeanDefinitionRegistry extends AliasRegistry {        void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)            throws BeanDefinitionStoreException;      void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;      BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;        boolean containsBeanDefinition(String beanName);        String[] getBeanDefinitionNames();        int getBeanDefinitionCount();        boolean isBeanNameInUse(String beanName);}</code></pre><ol><li>首先是实现,实现方式是怎么样的?</li></ol><p>registerBeanDefinition 在哪里实现 , 可以定位到 DefaultListableBeanFactory中</p><pre><code class="java">//---------------------------------------------------------------------// Implementation of BeanDefinitionRegistry interface//---------------------------------------------------------------------@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)      throws BeanDefinitionStoreException {     //校验   ((AbstractBeanDefinition) beanDefinition).validate();        ...     //已存在的处理   BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);   if (existingDefinition != null) {      if (!isAllowBeanDefinitionOverriding()) {         throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);      }            //省略日志打印      this.beanDefinitionMap.put(beanName, beanDefinition);   }   else {      if (hasBeanCreationStarted()) {         // Cannot modify startup-time collection elements anymore (for stable iteration)         synchronized (this.beanDefinitionMap) {            this.beanDefinitionMap.put(beanName, beanDefinition);            List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);            updatedDefinitions.addAll(this.beanDefinitionNames);            updatedDefinitions.add(beanName);            this.beanDefinitionNames = updatedDefinitions;            if (this.manualSingletonNames.contains(beanName)) {               Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames);               updatedSingletons.remove(beanName);               this.manualSingletonNames = updatedSingletons;            }         }      }      else {         // Still in startup registration phase         this.beanDefinitionMap.put(beanName, beanDefinition);         this.beanDefinitionNames.add(beanName);         this.manualSingletonNames.remove(beanName);      }      this.frozenBeanDefinitionNames = null;   }   if (existingDefinition != null || containsSingleton(beanName)) {      resetBeanDefinition(beanName);   }}</code></pre><p>简单来说就是干了以下的事情</p><p>this.beanDefinitionMap.put(beanName, beanDefinition);</p><p>this.beanDefinitionNames.add(beanName);</p><p>this.manualSingletonNames.remove(beanName);</p><ol start="2"><li>那么在哪里调用?BeanDefinition是怎么来的?</li></ol><p>从XmlBeanFactory 中可以发现 XmlBeanDefinitionReader 的作用是loadBeanDefinitions ,那么我们先从其父类说起</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9pqnrafenj30rw0fet9w.jpg" alt="image-20191208233705110" style="zoom:50%;"></p><h4 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h4><pre><code class="java">package org.springframework.beans.factory.support;import org.springframework.beans.factory.BeanDefinitionStoreException;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.lang.Nullable;/** * Simple interface for bean definition readers. * Specifies load methods with Resource and String location parameters. * * &lt;p&gt;Concrete bean definition readers can of course add additional * load and register methods for bean definitions, specific to * their bean definition format. * * &lt;p&gt;Note that a bean definition reader does not have to implement * this interface. It only serves as suggestion for bean definition * readers that want to follow standard naming conventions. * * @author Juergen Hoeller * @since 1.1 * @see org.springframework.core.io.Resource */public interface BeanDefinitionReader {   BeanDefinitionRegistry getRegistry();   @Nullable   ResourceLoader getResourceLoader();   @Nullable   ClassLoader getBeanClassLoader();   BeanNameGenerator getBeanNameGenerator();   int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;   int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException;   int loadBeanDefinitions(String location) throws BeanDefinitionStoreException;   int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;}</code></pre><p>可以看到这个Reader 在整个BeanFactory中的重要性, 其作用根据接口我们可以猜测出是 资源定位 解析 注册</p><p>@see ResourceLoader</p><p>@see ClassLoader</p><p>@see BeanNameGenerator</p><h5 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h5><p>调用链请看</p><p>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions</p><p>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</p><p>org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element)</p><p>org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition</p><p>详细</p><p>@see AbstractBeanDefinitionReader</p><p>@see DefaultBeanDefinitionDocumentReader</p><p>@see BeanDefinitionParserDelegate</p><p>@see BeanDefinitionReaderUtils</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>todo 总结</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> beanFactory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring Q&amp;A</title>
      <link href="/2019/12/02/spring-Q-A/"/>
      <url>/2019/12/02/spring-Q-A/</url>
      
        <content type="html"><![CDATA[<h1 id="spring学习问题记录"><a href="#spring学习问题记录" class="headerlink" title="spring学习问题记录"></a>spring学习问题记录</h1><h2 id="spring-资源管理"><a href="#spring-资源管理" class="headerlink" title="spring 资源管理"></a>spring 资源管理</h2><p>Q:spring ClassLoader是怎么破坏双亲委派的?</p><p><a href="https://www.cnblogs.com/binarylei/p/10312531.html" target="_blank" rel="noopener">https://www.cnblogs.com/binarylei/p/10312531.html</a></p><p>Q:ResourceLoader的问题?</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>Q:BeanFactory 和Application的关系?</p><p>Q:spring容器和springMvc容器是一个东西吗? 说说父子容器?</p><p>A:<a href="https://blog.csdn.net/qfikh/article/details/80507011" target="_blank" rel="noopener">https://blog.csdn.net/qfikh/article/details/80507011</a></p><p>Q:简单说说你对spring的理解?</p><p>A:?</p><p>Q: BeanFactory.getBean() 发生了什么?bean的创建过程?</p><p>A:?</p><p>Q:spring是怎么处理循环依赖问题?</p><p>Q:为什么需要singletonFactories? </p><p>A:需要Factories来创bean</p><p>Q:spring线程安全问题</p><p>A:<a href="https://segmentfault.com/a/1190000004255203" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004255203</a></p><p>Q: beanFactory、factorybean、ObjectFactory的区别你能说说吗</p><p>Q: which  runs first?  beanPostProcess  or Initialization Callbacks </p><p>A:You can refer to the section 5.8.1 of the Spring docs <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-extension" target="_blank" rel="noopener">here</a>. The key point here is that the “postProcessBeforeInitialization” should be read as “postProcessBeforeInitializationCallback” and “postProcessAfterInitialization” should be read as “postProcessAfterInitializationCallback”. So these are pre and post processeors after the before/after initialization callback are run by the Spring container on the bean. This is what is conveyed in the docs of these methods <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html#postProcessAfterInitialization-java.lang.Object-java.lang.String-" target="_blank" rel="noopener">here</a> too.</p><p>Q: 启动时候控制台打印的这个是什么意思呢? not eligible for auto-proxying</p><p>A:<code>BeanPostProcessor</code> instances and AOP auto-proxying</p><p>Classes that implement the <code>BeanPostProcessor</code> interface are special and are treated differently by the container. All <code>BeanPostProcessor</code> instances and beans that they directly reference are instantiated on startup, as part of the special startup phase of the <code>ApplicationContext</code>. Next, all <code>BeanPostProcessor</code> instances are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a <code>BeanPostProcessor</code> itself, neither <code>BeanPostProcessor</code> instances nor the beans they directly reference are eligible for auto-proxying and, thus, do not have aspects woven into them.</p><p>For any such bean, you should see an informational log message: <code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code>.</p><p>If you have beans wired into your <code>BeanPostProcessor</code> by using autowiring or <code>@Resource</code> (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates and, therefore, make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with <code>@Resource</code> where the field or setter name does not directly correspond to the declared name of a bean and no name attribute is used, Spring accesses other beans for matching them by type.</p><p>Q: all of beanPostProcess and beanFactoryProcess Extends point :Scope?</p><p>A: Also, <code>BeanFactoryPostProcessor</code> instances are scoped per-container.</p><p>marking it for lazy initialization will be ignored?</p><p> As with <code>BeanPostProcessor</code>s , you typically do not want to configure <code>BeanFactoryPostProcessor</code>s for lazy initialization. If no other bean references a <code>Bean(Factory)PostProcessor</code>, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the <code>Bean(Factory)PostProcessor</code> will be instantiated eagerly even if you set the <code>default-lazy-init</code> attribute to <code>true</code> on the declaration of your <code></code> element.</p><p>Q:classLoader 加载效率低?  spring有哪些优化 ?</p><p>A:Spring IoC 的 Lazy loading 有关, Spring IoC 为了加快初始化速度, 因此大量使用了延时加载技术. 而使用 classloader 不需要执行类中的初始化代码, 可以加快加载速度, 把类的初始化工作留到实际使用到这个类的时候.</p><p>Q:有看过官方文档吗 ? Annotation-based Container Configuration 和 </p><p>Java-based Container Configuration</p><p>Using JSR 330 Standard Annotations  这几章的侧重点?(或者谈谈你对注解的理解)</p><p>A:</p><p><strong>Annotation-based Container Configuration    (元信息配置)</strong> </p><p>🔑关键词: configuration metadata; @Autowired ;@Order;@Primary;@Qulifier;@Resources;BeanPostProcessor</p><p><strong>Java-based Container Configuration  (java代码的方式实现配置)</strong></p><p>@Bean; @Configuration;AnnotationConfigApplicationContext;lite vs full;@Import; @ImportResource;@Condition</p><p><strong>Java-based Container Configuration (主要是支持JSR330)</strong></p><p>🔑关键词: javax.inject ; @Inject; @Named</p><p>Q:Spring的配置文件中</p><p>&lt;context:annotation-config /&gt;</p><p>&lt;context:component-scan base-package=””/&gt;</p><p>&lt;mvc:annotation-driven /&gt; 分别有什么不同和联系?</p><p>A:那是因为&lt;context:annotation-config /&gt;<strong>仅能够在已经在已经注册过的bean上面起作用</strong>。</p><p><a href="https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan" target="_blank" rel="noopener">https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan</a></p><p>Q:Full @Configuration vs “lite” @Bean mode ?</p><p>A:在<code>lite @Bean mode</code>模式下， <code>@Bean</code>方法不会被CGLIB代理</p><p>That definitely would be problematic: In Spring, instantiated beans have a <code>singleton</code> scope by default. </p><p>This is where the magic comes in: All <code>@Configuration</code> classes are subclassed at startup-time with <code>CGLIB</code>. </p><p>In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance.</p><p>Q:spring 为什么会使用cglib 、什么时候使用?</p><p>A: Spring提供了ProxyFactoryBean创建代理，及利用BeanPostProcessor实现自动创建代理。</p><p>Q : spring Xml schema 扩展的了解?</p><p>A : <a href="https://juejin.im/post/5d06018b518825276a286a3d" target="_blank" rel="noopener">https://juejin.im/post/5d06018b518825276a286a3d</a></p><p>Q:LTW是啥?</p><p>A:  Spring是在运行期利用JDK或CGLib创建代理，我们还可以在类加载期间通过字节码编辑的技术，将切面织入到目标类中，这种织入方式称为LTW(Load Time Weaving)。Spring为LTW的过程提供了细粒度的控制，它支持在单个ClassLoader范围内实施类文件转换，且配置更为简单。</p><p>原文链接：<a href="https://blog.csdn.net/evergreenfetch/article/details/42002017" target="_blank" rel="noopener">https://blog.csdn.net/evergreenfetch/article/details/42002017</a></p><p>将 spring-agent.jar, </p><p>spring-aspects.jar, </p><p>aspectj-weaver.jar, </p><p>aspectj-rt.jar 加入到 classpath 中， 运行期主要发生以下调用 : </p><p>LoadTimeWeaverBeanDefinitionParser (spring.jar) // 解析配置<br>-&gt;  AspectJWeavingEnabler (spring.jar) // 开启 aspectj weaving<br>-&gt;  InstrumentationSavingAgent (spring-agent.jar)  // 获取 instrumentation<br>-&gt;  InstrumentationLoadTimeWeaver#addTransformer (spring.jar) // 增加 aspectj class transformer 到 instrumentation<br>-&gt;  ClassPreProcessorAgentAdapter#transform (aspectj-weaver.jar) // aspectj 拦截 domain object 装载<br>-&gt;  AnnotationBeanConfigurerAspect#configureBean (spring-aspects.jar) // spring 注入依赖到标注了 @Configurable 的对象中</p><p>beanfactory支持aop吗？</p><p>BeanFactory or ApplicationContext?</p><p>Users are sometimes unsure whether a BeanFactory or an ApplicationContext is best suited for use in a particular situation. A BeanFactory pretty much just instantiates and configures beans. An ApplicationContext also does that, and it provides the supporting infrastructure to enable lots of enterprise-specific features such as transactions and AOP.</p><p>为什么</p><p> aop是在什么织入的 ？</p><p>-bean初始化时</p><p><a href="https://juejin.im/entry/5b572405e51d451964625f66" target="_blank" rel="noopener">https://juejin.im/entry/5b572405e51d451964625f66</a></p><p><a href="https://www.javadoop.com/post/spring-aop-intro" target="_blank" rel="noopener">https://www.javadoop.com/post/spring-aop-intro</a></p><p>factorybean beanfactory?</p><p>- mvc容器和ioc容器？</p><p>√ aop和aspectj?</p><p>√ 事件驱动 请求驱动</p><p>√ spring bean的实例化？与加载对象的过程？</p><p><a href="https://swenfang.github.io/2019/04/22/Spring面试题/" target="_blank" rel="noopener">https://swenfang.github.io/2019/04/22/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</a></p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/面试总结/" target="_blank" rel="noopener">https://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</a></p><p>怎么解决循环依赖问题?</p><p>spring listener的初始化时机?</p><p>springmvc容器初始化时机?第一次请求为啥比较慢?</p><p>springBoot 中的 webApplicationContext 什么时候创建的?</p><p>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</p><p>springBoot的启动流程?</p><p>bean为什么会被重复初始化?</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Documentation-Spring_Core_IOC</title>
      <link href="/2019/10/29/Documentation-Spring-Core-IOC/"/>
      <url>/2019/10/29/Documentation-Spring-Core-IOC/</url>
      
        <content type="html"><![CDATA[<p>关键字:  bean(定义-关系、 加载方式(创建、解析)  、扩展)、application(容器、resource、加载、扩展)、注解、环境(Environment)</p><p>Tips: 在看官方文档时候的一些摘抄、总结(建议直接阅读官方文档</p><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans</a></p><p>Version 5.2.1.RELEASE  ) </p><p>IOC 容器(DI 查找和注入)</p><p>​    —&gt; Bean管理 (关系、作用域、生命周期、扩展点)</p><p>​    —&gt; Bean元信息(属性值)</p><p>基础设施扩展 (资源管理 类型 事件等)</p><a id="more"></a><!--toc--><h2 id="🌟introduction-（介绍）"><a href="#🌟introduction-（介绍）" class="headerlink" title="🌟introduction （介绍）"></a>🌟introduction （介绍）</h2><p>关键词: BeanFactory、ApplicationContext (App internationalization 、event 、web)、beans</p><p>This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle.</p><p> IoC is also known as dependency injection (DI)</p><p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis for Spring Framework’s IoC container. </p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>The <a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener"><code>BeanFactory</code></a> interface provides an advanced configuration mechanism capable of managing any type of object</p><p>提供了一种能够管理任何类型对象的高级配置机制</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener"><code>ApplicationContext</code></a> </p><ul><li>Easier integration with Spring’s AOP features (和AOP更好集成)</li><li>Message resource handling (for use in internationalization)</li><li>Event publication (事件发布机制)</li><li>Application-layer specific contexts such as the <code>WebApplicationContext</code> for use in web applications.</li></ul><h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h3><p>A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container.</p><p>Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p><p>bean是由Spring IoC容器实例化、组装和管理的对象。</p><p>bean及其之间的依赖关系反映在容器使用的配置元数据中。</p><h2 id="🌟Container-overview-（容器预览）"><a href="#🌟Container-overview-（容器预览）" class="headerlink" title="🌟Container overview （容器预览）"></a>🌟Container overview （容器预览）</h2><p>关键词: configuration metadata、Instantiating</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8fetrcx4vj30du088mxd.jpg" alt="container magic"></p><h3 id="configuration-metadata-配置元信息"><a href="#configuration-metadata-配置元信息" class="headerlink" title="configuration metadata (配置元信息)"></a>configuration metadata (配置元信息)</h3><p>The configuration metadata is represented in XML, Java annotations, or Java code. </p><p>annotations </p><ul><li>spring 2.5   annotation-based</li><li>spring 3.0   java-based  Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the @Configuration, @Bean, @Import, and @DependsOn annotations.</li></ul><h3 id="Instantiating-a-Container-实例化容器"><a href="#Instantiating-a-Container-实例化容器" class="headerlink" title="Instantiating a Container (实例化容器)"></a>Instantiating a Container (实例化容器)</h3><!--The location path or paths supplied to an `ApplicationContext` constructor are resource strings that let the container load configuration metadata from a variety of external resources, such as the local file system, the Java `CLASSPATH`, and so on.--><p>提供给“ApplicationContext”构造函数的位置路径是资源字符串，它允许容器从各种外部资源(如本地文件系统、Java“CLASSPATH”等)加载配置元数据。</p><h3 id="Using-the-Container-使用容器"><a href="#Using-the-Container-使用容器" class="headerlink" title="Using the Container (使用容器)"></a>Using the Container (使用容器)</h3><pre><code class="java">// create and configure beansApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);// retrieve configured instancePetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList();</code></pre><h2 id="🌟Bean-Overview-bean-预览"><a href="#🌟Bean-Overview-bean-预览" class="headerlink" title="🌟Bean Overview (bean 预览)"></a>🌟Bean Overview (bean 预览)</h2><p>bean的一个介绍</p><p>关键词: beanDefinition、instantiating、Naming  </p><h3 id="beanDefinition-bean定义"><a href="#beanDefinition-bean定义" class="headerlink" title="beanDefinition(bean定义)"></a>beanDefinition(bean定义)</h3><p>Within the container itself, these bean definitions are represented as <code>BeanDefinition</code> objects, which contain (among other information) the following metadata:</p><ul><li>A package-qualified class name: typically, the actual implementation class of the bean being defined.(名字)</li><li>Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth). (状态、行为)</li><li>References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies. (依赖关系)</li><li>Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.</li></ul><table><thead><tr><th style="text-align:left">Property</th><th style="text-align:left">Explained in…</th></tr></thead><tbody><tr><td style="text-align:left">Class</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class" target="_blank" rel="noopener">Instantiating Beans</a></td></tr><tr><td style="text-align:left">Name</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beanname" target="_blank" rel="noopener">Naming Beans</a></td></tr><tr><td style="text-align:left">Scope</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes" target="_blank" rel="noopener">Bean Scopes</a></td></tr><tr><td style="text-align:left">Constructor arguments</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators" target="_blank" rel="noopener">Dependency Injection</a></td></tr><tr><td style="text-align:left">Properties</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators" target="_blank" rel="noopener">Dependency Injection</a></td></tr><tr><td style="text-align:left">Autowiring mode</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire" target="_blank" rel="noopener">Autowiring Collaborators</a></td></tr><tr><td style="text-align:left">Lazy initialization mode</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init" target="_blank" rel="noopener">Lazy-initialized Beans</a></td></tr><tr><td style="text-align:left">Initialization method</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener">Initialization Callbacks</a></td></tr><tr><td style="text-align:left">Destruction method</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener">Destruction Callbacks</a></td></tr></tbody></table><h3 id="naming-bean-bean命名"><a href="#naming-bean-bean命名" class="headerlink" title="naming  bean (bean命名)"></a>naming  bean (bean命名)</h3><h4 id="Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="Aliasing a Bean outside the Bean Definition"></a>Aliasing a Bean outside the Bean Definition</h4><h3 id="Instantiating-bean-bean构造方式"><a href="#Instantiating-bean-bean构造方式" class="headerlink" title="Instantiating bean (bean构造方式)"></a>Instantiating bean (bean构造方式)</h3><p>You can use the <code>Class</code> property in one of two ways:</p><ul><li>Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code with the <code>new</code> operator.</li><li>To specify the actual class containing the <code>static</code> factory method that is invoked to create the object, in the less common case where the container invokes a <code>static</code> factory method on a class to create the bean. The object type returned from the invocation of the <code>static</code> factory method may be the same class or another class entirely.</li></ul><h4 id="Instantiation-with-a-Constructor"><a href="#Instantiation-with-a-Constructor" class="headerlink" title="Instantiation with a Constructor"></a>Instantiation with a Constructor</h4><!--The Spring IoC container can manage virtually any class you want it to manage. It is not limited to managing true JavaBeans.--> <!--Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container.--> <!--You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.--><p>Spring IoC容器几乎可以管理您希望它管理的任何类。它不仅限于管理真正的javabean。</p><p>大多数Spring用户更喜欢实际的javabean，它只有一个默认的(无参数的)构造函数，以及根据容器中的属性建模的适当的setter和getter方法。</p><p>您还可以在容器中包含更多非bean风格的类。例如，如果您需要使用完全不符合JavaBean规范的遗留连接池，Spring也可以管理它。</p><h4 id="Instantiation-with-a-Static-Factory-Method"><a href="#Instantiation-with-a-Static-Factory-Method" class="headerlink" title="Instantiation with a Static Factory Method"></a>Instantiation with a Static Factory Method</h4><!--One use for such a bean definition is to call `static` factories in legacy code.--><p>这种bean定义的一个用途是在遗留代码中调用“静态”工厂。</p><h4 id="Instantiation-by-Using-an-Instance-Factory-Method"><a href="#Instantiation-by-Using-an-Instance-Factory-Method" class="headerlink" title="Instantiation by Using an Instance Factory Method"></a>Instantiation by Using an Instance Factory Method</h4><!--Similar to instantiation through a [static factory method](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class-static-factory-method), instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean.--> <p>与通过静态工厂方法实例化类似，使用实例工厂方法实例化将从容器中调用现有bean的非静态方法来创建新bean。</p><blockquote><p>In Spring documentation, “factory bean” refers to a bean that is configured in the Spring container and that creates objects through an <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class-instance-factory-method" target="_blank" rel="noopener">instance</a> or <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class-static-factory-method" target="_blank" rel="noopener">static</a> factory method. By contrast, <code>FactoryBean</code> (notice the capitalization) refers to a Spring-specific <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension-factorybean" target="_blank" rel="noopener"><code>FactoryBean</code></a>.</p></blockquote><p>在Spring文档中，“工厂bean”指的是在Spring容器中配置的bean，它通过实例或静态工厂方法创建对象。相反，FactoryBean(注意大小写)指的是特定于spring的FactoryBean。</p><h2 id="🌟Dependencies-依赖"><a href="#🌟Dependencies-依赖" class="headerlink" title="🌟Dependencies (依赖)"></a>🌟Dependencies (依赖)</h2><p>更多描述的是bean之间的关系</p><p>关键词: IOC、DI、collaborate(协作者)、 construct-b(type index name)、 setter-b 、解析过程、循环依赖、提前实例、自动装配、方法注入</p><!--A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application.--> <!--This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.--><p>典型的企业应用程序不包含单个对象(或Spring中的bean)。即使是最简单的应用程序也有几个对象一起工作，以呈现最终用户所看到的一致的应用程序。</p><p>下一节将解释如何从定义许多独立的bean定义过渡到一个完全实现的应用程序，其中对象通过协作实现目标。</p><h3 id="Dependency-Injection-DI"><a href="#Dependency-Injection-DI" class="headerlink" title="Dependency Injection(DI)"></a>Dependency Injection(DI)</h3><!--Code is cleaner with the DI principle, and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies and does not know the location or class of the dependencies.--><!--DI exists in two major variants: Constructor-based dependency and Setter-based dependency injection. --><p>使用DI原则，代码更简洁，并且当对象提供其依赖项时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类。</p><h4 id="Constructor-based-Dependency-Injection-构造注入"><a href="#Constructor-based-Dependency-Injection-构造注入" class="headerlink" title="Constructor-based Dependency Injection(构造注入)"></a>Constructor-based Dependency Injection(构造注入)</h4><ul><li>Constructor argument type matching</li><li>Constructor argument index</li><li>Constructor argument name</li></ul><h4 id="Setter-based-Dependency-Injection-Setter注入"><a href="#Setter-based-Dependency-Injection-Setter注入" class="headerlink" title="Setter-based Dependency Injection(Setter注入)"></a>Setter-based Dependency Injection(Setter注入)</h4><!--Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or a no-argument `static` factory method to instantiate your bean.--> <!--You configure the dependencies in the form of a `BeanDefinition`, which you use in conjunction with `PropertyEditor` instances to convert properties from one format to another.--> <!--However, most Spring users do not work with these classes directly (that is, programmatically) but rather with XML `bean` definitions, annotated components (that is, classes annotated with `@Component`, `@Controller`, and so forth), or `@Bean` methods in Java-based `@Configuration` classes.--> <!--These sources are then converted internally into instances of `BeanDefinition` and used to load an entire Spring IoC container instance.--><p>基于setter的DI是在调用无参数构造函数或无参数“静态”工厂方法来实例化bean之后，通过容器调用bean上的setter方法来完成的。</p><p>您可以将依赖项配置为“BeanDefinition”的形式，并将其与“PropertyEditor”实例结合使用，将属性从一种格式转换为另一种格式。</p><p>但是，大多数Spring用户并不直接使用这些类(也就是说，以编程的方式)，而是使用XML ‘ bean ‘定义、带注释的组件(也就是说，使用’ @Component ‘、’ @Controller ‘等注释的类)或基于java的’ @Configuration ‘类中的’ @Bean ‘方法。</p><p>然后，这些源在内部转换为“BeanDefinition”实例，并用于加载整个Spring IoC容器实例。</p><p><strong>Constructor-based or setter-based DI?</strong></p><blockquote><p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-required-annotation" target="_blank" rel="noopener">@Required</a> annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.</p><p>The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not <code>null</code>. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p><p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#jmx" target="_blank" rel="noopener">JMX MBeans</a> is therefore a compelling use case for setter injection.</p></blockquote><h4 id="Dependency-Resolution-Process-依赖解析过程"><a href="#Dependency-Resolution-Process-依赖解析过程" class="headerlink" title="Dependency Resolution Process (依赖解析过程)"></a>Dependency Resolution Process (依赖解析过程)</h4><p>ApplicationContext(configuration metadata)  -&gt; 注入方式 -&gt; 注入value初始化 -&gt; value-type</p><p>The container performs bean dependency resolution as follows:</p><ul><li>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.(配置元信息)</li><li>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created. (注入方式)</li><li>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.(value)</li><li>Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as <code>int</code>, <code>long</code>, <code>String</code>, <code>boolean</code>, and so forth.(value-type)</li></ul><h5 id="Circular-dependencies-循环依赖问题"><a href="#Circular-dependencies-循环依赖问题" class="headerlink" title="Circular dependencies (循环依赖问题)"></a>Circular dependencies (循环依赖问题)</h5><blockquote><p>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.</p><p>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. </p><p>If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a <code>BeanCurrentlyInCreationException</code>.</p><p>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. </p><p>In other words, although it is not recommended, you can configure circular dependencies with setter injection.</p></blockquote><p>如果主要使用构造函数注入，可能会创建无法解析的循环依赖场景。</p><p>例如:类A需要一个类B通过构造函数注入的实例，而类B需要一个类A通过构造函数注入的实例。</p><p>如果您将bean配置为类A和B相互注入，Spring IoC容器会在运行时检测到这个循环引用，并抛出一个“BeanCurrentlyInCreationException”。</p><p>一种可能的解决方案是编辑某些类的源代码，由setter而不是构造函数来配置。另外，避免构造函数注入，只使用setter注入。</p><p>换句话说，尽管不建议这样做，但您可以使用setter注入配置循环依赖项。</p><h5 id="pre-instantiate-预实例化可以提早发现错误"><a href="#pre-instantiate-预实例化可以提早发现错误" class="headerlink" title="pre-instantiate (预实例化可以提早发现错误)"></a>pre-instantiate (预实例化可以提早发现错误)</h5><!--This potentially delayed visibility of some configuration issues is why `ApplicationContext` implementations by default pre-instantiate singleton beans.--> <!--At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the `ApplicationContext` is created, not later--><p>这可能会延迟某些配置问题的可见性，这就是为什么默认情况下ApplicationContext实现会预先实例化单例bean的原因。</p><p>在实际需要使用这些bean之前要花一些前期时间和内存，您会在创建ApplicationContext时发现配置问题，而不是稍后。</p><h5 id="collaborating-被装载的是完整实例"><a href="#collaborating-被装载的是完整实例" class="headerlink" title="collaborating (被装载的是完整实例)"></a>collaborating (被装载的是完整实例)</h5><!--If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean.--> <!--This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A.--> <!--In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a [configured init method](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) or the [InitializingBean callback method](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)) are invoked.--><p>如果不存在循环依赖项，那么当一个或多个协作bean被注入一个依赖bean时，每个协作bean在被注入依赖bean之前都要完全配置好。</p><p>这意味着，如果bean A依赖于bean B，那么Spring IoC容器将在调用bean A的setter方法之前完全配置bean B。</p><p>换句话说，bean被实例化(如果它不是一个预实例化的单例对象)，它的依赖项被设置，相关的生命周期方法(例如配置的init方法或InitializingBean回调方法)被调用。</p><h4 id="Examples-of-Dependency-Injection"><a href="#Examples-of-Dependency-Injection" class="headerlink" title="Examples of Dependency Injection"></a><del>Examples of Dependency Injection</del></h4><h3 id="Dependencies-and-Configuration-in-Detail"><a href="#Dependencies-and-Configuration-in-Detail" class="headerlink" title="Dependencies and Configuration in Detail"></a><del>Dependencies and Configuration in Detail</del></h3><h3 id="Using-depends-on-使用-depends-on"><a href="#Using-depends-on-使用-depends-on" class="headerlink" title="Using depends-on (使用 depends-on)"></a>Using depends-on (使用 depends-on)</h3><!--The depends-on attribute can specify both an initialization-time dependency and, in the case of singleton beans only, a corresponding destruction-time dependency. Dependent beans that define a depends-on relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus, depends-on can also control shutdown order.--><p>能控制加载顺序</p><h3 id="Lazy-initialized-Beans-懒加载"><a href="#Lazy-initialized-Beans-懒加载" class="headerlink" title="Lazy-initialized Beans (懒加载)"></a>Lazy-initialized Beans (懒加载)</h3><!--By default, `ApplicationContext` implementations eagerly create and configure all singleton beans as part of the initialization process.--> <!--Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later.--> <!--When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.--><p>默认情况下，“ApplicationContext”实现会在初始化过程中创建并配置所有的单例bean。</p><p>通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几小时甚至几天之后。</p><p>当此行为不可取时，您可以通过将bean定义标记为延迟初始化来防止单例bean的预实例化。延迟初始化的bean告诉IoC容器在第一次请求时创建bean实例，而不是在启动时。</p><!--However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized, the `ApplicationContext` creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.--><!--You can also control lazy-initialization at the container level by using the `default-lazy-init` attribute on the `<beans/>` element--><p>但是，如果延迟初始化的bean是未延迟初始化的单例bean的依赖项，则ApplicationContext会在启动时创建延迟初始化的bean，因为它必须满足单例的依赖项。延迟初始化的bean被注入到其他未延迟初始化的单例bean中。</p><p>另外还可以容器级别的配置懒加载</p><p>注:使用@Lazy , 在需要注入到其他not lazy的bean的时候 使用@Autowire的话 在上面标注@Lazy 会延迟初始化</p><pre><code class="java">@Lazy@Componentclass LazyBean{   @PostConstruct           public void init(){               System.out.prinlt(&quot;init...&quot;);           }}@Componentclass NotLazyBean{       @Lazy       @Autowise               LazyBean lazyBean;}</code></pre><p>会在实际使用lazyBean的时候才实例</p><h3 id="Autowiring-Collaborators-自动装配"><a href="#Autowiring-Collaborators-自动装配" class="headerlink" title="Autowiring Collaborators(自动装配)"></a>Autowiring Collaborators(自动装配)</h3><p> Autowiring has the following advantages:</p><ul><li>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-child-bean-definitions" target="_blank" rel="noopener">discussed elsewhere in this chapter</a> are also valuable in this regard.)</li><li>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</li></ul><p>译:</p><ul><li>自动装配可以大大减少指定属性或构造函数参数的需要。(其他机制，如bean模板<a href="https://docs.spring.io/spring-framework/docs/current/spring-framereference/core.html #beans-child-bean-definitions" target="_blank" rel="noopener">在本章其他地方讨论过</a>在这方面也很有价值。)</li><li>自动装配可以随着对象的演化更新配置。例如，如果需要向类添加依赖项，则可以自动满足该依赖项，而不需要修改配置。因此，自动装配在开发过程中特别有用，当代码库变得更加稳定时，自动装配可以避免切换到显式连接的选项。</li></ul><table><thead><tr><th style="text-align:left">Mode</th><th style="text-align:left">Explanation</th></tr></thead><tbody><tr><td style="text-align:left"><code>no</code></td><td style="text-align:left">(Default) No autowiring. Bean references must be defined by <code>ref</code> elements. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.</td></tr><tr><td style="text-align:left"><code>byName</code></td><td style="text-align:left">Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a <code>master</code> property (that is, it has a <code>setMaster(..)</code> method), Spring looks for a bean definition named <code>master</code> and uses it to set the property.</td></tr><tr><td style="text-align:left"><code>byType</code></td><td style="text-align:left">Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use <code>byType</code> autowiring for that bean. If there are no matching beans, nothing happens (the property is not set).</td></tr><tr><td style="text-align:left"><code>constructor</code></td><td style="text-align:left">Analogous to <code>byType</code> but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.</td></tr></tbody></table><h4 id="Limitations-and-Disadvantages-of-Autowiring-自动装配的局限性和缺点"><a href="#Limitations-and-Disadvantages-of-Autowiring-自动装配的局限性和缺点" class="headerlink" title="Limitations and Disadvantages of Autowiring (自动装配的局限性和缺点)"></a>Limitations and Disadvantages of Autowiring (自动装配的局限性和缺点)</h4><p>Consider the limitations and disadvantages of autowiring:</p><ul><li>Explicit dependencies in <code>property</code> and <code>constructor-arg</code> settings always override autowiring. You cannot autowire simple properties such as primitives, <code>Strings</code>, and <code>Classes</code> (and arrays of such simple properties). This limitation is by-design.</li><li>Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results. The relationships between your Spring-managed objects are no longer documented explicitly.</li><li>Wiring information may not be available to tools that may generate documentation from a Spring container.</li><li>Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or <code>Map</code> instances, this is not necessarily a problem. However, for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.</li></ul><p>In the latter scenario, you have several options:</p><ul><li>Abandon autowiring in favor of explicit wiring.</li><li>Avoid autowiring for a bean definition by setting its <code>autowire-candidate</code> attributes to <code>false</code>, as described in the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire-candidate" target="_blank" rel="noopener">next section</a>.</li><li>Designate a single bean definition as the primary candidate by setting the <code>primary</code> attribute of its <code>&lt;bean/&gt;</code> element to <code>true</code>.</li><li>Implement the more fine-grained control available with annotation-based configuration, as described in <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-annotation-config" target="_blank" rel="noopener">Annotation-based Container Configuration</a>.</li></ul><p>使用自动装配 ,可能不那么精确, 会导致一些问题</p><h4 id="Excluding-a-Bean-from-Autowiring-从自动装配中排除Bean"><a href="#Excluding-a-Bean-from-Autowiring-从自动装配中排除Bean" class="headerlink" title="Excluding a Bean from Autowiring(从自动装配中排除Bean)"></a>Excluding a Bean from Autowiring(从自动装配中排除Bean)</h4><!--On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the `autowire-candidate` attribute of the `<bean/>` element to `false`. The container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as [`@Autowired`](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-annotation)).--><p>在每个bean的基础上，可以将bean排除在自动装配之外。在Spring的XML格式中，将“”元素的“autowire-candidate”属性设置为“false”。容器使特定的bean定义对自动装配基础设施不可用(包括注释样式配置，如<a href="https://docs.spring.io/spring-framework/docs/current/spring-framereference/core.html #beans-autowired-annotation" target="_blank" rel="noopener">‘ @Autowired ‘</a>)。</p><h3 id="Method-Injection-方法注入"><a href="#Method-Injection-方法注入" class="headerlink" title="Method Injection (方法注入)"></a>Method Injection (方法注入)</h3><!--Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties.--> <!--A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean("B") call to the container ask for (a typically new) bean B instance every time bean A needs it.--><p>假设单例bean A需要使用非单例(原型)bean B，可能是在A的每个方法调用上。容器只创建一次单例bean A，因此只有一次机会来设置属性。</p><p>解决的办法是放弃一些控制反转。您可以通过实现applicationcontext - ware接口，并在每次bean A需要时调用容器的getBean(“B”)来请求(通常是一个新的)bean B实例，从而使bean A知道容器。</p><h4 id="Lookup-Method-Injection"><a href="#Lookup-Method-Injection" class="headerlink" title="Lookup Method Injection"></a>Lookup Method Injection</h4><!--Lookup method injection is the ability of the container to override methods on container-managed beans and return the lookup result for another named bean in the container.--> <!--The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to dynamically generate a subclass that overrides the method.--><p>查找方法注入是容器覆盖容器管理bean上的方法 并返回容器中另一个命名bean的查找结果的能力。</p><p>Spring框架通过使用来自CGLIB库的字节码生成来动态生成覆盖该方法的子类，从而实现了这种方法注入。</p><p>ex</p><h4 id="Arbitrary-任意的-Method-Replacement"><a href="#Arbitrary-任意的-Method-Replacement" class="headerlink" title="Arbitrary (任意的)Method Replacement"></a><del>Arbitrary (任意的)Method Replacement</del></h4><!--A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation.--> <p>与查找方法注入相比，一种不太有用的方法注入形式是能够用另一种方法实现替换托管bean中的任意方法。</p><h2 id="🌟Bean-Scopes-（作用域）"><a href="#🌟Bean-Scopes-（作用域）" class="headerlink" title="🌟Bean Scopes  （作用域）"></a>🌟Bean Scopes  （作用域）</h2><p>关键词: singleton、prototype、request、session、application、websocket 、cglib public</p><!--You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition but also control the scope of the objects created from a particular bean definition--><p>您不仅可以控制要插入到由特定bean定义创建的对象中的各种依赖项和配置值，还可以控制由特定bean定义创建的对象的范围</p><table><thead><tr><th style="text-align:left">Scope</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a></td><td style="text-align:left">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype" target="_blank" rel="noopener">prototype</a></td><td style="text-align:left">Scopes a single bean definition to any number of object instances.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-request" target="_blank" rel="noopener">request</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-session" target="_blank" rel="noopener">session</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-application" target="_blank" rel="noopener">application</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#websocket-stomp-websocket-scope" target="_blank" rel="noopener">websocket</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr></tbody></table><h3 id="The-Singleton-Scope"><a href="#The-Singleton-Scope" class="headerlink" title="The Singleton Scope"></a>The Singleton Scope</h3><!--To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition.--> <!--This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that named bean return the cached object--><p>换句话说，当您定义一个bean定义并将其定义为一个单例对象时，Spring IoC容器只创建该bean定义定义的对象的一个实例。</p><p>此单一实例存储在此类单例bean的缓存中，该指定bean的所有后续请求和引用都将返回缓存的对象</p><!--Spring’s concept of a singleton bean differs from the singleton pattern as defined in the Gang of Four (GoF) patterns book.--> <!--The GoF singleton hard-codes the scope of an object such that one and only one instance of a particular class is created per ClassLoader--><p>Spring的单例bean概念与Gang of Four(GoF)模式书中定义的单例模式不同。</p><p>单例对象对对象的作用域进行硬编码，这样每个类装入器只能创建一个特定类的实例</p><h3 id="The-Prototype-Scope"><a href="#The-Prototype-Scope" class="headerlink" title="The Prototype Scope"></a>The Prototype Scope</h3><!--As a rule, you should use the prototype scope for all stateful beans and the singleton scope for stateless beans.--><!--In some respects, the Spring container’s role in regard to a prototype-scoped bean is a replacement for the Java `new` operator.--> <p>通常，您应该为所有有状态bean使用原型范围，为无状态bean使用单例范围。</p><p>在某些方面，Spring容器在原型作用域bean方面的作用是替代Java“new”操作符。</p><h3 id="Singleton-Beans-with-Prototype-bean-Dependencies"><a href="#Singleton-Beans-with-Prototype-bean-Dependencies" class="headerlink" title="Singleton Beans with Prototype-bean Dependencies"></a><del>Singleton Beans with Prototype-bean Dependencies</del></h3><h3 id="Request-Session-Application-and-WebSocket-Scopes"><a href="#Request-Session-Application-and-WebSocket-Scopes" class="headerlink" title="Request, Session, Application, and WebSocket Scopes"></a>Request, Session, Application, and WebSocket Scopes</h3><h4 id="Request-scope"><a href="#Request-scope" class="headerlink" title="Request scope"></a>Request scope</h4><!--You can change the internal state of the instance that is created as much as you want, because other instances created from the same `loginAction` bean definition do not see these changes in state.--> <p>您可以随意更改创建的实例的内部状态，因为从相同的“loginAction”bean定义创建的其他实例在状态中看不到这些更改。</p><h4 id="Session-Scope"><a href="#Session-Scope" class="headerlink" title="Session Scope"></a>Session Scope</h4> <!--As with request-scoped beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP `Session` instances that are also using instances created from the same `userPreferences` bean definition do not see these changes in state, because they are particular to an individual HTTP `Session`.--><p>与请求范围内bean一样,你可以改变内部状态的实例创建尽可能多的你想要的,知道其他HTTP会话的实例也使用相同的实例创建的userPreferences bean定义看不到这些变化状态,因为他们是特定的一个单独的HTTP会话的。</p><h4 id="Application-Scope"><a href="#Application-Scope" class="headerlink" title="Application Scope"></a>Application Scope</h4><!--This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton per `ServletContext`, not per Spring 'ApplicationContext' (for which there may be several in any given web application), and it is actually exposed and therefore visible as a `ServletContext` attribute.--><p>这有点类似于spring单例bean,但在两个重要方面不同: 它是一个单例每ServletContext,不是每个spring ApplicationContext的(可能有几个在任何给定的web应用程序),它实际上是暴露,因此可见“ServletContext”属性。</p><h4 id="Scoped-Beans-as-Dependencies"><a href="#Scoped-Beans-as-Dependencies" class="headerlink" title="Scoped Beans as Dependencies"></a>Scoped Beans as Dependencies</h4><!--The Spring IoC container manages not only the instantiation of your objects (beans), but also the wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request-scoped bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in place of the scoped bean.--><p>Spring IoC容器不仅管理对象(bean)的实例化，还管理协作者(或依赖项)的连接。如果您想将(例如)一个HTTP请求作用域的bean注入到另一个更长的作用域的bean中，您可以选择注入一个AOP代理来代替作用域的bean。</p><p>Choosing the Type of Proxy to Create</p><blockquote><p>CGLIB proxies intercept only public method calls! Do not call non-public methods on such a proxy. They are not delegated to the actual scoped target object.</p></blockquote><h3 id="Custom-Scopes"><a href="#Custom-Scopes" class="headerlink" title="Custom Scopes"></a><del>Custom Scopes</del></h3><h2 id="🌟Customizing-the-Nature-of-a-Bean-bean扩展点"><a href="#🌟Customizing-the-Nature-of-a-Bean-bean扩展点" class="headerlink" title="🌟Customizing the Nature of a Bean(bean扩展点)"></a>🌟Customizing the Nature of a Bean(bean扩展点)</h2><p>关键词: lifecycle callback; aware; </p><p>The Spring Framework provides a number of interfaces you can use to customize the nature of a bean. This section groups them as follows:</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle" target="_blank" rel="noopener">Lifecycle Callbacks</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aware-list" target="_blank" rel="noopener">Other <code>Aware</code> Interfaces</a></li></ul><h3 id="Lifecycle-Callbacks-生命周期回调"><a href="#Lifecycle-Callbacks-生命周期回调" class="headerlink" title="Lifecycle Callbacks (生命周期回调)"></a>Lifecycle Callbacks (生命周期回调)</h3><!--Internally, the Spring Framework uses `BeanPostProcessor` implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not by default offer, you can implement a `BeanPostProcessor` yourself. For more information, see [Container Extension Points](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension).--><p>在内部，Spring框架使用“BeanPostProcessor”实现来处理它能找到并调用适当方法的任何回调接口。如果您需要自定义特性或Spring默认不提供的其他生命周期行为，您可以自己实现一个“BeanPostProcessor”。有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/current/spring-framereference/core.html #beans-factory-extension" target="_blank" rel="noopener">容器扩展点</a>。</p><ul><li>spring 接口 耦合  <code>InitializingBean</code>，<code>DisposableBean</code></li><li>JSR-250 @PostConstruct 或 init-method   @PreDestroy或 destroy-method</li><li><code>Lifecycle</code></li></ul><h4 id="Initialization-Callbacks"><a href="#Initialization-Callbacks" class="headerlink" title="Initialization Callbacks"></a>Initialization Callbacks</h4><pre><code>public class AnotherExampleBean implements InitializingBean {    @Override    public void afterPropertiesSet() {        // do some initialization work    }}</code></pre><h4 id="Destruction-Callbacks"><a href="#Destruction-Callbacks" class="headerlink" title="Destruction Callbacks"></a>Destruction Callbacks</h4><pre><code>public class AnotherExampleBean implements DisposableBean {    @Override    public void destroy() {        // do some destruction work (like releasing pooled connections)    }}</code></pre><h4 id="Default-Initialization-and-Destroy-Methods"><a href="#Default-Initialization-and-Destroy-Methods" class="headerlink" title="Default Initialization and Destroy Methods"></a>Default Initialization and Destroy Methods</h4><ul><li>default-init-method</li><li>default-destroy-method</li></ul><h4 id="Combining-Lifecycle-Mechanisms"><a href="#Combining-Lifecycle-Mechanisms" class="headerlink" title="Combining Lifecycle Mechanisms"></a>Combining Lifecycle Mechanisms</h4><p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior:</p><ul><li>The <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener"><code>InitializingBean</code></a> and <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener"><code>DisposableBean</code></a> callback interfaces</li><li>Custom <code>init()</code> and <code>destroy()</code> methods</li><li>The <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations" target="_blank" rel="noopener"><code>@PostConstruct</code> and <code>@PreDestroy</code> annotations</a>. You can combine these mechanisms to control a given bean.</li></ul><h4 id="Startup-and-Shutdown-Callbacks"><a href="#Startup-and-Shutdown-Callbacks" class="headerlink" title="Startup and Shutdown Callbacks"></a>Startup and Shutdown Callbacks</h4><h5 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h5><pre><code class="java">public interface Lifecycle {    void start();    void stop();    boolean isRunning();}</code></pre><h5 id="LifecycleProcessor"><a href="#LifecycleProcessor" class="headerlink" title="LifecycleProcessor"></a>LifecycleProcessor</h5><pre><code class="java">public interface LifecycleProcessor extends Lifecycle {    void onRefresh();    void onClose();}</code></pre><h5 id="Phased"><a href="#Phased" class="headerlink" title="Phased"></a>Phased</h5><!--The order of startup and shutdown invocations can be important. If a “depends-on” relationship exists between any two objects, the dependent side starts after its dependency, and it stops before its dependency. However, at times, the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type.--><p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在“依赖关系”，依赖方在依赖后开始，在依赖前停止。然而，有时，直接依赖关系是未知的。您可能只知道某种类型的对象应该先于另一种类型的对象启动。</p><pre><code class="java">public interface Phased {    int getPhase();}</code></pre><h4 id="Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><a href="#Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications" class="headerlink" title="Shutting Down the Spring IoC Container Gracefully in Non-Web Applications"></a>Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h4><!--If you use Spring’s IoC container in a non-web application environment (for example, in a rich client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. You must still configure and implement these destroy callbacks correctly.--><p>如果您在非web应用程序环境(例如，在客户机桌面环境中)中使用Spring的IoC容器，请向JVM注册一个关闭挂钩。这样做可以确保优雅地关闭并调用单例bean上的相关销毁方法，以便释放所有资源。您仍然必须正确配置和实现这些销毁回调。</p><p>registerShutdownHook()</p><h3 id="ApplicationContextAware-and-BeanNameAware"><a href="#ApplicationContextAware-and-BeanNameAware" class="headerlink" title="ApplicationContextAware and BeanNameAware"></a><code>ApplicationContextAware</code> and <code>BeanNameAware</code></h3><h4 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h4><pre><code class="java">public interface ApplicationContextAware {    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;}</code></pre><h4 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h4><pre><code class="java">public interface BeanNameAware {    void setBeanName(String name) throws BeansException;}</code></pre><h3 id="Other-Aware-Interfaces"><a href="#Other-Aware-Interfaces" class="headerlink" title="Other Aware Interfaces"></a>Other <code>Aware</code> Interfaces</h3><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Injected Dependency</th><th style="text-align:left">Explained in…</th></tr></thead><tbody><tr><td style="text-align:left"><code>ApplicationContextAware</code></td><td style="text-align:left">Declaring <code>ApplicationContext</code>.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr><tr><td style="text-align:left"><code>ApplicationEventPublisherAware</code></td><td style="text-align:left">Event publisher of the enclosing <code>ApplicationContext</code>.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-introduction" target="_blank" rel="noopener">Additional Capabilities of the <code>ApplicationContext</code></a></td></tr><tr><td style="text-align:left"><code>BeanClassLoaderAware</code></td><td style="text-align:left">Class loader used to load the bean classes.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class" target="_blank" rel="noopener">Instantiating Beans</a></td></tr><tr><td style="text-align:left"><code>BeanFactoryAware</code></td><td style="text-align:left">Declaring <code>BeanFactory</code>.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr><tr><td style="text-align:left"><code>BeanNameAware</code></td><td style="text-align:left">Name of the declaring bean.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-aware" target="_blank" rel="noopener"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr><tr><td style="text-align:left"><code>BootstrapContextAware</code></td><td style="text-align:left">Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in JCA-aware <code>ApplicationContext</code> instances.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#cci" target="_blank" rel="noopener">JCA CCI</a></td></tr><tr><td style="text-align:left"><code>LoadTimeWeaverAware</code></td><td style="text-align:left">Defined weaver for processing class definition at load time.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-aj-ltw" target="_blank" rel="noopener">Load-time Weaving with AspectJ in the Spring Framework</a></td></tr><tr><td style="text-align:left"><code>MessageSourceAware</code></td><td style="text-align:left">Configured strategy for resolving messages (with support for parametrization and internationalization).</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-introduction" target="_blank" rel="noopener">Additional Capabilities of the <code>ApplicationContext</code></a></td></tr><tr><td style="text-align:left"><code>NotificationPublisherAware</code></td><td style="text-align:left">Spring JMX notification publisher.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#jmx-notifications" target="_blank" rel="noopener">Notifications</a></td></tr><tr><td style="text-align:left"><code>ResourceLoaderAware</code></td><td style="text-align:left">Configured loader for low-level access to resources.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#resources" target="_blank" rel="noopener">Resources</a></td></tr><tr><td style="text-align:left"><code>ServletConfigAware</code></td><td style="text-align:left">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">Spring MVC</a></td></tr><tr><td style="text-align:left"><code>ServletContextAware</code></td><td style="text-align:left">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td><td style="text-align:left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">Spring MVC</a></td></tr></tbody></table><!--Note again that using these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As a result, we recommend them for infrastructure beans that require programmatic access to the container.--><p>再次注意，使用这些接口将您的代码绑定到Spring API，并且不遵循控制反转样式。因此，我们建议将它们用于需要对容器进行编程访问的基础设施bean。</p><h2 id="Bean-Definition-Inheritance-定义继承"><a href="#Bean-Definition-Inheritance-定义继承" class="headerlink" title="Bean Definition Inheritance (定义继承)"></a><del>Bean Definition Inheritance (定义继承)</del></h2><h2 id="🌟Container-Extension-Points-（容器扩展点）"><a href="#🌟Container-Extension-Points-（容器扩展点）" class="headerlink" title="🌟Container Extension Points （容器扩展点）"></a>🌟Container Extension Points （容器扩展点）</h2><p>关键词 : bean; beanPostProcessor;Metadata ;BeanFactoryPostProcessor;FactoryBean; scoped per-container</p><h3 id="Customizing-Beans-by-Using-a-BeanPostProcessor"><a href="#Customizing-Beans-by-Using-a-BeanPostProcessor" class="headerlink" title="Customizing Beans by Using a BeanPostProcessor"></a>Customizing Beans by Using a BeanPostProcessor</h3><p>//一般用于自定义构造bean, 处理注解 (通用注解 和 自定义注解)</p><!--The `BeanPostProcessor` interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth.--> <!--If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom `BeanPostProcessor` implementations.--><!--You can configure multiple `BeanPostProcessor` instances, and you can control the order in which these `BeanPostProcessor` instances execute by setting the `order` property. You can set this property only if the `BeanPostProcessor` implements the `Ordered` interface.--> <p>BeanPostProcessor接口定义了回调方法，您可以实现这些回调方法来提供自己的(或覆盖容器的默认)实例化逻辑、依赖项解析逻辑等等。</p><p>如果希望在Spring容器完成实例化、配置和初始化bean之后实现一些自定义逻辑，可以插入一个或多个自定义BeanPostProcessor实现。</p><p>您可以配置多个BeanPostProcessor实例，并且可以通过设置order属性来控制这些BeanPostProcessor实例的执行顺序。只有在BeanPostProcessor实现有序接口时才能设置此属性。</p><!--the `org.springframework.beans.factory.config.BeanPostProcessor` interface consists of exactly two callback methods--><!--When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as `InitializingBean.afterPropertiesSet()` or any declared `init` method) are called, and after any bean initialization callbacks.--><!--The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces, or it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.--><p>org.springframework.beans.factory.config。BeanPostProcessor接口正好由两个回调方法组成。</p><p>当这样一个类注册为后处理器的容器,每个容器创建bean实例,后处理器从容器之前得到一个回调容器初始化方法(如InitializingBean.afterPropertiesSet()或任何宣布init方法),任何bean初始化后回调。</p><p>后处理器可以对bean实例采取任何操作，包括完全忽略回调。bean后处理器通常检查回调接口，或者使用代理包装bean。为了提供代理包装逻</p><p><code>BeanPostProcessor</code> instances and AOP auto-proxying</p><!--Classes that implement the `BeanPostProcessor` interface are special and are treated differently by the container.--> <!--All `BeanPostProcessor` instances and beans that they directly reference are instantiated on startup, as part of the special startup phase of the `ApplicationContext`.--> <!--Next, all `BeanPostProcessor` instances are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a `BeanPostProcessor` itself, neither `BeanPostProcessor` instances nor the beans they directly reference are eligible for auto-proxying and, thus, do not have aspects woven into them.--><!--For any such bean, you should see an informational log message: `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`.--><p>实现“BeanPostProcessor”接口的类是特殊的，容器会以不同的方式对待它们。</p><p>它们直接引用的所有“BeanPostProcessor”实例和bean在启动时实例化，作为“ApplicationContext”的特殊启动阶段的一部分。</p><p>接下来，以排序的方式注册所有’ BeanPostProcessor ‘实例，并将其应用于容器中所有后续的bean。因为AOP自动代理是作为“BeanPostProcessor”本身实现的，所以无论是“BeanPostProcessor”实例还是它们直接引用的bean都没有资格进行自动代理，因此没有将方面融入到它们之中。</p><p>对于任何这样的bean，您应该看到一条信息日志消息:“bean someBean不适合被所有BeanPostProcessor接口处理(例如: not eligible for auto-proxying)”。</p><pre><code class="java">public interface BeanPostProcessor {   @Nullable   default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {      return bean;   }   @Nullable   default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {      return bean;   }}</code></pre><h3 id="Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor"><a href="#Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor" class="headerlink" title="Customizing Configuration Metadata with a BeanFactoryPostProcessor"></a>Customizing Configuration Metadata with a BeanFactoryPostProcessor</h3><p>//一般应用用于配置文件的解析 , 占位符的替换 </p><!--The semantics of this interface are similar to those of the `BeanPostProcessor`, with one major difference: `BeanFactoryPostProcessor` operates on the bean configuration metadata.--> <!--That is, the Spring IoC container lets a `BeanFactoryPostProcessor` read the configuration metadata and potentially change it *before* the container instantiates any beans other than `BeanFactoryPostProcessor` instances.--><!--You can configure multiple `BeanFactoryPostProcessor` instances, and you can control the order in which these `BeanFactoryPostProcessor` instances run by setting the `order` property. However, you can only set this property if the `BeanFactoryPostProcessor` implements the `Ordered` interface.--><p>这个接口的语义与“BeanPostProcessor”的语义类似，但有一个主要区别:“BeanFactoryPostProcessor”操作bean配置元数据。</p><p>也就是说，Spring IoC容器允许“BeanFactoryPostProcessor”读取配置元数据，并可能在容器实例化除“BeanFactoryPostProcessor”实例之外的任何bean之前更改它。</p><p>您可以配置多个’ BeanFactoryPostProcessor ‘实例，并且可以通过设置’ order ‘属性来控制这些’ BeanFactoryPostProcessor ‘实例的运行顺序。但是，只有在’ BeanFactoryPostProcessor ‘实现’ Ordered ‘接口时才能设置此属性。</p><pre><code class="java">@FunctionalInterfacepublic interface BeanFactoryPostProcessor {   /**    * Modify the application context&#39;s internal bean factory after its standard    * initialization. All bean definitions will have been loaded, but no beans    * will have been instantiated yet. This allows for overriding or adding    * properties even to eager-initializing beans.    * @param beanFactory the bean factory used by the application context    * @throws org.springframework.beans.BeansException in case of errors    */   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;}</code></pre><p>Spring includes a number of predefined bean factory post-processors, such as <code>PropertyOverrideConfigurer</code> and <code>PropertySourcesPlaceholderConfigurer</code>. </p><h4 id="PropertySourcesPlaceholderConfigurer"><a href="#PropertySourcesPlaceholderConfigurer" class="headerlink" title="PropertySourcesPlaceholderConfigurer"></a>PropertySourcesPlaceholderConfigurer</h4><!--At runtime, a `PropertySourcesPlaceholderConfigurer` is applied to the metadata that replaces some properties of the DataSource.--><!--The `PropertySourcesPlaceholderConfigurer` not only looks for properties in the `Properties` file you specify. By default, if it cannot find a property in the specified properties files, it checks against Spring `Environment` properties and regular Java `System` properties.--><p>在运行时，’ PropertySourcesPlaceholderConfigurer ‘应用于替代数据源的某些属性的元数据。</p><p>‘ PropertySourcesPlaceholderConfigurer ‘不仅在您指定的’ properties ‘文件中查找属性。默认情况下，如果在指定的属性文件中找不到属性，它会检查Spring的“Environment”属性和常规的Java“System”属性。</p><h4 id="PropertyOverrideConfigurer"><a href="#PropertyOverrideConfigurer" class="headerlink" title="PropertyOverrideConfigurer"></a>PropertyOverrideConfigurer</h4><!--The `PropertyOverrideConfigurer`, another bean factory post-processor, resembles the `PropertySourcesPlaceholderConfigurer`, but unlike the latter, the original definitions can have default values or no values at all for bean properties.--> <!--If an overriding `Properties` file does not have an entry for a certain bean property, the default context definition is used.--><p>另一个bean工厂后处理器’ PropertyOverrideConfigurer ‘类似于’ PropertySourcesPlaceholderConfigurer ‘，但与后者不同，原始定义可以有缺省值，也可以没有bean属性的值。</p><p>如果覆盖的“属性”文件没有某个bean属性的条目，则使用默认的上下文定义。</p><h3 id="Customizing-Instantiation-Logic-with-a-FactoryBean"><a href="#Customizing-Instantiation-Logic-with-a-FactoryBean" class="headerlink" title="Customizing Instantiation Logic with a FactoryBean"></a>Customizing Instantiation Logic with a FactoryBean</h3><!--The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation logic.--> <!--If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container.--><p>FactoryBean接口是一个可插入Spring IoC容器实例化逻辑的点。</p><p>如果您有复杂的初始化代码，用Java表示比(可能的)冗长的XML更好，那么您可以创建自己的FactoryBean，在该类中编写复杂的初始化，然后将定制的FactoryBean插入容器中。</p><p>The <code>FactoryBean</code> interface provides three methods:</p><ul><li><code>Object getObject()</code>: Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.</li><li><code>boolean isSingleton()</code>: Returns <code>true</code> if this <code>FactoryBean</code> returns singletons or <code>false</code> otherwise.</li><li><code>Class getObjectType()</code>: Returns the object type returned by the <code>getObject()</code> method or <code>null</code> if the type is not known in advance.</li></ul><!--When you need to ask a container for an actual `FactoryBean` instance itself instead of the bean it produces, preface the bean’s `id` with the ampersand symbol (`&`) when calling the `getBean()` method of the `ApplicationContext`.--><p>当您需要向容器请求实际的“FactoryBean”实例本身而不是它所生成的bean时，</p><p>在调用“ApplicationContext”的“getBean()”方法时，在bean的“id”前面加上与符号(“&amp;”)。</p><h2 id="🌟Annotation-based-Container-Configuration-（基于注释的容器配置）"><a href="#🌟Annotation-based-Container-Configuration-（基于注释的容器配置）" class="headerlink" title="🌟Annotation-based Container Configuration （基于注释的容器配置）"></a>🌟Annotation-based Container Configuration （基于注释的容器配置）</h2><p>🔑关键词: configuration metadata; @Autowired ;@Order;@Primary;@Qulifier;@Resources;BeanPostProcessor</p><p>🕙Timeline:</p><ul><li>Spring 2.0 @required</li><li>Spring 2.5   @Autowired ,also JSR-250 annotations, such as <code>@PostConstruct</code> and <code>@PreDestroy</code>. </li><li>Spring 3.0  JSR-330 (Dependency Injection for Java) annotations contained in the <code>javax.inject</code> package such as <code>@Inject</code> and <code>@Named</code>. </li></ul><p>how to provide a lot of the configuration metadata through source-level annotations.</p><p>如何通过源级别的注解提供许多配置元数据。</p><p>can also be implicitly registered by including the following tag in an XML-based Spring configuration</p><pre><code class="xml">&lt;beans xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       ...&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;</code></pre><p>The implicitly registered post-processors include</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>AutowiredAnnotationBeanPostProcessor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>CommonAnnotationBeanPostProcessor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>PersistenceAnnotationBeanPostProcessor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>RequiredAnnotationBeanPostProcessor</code></a></li></ul><!--Annotation injection is performed before XML injection. Thus, the XML configuration overrides the annotations for properties wired through both approaches.--><p>注解注入在XML注入之前执行。 因此，XML配置将覆盖通过两种方法连接的属性的注释。</p><h3 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h3><!--The `@Required` annotation is formally deprecated(弃用) as of Spring Framework 5.1, in favor of using constructor injection for required settings (or a custom implementation of `InitializingBean.afterPropertiesSet()` along with bean property setter methods).--><p>从Spring Framework 5.1开始，正式弃用了@Required批注（弃用），以便使用构造函数注入进行必需的设置（或InitializingBean.afterPropertiesSet（）的自定义实现以及bean属性设置器方法）。</p><h3 id="Using-Autowired"><a href="#Using-Autowired" class="headerlink" title="Using @Autowired"></a>Using @Autowired</h3><ul><li>apply the <code>@Autowired</code> annotation to constructors</li><li>apply the <code>@Autowired</code> annotation to <em>traditional</em> setter methods</li><li>apply the annotation to methods with arbitrary names and multiple arguments</li><li>apply <code>@Autowired</code> to fields as well and even mix it with constructors</li></ul><!--As of Spring Framework 4.3, an `@Autowired` annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available, at least one must be annotated with `@Autowired` in order to instruct the container which one to use.--><p>从Spring Framework 4.3开始，如果目标bean仅定义一个构造函数作为开始，则不再需要在此类构造函数上使用@Autowired批注。 </p><p>但是，如果有几个构造函数可用，则至少一个必须用@Autowired注释，以指示容器使用哪个构造函数。</p><p>⚠️Ps:  自动装配注意 no type match found ,需要确保类型唯一</p><h4 id="Order"><a href="#Order" class="headerlink" title="@Order"></a>@<strong>Order</strong></h4><!--You can declare the `@Order` annotation at the target class level and on `@Bean` methods, potentially for individual bean definitions (in case of multiple definitions that use the same bean class). `@Order` values may influence priorities at injection points, but be aware that they do not influence singleton startup order, which is an orthogonal concern determined by dependency relationships and `@DependsOn` declarations.--><!--Note that the standard `javax.annotation.Priority` annotation is not available at the `@Bean` level, since it cannot be declared on methods. Its semantics can be modeled through `@Order` values in combination with `@Primary` on a single bean for each type.--><p>您可以在目标类级别和@Bean方法上声明@Order批注，这可能适用于单个bean定义（如果使用同一bean类的多个定义）。 @Order值可能会影响注入点的优先级，但请注意它们不会影响单例启动顺序，这是由依赖关系和@DependsOn声明确定的正交关注点 。</p><p>注意，标准javax.annotation.Priority注释在@Bean级别不可用，因为无法在方法上声明它。 它的语义可以通过@Order值与@Primary结合在每种类型的单个bean上进行建模。</p><h4 id="Java8-amp-spring-5-0"><a href="#Java8-amp-spring-5-0" class="headerlink" title="Java8 &amp; spring 5.0"></a><strong>Java8 &amp; spring 5.0</strong></h4><p>express the non-required nature of a particular dependency through Java 8’s <code>java.util.Optional</code></p><p>As of Spring Framework 5.0, you can also use a <code>@Nullable</code> annotation (of any kind in any package — for example, <code>javax.annotation.Nullable</code> from JSR-305)</p><!--the `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring `BeanPostProcessor` implementations.--> <!--This means that you cannot apply these annotations within your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any).--><p>Spring BeanPostProcessor实现处理@ Autowired，@ Inject，@ Value和@Resource批注。</p><p>  这意味着您不能在自己的BeanPostProcessor或BeanFactoryPostProcessor类型（如果有）中应用这些注释。</p><h3 id="Fine-tuning-微调-Annotation-based-Autowiring-with-Primary"><a href="#Fine-tuning-微调-Annotation-based-Autowiring-with-Primary" class="headerlink" title="Fine-tuning(微调) Annotation-based Autowiring with @Primary"></a>Fine-tuning(微调) Annotation-based Autowiring with @Primary</h3><p>当可以确定一个主要候选者时，@ Primary是在几种情况下按类型使用自动装配的有效方法。</p><h3 id="Fine-tuning-Annotation-based-Autowiring-with-Qualifiers"><a href="#Fine-tuning-Annotation-based-Autowiring-with-Qualifiers" class="headerlink" title="Fine-tuning Annotation-based Autowiring with Qualifiers"></a>Fine-tuning Annotation-based Autowiring with Qualifiers</h3><!--That said, if you intend to express annotation-driven injection by name, do not primarily use `@Autowired`, even if it is capable of selecting by bean name among type-matching candidates.--> <!--Instead, use the JSR-250 `@Resource` annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process.--><p>就是说，如果您打算按名称表示注释驱动的注入，则即使它能够在类型匹配的候选对象中按bean名称进行选择，也不要主要使用<code>@ Autowired</code>。</p><p>相反，请使用JSR-250<code>@ Resource</code>注释，该注释在语义上定义为通过其唯一名称标识特定目标组件，而声明的类型与匹配过程无关。</p><h3 id="Using-Generics-as-Autowiring-Qualifiers"><a href="#Using-Generics-as-Autowiring-Qualifiers" class="headerlink" title="Using Generics as Autowiring Qualifiers"></a>Using Generics as Autowiring Qualifiers</h3><!--In addition to the @Qualifier annotation, you can use Java generic types as an implicit form of qualification--><p>除了@Qualifier批注之外，您还可以使用Java泛型类型作为资格的隐式形式</p><h3 id="Using-CustomAutowireConfigurer"><a href="#Using-CustomAutowireConfigurer" class="headerlink" title="Using CustomAutowireConfigurer"></a>Using <code>CustomAutowireConfigurer</code></h3><!--[`CustomAutowireConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html) is a `BeanFactoryPostProcessor` that lets you register your own custom qualifier annotation types, even if they are not annotated with Spring’s `@Qualifier` annotation.--><p>CustomAutowireConfigurer是BeanFactoryPostProcessor，即使您没有使用Spring的@Qualifier批注进行批注，也可以让您注册自己的自定义批注批注类型。</p><p>@see org.springframework.beans.factory.annotation.CustomAutowireConfigurer</p><h3 id="Injection-with-Resource-JSR-250-amp-name"><a href="#Injection-with-Resource-JSR-250-amp-name" class="headerlink" title="Injection with @Resource (JSR-250 &amp; name)"></a>Injection with @Resource (JSR-250 &amp; name)</h3><!--Spring also supports injection by using the JSR-250 `@Resource` annotation (`javax.annotation.Resource`) on fields or bean property setter methods.--><!--`@Resource` takes a name attribute. By default, Spring interprets that value as the bean name to be injected.--> <p>Spring还通过在字段或bean属性设置器方法上使用JSR-250<code>@ Resource</code>批注（javax.annotation.Resource`）支持注入。</p><p>@Resource具有名称属性。 默认情况下，Spring将该值解释为要注入的Bean名称。</p><h3 id="Using-Value"><a href="#Using-Value" class="headerlink" title="Using @Value"></a>Using <code>@Value</code></h3><!--A default lenient embedded value resolver is provided by Spring. It will try to resolve the property value and if it cannot be resolved, the property name (for example `${catalog.name}`) will be injected as the value.--> <!--If you want to maintain strict control over nonexistent values, you should declare a `PropertySourcesPlaceholderConfigurer` bean--><p>Spring提供了一个默认的宽松内嵌值解析器。 它将尝试解析属性值，如果无法解析，则将属性名称（例如$ {catalog.name}）作为值注入。 </p><p>如果要严格控制不存在的值，则应声明一个PropertySourcesPlaceholderConfigurer bean</p><!--Using the above configuration ensures Spring initialization failure if any ${} placeholder could not be resolved. It is also possible to use methods like setPlaceholderPrefix, setPlaceholderSuffix, or setValueSeparator to customize placeholders.--><p>如果无法解析任何$ {}占位符，则使用上述配置可确保Spring初始化失败。 也可以使用setPlaceholderPrefix，setPlaceholderSuffix或setValueSeparator之类的方法来自定义占位符。</p><!--When configuring a `PropertySourcesPlaceholderConfigurer` using JavaConfig, the `@Bean` method must be `static`.--><!--Spring Boot configures by default a PropertySourcesPlaceholderConfigurer bean that will get properties from application.properties and application.yml files.--><p>当使用JavaConfig配置<code>PropertySourcesPlaceholderConfigurer</code>时，@Bean方法必须是静态的。</p><p>Spring Boot默认配置一个PropertySourcesPlaceholderConfigurer bean，它将从application.properties和application.yml文件获取属性。</p><!--A Spring `BeanPostProcessor` uses a `ConversionService` behind the scene to handle the process for converting the String value in `@Value` to the target type. If you want to provide conversion support for your own custom type, you can provide your own `ConversionService` bean instance--><p>Spring  BeanPostProcessor使用ConversionService来处理将@Value中的String值转换为目标类型的过程。 如果要为自己的自定义类型提供转换支持，则可以提供自己的<code>ConversionService</code> bean实例</p><p><strong>相关类</strong>:</p><p>@see org.springframework.core.convert.ConversionService</p><p>@see org.springframework.context.support.PropertySourcesPlaceholderConfigurer</p><h3 id="Using-PostConstruct-and-PreDestroy-JSR-250"><a href="#Using-PostConstruct-and-PreDestroy-JSR-250" class="headerlink" title="Using @PostConstruct and @PreDestroy (JSR-250)"></a>Using <code>@PostConstruct</code> and <code>@PreDestroy</code> (JSR-250)</h3><p>The <code>CommonAnnotationBeanPostProcessor</code> not only recognizes the <code>@Resource</code> annotation but also the JSR-250 lifecycle annotations: <code>javax.annotation.PostConstruct</code> and <code>javax.annotation.PreDestroy</code>.</p><h2 id="🌟Classpath-Scanning-and-Managed-Components"><a href="#🌟Classpath-Scanning-and-Managed-Components" class="headerlink" title="🌟Classpath Scanning and Managed Components"></a>🌟Classpath Scanning and Managed Components</h2><p>🔑关键词: @Component ;Stereotype Annotations; @ComponentScan; spring-context-indexer</p><!--Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the `@Configuration`, `@Bean`, `@Import`, and `@DependsOn` annotations for examples of how to use these new features.--><p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能是核心Spring Framework的一部分。这使您可以使用Java而不是使用传统的XML文件来定义bean。请看一下@ Configuration，@ Bean，@ Import和@DependsOn注释，以获取有关如何使用这些新功能的示例。</p><h3 id="Component-and-Further-Stereotype-Annotations-模式注解"><a href="#Component-and-Further-Stereotype-Annotations-模式注解" class="headerlink" title="@Component and Further Stereotype Annotations (模式注解)"></a><code>@Component</code> and Further Stereotype Annotations (模式注解)</h3><!--Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the `@Configuration`, `@Bean`, `@Import`, and `@DependsOn` annotations for examples of how to use these new features.--><p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能是核心Spring Framework的一部分。这使您可以使用Java而不是使用传统的XML文件来定义bean。请看一下@ Configuration，@ Bean，@ Import和@DependsOn注释，以获取有关如何使用这些新功能的示例。</p><!--The @Repository annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). Among the uses of this marker is the automatic translation of exceptions, as described in Exception Translation.--><!--Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers, respectively).--> <!--Therefore, you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework.--> <!--Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer.--><p>@Repository批注是实现存储库的角色或构造型（也称为数据访问对象或DAO）的任何类的标记。该标记的用途包括自动翻译异常，如“异常翻译”中所述。</p><p>Spring提供了进一步的构造型注释：@ Component，@ Service和@Controller。 @Component是任何Spring托管组件的通用构造型。 @ Repository，@ Service和@Controller是@Component的特化，用于更特定的用例（分别在持久层，服务层和表示层中）。</p><p>因此，您可以使用@Component来注释组件类，但是通过使用@ Repository，@ Service或@Controller来注释组件类，您的类更适合通过工具进行处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 @ Repository，@ Service和@Controller在Spring框架的将来版本中也可以带有其他语义。</p><p>因此，如果在服务层使用@Component或@Service之间进行选择，则@Service显然是更好的选择。同样，如前所述，@ Repository已被支持作为持久层中自动异常转换的标记。</p><h3 id="Using-Meta-annotations-and-Composed-Annotations-元注解"><a href="#Using-Meta-annotations-and-Composed-Annotations-元注解" class="headerlink" title="Using Meta-annotations and Composed Annotations(元注解)"></a>Using Meta-annotations and Composed Annotations(元注解)</h3><!--Many of the annotations provided by Spring can be used as meta-annotations in your own code. A meta-annotation is an annotation that can be applied to another annotation.For example, the @Service annotation mentioned earlier is meta-annotated with @Component--><p>Spring提供的许多注释都可以在您自己的代码中用作元注释。 元注释是可以应用于另一个注释的注释。 例如，前面提到的@Service注释使用@Component进行元注释。</p><h3 id="Automatically-Detecting-Classes-and-Registering-Bean-Definitions-自动检测类并注册Bean定义"><a href="#Automatically-Detecting-Classes-and-Registering-Bean-Definitions-自动检测类并注册Bean定义" class="headerlink" title="Automatically Detecting Classes and Registering Bean Definitions(自动检测类并注册Bean定义)"></a>Automatically Detecting Classes and Registering Bean Definitions(自动检测类并注册Bean定义)</h3><!--To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, where the basePackages attribute is a common parent package for the two classes.--><p>要自动检测这些类并注册相应的bean，您需要将@ComponentScan添加到@Configuration类中，其中basePackages属性是这两个类的公共父包。 （或者，您可以指定一个逗号分隔，分号分隔或空格分隔的列表，其中包括每个类的父包。）</p><p>The use of <code>&lt;context:component-scan&gt;</code> implicitly enables the functionality of <code>&lt;context:annotation-config&gt;</code>. There is usually no need to include the <code>&lt;context:annotation-config&gt;</code> element when using <code>&lt;context:component-scan&gt;</code>.</p><h3 id="Using-Filters-to-Customize-Scanning"><a href="#Using-Filters-to-Customize-Scanning" class="headerlink" title="Using Filters to Customize Scanning"></a>Using Filters to Customize Scanning</h3><p>Add them as <code>includeFilters</code> or <code>excludeFilters</code> attributes of the <code>@ComponentScan</code> annotation (or as <code>or</code> child elements of the <code></code> element in XML configuration). Each filter element requires the <code>type</code> and <code>expression</code> attributes. </p><p>Filter Type</p><ul><li><p>annotation (default)</p></li><li><p>assignable</p></li><li><p>aspectj</p></li><li><p>regex</p></li><li><p>custom</p></li></ul><h3 id="Defining-Bean-Metadata-within-Components-在组件中定义Bean元数据"><a href="#Defining-Bean-Metadata-within-Components-在组件中定义Bean元数据" class="headerlink" title="Defining Bean Metadata within Components(在组件中定义Bean元数据)"></a>Defining Bean Metadata within Components(在组件中定义Bean元数据)</h3><!--You may declare @Bean methods as static, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans (for example, of type BeanFactoryPostProcessor or BeanPostProcessor), since such beans get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point.--><p>您可以将@Bean方法声明为静态方法，从而允许在不将其包含配置类创建为实例的情况下调用它们。在定义后处理器Bean（例如BeanFactoryPostProcessor或BeanPostProcessor类型）时，这特别有意义，因为此类Bean在容器生命周期的早期进行了初始化，并且应避免在那时触发配置的其他部分。</p><!--Calls to static @Bean methods never get intercepted by the container, not even within @Configuration classes (as described earlier in this section), due to technical limitations: CGLIB subclassing can override only non-static methods. As a consequence, a direct call to another @Bean method has standard Java semantics, resulting in an independent instance being returned straight from the factory method itself.--><p>由于技术限制，对静态@Bean方法的调用永远不会被容器拦截，即使在@Configuration类中也是如此（如本节前面所述），由于技术限制：CGLIB子类只能覆盖非静态方法。结果，直接调用另一个@Bean方法具有标准的Java语义，从而导致直接从工厂方法本身直接返回一个独立的实例。</p><!--The Java language visibility of @Bean methods does not have an immediate impact on the resulting bean definition in Spring’s container. You can freely declare your factory methods as you see fit in non-@Configuration classes and also for static methods anywhere. However, regular @Bean methods in @Configuration classes need to be overridable — that is, they must not be declared as private or final.--><p>@Bean方法的Java语言可见性不会对Spring容器中的最终bean definition 产生直接影响。您可以在非@Configuration类中自由声明自己的工厂方法，也可以在任何地方声明静态方法。但是，@ Configuration类中的常规@Bean方法必须是可重写的—即，不得将它们声明为private或final。</p><h3 id="Naming-Autodetected-Components-命名自动检测的组件"><a href="#Naming-Autodetected-Components-命名自动检测的组件" class="headerlink" title="Naming Autodetected Components(命名自动检测的组件)"></a>Naming Autodetected Components(命名自动检测的组件)</h3><!--When a component is autodetected as part of the scanning process, its bean name is generated by the `BeanNameGenerator` strategy known to that scanne--> <!--If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the `BeanNameGenerator` interface, and be sure to include a default no-arg constructor.--> <p>当在扫描过程中自动检测到组件时，其bean名称由该scanne已知的<code>BeanNameGenerator</code>策略生成。</p><p>  如果您不想依赖默认的Bean命名策略，则可以提供自定义Bean命名策略。 首先，实现<code>BeanNameGenerator</code> 接口，并确保包含默认的无参数构造函数。</p><h4 id="Providing-a-Scope-for-Autodetected-Components-提供自动检测组件的作用域"><a href="#Providing-a-Scope-for-Autodetected-Components-提供自动检测组件的作用域" class="headerlink" title="Providing a Scope for Autodetected Components(提供自动检测组件的作用域)"></a>Providing a Scope for Autodetected Components(提供自动检测组件的作用域)</h4><!--To provide a custom strategy for scope resolution rather than relying on the annotation-based approach, you can implement the ScopeMetadataResolver interface.Be sure to include a default no-arg constructor.--> <p>要提供用于范围解析的自定义策略，而不是依赖于基于注释的方法，可以实现ScopeMetadataResolver接口。<br>确保包括默认的无参数构造函数。</p><h4 id="Providing-Qualifier-Metadata-with-Annotations"><a href="#Providing-Qualifier-Metadata-with-Annotations" class="headerlink" title="Providing Qualifier Metadata with Annotations"></a>P<del>roviding Qualifier Metadata with Annotations</del></h4><h4 id="Generating-an-Index-of-Candidate-Components-生成候选组件的索引"><a href="#Generating-an-Index-of-Candidate-Components-生成候选组件的索引" class="headerlink" title="Generating an Index of Candidate Components(生成候选组件的索引)"></a>Generating an Index of Candidate Components(生成候选组件的索引)</h4><p>While classpath scanning is very fast, it is possible to improve the startup performance of large applications by creating a static list of candidates at compilation time. In this mode, all modules that are target of component scan must use this mechanism.</p><p>加快扫描速度</p><h2 id="🌟Using-JSR-330-Standard-Annotations"><a href="#🌟Using-JSR-330-Standard-Annotations" class="headerlink" title="🌟Using JSR 330 Standard Annotations"></a>🌟Using JSR 330 Standard Annotations</h2><p>🔑关键词: javax.inject ; @Inject; @Named</p><h3 id="Dependency-Injection-with-Inject-and-Named"><a href="#Dependency-Injection-with-Inject-and-Named" class="headerlink" title="Dependency Injection with @Inject and @Named"></a>Dependency Injection with <code>@Inject</code> and <code>@Named</code></h3><p>If you would like to use a qualified name for the dependency that should be injected, you should use the <code>@Named</code> annotation</p><p>如果您想对注入的依赖项使用限定名称，则应使用@Named注解</p><h3 id="Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation-Component注解的比较"><a href="#Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation-Component注解的比较" class="headerlink" title="@Named and @ManagedBean: Standard Equivalents to the @Component Annotation(@Component注解的比较)"></a>@Named and @ManagedBean: Standard Equivalents to the @Component Annotation(@Component注解的比较)</h3><!--In contrast to @Component, the JSR-330 @Named and the JSR-250 ManagedBean annotations are not composable.--> <!--You should use Spring’s stereotype model for building custom component annotations.--><p>与@Component相反，JSR-330 @Named和JSR-250 ManagedBean注释是不可组合的。</p><p>您应该使用Spring的原型模型来构建自定义组件注释。</p><h3 id="Limitations-of-JSR-330-Standard-Annotations"><a href="#Limitations-of-JSR-330-Standard-Annotations" class="headerlink" title="Limitations of JSR-330 Standard Annotations"></a>Limitations of JSR-330 Standard Annotations</h3><table><thead><tr><th style="text-align:left">Spring</th><th style="text-align:left">javax.inject.*</th><th style="text-align:left">javax.inject restrictions / comments</th></tr></thead><tbody><tr><td style="text-align:left">@Autowired</td><td style="text-align:left">@Inject</td><td style="text-align:left"><code>@Inject</code> has no ‘required’ attribute. Can be used with Java 8’s <code>Optional</code> instead.</td></tr><tr><td style="text-align:left">@Component</td><td style="text-align:left">@Named / @ManagedBean</td><td style="text-align:left">JSR-330 does not provide a composable model, only a way to identify named components.</td></tr><tr><td style="text-align:left">@Scope(“singleton”)</td><td style="text-align:left">@Singleton</td><td style="text-align:left">The JSR-330 default scope is like Spring’s <code>prototype</code>. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a <code>singleton</code> by default. In order to use a scope other than <code>singleton</code>, you should use Spring’s <code>@Scope</code> annotation. <code>javax.inject</code> also provides a <a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html" target="_blank" rel="noopener">@Scope</a> annotation. Nevertheless, this one is only intended to be used for creating your own annotations.</td></tr><tr><td style="text-align:left">@Qualifier</td><td style="text-align:left">@Qualifier / @Named</td><td style="text-align:left"><code>javax.inject.Qualifier</code> is just a meta-annotation for building custom qualifiers. Concrete <code>String</code> qualifiers (like Spring’s <code>@Qualifier</code> with a value) can be associated through <code>javax.inject.Named</code>.</td></tr><tr><td style="text-align:left">@Value</td><td style="text-align:left">-</td><td style="text-align:left">no equivalent</td></tr><tr><td style="text-align:left">@Required</td><td style="text-align:left">-</td><td style="text-align:left">no equivalent</td></tr><tr><td style="text-align:left">@Lazy</td><td style="text-align:left">-</td><td style="text-align:left">no equivalent</td></tr><tr><td style="text-align:left">ObjectFactory</td><td style="text-align:left">Provider</td><td style="text-align:left"><code>javax.inject.Provider</code> is a direct alternative to Spring’s <code>ObjectFactory</code>, only with a shorter <code>get()</code> method name. It can also be used in combination with Spring’s <code>@Autowired</code> or with non-annotated constructors and setter methods.</td></tr></tbody></table><h2 id="🌟Java-based-Container-Configuration-基于Java的容器配置"><a href="#🌟Java-based-Container-Configuration-基于Java的容器配置" class="headerlink" title="🌟Java-based Container Configuration(基于Java的容器配置)"></a>🌟Java-based Container Configuration(基于Java的容器配置)</h2><p>🔑关键词: @Bean; @Configuration;AnnotationConfigApplicationContext;lite vs full;@Import; @ImportResource;@Condition</p><p>This section covers how to use annotations in your Java code to configure the Spring container. It includes the following topics:</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-basic-concepts" target="_blank" rel="noopener">Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-instantiating-container" target="_blank" rel="noopener">Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation" target="_blank" rel="noopener">Using the <code>@Bean</code> Annotation</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-configuration-annotation" target="_blank" rel="noopener">Using the <code>@Configuration</code> annotation</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-composing-configuration-classes" target="_blank" rel="noopener">Composing Java-based Configurations</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-definition-profiles" target="_blank" rel="noopener">Bean Definition Profiles</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction" target="_blank" rel="noopener"><code>PropertySource</code> Abstraction</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-using-propertysource" target="_blank" rel="noopener">Using <code>@PropertySource</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-placeholder-resolution-in-statements" target="_blank" rel="noopener">Placeholder Resolution in Statements</a></li></ul><h3 id="Basic-Concepts-Bean-and-Configuration"><a href="#Basic-Concepts-Bean-and-Configuration" class="headerlink" title="Basic Concepts: @Bean and @Configuration"></a>Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></h3><!--Annotating a class with `@Configuration` indicates that its primary purpose is as a source of bean definitions. Furthermore, `@Configuration` classes let inter-bean dependencies be defined by calling other `@Bean` methods in the same class.--><p>@Configuration: 用@Configuration注释类表示该类的主要目的是作为Bean定义的来源。 此外，@Configuration类允许通过调用同一类中的其他@Bean方法 来定义Bean间的依赖关系。</p><p>@Bean : Indicates that a method produces a bean to be managed by the Spring container.</p><p><strong>Full @Configuration vs “lite” @Bean mode?</strong></p><p>在<code>lite @Bean mode</code>模式下， <code>@Bean</code>方法不会被CGLIB代理 ,所以尽量使用Full @Configuration模式</p><h3 id="Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext"><a href="#Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext" class="headerlink" title="Instantiating the Spring Container by Using AnnotationConfigApplicationContext"></a>Instantiating the Spring Container <strong>by</strong> Using AnnotationConfigApplicationContext</h3><!--This versatile `ApplicationContext` implementation is capable of accepting not only `@Configuration` classes as input but also plain `@Component` classes and classes annotated with JSR-330 metadata.--><p>这种通用的ApplicationContext实现不仅能够接受@Configuration类作为输入，</p><p>而且还可以接受普通的@Component类和带有JSR-330元数据注释的类。</p><p><strong>scan &amp; register</strong></p><pre><code class="java">package org.springframework.context.annotation;/** * Common interface for annotation config application contexts, * defining {@link #register} and {@link #scan} methods. * * @author Juergen Hoeller * @since 4.1 */public interface AnnotationConfigRegistry {   /**    * Register one or more annotated classes to be processed.    * &lt;p&gt;Calls to {@code register} are idempotent; adding the same    * annotated class more than once has no additional effect.    * @param annotatedClasses one or more annotated classes,    * e.g. {@link Configuration @Configuration} classes    */   void register(Class&lt;?&gt;... annotatedClasses);   /**    * Perform a scan within the specified base packages.    * @param basePackages the packages to check for annotated classes    */   void scan(String... basePackages);}</code></pre><p>more details: @see org.springframework.context.annotation.AnnotationConfigApplicationContext</p><p><strong>Support for Web Applications with <code>AnnotationConfigWebApplicationContext</code></strong></p><h3 id="Using-the-Bean-Annotation"><a href="#Using-the-Bean-Annotation" class="headerlink" title="Using the @Bean Annotation"></a>Using the <code>@Bean</code> Annotation</h3><ul><li>Declaring a Bean</li><li>Bean Dependencies</li><li>Receiving Lifecycle Callbacks</li><li>Specifying Bean Scope</li><li>Customizing Bean Naming</li><li>Bean Aliasing</li><li>Bean Description</li></ul><p>@see org.springframework.context.annotation.Bean</p><h3 id="Using-the-Configuration-annotation"><a href="#Using-the-Configuration-annotation" class="headerlink" title="Using the @Configuration annotation"></a>Using the <code>@Configuration</code> annotation</h3><p><strong>Injecting Inter-bean Dependencies(注入bean间的依赖关系)</strong></p><p><strong>Lookup Method Injection</strong></p><p><strong>Further Information About How Java-based Configuration Works Internally</strong></p><!--This is where the magic comes in: All `@Configuration` classes are subclassed at startup-time with `CGLIB`.In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance--><h3 id="Composing-Java-based-Configurations"><a href="#Composing-Java-based-Configurations" class="headerlink" title="Composing Java-based Configurations"></a>Composing Java-based Configurations</h3><h3 id="Using-the-Import-Annotation"><a href="#Using-the-Import-Annotation" class="headerlink" title="Using the @Import Annotation"></a>Using the <code>@Import</code> Annotation</h3><!--As of Spring Framework 4.2, `@Import` also supports references to regular component classes, analogous to the `AnnotationConfigApplicationContext.register` method.--> <!--This is particularly useful if you want to avoid component scanning, by using a few configuration classes as entry points to explicitly define all your components.--><p>从Spring Framework 4.2开始，@ Import还支持对常规组件类的引用，类似于AnnotationConfigApplicationContext.register方法。 </p><p>如果要通过使用一些配置类作为入口点来显式定义所有组件，从而避免组件扫描，则此功能特别有用。</p><h3 id="Conditionally-Include-Configuration-Classes-or-Bean-Methods"><a href="#Conditionally-Include-Configuration-Classes-or-Bean-Methods" class="headerlink" title="Conditionally Include @Configuration Classes or @Bean Methods"></a>Conditionally Include <code>@Configuration</code> Classes or <code>@Bean</code> Methods</h3><p>The <code>@Profile</code> annotation is actually implemented by using a much more flexible annotation called <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html" target="_blank" rel="noopener"><code>@Conditional</code></a>. </p><p>The <code>@Conditional</code> annotation indicates specific <code>org.springframework.context.annotation.Condition</code> implementations that should be consulted before a <code>@Bean</code> is registered.</p><p><strong>@Profile</strong></p><pre><code class="java">@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ProfileCondition.class)public @interface Profile {    /**     * The set of profiles for which the annotated component should be registered.     */    String[] value();}</code></pre><p><strong>ProfileCondition</strong></p><pre><code class="java">class ProfileCondition implements Condition {  @Override  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());    if (attrs != null) {      for (Object value : attrs.get(&quot;value&quot;)) {        if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) {          return true;        }      }      return false;    }    return true;  }}</code></pre><p><strong>Condition</strong></p><pre><code class="java">@FunctionalInterfacepublic interface Condition {   /**    * Determine if the condition matches.    * @param context the condition context    * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class}    * or {@link org.springframework.core.type.MethodMetadata method} being checked    * @return {@code true} if the condition matches and the component can be registered,    * or {@code false} to veto the annotated component&#39;s registration    */   boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);}</code></pre><h3 id="Combining-Java-and-XML-Configuration"><a href="#Combining-Java-and-XML-Configuration" class="headerlink" title="Combining Java and XML Configuration"></a>Combining Java and XML Configuration</h3><p>Spring’s <code>@Configuration</code> class support does not aim to be a 100% complete replacement for Spring XML.</p><h4 id="XML-centric-Use-of-Configuration-Classes"><a href="#XML-centric-Use-of-Configuration-Classes" class="headerlink" title="XML-centric Use of @Configuration Classes"></a>XML-centric Use of <code>@Configuration</code> Classes</h4><p><strong>Declaring @Configuration classes as plain Spring &lt;bean/ &gt; elements</strong></p><pre><code class="xml">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;&lt;context:annotation-config/&gt;&lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;</code></pre><p>&lt;context:annotation-config /&gt; <strong>仅能够在已经在已经注册过的bean上面起作用,所以需要手动注册</strong></p><p>Using &lt;context:component-scan/ &gt; to pick up @Configuration classes**</p><pre><code class="xml">&lt;!-- picks up and registers AppConfig as a bean definition --&gt; &lt;context:component-scan base-package=&quot;com.acme&quot;/&gt;</code></pre><h4 id="ConfigurationClass-centric-Use-of-XML-with-ImportResource"><a href="#ConfigurationClass-centric-Use-of-XML-with-ImportResource" class="headerlink" title="@ConfigurationClass-centric Use of XML with@ImportResource"></a>@Configuration<code>Class-centric Use of XML with</code>@ImportResource</h4><p><strong>@ImportResource</strong></p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documentedpublic @interface ImportResource {    /**     * Alias for {@link #locations}.     * @see #locations     * @see #reader     */    @AliasFor(&quot;locations&quot;)    String[] value() default {};    /**     * Resource locations from which to import.     * &lt;p&gt;Supports resource-loading prefixes such as {@code classpath:},     * {@code file:}, etc.     * &lt;p&gt;Consult the Javadoc for {@link #reader} for details on how resources     * will be processed.     * @since 4.2     * @see #value     * @see #reader     */    @AliasFor(&quot;value&quot;)    String[] locations() default {};    /**     * {@link BeanDefinitionReader} implementation to use when processing     * resources specified via the {@link #value} attribute.     * &lt;p&gt;By default, the reader will be adapted to the resource path specified:     * {@code &quot;.groovy&quot;} files will be processed with a     * {@link org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader GroovyBeanDefinitionReader};     * whereas, all other resources will be processed with an     * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader XmlBeanDefinitionReader}.     * @see #value     */    Class&lt;? extends BeanDefinitionReader&gt; reader() default BeanDefinitionReader.class;}</code></pre><h2 id="🌟Environment-Abstraction-（环境抽象）"><a href="#🌟Environment-Abstraction-（环境抽象）" class="headerlink" title="🌟Environment Abstraction （环境抽象）"></a>🌟Environment Abstraction （环境抽象）</h2><p>🔑关键词: Environment; profiles; properties;PropertySources;PropertySourcesPlaceholderConfigurer</p><p>The <a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/javadoc-api/org/springframework/core/env/Environment.html" target="_blank" rel="noopener"><code>Environment</code></a> interface is an abstraction integrated in the container that models two key aspects of the application environment: <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-definition-profiles" target="_blank" rel="noopener">profiles</a> and <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction" target="_blank" rel="noopener">properties</a>.</p><p>Environment接口是集成在容器中的抽象，它对应用程序环境的两个关键方面进行建模：profiles和properties</p><p>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. </p><p>The role of the <code>Environment</code> object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.</p><p>Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc <code>Properties</code> objects, <code>Map</code> objects, and so on.</p><p> The role of the <code>Environment</code> object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.</p><h3 id="Bean-Definition-Profiles"><a href="#Bean-Definition-Profiles" class="headerlink" title="Bean Definition Profiles"></a>Bean Definition Profiles</h3><h4 id="Using-Profile"><a href="#Using-Profile" class="headerlink" title="Using @Profile"></a>Using <code>@Profile</code></h4><h4 id="XML-Bean-Definition-Profiles"><a href="#XML-Bean-Definition-Profiles" class="headerlink" title="XML Bean Definition Profiles"></a>XML Bean Definition Profiles</h4><h4 id="Activating-a-Profile"><a href="#Activating-a-Profile" class="headerlink" title="Activating a Profile"></a>Activating a Profile</h4><p>spring.profiles.active</p><h4 id="Default-Profile"><a href="#Default-Profile" class="headerlink" title="Default Profile"></a>Default Profile</h4><p>default</p><h3 id="PropertySource-Abstraction"><a href="#PropertySource-Abstraction" class="headerlink" title="PropertySource Abstraction"></a><code>PropertySource</code> Abstraction</h3><p>For a common <code>StandardServletEnvironment</code>, the full hierarchy is as follows, with the highest-precedence entries at the top:</p><ul><li>ServletConfig parameters (if applicable — for example, in case of a <code>DispatcherServlet</code> context)</li><li>ServletContext parameters (web.xml context-param entries)</li><li>JNDI environment variables (<code>java:comp/env/</code> entries)</li><li>JVM system properties (<code>-D</code> command-line arguments)</li><li>JVM system environment (operating system environment variables)</li></ul><pre><code class="java">ConfigurableApplicationContext ctx = new GenericApplicationContext();MutablePropertySources sources = ctx.getEnvironment().getPropertySources();</code></pre><h3 id="Using-PropertySource"><a href="#Using-PropertySource" class="headerlink" title="Using @PropertySource"></a>Using <code>@PropertySource</code></h3><p>The <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code></a> annotation provides a convenient and declarative mechanism for adding a <code>PropertySource</code> to Spring’s <code>Environment</code>.</p><h3 id="Placeholder-Resolution-in-Statements"><a href="#Placeholder-Resolution-in-Statements" class="headerlink" title="Placeholder Resolution in Statements"></a>Placeholder Resolution in Statements</h3><p>Historically, the value of placeholders in elements could be resolved only against JVM system properties or environment variables. This is no longer the case.</p><p>Because the <code>Environment</code> abstraction is integrated throughout the container, it is easy to route resolution of placeholders through it. </p><p>This means that you may configure the resolution process in any way you like.</p><p> You can change the precedence of searching through system properties and environment variables or remove them entirely.</p><p>@See org.springframework.context.support.PropertySourcesPlaceholderConfigurer</p><h2 id="🌟Registering-a-LoadTimeWeaver"><a href="#🌟Registering-a-LoadTimeWeaver" class="headerlink" title="🌟Registering a LoadTimeWeaver"></a><del>🌟Registering a <code>LoadTimeWeaver</code></del></h2><p>weaving(编织 编译时、加载时、运行时) 这里是类加载时</p><p>The <code>LoadTimeWeaver</code> is used by Spring to dynamically transform classes as they are loaded into the Java virtual machine (JVM).</p><p>@See <a href="https://www.cnblogs.com/wade-luffy/p/6073702.html" target="_blank" rel="noopener">https://www.cnblogs.com/wade-luffy/p/6073702.html</a></p><h2 id="🌟Additional-Capabilities-of-the-ApplicationContext-BeanFactory的扩展"><a href="#🌟Additional-Capabilities-of-the-ApplicationContext-BeanFactory的扩展" class="headerlink" title="🌟Additional Capabilities of the ApplicationContext (BeanFactory的扩展)"></a>🌟Additional Capabilities of the <code>ApplicationContext</code> (BeanFactory的扩展)</h2><p>🔑关键词:BeanFactory;ResourceLoader;MessageSource;ResourceBundleMessageSource;Environment;EventPublisher;</p><p>@EventListener;ContextLoaderListener;</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g949aex83ij31d80fotac.jpg" alt="image-20191120093906082"></p><p>To enhance <code>BeanFactory</code> functionality in a more framework-oriented style, the context package also provides the following functionality:</p><ul><li>Access to messages in i18n-style, through the <code>MessageSource</code> interface.</li><li>Access to resources, such as URLs and files, through the <code>ResourceLoader</code> interface.</li><li>Event publication, namely to beans that implement the <code>ApplicationListener</code> interface, through the use of the <code>ApplicationEventPublisher</code> interface.</li><li>Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such as the web layer of an application, through the <code>HierarchicalBeanFactory</code> interface.</li></ul><h3 id="Internationalization-using-MessageSource"><a href="#Internationalization-using-MessageSource" class="headerlink" title="Internationalization using MessageSource"></a>Internationalization using <code>MessageSource</code></h3><h3 id="Standard-and-Custom-Events"><a href="#Standard-and-Custom-Events" class="headerlink" title="Standard and Custom Events"></a>Standard and Custom Events</h3><table><thead><tr><th style="text-align:left">Event</th><th style="text-align:left">Explanation</th></tr></thead><tbody><tr><td style="text-align:left"><code>ContextRefreshedEvent</code></td><td style="text-align:left">Published when the <code>ApplicationContext</code> is initialized or refreshed (for example, by using the <code>refresh()</code> method on the <code>ConfigurableApplicationContext</code> interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the <code>ApplicationContext</code> object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen <code>ApplicationContext</code> actually supports such “hot” refreshes. For example, <code>XmlWebApplicationContext</code> supports hot refreshes, but <code>GenericApplicationContext</code> does not.</td></tr><tr><td style="text-align:left"><code>ContextStartedEvent</code></td><td style="text-align:left">Published when the <code>ApplicationContext</code> is started by using the <code>start()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “started” means that all <code>Lifecycle</code> beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization).</td></tr><tr><td style="text-align:left"><code>ContextStoppedEvent</code></td><td style="text-align:left">Published when the <code>ApplicationContext</code> is stopped by using the <code>stop()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “stopped” means that all <code>Lifecycle</code> beans receive an explicit stop signal. A stopped context may be restarted through a <code>start()</code> call.</td></tr><tr><td style="text-align:left"><code>ContextClosedEvent</code></td><td style="text-align:left">Published when the <code>ApplicationContext</code> is being closed by using the <code>close()</code> method on the <code>ConfigurableApplicationContext</code> interface or via a JVM shutdown hook. Here, “closed” means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.</td></tr><tr><td style="text-align:left"><code>RequestHandledEvent</code></td><td style="text-align:left">A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s <code>DispatcherServlet</code>.</td></tr><tr><td style="text-align:left"><code>ServletRequestHandledEvent</code></td><td style="text-align:left">A subclass of <code>RequestHandledEvent</code> that adds Servlet-specific context information.</td></tr></tbody></table><h4 id="Annotation-based-Event-Listeners"><a href="#Annotation-based-Event-Listeners" class="headerlink" title="Annotation-based Event Listeners"></a>Annotation-based Event Listeners</h4><p> As of Spring 4.2, the event infrastructure has been significantly improved and offers an <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-functionality-events-annotation" target="_blank" rel="noopener">annotation-based model</a> as well as the ability to publish any arbitrary event (that is, an object that does not necessarily extend from <code>ApplicationEvent</code>). When such an object is published, we wrap it in an event for you.</p><h4 id="Asynchronous-Listeners"><a href="#Asynchronous-Listeners" class="headerlink" title="Asynchronous Listeners"></a>Asynchronous Listeners</h4><p>Be aware of the following limitations when using asynchronous events:</p><ul><li>If an asynchronous event listener throws an <code>Exception</code>, it is not propagated to the caller. See <code>AsyncUncaughtExceptionHandler</code> for more details.</li><li>Asynchronous event listener methods cannot publish a subsequent event by returning a value. If you need to publish another event as the result of the processing, inject an <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html" target="_blank" rel="noopener"><code>ApplicationEventPublisher</code></a> to publish the event manually.</li></ul><h4 id="Ordering-Listeners"><a href="#Ordering-Listeners" class="headerlink" title="Ordering Listeners"></a>Ordering Listeners</h4><p>@Order</p><h4 id="Generic-Events"><a href="#Generic-Events" class="headerlink" title="Generic Events"></a><del>Generic Events</del></h4><p>@see org.springframework.core.ResolvableTypeProvider</p><h3 id="Convenient-Access-to-Low-level-Resources"><a href="#Convenient-Access-to-Low-level-Resources" class="headerlink" title="Convenient Access to Low-level Resources"></a>Convenient Access to Low-level Resources</h3><p>An application context is a <code>ResourceLoader</code>, which can be used to load <code>Resource</code> objects. A <code>Resource</code> is essentially a more feature rich version of the JDK <code>java.net.URL</code> class</p><h3 id="Convenient-ApplicationContext-Instantiation-for-Web-Applications"><a href="#Convenient-ApplicationContext-Instantiation-for-Web-Applications" class="headerlink" title="Convenient ApplicationContext Instantiation for Web Applications"></a>Convenient ApplicationContext Instantiation for Web Applications</h3><p>You can register an <code>ApplicationContext</code> by using the <code>ContextLoaderListener</code></p><pre><code class="xml">&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><h3 id="Deploying-a-Spring-ApplicationContext-as-a-Java-EE-RAR-File"><a href="#Deploying-a-Spring-ApplicationContext-as-a-Java-EE-RAR-File" class="headerlink" title="Deploying a Spring ApplicationContext as a Java EE RAR File"></a>Deploying a Spring <code>ApplicationContext</code> as a Java EE RAR File</h3><p>Such RAR deployment units are usually self-contained. They do not expose components to the outside world, not even to other modules of the same application. </p><h2 id="🌟The-BeanFactory"><a href="#🌟The-BeanFactory" class="headerlink" title="🌟The BeanFactory"></a>🌟The <code>BeanFactory</code></h2><p>🔑关键词: DefaultListableBeanFactory ; extensions</p><p>Note that the core <code>BeanFactory</code> API level and its <code>DefaultListableBeanFactory</code> implementation do not make assumptions about the configuration format or any component annotations to be used. All of these flavors come in through extensions (such as <code>XmlBeanDefinitionReader</code> and <code>AutowiredAnnotationBeanPostProcessor</code>) and operate on shared <code>BeanDefinition</code> objects as a core metadata representation.</p><p> This is the essence of what makes Spring’s container so flexible and extensible.</p><h3 id="BeanFactory-or-ApplicationContext"><a href="#BeanFactory-or-ApplicationContext" class="headerlink" title="BeanFactory or ApplicationContext?"></a><code>BeanFactory</code> or <code>ApplicationContext</code>?</h3><p>For many extended container features, such as annotation processing and AOP proxying, the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp" target="_blank" rel="noopener"><code>BeanPostProcessor</code> extension point</a> is essential. </p><p>If you use only a plain <code>DefaultListableBeanFactory</code>, such post-processors do not get detected and activated by default. This situation could be confusing, because nothing is actually wrong with your bean configuration. </p><p>Rather, in such a scenario, the container needs to be fully bootstrapped through additional setup.</p><p>The following table lists features provided by the <code>BeanFactory</code> and <code>ApplicationContext</code> interfaces and implementations.</p><table><thead><tr><th style="text-align:left">Feature</th><th style="text-align:left"><code>BeanFactory</code></th><th style="text-align:left"><code>ApplicationContext</code></th></tr></thead><tbody><tr><td style="text-align:left">Bean instantiation/wiring</td><td style="text-align:left">Yes</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">Integrated lifecycle management</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">Automatic <code>BeanPostProcessor</code> registration</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">Automatic <code>BeanFactoryPostProcessor</code> registration</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">Convenient <code>MessageSource</code> access (for internalization)</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr><tr><td style="text-align:left">Built-in <code>ApplicationEvent</code> publication mechanism</td><td style="text-align:left">No</td><td style="text-align:left">Yes</td></tr></tbody></table><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>顶级接口</p><ul><li>BeanFactory <ul><li>bean (beanDefined); </li><li>状态(作用域)/行为(回调,bean extends)/关系(依赖) </li><li>contains extension (BPF/BBPF/FactoryBean)</li></ul></li><li>ApplicationContext <ul><li>Messagesource</li><li>Event</li><li>layer (AOP /web /auto registration )</li></ul></li></ul><p> Core (core/asm/cglib/util) </p><ul><li>Env</li><li>IO</li><li>Type : Core support package for type introspection.(内省)</li><li><p>@AliasFor / @Order</p><p>Annotaion(2.5 / 3.0/ 4.0/ 5.0)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_Packages_java_nio</title>
      <link href="/2019/09/26/JDK-Packages-java-nio/"/>
      <url>/2019/09/26/JDK-Packages-java-nio/</url>
      
        <content type="html"><![CDATA[<blockquote><p>年少风雅鲜衣怒马  也不过一刹那                 —《红昭愿》</p></blockquote><p>从JDK4 开始 ,NIO是New I/O的简称，具有以下特性：</p><ul><li>为所有的原始类型提供（Buffer）缓存支持；(IO也有BufferInputStream)</li><li>增加通道（channel）对象，作为新的原始 I/O 抽象；</li><li>提供了基于 Selector 的异步网络 I/O。(线程模型)</li><li>使用 java.nio.charset.Charset 作为字符集编码解码解决方案；</li><li>支持锁和内存映射(MappedByteBuffer)文件的文件访问接口；</li></ul><p>参考资料:</p><p><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/index.html</a></p><p><a href="https://ifeve.com/overview/" target="_blank" rel="noopener">https://ifeve.com/overview/</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html</a></p><p><a href="https://cloud.tencent.com/developer/information/使用ByteBuffer" target="_blank" rel="noopener">https://cloud.tencent.com/developer/information/%E4%BD%BF%E7%94%A8ByteBuffer</a></p><a id="more"></a><h3 id="Overivew"><a href="#Overivew" class="headerlink" title="Overivew"></a>Overivew</h3><p>Java NIO (New IO) is an alternative IO API for Java (from Java 1.4), meaning alternative to the standard <a href="http://tutorials.jenkov.com/java-io/index.html" target="_blank" rel="noopener">Java IO</a> and <a href="http://tutorials.jenkov.com/java-networking/index.html" target="_blank" rel="noopener">Java Networking</a> API’s. Java NIO offers a different way of working with IO than the standard IO API’s.</p><p>Java NIO consist of the following core components:</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="buffer-api"><a href="#buffer-api" class="headerlink" title="buffer api"></a>buffer api</h4><h5 id="filed"><a href="#filed" class="headerlink" title="filed"></a>filed</h5><ul><li>capacity：容量，表示buffer的最大数据容量，缓冲区容量不能为负，创建后不能更改</li><li>limit：限制，按照索引来，limit之后的数据不可读写，即只有在limit范围内的数据我们才可以读写操作。</li><li>position：位置，下一个要读取或写入的索引位置。该位置不能大于limit的限制。</li><li>mark：标记，标记后的索引位置，我们可以通过reset方法恢复position到该位置，该mark的位置要小于或等于position</li></ul><pre><code class="java">// Invariants: mark &lt;= position &lt;= limit &lt;= capacityprivate int mark = -1;private int position = 0;private int limit;private int capacity;</code></pre><h5 id="method"><a href="#method" class="headerlink" title="method"></a>method</h5><ul><li><p>clear : Clears this buffer.  The position is set to zero, the limit is set to the capacity, and the mark is discarded.</p><p>  将position置为0，并不清除buffer内容。 </p><p>  <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7f35bshboj30pa0iawf3.jpg" alt="img" style="zoom:33%;"></p></li><li><p>flip(翻转 write-&gt;read) : Flips this buffer.  The limit is set to the current position and then the position is set to zero.  If the mark is defined then it is  discarded.</p><p>  写完数据(put)，需要开始读的时候，将postion复位到0，并将limit设为当前postion。 </p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7f34btvf6j30oy0ic74v.jpg" alt="img" style="zoom:33%;"></p><ul><li>Rewind(倒带,和flip相比少了对limit的操作) :  Rewinds this buffer.  The position is set to zero and the mark is discarded.</li><li>Remaining\hasRemaining : Returns the number of elements between the current position and the limit.</li></ul><h5 id="source"><a href="#source" class="headerlink" title="source"></a>source</h5><pre><code class="java">                        /**     * Clears this buffer.  The position is set to zero, the limit is set to     * the capacity, and the mark is discarded.     *     * &lt;p&gt; Invoke this method before using a sequence of channel-read or     * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:     *     * &lt;blockquote&gt;&lt;pre&gt;     * buf.clear();     // Prepare buffer for reading     * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;     *     * &lt;p&gt; This method does not actually erase the data in the buffer, but it     * is named as if it did because it will most often be used in situations     * in which that might as well be the case. &lt;/p&gt;     *     * @return  This buffer     */    public final Buffer clear() {        position = 0;        limit = capacity;        mark = -1;        return this;    }    /**     * Flips this buffer.  The limit is set to the current position and then     * the position is set to zero.  If the mark is defined then it is     * discarded.     *     * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke     * this method to prepare for a sequence of channel-write or relative     * &lt;i&gt;get&lt;/i&gt; operations.  For example:     *     * &lt;blockquote&gt;&lt;pre&gt;     * buf.put(magic);    // Prepend header     * in.read(buf);      // Read data into rest of buffer     * buf.flip();        // Flip buffer     * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;     *     * &lt;p&gt; This method is often used in conjunction with the {@link     * java.nio.ByteBuffer#compact compact} method when transferring data from     * one place to another.  &lt;/p&gt;     *     * @return  This buffer     */    public final Buffer flip() {        limit = position;        position = 0;        mark = -1;        return this;    }    /**     * Rewinds this buffer.  The position is set to zero and the mark is     * discarded.     *     * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;     * operations, assuming that the limit has already been set     * appropriately.  For example:     *     * &lt;blockquote&gt;&lt;pre&gt;     * out.write(buf);    // Write remaining data     * buf.rewind();      // Rewind buffer     * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;     *     * @return  This buffer     */    public final Buffer rewind() {        position = 0;        mark = -1;        return this;    }    /**     * Returns the number of elements between the current position and the     * limit.     *     * @return  The number of elements remaining in this buffer     */    public final int remaining() {        return limit - position;    }    /**     * Tells whether there are any elements between the current position and     * the limit.     *     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, there is at least one element     *          remaining in this buffer     */    public final boolean hasRemaining() {        return position &lt; limit;    }</code></pre><h4 id="buffer-extends"><a href="#buffer-extends" class="headerlink" title="buffer extends"></a>buffer extends</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7cpyddkurj31ps0s0adh.jpg" alt="image-20190924145529968"></p><p>Here is a list of the core <code>Buffer</code> implementations in Java NIO:</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>These <code>Buffer</code>‘s cover the basic data types that you can send via IO: byte, short, int, long, float, double and characters.</p><h4 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4><p>ByteBuffer最核心的方法是put(byte)和get()。分别是往ByteBuffer里写一个字节，和读一个字节。</p><p>值得注意的是，ByteBuffer的读写模式是分开的，正常的应用场景是：往ByteBuffer里写一些数据，然后flip()，然后再读出来。</p><h5 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h5><pre><code class="java">                    public static ByteBuffer allocateDirect(int capacity) {        return new DirectByteBuffer(capacity);    }    public static ByteBuffer allocate(int capacity) {        if (capacity &lt; 0)            throw new IllegalArgumentException();        return new HeapByteBuffer(capacity, capacity);    }</code></pre><h5 id="HeapByteBuffer"><a href="#HeapByteBuffer" class="headerlink" title="HeapByteBuffer"></a>HeapByteBuffer</h5><p>间接的ByteBuffer是在JVM的堆上面的。间接缓冲区就是我们通常说的堆缓冲区。</p><pre><code class="java">class HeapByteBuffer extends ByteBuffer {}</code></pre><h5 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h5><p>直接就是指MappedByteBuffer，直接使用内存映射（java的话就意味着在JVM之外分配虚拟地址空间）；</p><pre><code class="java">class DirectByteBuffer extends MappedByteBuffer implements DirectBuffer {}</code></pre><p>资料:</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1428920" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1428920</a>  MappedByteBuffer VS FileChannel ，孰强孰弱</p><p><a href="https://cloud.tencent.com/developer/article/1152616" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1152616</a>   堆外内存 之 DirectByteBuffer 详解</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hmmyw3xnj30er047wes.jpg" alt="img"></p><p>最佳实践</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc7dgoh07rj30d90433yw.jpg" alt="img"></p><h6 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h6><ul><li><p>load : 会整个文件加载到内存中。</p></li><li><p>isLoaded : 判断一个被映射的文件是否完全加载内存了</p></li><li><p>force :该方法会强制将此缓冲区上的任何更改写入映射到永久磁盘存储器上。</p></li></ul><pre><code class="java">public abstract class MappedByteBuffer extends ByteBuffer {    public final MappedByteBuffer load( )    public final boolean isLoaded( )    public final MappedByteBuffer force( )}</code></pre><p><a href="https://cloud.tencent.com/developer/article/1130046" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1130046</a></p><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>Typically, all IO in NIO starts with a <code>Channel</code>. A <code>Channel</code> is a bit like a stream. From the <code>Channel</code> data can be read into a <code>Buffer</code>. Data can also be written from a <code>Buffer</code> into a <code>Channel</code>. Here is an illustration of that:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7cpybgjbdj309e06fjre.jpg" alt="Java NIO: Channels and Buffers"></p><p>​            <strong>Java NIO: Channels read data into Buffers, and Buffers write data into Channels</strong></p><p>Java NIO Channels are similar to streams with a few differences:</p><ul><li>You can both read and write to a Channels. Streams are typically one-way (read or write).</li><li>Channels can be read and written asynchronously.</li><li>Channels always read to, or write from, a Buffer.</li></ul><h4 id="Channel-Implementations"><a href="#Channel-Implementations" class="headerlink" title="Channel Implementations"></a>Channel Implementations</h4><p>Here are the most important Channel implementations in Java NIO:</p><ul><li><p>FileChannel  : reads data from and to files.</p><p>  **public abstract long transferTo(long position,long count,WritableByteChannel target)</p><pre><code>                       throws IOException**</code></pre><p>  This method is potentially much more efficient than a simple loop that reads from this channel and writes to the target channel. Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them.</p></li><li><p>DatagramChannel : can read and write data over the network via UDP.</p></li><li><p>SocketChannel : can read and write data over the network via TCP.</p></li><li><p>ServerSocketChannel : allows you to listen for incoming TCP connections, like a web server does. For each incoming connection a <code>SocketChannel</code> is created.</p></li></ul><h4 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h4><h5 id="Why-Use-a-Selector"><a href="#Why-Use-a-Selector" class="headerlink" title="Why Use a Selector?"></a>Why Use a Selector?</h5><p>A <code>Selector</code> allows a single thread to handle multiple <code>Channel</code>‘s. This is handy if your application has many connections (Channels) open, but only has low traffic on each connection. For instance, in a chat server.</p><p>Here is an illustration of a thread using a <code>Selector</code> to handle 3 <code>Channel</code>‘s:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7cpycvhlgj30bc08zdg0.jpg" alt="Java NIO: Selectors"></p><p>​                                 <strong>Java NIO: A Thread uses a Selector to handle 3 Channel’s</strong></p><p>To use a <code>Selector</code> you register the <code>Channel</code>‘s with it. Then you call it’s <code>select()</code> method. This method will block until there is an event ready for one of the registered channels. Once the method returns, the thread can then process these events. Examples of events are incoming connection, data received etc.</p><h5 id="full-demo"><a href="#full-demo" class="headerlink" title="full demo"></a>full demo</h5><h6 id="Server-demo"><a href="#Server-demo" class="headerlink" title="Server  demo"></a>Server  demo</h6><pre><code class="java">package nio;import org.springframework.util.StringUtils;import java.io.Closeable;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;/** * @author zhengyumin * @description Nio服务端 使用selector接收消息 * @date 2019-09-25 1:22 AM */public class NioServer implements Closeable{    private Selector selector;    private ServerSocketChannel serverSocketChannel;    private int port;    private String hostname;    public NioServer(int port) {        this.port = port;    }    public NioServer(int port, String hostname) {        this.port = port;        this.hostname = hostname;    }    public static NioServer port(int port) {        return new NioServer(port);    }    public NioServer start() {        System.out.println(&quot;starting....&quot;);        try {            startServer();            //开启selector 并监听            startSelector();        } catch (Exception e) {            e.printStackTrace();        }        return this;    }    @Override    public void close() {        try {            System.out.println(&quot;closing....&quot;);            selector.close();            serverSocketChannel.close();        } catch (IOException e) {            e.printStackTrace();        }    }    private void startSelector() throws IOException {        selector = Selector.open();        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        System.out.println(&quot;startSelector succ&quot;);        while (true) {            int readyChannels = selector.selectNow();            if (readyChannels == 0) {                continue;//                    return;            }            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();            while (keyIterator.hasNext()) {                SelectionKey key = keyIterator.next();                if (key.isAcceptable()) {                    // a connection was accepted by a ServerSocketChannel.                    connectEven(key, selector);                } else if (key.isConnectable()) {                    // a connection was established with a remote server.                    System.out.println(&quot;a connection was established with a remote server.&quot;);                } else if (key.isReadable()) {                    // a channel is ready for reading                    readData(key);                } else if (key.isWritable()) {                    // a channel is ready for writing                    System.out.println(&quot;a channel is ready for writing&quot;);                }                keyIterator.remove();            }        }    }    private void startServer() throws Exception {        //开启服务器        serverSocketChannel = ServerSocketChannel.open();        serverSocketChannel.socket().bind(StringUtils.isEmpty(hostname) ?                new InetSocketAddress(port) : new InetSocketAddress(hostname, port));        serverSocketChannel.configureBlocking(false);        System.out.println(&quot;startServer succ&quot;);    }    private void connectEven(SelectionKey key, Selector selector) {        try {            ServerSocketChannel server = (ServerSocketChannel) key.channel();            SocketChannel channel = server.accept();            channel.configureBlocking(false);            //获得远程连接的IP地址            System.out.println(&quot;已有连接，连接的ip地址是&quot; + channel.socket().getInetAddress());            channel.register(selector, SelectionKey.OP_READ);        } catch (IOException e) {            e.printStackTrace();        }    }    /**     * 数据读取处理     *     * @param key     */    private void readData(SelectionKey key) {        SocketChannel socketChannel = (SocketChannel) key.channel();        ByteBuffer buf = ByteBuffer.allocate(1024);        try {            int readSize = socketChannel.read(buf);            if (readSize &gt; 0) {                byte[] data = buf.array();                String msg = new String(data, &quot;UTF-8&quot;).trim();                System.out.println(msg);            }        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        try(NioServer nioServer =  NioServer.port(9999)) {            nioServer.start();        }catch (Exception e){            e.printStackTrace();        }    }     }</code></pre><h6 id="Client-demo"><a href="#Client-demo" class="headerlink" title="Client demo"></a>Client demo</h6><pre><code class="java">package nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;/** * @author zhengyumin * @description nio客户端demo * @date 2019-09-25 11:36 AM */public class NioClientDemo {    public static void main(String[] args) throws IOException {        SocketChannel socketChannel = SocketChannel.open();        socketChannel.connect(new InetSocketAddress(9999));        String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();        ByteBuffer buf = ByteBuffer.allocate(48);        buf.clear();        buf.put(newData.getBytes());        buf.flip();        while(buf.hasRemaining()) {            socketChannel.write(buf);        }    }}</code></pre><h4 id="Pipe-todo"><a href="#Pipe-todo" class="headerlink" title="Pipe(todo)"></a>Pipe(todo)</h4><p>​    </p><h3 id="Charset-todo"><a href="#Charset-todo" class="headerlink" title="Charset(todo)"></a>Charset(todo)</h3><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><h4 id="Path-todo"><a href="#Path-todo" class="headerlink" title="Path(todo)"></a>Path(todo)</h4><h4 id="Files-todo"><a href="#Files-todo" class="headerlink" title="Files(todo)"></a>Files(todo)</h4><h3 id="Java-NIO-vs-IO"><a href="#Java-NIO-vs-IO" class="headerlink" title="Java NIO vs. IO"></a>Java NIO vs. IO</h3><p>When studying both the Java NIO and IO API’s, a question quickly pops into mind:</p><p><strong>When should I use IO and when should I use NIO?</strong></p><h4 id="Main-Differences-Betwen-Java-NIO-and-IO"><a href="#Main-Differences-Betwen-Java-NIO-and-IO" class="headerlink" title="Main Differences Betwen Java NIO and IO"></a>Main Differences Betwen Java NIO and IO</h4><p>The table below summarizes the main differences between Java NIO and IO. I will get into more detail about each difference in the sections following the table.</p><table><thead><tr><th><strong>IO</strong></th><th><strong>NIO</strong></th><th>Diff</th></tr></thead><tbody><tr><td>Stream oriented</td><td>Buffer oriented</td><td>Cache</td></tr><tr><td>Blocking IO</td><td>Non blocking IO</td><td>Threads</td></tr><tr><td></td><td>Selectors</td></tr></tbody></table><h4 id="How-NIO-and-IO-Influences-Application-Design"><a href="#How-NIO-and-IO-Influences-Application-Design" class="headerlink" title="How NIO and IO Influences Application Design"></a>How NIO and IO Influences Application Design</h4><p>Whether you choose NIO or IO as your IO toolkit may impact the following aspects of your application design:</p><ol><li>The API calls to the NIO or IO classes.</li><li>The processing of data.</li><li>The number of thread used to process the data.</li></ol><h5 id="The-API-calls-to-the-NIO-or-IO-classes"><a href="#The-API-calls-to-the-NIO-or-IO-classes" class="headerlink" title="The API calls to the NIO or IO classes."></a>The API calls to the NIO or IO classes.</h5><p>Of course the API calls when using NIO look different than when using IO. This is no surprise. Rather than just read the data byte for byte from e.g. an <code>InputStream</code>, the data must first be read into a buffer, and then be processed from there.</p><h5 id="The-processing-of-data"><a href="#The-processing-of-data" class="headerlink" title="The processing of data."></a>The processing of data.</h5><table><thead><tr><th><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7cpydvocgj309i092t8p.jpg" alt="Java IO: Reading data from a blocking stream."></th></tr></thead><tbody><tr><td><strong>Java IO: Reading data from a blocking stream.</strong></td></tr></tbody></table><table><thead><tr><th><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7cpybzkgvj30bp09074b.jpg" alt="Java NIO: Reading data from a channel until all needed data is in buffer."></th></tr></thead><tbody><tr><td><strong>Java NIO: Reading data from a channel until all needed data is in buffer.</strong></td></tr></tbody></table><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>NIO allows you to manage multiple channels (network connections or files) using only a single (or few) threads, but the cost is that parsing the data might be somewhat more complicated than when reading data from a blocking stream.</p><p>If you need to manage thousands of open connections simultanously, which each only send a little data, for instance a chat server, implementing the server in NIO is probably an advantage. Similarly, if you need to keep a lot of open connections to other computers, e.g. in a P2P network, using a single thread to manage all of your outbound connections might be an advantage. This one thread, multiple connections design is illustrated in this diagram:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7cpycfkpej3085070jrh.jpg" alt="Java NIO: A single thread managing multiple connections."></p><p>​                            <strong>Java NIO: A single thread managing multiple connections.</strong></p><p>If you have fewer connections with very high bandwidth, sending a lot of data at a time, perhaps a classic IO server implementation might be the best fit. This diagram illustrates a classic IO server design:</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7couh9zd6j30dw07n0sx.jpg" alt="Java IO: A classic IO server design - one connection handled by one thread."></p><p>​                       <strong>Java IO: A classic IO server design - one connection handled by one thread.</strong></p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> packages </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_Packages_java_io</title>
      <link href="/2019/09/23/JDK-Packages-java-io/"/>
      <url>/2019/09/23/JDK-Packages-java-io/</url>
      
        <content type="html"><![CDATA[<blockquote><p>若逢新雪初霁 满月当空 下面流转着亮银 而你带笑地想我走来 月色和雪色之间 你是第三种绝色    —余光中《绝色》</p></blockquote><p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html</a></p><p>官方介绍</p><pre><code>Provides for system input and output through data streams, serialization and the file system.</code></pre><p>通过数据流、序列化和文件系统提供系统输入和输出。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    创建一个好的I/O系统不是一件容易的事，难度似乎来自于需要覆盖所有的可能性。</p><p>因为不仅存在各种I/O源端（文件、控制台、网络连接等），还需要以多种不同的方式与这些I/O源端（顺序、回退、随机、缓冲、二进制、按字符、按行、按字）进行通信。Java类库的设计者通过创建大量的类来解决这个问题。</p><p>从下面三个主题来讨论这个话题</p><ul><li>data streams</li><li>serialization</li><li>File system</li></ul><h2 id="接口总览"><a href="#接口总览" class="headerlink" title="接口总览"></a>接口总览</h2><table><thead><tr><th style="text-align:left">Interface</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html" target="_blank" rel="noopener">Closeable</a></td><td style="text-align:left">A <code>Closeable</code> is a source or destination of data that can be closed.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataInput.html" target="_blank" rel="noopener">DataInput</a></td><td style="text-align:left">The <code>DataInput</code> interface provides for reading bytes from a binary stream and reconstructing from them data in any of the Java primitive types.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataOutput.html" target="_blank" rel="noopener">DataOutput</a></td><td style="text-align:left">The <code>DataOutput</code> interface provides for converting data from any of the Java primitive types to a series of bytes and writing these bytes to a binary stream.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Externalizable.html" target="_blank" rel="noopener">Externalizable</a></td><td style="text-align:left">Only the identity of the class of an Externalizable instance is written in the serialization stream and it is the responsibility of the class to save and restore the contents of its instances.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileFilter.html" target="_blank" rel="noopener">FileFilter</a></td><td style="text-align:left">A filter for abstract pathnames.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/FilenameFilter.html" target="_blank" rel="noopener">FilenameFilter</a></td><td style="text-align:left">Instances of classes that implement this interface are used to filter filenames.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Flushable.html" target="_blank" rel="noopener">Flushable</a></td><td style="text-align:left">A <code>Flushable</code> is a destination of data that can be flushed.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInput.html" target="_blank" rel="noopener">ObjectInput</a></td><td style="text-align:left">ObjectInput extends the DataInput interface to include the reading of objects.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputValidation.html" target="_blank" rel="noopener">ObjectInputValidation</a></td><td style="text-align:left">Callback interface to allow validation of objects within a graph.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutput.html" target="_blank" rel="noopener">ObjectOutput</a></td><td style="text-align:left">ObjectOutput extends the DataOutput interface to include writing of objects.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectStreamConstants.html" target="_blank" rel="noopener">ObjectStreamConstants</a></td><td style="text-align:left">Constants written into the Object Serialization Stream.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html" target="_blank" rel="noopener">Serializable</a></td><td style="text-align:left">Serializability of a class is enabled by the class implementing the java.io.Serializable interface.</td></tr></tbody></table><h2 id="data-streams"><a href="#data-streams" class="headerlink" title="data streams"></a>data streams</h2><p>整体结构</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g79ikws9ewj30kx0mego6.jpg" alt="I/Oæ´ä½ç»æå¾"></p><h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><ul><li>文件（file）：FileInputStream、FileOutputStream、FileReader、FileWriter</li><li>数组（[]）：<ul><li>2.1、字节数组（byte[]）：ByteArrayInputStream、ByteArrayOutputStream</li><li>2.2、字符数组（char[]）：CharArrayReader、CharArrayWriter</li></ul></li><li>管道操作：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter</li><li>基本数据类型：DataInputStream、DataOutputStream</li><li>缓冲操作：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</li><li>打印：PrintStream、PrintWriter</li><li>对象序列化反序列化：ObjectInputStream、ObjectOutputStream</li><li>转换：InputStreamReader、OutputStreWriter</li><li><del>字符串（String）</del><strong>Java8中已废弃</strong>：<del>StringBufferInputStream、StringBufferOutputStream、StringReader、StringWriter</del></li></ul><h3 id="传输类型"><a href="#传输类型" class="headerlink" title="传输类型"></a>传输类型</h3><h4 id="字节流-byte"><a href="#字节流-byte" class="headerlink" title="字节流  byte"></a>字节流  byte</h4><p>InputStream、OutputStream</p><h5 id="InputStream-类"><a href="#InputStream-类" class="headerlink" title="InputStream 类"></a><strong>InputStream 类</strong></h5><h6 id="inputStream方法"><a href="#inputStream方法" class="headerlink" title="inputStream方法"></a>inputStream方法</h6><table><thead><tr><th style="text-align:left">方法</th><th>方法介绍</th></tr></thead><tbody><tr><td style="text-align:left">public abstract int read()</td><td>读取数据</td></tr><tr><td style="text-align:left">public int read(byte b[])</td><td>将读取到的数据放在 byte 数组中，该方法实际上是根据下面的方法实现的，off 为 0，len 为数组的长度</td></tr><tr><td style="text-align:left">public int read(byte b[], int off, int len)</td><td>从第 off 位置读取 len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的（注意这里读取的虽然是一个字节，但是返回的却是 int 类型 4 个字节，这里当然是有原因，这里就不再细说了，推荐这篇文章，<a href="https://blog.csdn.net/congwiny/article/details/18922847" target="_blank" rel="noopener">链接</a>）</td></tr><tr><td style="text-align:left">public long skip(long n)</td><td>跳过指定个数的字节不读取，想想看电影跳过片头片尾</td></tr><tr><td style="text-align:left">public int available()</td><td>返回可读的字节数量</td></tr><tr><td style="text-align:left">public void close()</td><td>读取完，关闭流，释放资源</td></tr><tr><td style="text-align:left">public synchronized void mark(int readlimit)</td><td>标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断</td></tr><tr><td style="text-align:left">public synchronized void reset()</td><td>重置读取位置为上次 mark 标记的位置</td></tr><tr><td style="text-align:left">public boolean markSupported()</td><td>判断当前流是否支持标记流，和上面两个方法配套使用</td></tr></tbody></table><h6 id="inputStream-体系"><a href="#inputStream-体系" class="headerlink" title="inputStream 体系"></a>inputStream 体系</h6><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g79ikx5gccj31r00p4n0m.jpg" alt="image-20190922173230599"></p><h6 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h6><p>InputStream 抽象类,所有子类实现如下</p><ul><li>ByteArrayInputStream  字节数组输入流</li><li>PipedInputStream 管道流 用于线程间通信</li><li>FileInputStream 文件系统IO</li><li>FilterInputStream  装饰器模式<ul><li>BufferedInputStream   带缓冲池的输入流</li><li>DataInputStream  基本数据类型的输入流</li><li>PushbackInputStream   </li></ul></li><li>ObjectInputStream</li></ul><h5 id="OutputStream-类"><a href="#OutputStream-类" class="headerlink" title="OutputStream 类"></a><strong>OutputStream 类</strong></h5><p>PrintStream -&gt;System.out </p><table><thead><tr><th>方法</th><th>方法介绍</th></tr></thead><tbody><tr><td>public abstract void write(int b)</td><td>写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。</td></tr><tr><td>public void write(byte b[])</td><td>将数组中的所有字节写入，和上面对应的 read() 方法类似，实际调用的也是下面的方法。</td></tr><tr><td>public void write(byte b[], int off, int len)</td><td>将 byte 数组从 off 位置开始，len 长度的字节写入</td></tr><tr><td>public void flush()</td><td>强制刷新，将缓冲中的数据写入</td></tr><tr><td>public void close()</td><td>关闭输出流，流被关闭后就不能再输出数据了</td></tr></tbody></table><h4 id="字符流-char"><a href="#字符流-char" class="headerlink" title="字符流  char"></a>字符流  char</h4><p>区别</p><p>1.实现接口</p><p>2.为什么有lock </p><p>其中</p><p>InputStreamReader，字节流通向字符流的桥梁：它使用指定的charset(nio)读取字节并将其解码为字符。功能是依赖于StreamDecoder完成的。</p><p>Reader、Writer</p><h5 id="Reader-类"><a href="#Reader-类" class="headerlink" title="Reader 类"></a><strong>Reader 类</strong></h5><table><thead><tr><th>方法</th><th>方法介绍</th></tr></thead><tbody><tr><td>public int read(java.nio.CharBuffer target)</td><td>读取字节到字符缓存中</td></tr><tr><td>public int read()</td><td>读取单个字符</td></tr><tr><td>public int read(char cbuf[])</td><td>读取字符到指定的 char 数组中</td></tr><tr><td>abstract public int read(char cbuf[], int off, int len)</td><td>从 off 位置读取 len 长度的字符到 char 数组中</td></tr><tr><td>public long skip(long n)</td><td>跳过指定长度的字符数量</td></tr><tr><td>public boolean ready()</td><td>和上面的 available() 方法类似</td></tr><tr><td>public boolean markSupported()</td><td>判断当前流是否支持标记流</td></tr><tr><td>public void mark(int readAheadLimit)</td><td>标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断</td></tr><tr><td>public void reset()</td><td>重置读取位置为上次 mark 标记的位置</td></tr><tr><td>abstract public void close()</td><td>关闭流释放相关资源</td></tr></tbody></table><h5 id="Writer-类"><a href="#Writer-类" class="headerlink" title="Writer 类"></a><strong>Writer 类</strong></h5><table><thead><tr><th>方法</th><th>方法介绍</th></tr></thead><tbody><tr><td>public void write(int c)</td><td>写入一个字符</td></tr><tr><td>public void write(char cbuf[])</td><td>写入一个字符数组</td></tr><tr><td>abstract public void write(char cbuf[], int off, int len)</td><td>从字符数组的 off 位置写入 len 数量的字符</td></tr><tr><td>public void write(String str)</td><td>写入一个字符串</td></tr><tr><td>public void write(String str, int off, int len)</td><td>从字符串的 off 位置写入 len 数量的字符</td></tr><tr><td>public Writer append(CharSequence csq)</td><td>追加吸入一个字符序列</td></tr><tr><td>public Writer append(CharSequence csq, int start, int end)</td><td>追加写入一个字符序列的一部分，从 start 位置开始，end 位置结束</td></tr><tr><td>public Writer append(char c)</td><td>追加写入一个 16 位的字符</td></tr><tr><td>abstract public void flush()</td><td>强制刷新，将缓冲中的数据写入</td></tr><tr><td>abstract public void close()</td><td>关闭输出流，流被关闭后就不能再输出数据了</td></tr></tbody></table><p>参考链接:</p><blockquote><p>@link: <a href="https://blog.csdn.net/panweiwei1994/article/details/78046000" target="_blank" rel="noopener">https://blog.csdn.net/panweiwei1994/article/details/78046000</a></p><p>@link <a href="https://www.jianshu.com/p/715659e4775f" target="_blank" rel="noopener">https://www.jianshu.com/p/715659e4775f</a></p></blockquote><h2 id="serialization"><a href="#serialization" class="headerlink" title="serialization"></a>serialization</h2><p>​    Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。</p><p>为什么需要</p><ul><li>持久化</li><li>网络传输</li></ul><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html</a></p><p>Serializability of a class is enabled by the class implementing the java.io.Serializable interface.</p><p>通过实现接口,开启可序列化</p><h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>如果可序列化的类未明确声明serialVersionUID，则序列化运行时将根据该类的各个方面，为该类计算默认的serialVersionUID值，如Java（TM）对象序列化规范中所述。</p><p>但是，<em>强烈建议</em>所有可序列化的类显式声明serialVersionUID值，因为默认的serialVersionUID计算对类详细信息高度敏感，类详细信息可能会因编译器的实现而有所不同，因此可能导致意外情况 <code>InvalidClassException</code>在反序列化过程中。因此，为了保证不同Java编译器实现之间的serialVersionUID值一致，可序列化的类必须声明一个显式的serialVersionUID值。</p><p>还强烈建议显式serialVersionUID声明<code>private</code>在可能的情况下使用修饰符，因为此类声明仅适用于立即声明的类-serialVersionUID字段作为继承成员不起作用。数组类无法声明显式的serialVersionUID，因此它们始终具有默认的计算值，但是对于数组类，无需匹配serialVersionUID值。</p><h3 id="ObjectStreamClass-序列化描述符"><a href="#ObjectStreamClass-序列化描述符" class="headerlink" title="ObjectStreamClass (序列化描述符)"></a>ObjectStreamClass (序列化描述符)</h3><p>官方文档对这个类的介绍如下</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectStreamClass.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/io/ObjectStreamClass.html</a></p><p>Serialization’s descriptor for classes. It contains the name and serialVersionUID of the class. The ObjectStreamClass for a specific class loaded in this Java VM can be found/created using the lookup method.</p><p>可以看到ObjectStreamClass这个是类的序列化描述符，这个类可以描述需要被序列化的类的元数据，包括被序列化的类的名字以及序列号。可以通过lookup()方法来查找/创建在这个JVM中加载的特定的ObjectStreamClass对象</p><h3 id="ObjectOutputStream-序列化"><a href="#ObjectOutputStream-序列化" class="headerlink" title="ObjectOutputStream (序列化)"></a>ObjectOutputStream (序列化)</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g79fkji2phj313o0iiq4m.jpg" alt="image-20190923142345325" style="zoom:50%;"></p><h4 id="ObjectOutput"><a href="#ObjectOutput" class="headerlink" title="ObjectOutput"></a>ObjectOutput</h4><p>​    DataOutput includes methods for output of primitive types, ObjectOutput extends that interface to include objects, arrays, and Strings.</p><pre><code class="java">public interface ObjectOutput extends DataOutput, AutoCloseable {    /**     * Write an object to the underlying storage or stream.  The     * class that implements this interface defines how the object is     * written.     *     * @param obj the object to be written     * @exception IOException Any of the usual Input/Output related exceptions.     */    public void writeObject(Object obj)      throws IOException;    /**     * Writes a byte. This method will block until the byte is actually     * written.     * @param b the byte     * @exception IOException If an I/O error has occurred.     */    public void write(int b) throws IOException;    /**     * Writes an array of bytes. This method will block until the bytes     * are actually written.     * @param b the data to be written     * @exception IOException If an I/O error has occurred.     */    public void write(byte b[]) throws IOException;    /**     * Writes a sub array of bytes.     * @param b the data to be written     * @param off       the start offset in the data     * @param len       the number of bytes that are written     * @exception IOException If an I/O error has occurred.     */    public void write(byte b[], int off, int len) throws IOException;    /**     * Flushes the stream. This will write any buffered     * output bytes.     * @exception IOException If an I/O error has occurred.     */    public void flush() throws IOException;    /**     * Closes the stream. This method must be called     * to release any resources associated with the     * stream.     * @exception IOException If an I/O error has occurred.     */    public void close() throws IOException;}</code></pre><h4 id="ObjectStreamConstants"><a href="#ObjectStreamConstants" class="headerlink" title="ObjectStreamConstants"></a>ObjectStreamConstants</h4><p>​    Constants written into the Object Serialization Stream.</p><p>更多细节 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectStreamConstants.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/io/ObjectStreamConstants.html</a></p><h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code>public class ObjectOutputStream    extends OutputStream implements ObjectOutput, ObjectStreamConstants{        public ObjectOutputStream(OutputStream out) throws IOException {        verifySubclass();        bout = new BlockDataOutputStream(out);        handles = new HandleTable(10, (float) 3.00);        subs = new ReplaceTable(10, (float) 3.00);        enableOverride = false;        writeStreamHeader();        bout.setBlockDataMode(true);        if (extendedDebugInfo) {            debugInfoStack = new DebugTraceInfoStack();        } else {            debugInfoStack = null;        }    }    ...}</code></pre><p>构造函数中首先会把bout对绑定到底层的字节数据容器，接着会调用writeStreamHeader()方法</p><p>,会往底层字节容器中写入表示序列化的Magic Number以及版本号</p><h5 id="writeObject"><a href="#writeObject" class="headerlink" title="writeObject"></a>writeObject</h5><pre><code class="java">      public final void writeObject(Object obj) throws IOException {        if (enableOverride) {            writeObjectOverride(obj);            return;        }        try {            writeObject0(obj, false);        } catch (IOException ex) {            if (depth == 0) {                writeFatalException(ex);            }            throw ex;        }    }/** * Underlying writeObject/writeUnshared implementation. */private void writeObject0(Object obj, boolean unshared)    throws IOException{    boolean oldMode = bout.setBlockDataMode(false);    depth++;    try {        // handle previously written and non-replaceable objects        int h;        if ((obj = subs.lookup(obj)) == null) {            writeNull();            return;        } else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) {            writeHandle(h);            return;        } else if (obj instanceof Class) {            writeClass((Class) obj, unshared);            return;        } else if (obj instanceof ObjectStreamClass) {            writeClassDesc((ObjectStreamClass) obj, unshared);            return;        }        // check for replacement object        Object orig = obj;        Class&lt;?&gt; cl = obj.getClass();        ObjectStreamClass desc;        for (;;) {            // REMIND: skip this check for strings/arrays?            Class&lt;?&gt; repCl;            desc = ObjectStreamClass.lookup(cl, true);            if (!desc.hasWriteReplaceMethod() ||                (obj = desc.invokeWriteReplace(obj)) == null ||                (repCl = obj.getClass()) == cl)            {                break;            }            cl = repCl;        }        if (enableReplace) {            Object rep = replaceObject(obj);            if (rep != obj &amp;&amp; rep != null) {                cl = rep.getClass();                desc = ObjectStreamClass.lookup(cl, true);            }            obj = rep;        }        // if object replaced, run through original checks a second time        if (obj != orig) {            subs.assign(orig, obj);            if (obj == null) {                writeNull();                return;            } else if (!unshared &amp;&amp; (h = handles.lookup(obj)) != -1) {                writeHandle(h);                return;            } else if (obj instanceof Class) {                writeClass((Class) obj, unshared);                return;            } else if (obj instanceof ObjectStreamClass) {                writeClassDesc((ObjectStreamClass) obj, unshared);                return;            }        }        // remaining cases        if (obj instanceof String) {            writeString((String) obj, unshared);        } else if (cl.isArray()) {            writeArray(obj, desc, unshared);        } else if (obj instanceof Enum) {            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);        } else if (obj instanceof Serializable) {            writeOrdinaryObject(obj, desc, unshared);        } else {            if (extendedDebugInfo) {                throw new NotSerializableException(                    cl.getName() + &quot;\n&quot; + debugInfoStack.toString());            } else {                throw new NotSerializableException(cl.getName());            }        }    } finally {        depth--;        bout.setBlockDataMode(oldMode);    }}</code></pre><p>  这个方法主要就是 创建描述cl的ObjectStreamClass对象,然后根据是否实现接口调用writeOrdinaryObject方法</p><h5 id="writeOrdinaryObject"><a href="#writeOrdinaryObject" class="headerlink" title="writeOrdinaryObject"></a>writeOrdinaryObject</h5><pre><code class="java">/** * Writes representation of a &quot;ordinary&quot; (i.e., not a String, Class, * ObjectStreamClass, array, or enum constant) serializable object to the * stream. */private void writeOrdinaryObject(Object obj,                                 ObjectStreamClass desc,                                 boolean unshared)    throws IOException{    if (extendedDebugInfo) {        debugInfoStack.push(            (depth == 1 ? &quot;root &quot; : &quot;&quot;) + &quot;object (class \&quot;&quot; +            obj.getClass().getName() + &quot;\&quot;, &quot; + obj.toString() + &quot;)&quot;);    }    try {        desc.checkSerialize();       // 写入Object标志位        bout.writeByte(TC_OBJECT);        // 写入类元数据        writeClassDesc(desc, false);        handles.assign(unshared ? null : obj);        if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {            writeExternalData((Externalizable) obj);        } else {           // 写入被序列化的对象的实例数据            writeSerialData(obj, desc);        }    } finally {        if (extendedDebugInfo) {            debugInfoStack.pop();        }    }}</code></pre><h5 id="writeSerialData"><a href="#writeSerialData" class="headerlink" title="writeSerialData"></a>writeSerialData</h5><pre><code class="java">/** * Writes instance data for each serializable class of given object, from * superclass to subclass. */private void writeSerialData(Object obj, ObjectStreamClass desc)    throws IOException{    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();    for (int i = 0; i &lt; slots.length; i++) {        ObjectStreamClass slotDesc = slots[i].desc;        if (slotDesc.hasWriteObjectMethod()) {            PutFieldImpl oldPut = curPut;            curPut = null;            SerialCallbackContext oldContext = curContext;            if (extendedDebugInfo) {                debugInfoStack.push(                    &quot;custom writeObject data (class \&quot;&quot; +                    slotDesc.getName() + &quot;\&quot;)&quot;);            }            try {                curContext = new SerialCallbackContext(obj, slotDesc);                bout.setBlockDataMode(true);                slotDesc.invokeWriteObject(obj, this);                bout.setBlockDataMode(false);                bout.writeByte(TC_ENDBLOCKDATA);            } finally {                curContext.setUsed();                curContext = oldContext;                if (extendedDebugInfo) {                    debugInfoStack.pop();                }            }            curPut = oldPut;        } else {            defaultWriteFields(obj, slotDesc);        }    }}</code></pre><p>​    在这个方法中首先会调用getClassDataSlot()方法获取被序列化对象的数据的布局, 需要注意的是这个方法会把从父类继承的数据一并返回，并且表示从父类继承的数据的ClassDataSlot对象在数组的最前面。</p><p>​    然后根据slotDesc.hasWriteObjectMethod() , 对于没有自定义writeObject()方法的对象来说，接下来会调用defaultWriteFields()方法写入数据</p><h5 id="defaultWriteFields"><a href="#defaultWriteFields" class="headerlink" title="defaultWriteFields"></a>defaultWriteFields</h5><pre><code class="java">/** * Fetches and writes values of serializable fields of given object to * stream.  The given class descriptor specifies which field values to * write, and in which order they should be written. */private void defaultWriteFields(Object obj, ObjectStreamClass desc)    throws IOException{    Class&lt;?&gt; cl = desc.forClass();    if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {        throw new ClassCastException();    }    desc.checkDefaultSerialize();    int primDataSize = desc.getPrimDataSize();    if (primVals == null || primVals.length &lt; primDataSize) {        primVals = new byte[primDataSize];    }    // 获取对应类中的基本数据类型的数据并保存在primVals字节数组中    desc.getPrimFieldValues(obj, primVals);    // 把基本数据类型的数据写入底层字节容器中    bout.write(primVals, 0, primDataSize, false);        // 获取对应类的所有的字段对象    ObjectStreamField[] fields = desc.getFields(false);    Object[] objVals = new Object[desc.getNumObjFields()];    int numPrimFields = fields.length - objVals.length;    // 把对应类的Object类型(非原始类型)的对象保存到objVals数组中    desc.getObjFieldValues(obj, objVals);    for (int i = 0; i &lt; objVals.length; i++) {        if (extendedDebugInfo) {            debugInfoStack.push(                &quot;field (class \&quot;&quot; + desc.getName() + &quot;\&quot;, name: \&quot;&quot; +                fields[numPrimFields + i].getName() + &quot;\&quot;, type: \&quot;&quot; +                fields[numPrimFields + i].getType() + &quot;\&quot;)&quot;);        }        try {            // 对所有Object类型的字段递归调用writeObject0()方法写入对应的数据            writeObject0(objVals[i],                         fields[numPrimFields + i].isUnshared());        } finally {            if (extendedDebugInfo) {                debugInfoStack.pop();            }        }    }}</code></pre><p>可以看到，在这个方法中会做下面几件事情:</p><ul><li>获取对应类的基本类型的字段的数据，并写入到底层的字节容器中。</li><li>获取对应类的Object类型(非基本类型)的字段成员，递归调用writeObject0()方法写入相应的数据。</li></ul><p>从上面对写入数据的分析可以知道，写入数据是是按照先父类后子类的顺序来写的。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>1. static和transient字段不能被序列化。</strong></p><p>序列化的时候所有的数据都是来自于ObejctStreamClass对象，在生成ObjectStreamClass的构造函数中会调用fields = getSerialFields(cl);</p><p>​    int mask = Modifier.STATIC | Modifier.TRANSIENT;</p><p><strong>2. 如何实现自定义序列化和反序列化？</strong></p><p>​    在ObejctStreamClass的构造函数中会查找被序列化类中有没有定义为void writeObject(ObjectOutputStream oos) 的函数，如果找到的话，则会把找到的方法赋值给writeObjectMethod这个变量，如果没有找到的话则为null。</p><h3 id="ObjectInputStream-反序列化"><a href="#ObjectInputStream-反序列化" class="headerlink" title="ObjectInputStream (反序列化)"></a>ObjectInputStream (反序列化)</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g79fjqic29j30yi0hw0ua.jpg" alt="image-20190923142258452" style="zoom:50%;"></p><p>反序列化过程就是按照前面介绍的序列化算法来解析二进制数据。</p><p>有一个需要注意的问题就是，如果子类实现了Serializable接口，但是父类没有实现Serializable接口，这个时候进行反序列化会发生什么情况？</p><p>答：如果父类有默认构造函数的话，即使没有实现Serializable接口也不会有问题，反序列化的时候会调用默认构造函数进行初始化，否则的话反序列化的时候会抛出.InvalidClassException:异常，异常原因为no valid constructor。</p><h3 id="序列化性能"><a href="#序列化性能" class="headerlink" title="序列化性能"></a>序列化性能</h3><p><a href="https://blog.csdn.net/qq_31457665/article/details/82587942" target="_blank" rel="noopener">https://blog.csdn.net/qq_31457665/article/details/82587942</a></p><p>参考链接:</p><blockquote><p>@link : <a href="https://mp.weixin.qq.com/s/1D-CtyvAXOYO8mH66HHJJQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1D-CtyvAXOYO8mH66HHJJQ</a></p></blockquote><h2 id="file-system"><a href="#file-system" class="headerlink" title="file system"></a>file system</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>from <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/io/File.html</a></p><blockquote><p>An abstract representation of file and directory pathnames.</p><p>User interfaces and operating systems use system-dependent <em>pathname strings</em> to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames. An <em>abstract pathname</em> has two components:</p><ol><li>An optional system-dependent <em>prefix</em> string, such as a disk-drive specifier, <code>&quot;/&quot;</code> for the UNIX root directory, or <code>&quot;\\\\&quot;</code> for a Microsoft Windows UNC pathname, and</li><li>A sequence of zero or more string <em>names</em>.</li></ol></blockquote><p>文件和目录路径名的抽象表示形式。 我们知道,对于不同的操作系统,文件路径的描述是不同的 比如 </p><ul><li>windows平台：用\ </li><li>linux平台：用/ </li></ul><p>File是Java为了这一概念提供的抽象描述,与系统无关的视图 </p><p><strong>抽象路径名</strong>有两个组件: </p><p>1.可选的与系统有关的<strong>前缀</strong>  字符串   比如盘符，”/“ 表示 UNIX 中的根目录,”\\“ 表示 Microsoft Windows UNC 路径名 </p><p>2.零个或者多个  字符串  名称 序列 </p><p><strong>最后一个名称可以是目录,也可以是文件名称,那么File 并不一定就是一个文件,也可以是一个文件路径,也就是目录</strong></p><h4 id="File-API分类"><a href="#File-API分类" class="headerlink" title="File API分类"></a><strong>File API分类</strong></h4><ul><li>文件自身属性读取</li><li>创建文件/目录基本操作</li><li>文件/目录 列表读取</li><li>文件权限访问以及文件信息设置</li><li>其他</li></ul><h3 id="FileSystem"><a href="#FileSystem" class="headerlink" title="FileSystem"></a>FileSystem</h3><p>File中有一个变量fs  类型为FileSystem </p><pre><code>private static final FileSystem fs = DefaultFileSystem.getFileSystem();</code></pre><p>​    操作系统有各自的文件系统，这些文件系统又存在很多差异，而Java 因为是跨平台的，所以它必须要统一处理这些不同平台文件系统之间的差异，才能往上提供统一的入口。 </p><p>说白了又是接口来实现统一,不同的操作系统实现这个接口,就可以提供统一的表现形式 </p><p>FileSystem是一个抽象类,不同系统会有不同的实现 </p><h3 id="java-nio-file"><a href="#java-nio-file" class="headerlink" title="java.nio.file"></a>java.nio.file</h3><p>在1.7中重构了文件系统</p><pre><code>public Path toPath() {    Path result = filePath;    if (result == null) {        synchronized (this) {            result = filePath;            if (result == null) {                result = FileSystems.getDefault().getPath(path);                filePath = result;            }        }    }    return result;}</code></pre><p>Nio file中解决了一些问题,和扩展</p><blockquote><p>Interoperability with <code>java.nio.file</code> package</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/package-summary.html" target="_blank" rel="noopener"><code>java.nio.file</code></a> package defines interfaces and classes for the Java virtual machine to access files, file attributes, and file systems. This API may be used to overcome many of the limitations of the <code>java.io.File</code> class. The <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html#toPath--" target="_blank" rel="noopener"><code>toPath</code></a> method may be used to obtain a <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html" target="_blank" rel="noopener"><code>Path</code></a> that uses the abstract path represented by a <code>File</code> object to locate a file. The resulting <code>Path</code> may be used with the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" target="_blank" rel="noopener"><code>Files</code></a> class to provide more efficient and extensive access to additional file operations, file attributes, and I/O exceptions to help diagnose errors when an operation on a file fails.</p></blockquote><p>参考链接:</p><blockquote><p>@Link:<a href="https://cloud.tencent.com/developer/article/1333744" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1333744</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> packages </tag>
            
            <tag> io </tag>
            
            <tag> serialization </tag>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_Class</title>
      <link href="/2019/08/31/JDK-Class/"/>
      <url>/2019/08/31/JDK-Class/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我最后的祝福是要给那些人——他们知道我不完美却还爱着我 ——《流萤集》</p></blockquote><p>关于Class 你想知道的我这里都有😊</p><ul><li>☕️ JDK Class类分析</li><li>📃 class文件构成分析</li><li>🔧 字节码工具介绍</li><li>➕ 类加载</li></ul><a id="more"></a><h3 id="JDK中的Class类"><a href="#JDK中的Class类" class="headerlink" title="JDK中的Class类"></a>JDK中的Class类</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html</a></p><p>先来看看JDK中对Class类的介绍</p><blockquote><p>Instances of the class <code>Class</code> represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a <code>Class</code> object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (<code>boolean</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code>), and the keyword <code>void</code> are also represented as <code>Class</code>objects.</p><p><code>Class</code> has no public constructor. Instead <code>Class</code> objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the <code>defineClass</code> method in the class loader.</p></blockquote><p>类的实例表示运行中的Java应用程序中的类和接口。枚举是一种类，注解是一种接口。每个数组也属于一个类，这个类反映为一个类对象，由具有相同元素类型和维数的所有数组共享。原始Java类型(boolean、byte、char、short、int、long、float和double)和关键字void也表示为类对象。</p><p>类没有公共构造函数。相反，类对象是在类装入时由Java虚拟机自动构造的，并通过调用类装入器中的defineClass方法构造的。</p><p>类的成员 包含 (Declared前缀可以获得公开的类)  </p><ul><li>getFields  字段 </li><li>getMethods 方法</li><li>getConstructors  构造函数</li><li>getClasses  内部类</li><li>getAnnotations  注解</li><li>getSuperclass  父类</li><li>getInterfaces   接口</li></ul><p>更多细节可以查看 JLS 第8章</p><p>getFields 分析</p><pre><code class="java">////// java.lang.reflect.Field handling////// Returns an array of &quot;root&quot; fields. These Field objects must NOT// be propagated to the outside world, but must instead be copied// via ReflectionFactory.copyField.private Field[] privateGetDeclaredFields(boolean publicOnly) {    checkInitted();    Field[] res;    ReflectionData&lt;T&gt; rd = reflectionData();    if (rd != null) {        res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;        if (res != null) return res;    }    // No cached value available; request value from VM    res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));    if (rd != null) {        if (publicOnly) {            rd.declaredPublicFields = res;        } else {            rd.declaredFields = res;        }    }    return res;}</code></pre><p>从缓存中获取, 如果为空则从VM获取 , 其中 reflectionData 反射缓存Bo  (useCaches 默认为true)</p><pre><code class="java">private volatile transient SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;// Incremented by the VM on each call to JVM TI RedefineClasses()// that redefines this class or a superclass.private volatile transient int classRedefinedCount = 0;// Lazily create and cache ReflectionDataprivate ReflectionData&lt;T&gt; reflectionData() {    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;    int classRedefinedCount = this.classRedefinedCount;    ReflectionData&lt;T&gt; rd;    if (useCaches &amp;&amp;        reflectionData != null &amp;&amp;        (rd = reflectionData.get()) != null &amp;&amp;        rd.redefinedCount == classRedefinedCount) {        return rd;    }    // else no SoftReference or cleared SoftReference or stale ReflectionData    // -&gt; create and replace new instance    return newReflectionData(reflectionData, classRedefinedCount);}private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,int classRedefinedCount) {        if (!useCaches) return null;        while (true) {            ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);            // try to CAS it...            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {                return rd;            }            // else retry            oldReflectionData = this.reflectionData;            classRedefinedCount = this.classRedefinedCount;            if (oldReflectionData != null &amp;&amp;                (rd = oldReflectionData.get()) != null &amp;&amp;                rd.redefinedCount == classRedefinedCount) {                return rd;            }        }    }</code></pre><p>简单总结 Class的成员 字段 方法 和构造函数  通常与反射一起使用</p><h3 id="Class文件的构成"><a href="#Class文件的构成" class="headerlink" title="Class文件的构成"></a>Class文件的构成</h3><p>通过javac xxx 可以生成 xxx.class 文件</p><p>字节码结构</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">说明</th><th style="text-align:center">长度</th></tr></thead><tbody><tr><td style="text-align:center">u4</td><td style="text-align:center">magic</td><td style="text-align:center">魔数，识别Class文件格式</td><td style="text-align:center">4个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">minor_version</td><td style="text-align:center">副版本号</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">major_version</td><td style="text-align:center">主版本号</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">constant_pool_count</td><td style="text-align:center">常量池计算器</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">cp_info</td><td style="text-align:center">constant_pool</td><td style="text-align:center">常量池</td><td style="text-align:center">n个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">access_flags</td><td style="text-align:center">访问标志</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">this_class</td><td style="text-align:center">类索引</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">super_class</td><td style="text-align:center">父类索引</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">interfaces_count</td><td style="text-align:center">接口计数器</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">interfaces</td><td style="text-align:center">接口索引集合</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">fields_count</td><td style="text-align:center">字段个数</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">field_info</td><td style="text-align:center">fields</td><td style="text-align:center">字段集合</td><td style="text-align:center">n个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">methods_count</td><td style="text-align:center">方法计数器</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">method_info</td><td style="text-align:center">methods</td><td style="text-align:center">方法集合</td><td style="text-align:center">n个字节</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">attributes_count</td><td style="text-align:center">附加属性计数器</td><td style="text-align:center">2个字节</td></tr><tr><td style="text-align:center">attribute_info</td><td style="text-align:center">attributes</td><td style="text-align:center">附加属性集合</td><td style="text-align:center">n个字节</td></tr></tbody></table><p>这是一张Java字节码总的结构表，我们按照上面的顺序逐一进行解读就可以了。</p><p>首先，我们来说明一下：class文件只有两种数据类型：<code>无符号数</code>和<code>表</code>。如下表所示：</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">定义</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">无符号数</td><td style="text-align:center">无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td><td style="text-align:center">其中无符号数属于基本的数据类型。以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td></tr><tr><td style="text-align:center">表</td><td style="text-align:center">表是由多个无符号数或其他表构成的复合数据结构。</td><td style="text-align:center">所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><p>实际上整个class文件就是一张表，其结构就是上面的表一了。</p><p>更多细节参考<a href="https://www.jianshu.com/p/2c106b682cfb" target="_blank" rel="noopener">https://www.jianshu.com/p/2c106b682cfb</a></p><h3 id="操纵字节码"><a href="#操纵字节码" class="headerlink" title="操纵字节码"></a>操纵字节码</h3><p>Javassist 、 ASM 、 cglib</p><p>更多参考 <a href="https://blog.csdn.net/Mary881225/article/details/64132547" target="_blank" rel="noopener">https://blog.csdn.net/Mary881225/article/details/64132547</a></p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="Class-是什么时候加载进来的"><a href="#Class-是什么时候加载进来的" class="headerlink" title="Class 是什么时候加载进来的"></a>Class 是什么时候加载进来的</h4><h5 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h5><ul><li>JVM启动的时候,会使用 ClassLoader 加载 java自身相关的类</li><li>自定义类使用的时候加载</li></ul><h5 id="类装载的过程"><a href="#类装载的过程" class="headerlink" title="类装载的过程"></a>类装载的过程</h5><p>加载 、链接(验证、准备、解析)、初始化</p><p>Jvm把class文件字节码加载到内存中，并将这些静态数据装换成运行时数据区中方法区的类型数据，在运行时数据区堆中生成一个代表这个类</p><ul><li>类加载：Jvm把class文件字节码加载到内存中，并将这些静态数据装换成运行时数据区中方法区的类型数据，在运行时数据区堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</li><li>链接：执行下面的校验、准备和解析步骤，其中解析步骤是可选的。</li><li>初始化：执行类变量赋值和静态代码块。</li></ul><h4 id="你知道Class-forName-和-ClassLoder-loadClass的区别吗"><a href="#你知道Class-forName-和-ClassLoder-loadClass的区别吗" class="headerlink" title="你知道Class.forName  和 ClassLoder.loadClass的区别吗?"></a>你知道Class.forName  和 ClassLoder.loadClass的区别吗?</h4><pre><code class="java">class MyClass {    static {//静态块          System.err.println(&quot;static block run&quot;);    }    static String init(){        return &quot;init&quot;;    }}/** * 静态代码块的执行是处在类加载的最后一个阶段“初始化” * * 加载 、验证、准备、解析、初始化 */public class StaticInitDemo {    public static void main(String[] args) {        System.out.println(&quot;run MyClass.class&quot;);        Class c = MyClass.class;        System.out.println(&quot;run ClassLoader.loadClass&quot;);        try {          Thread.currentThread().getContextClassLoader().loadClass(&quot;com.practical.MyClass&quot;);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        System.out.println(&quot;run Class forName&quot;);        try {            Class.forName(&quot;com.practical.MyClass&quot;);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>上述代码运行结果为</p><pre><code>run MyClass.classrun ClassLoader.loadClassrun Class forNamestatic block run</code></pre><h5 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h5><pre><code class="java">@CallerSensitivepublic static Class&lt;?&gt; forName(String className)            throws ClassNotFoundException {    Class&lt;?&gt; caller = Reflection.getCallerClass();    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);}</code></pre><h5 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h5><pre><code class="java">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {    return loadClass(name, false);} protected Class&lt;?&gt; loadClass(String name, boolean resolve)        throws ClassNotFoundException    {        synchronized (getClassLoadingLock(name)) {            // First, check if the class has already been loaded            Class&lt;?&gt; c = findLoadedClass(name);            if (c == null) {                long t0 = System.nanoTime();                try {                    if (parent != null) {                        c = parent.loadClass(name, false);                    } else {                        c = findBootstrapClassOrNull(name);                    }                } catch (ClassNotFoundException e) {                    // ClassNotFoundException thrown if class not found                    // from the non-null parent class loader                }                if (c == null) {                    // If still not found, then invoke findClass in order                    // to find the class.                    long t1 = System.nanoTime();                    c = findClass(name);                    // this is the defining class loader; record the stats                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    sun.misc.PerfCounter.getFindClasses().increment();                }            }            if (resolve) {                resolveClass(c);            }            return c;        }    }</code></pre><p>结论:</p><p>Class.forName得到的class是已经初始化完成的，该方法适合那些在类加载时需要初始化一些东西的情况。比如，加载数据库驱动。</p><p>Classloder.loaderClass得到的class是还没有链接的，该方法适合在类加载时不需要一些初始化的情况。</p><h4 id="ClassNotFoundException-and-NoClassDefFoundError-LinkageError"><a href="#ClassNotFoundException-and-NoClassDefFoundError-LinkageError" class="headerlink" title="ClassNotFoundException and  NoClassDefFoundError(LinkageError)"></a>ClassNotFoundException and  NoClassDefFoundError(LinkageError)</h4><p>ClassNotFoundException 发生在类加载时候</p><p>NoclassDefFoundError 发生在在链接时候</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_Thread</title>
      <link href="/2019/08/31/JDK-Thread/"/>
      <url>/2019/08/31/JDK-Thread/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我的心是旷野的鸟 在你眼里找到了它的天空  ——园丁集</p></blockquote><h2 id="prefer"><a href="#prefer" class="headerlink" title="prefer"></a>prefer</h2><p>在 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#method.detail" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#method.detail</a> 中有这样一句</p><p>There are two ways to create a new thread of execution.</p><ul><li>Extends Thread</li><li>Implement Runnable</li></ul><p>然后想起经常可以看网上问的 线程有几种创建方式? Thread 和Runnable 有什么区别? </p><a id="more"></a><h2 id="Java与os线程"><a href="#Java与os线程" class="headerlink" title="Java与os线程"></a>Java与os线程</h2><h3 id="os线程"><a href="#os线程" class="headerlink" title="os线程"></a>os线程</h3><p>我们知道，java的一个线程实际上是对应了操作系统的一个线程；</p><p>而操作系统实现线程有三种方式：</p><ul><li>内核线程实现 (java 1.2后实现)</li><li>用户线程实现</li><li>用户线程加轻量级进程混合实现</li></ul><p>具体详细实现方式就不具体讲了，参见 «深入理解 JAVA虚拟机»第二版 第12章 Java内存模型与线程（378页）</p><h3 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h3><p>Java线程在JDK1.2之前，是基于用户线程实现的。而在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现。</p><p>而在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没法达成一致。</p><p>对于Sun JDK来说，它的Windows版本和Linux版本都是使用一对一的线程模型实现的，一条Java线程映射到一条轻量级进程之中。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>先来看看两种方式的实现</p><h3 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h3><pre><code class="java">/** * 线程创建example */public static void threadCreateExample() {   //1.extend   class DemoThread extends Thread{       @Override       public void run() {           System.out.println(&quot;extend&quot;);       }    }    new DemoThread().start();   //2.runnable    new Thread(() -&gt; System.out.println(&quot;impl&quot;)).start();}</code></pre><p>先来看看 Thread 构造方法做了什么,再来看看 不管哪种最后的启动都是调用的start方法</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><h4 id="Thread-init"><a href="#Thread-init" class="headerlink" title="Thread#init"></a>Thread#init</h4><pre><code class="java">    /**     * Allocates a new {@code Thread} object. This constructor has the same     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}     * {@code (null, null, gname)}, where {@code gname} is a newly generated     * name. Automatically generated names are of the form     * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.     */    public Thread() {        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);    }    /**     * Allocates a new {@code Thread} object. This constructor has the same     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}     * {@code (null, target, gname)}, where {@code gname} is a newly generated     * name. Automatically generated names are of the form     * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.     *     * @param  target     *         the object whose {@code run} method is invoked when this thread     *         is started. If {@code null}, this classes {@code run} method does     *         nothing.     */    public Thread(Runnable target) {        init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);    }/** * Initializes a Thread. * * @param g the Thread group * @param target the object whose run() method gets called * @param name the name of the new Thread * @param stackSize the desired stack size for the new thread, or *        zero to indicate that this parameter is to be ignored. * @param acc the AccessControlContext to inherit, or *            AccessController.getContext() if null * @param inheritThreadLocals if {@code true}, inherit initial values for *            inheritable thread-locals from the constructing thread */private void init(ThreadGroup g, Runnable target, String name,                  long stackSize, AccessControlContext acc,                  boolean inheritThreadLocals) {    if (name == null) {        throw new NullPointerException(&quot;name cannot be null&quot;);    }    this.name = name;    Thread parent = currentThread();    SecurityManager security = System.getSecurityManager();    if (g == null) {        /* Determine if it&#39;s an applet or not */        /* If there is a security manager, ask the security manager           what to do. */        if (security != null) {            g = security.getThreadGroup();        }        /* If the security doesn&#39;t have a strong opinion of the matter           use the parent thread group. */        if (g == null) {            g = parent.getThreadGroup();        }    }    /* checkAccess regardless of whether or not threadgroup is       explicitly passed in. */    g.checkAccess();    /*     * Do we have the required permissions?     */    if (security != null) {        if (isCCLOverridden(getClass())) {            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);        }    }    g.addUnstarted();    this.group = g;    this.daemon = parent.isDaemon();    this.priority = parent.getPriority();    if (security == null || isCCLOverridden(parent.getClass()))        this.contextClassLoader = parent.getContextClassLoader();    else        this.contextClassLoader = parent.contextClassLoader;    this.inheritedAccessControlContext =            acc != null ? acc : AccessController.getContext();    this.target = target;    setPriority(priority);    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)        this.inheritableThreadLocals =            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);    /* Stash the specified stack size in case the VM cares */    this.stackSize = stackSize;    /* Set thread ID */    tid = nextThreadID();}</code></pre><h4 id="Thread-start"><a href="#Thread-start" class="headerlink" title="Thread#start"></a>Thread#start</h4><p>调用start发生了什么?</p><p>使该线程开始执行;Java虚拟机调用这个线程的run方法。</p><p>结果是两个线程并发地运行:当前线程(从对start方法的调用返回)和另一个线程(执行其run方法)。</p><pre><code class="java">/** * Causes this thread to begin execution; the Java Virtual Machine * calls the &lt;code&gt;run&lt;/code&gt; method of this thread. * &lt;p&gt; * The result is that two threads are running concurrently: the * current thread (which returns from the call to the * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its * &lt;code&gt;run&lt;/code&gt; method). * &lt;p&gt; * It is never legal to start a thread more than once. * In particular, a thread may not be restarted once it has completed * execution. * * @exception  IllegalThreadStateException  if the thread was already *               started. * @see        #run() * @see        #stop() */public synchronized void start() {    /**     * This method is not invoked for the main method thread or &quot;system&quot;     * group threads created/set up by the VM. Any new functionality added     * to this method in the future may have to also be added to the VM.     *     * A zero status value corresponds to state &quot;NEW&quot;.     */    if (threadStatus != 0)        throw new IllegalThreadStateException();    /* Notify the group that this thread is about to be started     * so that it can be added to the group&#39;s list of threads     * and the group&#39;s unstarted count can be decremented. */    group.add(this);    boolean started = false;    try {        start0();        started = true;    } finally {        try {            if (!started) {                group.threadStartFailed(this);            }        } catch (Throwable ignore) {            /* do nothing. If start0 threw a Throwable then              it will be passed up the call stack */        }    }}private native void start0();</code></pre><h4 id="native-start0"><a href="#native-start0" class="headerlink" title="native#start0"></a>native#start0</h4><p>start0 是native方法</p><p>在Thread.c中可以看到start0 是调用的JVM_StartThread </p><pre><code class="c++">static JNINativeMethod methods[] = {    {&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread},    {&quot;stop0&quot;,            &quot;(&quot; OBJ &quot;)V&quot;, (void *)&amp;JVM_StopThread},    {&quot;isAlive&quot;,          &quot;()Z&quot;,        (void *)&amp;JVM_IsThreadAlive},    {&quot;suspend0&quot;,         &quot;()V&quot;,        (void *)&amp;JVM_SuspendThread},    {&quot;resume0&quot;,          &quot;()V&quot;,        (void *)&amp;JVM_ResumeThread},    {&quot;setPriority0&quot;,     &quot;(I)V&quot;,       (void *)&amp;JVM_SetThreadPriority},    {&quot;yield&quot;,            &quot;()V&quot;,        (void *)&amp;JVM_Yield},    {&quot;sleep&quot;,            &quot;(J)V&quot;,       (void *)&amp;JVM_Sleep},    {&quot;currentThread&quot;,    &quot;()&quot; THD,     (void *)&amp;JVM_CurrentThread},    {&quot;countStackFrames&quot;, &quot;()I&quot;,        (void *)&amp;JVM_CountStackFrames},    {&quot;interrupt0&quot;,       &quot;()V&quot;,        (void *)&amp;JVM_Interrupt},    {&quot;isInterrupted&quot;,    &quot;(Z)Z&quot;,       (void *)&amp;JVM_IsInterrupted},    {&quot;holdsLock&quot;,        &quot;(&quot; OBJ &quot;)Z&quot;, (void *)&amp;JVM_HoldsLock},    {&quot;getThreads&quot;,        &quot;()[&quot; THD,   (void *)&amp;JVM_GetAllThreads},    {&quot;dumpThreads&quot;,      &quot;([&quot; THD &quot;)[[&quot; STE, (void *)&amp;JVM_DumpThreads},    {&quot;setNativeName&quot;,    &quot;(&quot; STR &quot;)V&quot;, (void *)&amp;JVM_SetNativeThreadName},};</code></pre><p>在jvm.cpp中</p><pre><code class="c++">JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))  JVMWrapper(&quot;JVM_StartThread&quot;);  JavaThread *native_thread = NULL;  bool throw_illegal_thread_state = false;  {    MutexLocker mu(Threads_lock);    // Since JDK 5 the java.lang.Thread threadStatus is used to prevent    // re-starting an already started thread, so we should usually find    // that the JavaThread is null.         //However for a JNI attached thread    // there is a small window between the Thread object being created    // (with its JavaThread set) and the update to its threadStatus, so we    // have to check for this    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {      throw_illegal_thread_state = true;    } else {      // We could also check the stillborn flag to see if this thread was already stopped, but      // for historical reasons we let the thread detect that itself when it starts running      jlong size =             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));      // Allocate the C++ Thread structure and create the native thread.  The      // stack size retrieved from java is signed, but the constructor takes      // size_t (an unsigned type), so avoid passing negative values which would      // result in really large stacks.      size_t sz = size &gt; 0 ? (size_t) size : 0;      native_thread = new JavaThread(&amp;thread_entry, sz);    //Look Here      // At this point it may be possible that no osthread was created for the      // JavaThread due to lack of memory. Check for this situation and throw      // an exception if necessary. Eventually we may want to change this so      // that we only grab the lock if the thread was created successfully -      // then we can also do this check and throw the exception in the      // JavaThread constructor.      if (native_thread-&gt;osthread() != NULL) {        // Note: the current thread is not being used within &quot;prepare&quot;.        native_thread-&gt;prepare(jthread);      }    }  }  if (throw_illegal_thread_state) {    THROW(vmSymbols::java_lang_IllegalThreadStateException());  }  assert(native_thread != NULL, &quot;Starting null thread?&quot;);  if (native_thread-&gt;osthread() == NULL) {    // No one should hold a reference to the &#39;native_thread&#39;.    delete native_thread;    if (JvmtiExport::should_post_resource_exhausted()) {      JvmtiExport::post_resource_exhausted(        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,        &quot;unable to create new native thread&quot;);    }    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),              &quot;unable to create new native thread&quot;);  }  Thread::start(native_thread);JVM_END</code></pre><p>其中 native_thread = new JavaThread(&amp;thread_entry, sz);    //Look Here </p><pre><code class="c++">static void thread_entry(JavaThread* thread, TRAPS) {  HandleMark hm(THREAD);  Handle obj(THREAD, thread-&gt;threadObj());  JavaValue result(T_VOID);  JavaCalls::call_virtual(&amp;result,                          obj,                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),                          vmSymbols::run_method_name(),    //LOOk Here                          vmSymbols::void_method_signature(),                          THREAD);}</code></pre><p>其中 void_method_signature 在vmSymbols.hpp中 (run怎么跑的实在找不到(´;︵;`) )</p><p>template(run_method_name,”run”)   </p><p>简单总结: 就是在虚拟机中启动个线程 (屏蔽了平台无关) ,分配内存,线程id, 设置状态。 然后回调java中的run方法</p><p>而runnable其实就只是线程中的一个对象targer</p><pre><code class="java">/** * If this thread was constructed using a separate * &lt;code&gt;Runnable&lt;/code&gt; run object, then that * &lt;code&gt;Runnable&lt;/code&gt; object&#39;s &lt;code&gt;run&lt;/code&gt; method is called; * otherwise, this method does nothing and returns. * &lt;p&gt; * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method. * * @see     #start() * @see     #stop() * @see     #Thread(ThreadGroup, Runnable, String) */@Overridepublic void run() {    if (target != null) {        target.run();    }}</code></pre><p>这也是Thread 继承方式为什么要重写run的原因</p><blockquote><p>参考 <a href="https://www.linuxidc.com/Linux/2016-03/128997.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-03/128997.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> jvm </tag>
            
            <tag> hotspot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_main方法分析</title>
      <link href="/2019/08/29/JVM-main%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/29/JVM-main%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>纵然伤心 也不要愁眉不展 因为你不知道谁会爱上你的笑容 ——飞鸟集</p></blockquote><p>启动一个最简单的Java main程序时，有多少个线程被创建? 有什么方法可以看到当前运行的线程?</p><ul><li>java线程</li><li>如何查看线程状态</li><li>线程类型</li></ul><a id="more"></a><h4 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h4><p>在java中，启动一个简单的main程序，并不是只是单单创建了一个main线程而已，JVM会自动创建一些辅助用的线程，主要有以下几个：</p><h5 id="Reference-Handler-2"><a href="#Reference-Handler-2" class="headerlink" title="Reference Handler #2"></a>Reference Handler #2</h5><p>VM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。</p><h5 id="Finalizer-3"><a href="#Finalizer-3" class="headerlink" title="Finalizer #3"></a>Finalizer #3</h5><p>这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：</p><p>　　1)只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；</p><p>　　2)该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；</p><p>　　3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；</p><p>　　4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</p><h5 id="Signal-Dispatcher-4"><a href="#Signal-Dispatcher-4" class="headerlink" title="Signal Dispatcher #4"></a>Signal Dispatcher #4</h5><p>前面我们提到第一个Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。</p><h5 id="Monitor-Ctrl-Break-5"><a href="#Monitor-Ctrl-Break-5" class="headerlink" title="Monitor Ctrl-Break #5"></a>Monitor Ctrl-Break #5</h5><p>Monitoring Thread Activity With Thread Dumps Thread dumps, or “thread stack traces,” reveal information about an application’s activity that can help you diagnose problems and better optimize application and JVM performance; for example, thread dumps can show the occurrence of “deadlock” conditions, which can seriously impact application performance. You can create a thread dump by invoking a control break (usually by pressing Ctrl-Break or Ctrl-\ or SIGQUIT on linux). This section provides information on working with thread dumps. It includes information on these subjects: 1.Lock Information in Thread Dumps 2.Detecting Deadlocks</p><h5 id="Attach-Listener"><a href="#Attach-Listener" class="headerlink" title="Attach Listener"></a>Attach Listener</h5><p>Attach Listener线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反 馈信 息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。</p><p>以上是被创建的java线程 </p><h4 id="ThreadMXBean查看"><a href="#ThreadMXBean查看" class="headerlink" title="ThreadMXBean查看"></a>ThreadMXBean查看</h4><p>如下代码 </p><pre><code class="java"> public class MainThreadInfoDemo {    public static void main(String[] args) {//        threadCreateExample();        dumpThreadInfo();    }    public static void dumpThreadInfo() {        Arrays.stream(ManagementFactory.getThreadMXBean().dumpAllThreads(false, false)).                forEach(threadInfo -&gt; System.out.println(&quot;[&quot; + threadInfo.getThreadId() + &quot;]&quot; + threadInfo.getThreadName())                );    }    /**     * 线程创建example     */    public static void threadCreateExample() {        class DemoThread extends Thread {            @Override            public void run() {                System.out.println(&quot;extend&quot;);                while (true) {                }            }        }        new DemoThread().start();        new Thread(() -&gt; { System.out.println(&quot;impl&quot;);while (true) { } }).start();    }}</code></pre><p>T</p><p>运行结果如下:</p><pre><code>[5]Monitor Ctrl-Break[4]Signal Dispatcher[3]Finalizer[2]Reference Handler[1]main</code></pre><p>把threadCreateExample注释去掉,运行方法后发现:</p><pre><code>[12]Thread-1[11]Thread-0[5]Monitor Ctrl-Break[4]Signal Dispatcher[3]Finalizer[2]Reference Handler[1]main</code></pre><p>接下来我们来看看为什么id是从11开始 ?</p><h4 id="jstack查看"><a href="#jstack查看" class="headerlink" title="jstack查看"></a>jstack查看</h4><h5 id="Jstack-文件"><a href="#Jstack-文件" class="headerlink" title="Jstack 文件"></a>Jstack 文件</h5><p>用jstack 查看(没有运行threadCreateExample方法)</p><pre><code>2019-08-29 11:44:28Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.161-b12 mixed mode):&quot;Attach Listener&quot; #11 daemon prio=9 os_prio=31 tid=0x00007fcf2582d000 nid=0x5603 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;Service Thread&quot; #10 daemon prio=9 os_prio=31 tid=0x00007fcf25093800 nid=0x3d03 runnable [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;C1 CompilerThread3&quot; #9 daemon prio=9 os_prio=31 tid=0x00007fcf25802800 nid=0x3b03 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;C2 CompilerThread2&quot; #8 daemon prio=9 os_prio=31 tid=0x00007fcf24874000 nid=0x3f03 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os_prio=31 tid=0x00007fcf24025000 nid=0x4103 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os_prio=31 tid=0x00007fcf25801800 nid=0x3803 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;Monitor Ctrl-Break&quot; #5 daemon prio=5 os_prio=31 tid=0x00007fcf229b1000 nid=0x3703 runnable [0x000070000feff000]   java.lang.Thread.State: RUNNABLE    at java.net.SocketInputStream.socketRead0(Native Method)    at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)    at java.net.SocketInputStream.read(SocketInputStream.java:171)    at java.net.SocketInputStream.read(SocketInputStream.java:141)    at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)    at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)    at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)    - locked &lt;0x000000076af13bc8&gt; (a java.io.InputStreamReader)    at java.io.InputStreamReader.read(InputStreamReader.java:184)    at java.io.BufferedReader.fill(BufferedReader.java:161)    at java.io.BufferedReader.readLine(BufferedReader.java:324)    - locked &lt;0x000000076af13bc8&gt; (a java.io.InputStreamReader)    at java.io.BufferedReader.readLine(BufferedReader.java:389)    at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)   Locked ownable synchronizers:    - None&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=31 tid=0x00007fcf22022800 nid=0x3603 runnable [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;Finalizer&quot; #3 daemon prio=8 os_prio=31 tid=0x00007fcf2280c800 nid=0x4a03 in Object.wait() [0x000070000fcf9000]   java.lang.Thread.State: WAITING (on object monitor)    at java.lang.Object.wait(Native Method)    - waiting on &lt;0x000000076ab08ec0&gt; (a java.lang.ref.ReferenceQueue$Lock)    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)    - locked &lt;0x000000076ab08ec0&gt; (a java.lang.ref.ReferenceQueue$Lock)    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)    at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)   Locked ownable synchronizers:    - None&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=31 tid=0x00007fcf22016000 nid=0x4b03 in Object.wait() [0x000070000fbf6000]   java.lang.Thread.State: WAITING (on object monitor)    at java.lang.Object.wait(Native Method)    - waiting on &lt;0x000000076ab06b68&gt; (a java.lang.ref.Reference$Lock)    at java.lang.Object.wait(Object.java:502)    at java.lang.ref.Reference.tryHandlePending(Reference.java:191)    - locked &lt;0x000000076ab06b68&gt; (a java.lang.ref.Reference$Lock)    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)   Locked ownable synchronizers:    - None&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fcf25004800 nid=0x1803 waiting on condition [0x000070000f1d8000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)    - parking to wait for  &lt;0x000000076ae01da0&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)    at lang.ThreadDemo.main(ThreadDemo.java:27)   Locked ownable synchronizers:    - None&quot;VM Thread&quot; os_prio=31 tid=0x00007fcf25015000 nid=0x4d03 runnable &quot;GC task thread#0 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf26000800 nid=0x1f07 runnable &quot;GC task thread#1 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf24000800 nid=0x2a03 runnable &quot;GC task thread#2 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf22000800 nid=0x5303 runnable &quot;GC task thread#3 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf25010000 nid=0x2b03 runnable &quot;GC task thread#4 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf22014000 nid=0x5103 runnable &quot;GC task thread#5 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf24001000 nid=0x5003 runnable &quot;GC task thread#6 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf22014800 nid=0x2e03 runnable &quot;GC task thread#7 (ParallelGC)&quot; os_prio=31 tid=0x00007fcf22015000 nid=0x4e03 runnable &quot;VM Periodic Task Thread&quot; os_prio=31 tid=0x00007fcf250c5000 nid=0x5503 waiting on condition JNI global references: 33</code></pre><p>可以发现 其中 6-10为:</p><ul><li>“C2 CompilerThread0” #6</li><li>“C2 CompilerThread1” #7</li><li>“C2 CompilerThread2” #8</li><li>“C1 CompilerThread3” #9</li><li>“Service Thread” #10</li></ul><p>为什么这些在dumpThreadInfo 没有打印出来?</p><h5 id="vm内部线程-VM-internal-JavaThreads"><a href="#vm内部线程-VM-internal-JavaThreads" class="headerlink" title="vm内部线程(VM internal JavaThreads)"></a>vm内部线程(VM internal JavaThreads)</h5><p> 在/src/share/vm/prims/jvm.cpp中 </p><pre><code class="c++">// Returns an array of all live Thread objects (VM internal JavaThreads,// jvmti agent threads, and JNI attaching threads  are skipped)// See CR 6404306 regarding JNI attaching threadsJVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))  ResourceMark rm(THREAD);  ThreadsListEnumerator tle(THREAD, false, false);  JvmtiVMObjectAllocEventCollector oam;  int num_threads = tle.num_threads();  objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);  objArrayHandle threads_ah(THREAD, r);  for (int i = 0; i &lt; num_threads; i++) {    Handle h = tle.get_threadObj(i);    threads_ah-&gt;obj_at_put(i, h());  }</code></pre><p>其中简单翻译一下方法的注释<br>返回所有活动线程对象的数组(跳过VM内部JavaThreads、jvmti代理线程和JNI附加线程)，请参阅CR 6404306关于JNI附加线程的信息</p><p>可以知道不会打印VM内部的JavaThreads</p><p>另外的 JVM自身的线程(初始化的时候创建的,非java线程 没有prio=5)</p><ul><li>VM Thread</li><li>GC task thread#0-7 (8核)</li><li>VM Periodic Task Thread</li></ul><p>Thread.getAllStackTraces 其实也是 private static native Thread[] getThreads();</p><p><a href="http://ifeve.com/jvm-thread/，可以取这个地址查看更多线程的信息" target="_blank" rel="noopener">http://ifeve.com/jvm-thread/，可以取这个地址查看更多线程的信息</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_ReentrantLock</title>
      <link href="/2019/08/24/JDK-ReentrantLock/"/>
      <url>/2019/08/24/JDK-ReentrantLock/</url>
      
        <content type="html"><![CDATA[<p>通过ReentrantLock  , 类来分析JUC包的基石 AbstractQueuedSynchronizer(后续简称 AQS)</p><ul><li>ReentrantLock skeleton</li><li>AQS  skeleton</li><li>Lock 、unlock</li><li>Condition</li></ul><a id="more"></a><h3 id="可重入锁-ReentrantLock-skeleton"><a href="#可重入锁-ReentrantLock-skeleton" class="headerlink" title="可重入锁(ReentrantLock skeleton)"></a>可重入锁(ReentrantLock skeleton)</h3><h4 id="类关系图-Class-Diagrams"><a href="#类关系图-Class-Diagrams" class="headerlink" title="类关系图(Class Diagrams)"></a>类关系图(Class Diagrams)</h4><p>​    从下图的类图来看,<code>ReentrantLock</code>  类实现了<code>Lock</code> 接口, 非阻塞式,超时支持.</p><p>​    更多细节参考 <a href="https://zyumin.github.io/2019/08/10/JDK-The-Concurrent-Framework/#Locks-锁" target="_blank" rel="noopener">JDK-The-Concurrent-Framework</a></p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6gy1g69g1omdxdj31c80pwgnw.jpg" width="70%" height="70%"></p><h4 id="框架细节-skeleton"><a href="#框架细节-skeleton" class="headerlink" title="框架细节(skeleton)"></a>框架细节(skeleton)</h4><p>#### </p><p><img src="http://ww4.sinaimg.cn/large/006y8mN6gy1g69k0z6ir1j30u00y8tfp.jpg" width="70%" height="70%"></p><h5 id="锁的实现-Lock-implement"><a href="#锁的实现-Lock-implement" class="headerlink" title="锁的实现(Lock implement)"></a>锁的实现(Lock implement)</h5><p>看ReentrantLock的源码我们可以发现,实现Lock接口的类 都由Sync 处理, Sync 类是extends AbstractQueuedSynchronizer. Sync 有两个实现,分别是公平和非公平锁</p><h5 id="扩展功能-extended-capabilities"><a href="#扩展功能-extended-capabilities" class="headerlink" title="扩展功能(extended capabilities)"></a>扩展功能(extended capabilities)</h5><p>除了实现Lock 的方法外,  还具有扩展功能。获取等待队列,当前线程是否获得锁等监控</p><p>源码:</p><pre><code class="java">public class ReentrantLock implements Lock, java.io.Serializable {    private final Sync sync;    abstract static class Sync extends AbstractQueuedSynchronizer {      ...        }        static final class NonfairSync extends Sync{}        static final class FairSync extends Sync{}        public ReentrantLock() {        sync = new NonfairSync();    }    public ReentrantLock(boolean fair) {        sync = fair ? new FairSync() : new NonfairSync();    }    public void lock() {        sync.lock();    }    public void unlock() {        sync.release(1);    }    ...}</code></pre><h3 id="抽象同步队列-AQS"><a href="#抽象同步队列-AQS" class="headerlink" title="抽象同步队列(AQS )"></a>抽象同步队列(AQS )</h3><h4 id="Class-Diagrams"><a href="#Class-Diagrams" class="headerlink" title="Class Diagrams"></a>Class Diagrams</h4><p><img src="http://tva1.sinaimg.cn/large/006y8mN6gy1g6aynej1qtj30u10u0n0j.jpg" alt="image-20190823192643197"></p><p>我们需要关注的是蓝色圈圈里的, AQS 其实底层用的是volatile 的Node节点 和 CAS 的操作, 实现阻塞队列的语义.  </p><h4 id="AQS-skeleton"><a href="#AQS-skeleton" class="headerlink" title="AQS skeleton"></a>AQS skeleton</h4><p>简单来说, AQS的实现可以从 双向节点、以及维护这些节点的方法 这两个方法去归类 ( 这里先不考虑Condition)</p><h5 id="队列节点-Node"><a href="#队列节点-Node" class="headerlink" title="队列节点(Node)"></a>队列节点(Node)</h5><h6 id="数据结构-struct"><a href="#数据结构-struct" class="headerlink" title="数据结构(struct)"></a>数据结构(struct)</h6><p>是一个双向链表,注意nextWaiter 是用于condition的Node</p><pre><code class="java">        /**         * Link to predecessor node that current node/thread relies on         * for checking waitStatus. Assigned during enqueuing, and nulled         * out (for sake of GC) only upon dequeuing.  Also, upon         * cancellation of a predecessor, we short-circuit while         * finding a non-cancelled one, which will always exist         * because the head node is never cancelled: A node becomes         * head only as a result of successful acquire. A         * cancelled thread never succeeds in acquiring, and a thread only         * cancels itself, not any other node.         */        volatile Node prev;        /**         * Link to the successor node that the current node/thread         * unparks upon release. Assigned during enqueuing, adjusted         * when bypassing cancelled predecessors, and nulled out (for         * sake of GC) when dequeued.  The enq operation does not         * assign next field of a predecessor until after attachment,         * so seeing a null next field does not necessarily mean that         * node is at end of queue. However, if a next field appears         * to be null, we can scan prev&#39;s from the tail to         * double-check.  The next field of cancelled nodes is set to         * point to the node itself instead of null, to make life         * easier for isOnSyncQueue.         */        volatile Node next;        /**         * Link to next node waiting on condition, or the special         * value SHARED.  Because condition queues are accessed only         * when holding in exclusive mode, we just need a simple         * linked queue to hold nodes while they are waiting on         * conditions. They are then transferred to the queue to         * re-acquire. And because conditions can only be exclusive,         * we save a field by using special value to indicate shared         * mode.         */        Node nextWaiter;        /**         * The thread that enqueued this node.  Initialized on         * construction and nulled out after use.         */        volatile Thread thread;</code></pre><h6 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式(mode)"></a>模式(mode)</h6><p>​       共享锁( 例如: 读锁 )还是排斥锁 </p><pre><code class="java">        /** Marker to indicate a node is waiting in shared mode */        static final Node SHARED = new Node();        /** Marker to indicate a node is waiting in exclusive mode */        static final Node EXCLUSIVE = null;        /**         * Returns true if node is waiting in shared mode.         */        final boolean isShared() {            return nextWaiter == SHARED;        }</code></pre><h6 id="状态-waitStatus"><a href="#状态-waitStatus" class="headerlink" title="状态(waitStatus)"></a>状态(waitStatus)</h6><p> 状态相关细节如下 </p><pre><code class="java">        /** waitStatus value to indicate thread has cancelled */        static final int CANCELLED =  1;        /** waitStatus value to indicate successor&#39;s thread needs unparking */        static final int SIGNAL    = -1;        /** waitStatus value to indicate thread is waiting on condition */        static final int CONDITION = -2;        /**         * waitStatus value to indicate the next acquireShared should         * unconditionally propagate         */        static final int PROPAGATE = -3;                /**         * Status field, taking on only the values:         *   SIGNAL:     The successor of this node is (or will soon be)         *               blocked (via park), so the current node must         *               unpark its successor when it releases or         *               cancels. To avoid races, acquire methods must         *               first indicate they need a signal,         *               then retry the atomic acquire, and then,         *               on failure, block.         *   CANCELLED:  This node is cancelled due to timeout or interrupt.         *               Nodes never leave this state. In particular,         *               a thread with cancelled node never again blocks.         *   CONDITION:  This node is currently on a condition queue.         *               It will not be used as a sync queue node         *               until transferred, at which time the status         *               will be set to 0. (Use of this value here has         *               nothing to do with the other uses of the         *               field, but simplifies mechanics.)         *   PROPAGATE:  A releaseShared should be propagated to other         *               nodes. This is set (for head node only) in         *               doReleaseShared to ensure propagation         *               continues, even if other operations have         *               since intervened.         *   0:          None of the above         *         * The values are arranged numerically to simplify use.         * Non-negative values mean that a node doesn&#39;t need to         * signal. So, most code doesn&#39;t need to check for particular         * values, just for sign.         *         * The field is initialized to 0 for normal sync nodes, and         * CONDITION for condition nodes.  It is modified using CAS         * (or when possible, unconditional volatile writes).         */        volatile int waitStatus;</code></pre><h5 id="队列节点的相关操作-Node-operation"><a href="#队列节点的相关操作-Node-operation" class="headerlink" title="队列节点的相关操作(Node operation)"></a>队列节点的相关操作(Node operation)</h5><h6 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h6><p> 对节点的cas操作</p><pre><code class="java">    /**     * Setup to support compareAndSet. We need to natively implement     * this here: For the sake of permitting future enhancements, we     * cannot explicitly subclass AtomicInteger, which would be     * efficient and useful otherwise. So, as the lesser of evils, we     * natively implement using hotspot intrinsics API. And while we     * are at it, we do the same for other CASable fields (which could     * otherwise be done with atomic field updaters).     */    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long stateOffset;    private static final long headOffset;    private static final long tailOffset;    private static final long waitStatusOffset;    private static final long nextOffset;    static {        try {            stateOffset = unsafe.objectFieldOffset                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));            headOffset = unsafe.objectFieldOffset                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));            tailOffset = unsafe.objectFieldOffset                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));            waitStatusOffset = unsafe.objectFieldOffset                (Node.class.getDeclaredField(&quot;waitStatus&quot;));            nextOffset = unsafe.objectFieldOffset                (Node.class.getDeclaredField(&quot;next&quot;));        } catch (Exception ex) { throw new Error(ex); }    }    /**     * CAS head field. Used only by enq.     */    private final boolean compareAndSetHead(Node update) {        return unsafe.compareAndSwapObject(this, headOffset, null, update);    }    /**     * CAS tail field. Used only by enq.     */    private final boolean compareAndSetTail(Node expect, Node update) {        return unsafe.compareAndSwapObject(this, tailOffset, expect, update);    }    /**     * CAS waitStatus field of a node.     */    private static final boolean compareAndSetWaitStatus(Node node,int expect,int update) {        return unsafe.compareAndSwapInt(node, waitStatusOffset,expect, update);    }    /**     * CAS next field of a node.     */    private static final boolean compareAndSetNext(Node node,Node expect, Node update) {        return unsafe.compareAndSwapObject(node, nextOffset, expect, update);    }</code></pre><p>state</p><p> 队列状态, 例如, <code>ReentrantLock</code> 中用于记录重入次数</p><pre><code class="java">/** * Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a {@code volatile} read * and write. * * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that the actual *         value was not equal to the expected value. */protected final boolean compareAndSetState(int expect, int update) {    // See below for intrinsics setup to support this    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);}    /**     * The synchronization state.     */    private volatile int state;</code></pre><h6 id="UnsupportedOperationException-method"><a href="#UnsupportedOperationException-method" class="headerlink" title="UnsupportedOperationException method"></a>UnsupportedOperationException method</h6><p>子类需要实现的方法, UnsupportedOperationException method</p><p>To use this class as the basis of a synchronizer, redefine the following methods, as applicable, by inspecting and/or modifying the synchronization state using <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState--" target="_blank" rel="noopener"><code>getState()</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState-int-" target="_blank" rel="noopener"><code>setState(int)</code></a> and/or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState-int-int-" target="_blank" rel="noopener"><code>compareAndSetState(int, int)</code></a>:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire-int-" target="_blank" rel="noopener"><code>tryAcquire(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease-int-" target="_blank" rel="noopener"><code>tryRelease(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared-int-" target="_blank" rel="noopener"><code>tryAcquireShared(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared-int-" target="_blank" rel="noopener"><code>tryReleaseShared(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively--" target="_blank" rel="noopener"><code>isHeldExclusively()</code></a></li></ul><p>Each of these methods by default throws <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html" target="_blank" rel="noopener"><code>UnsupportedOperationException</code></a><em>only</em><code>final</code></p><p>You may also find the inherited methods from <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractOwnableSynchronizer.html" target="_blank" rel="noopener"><code>AbstractOwnableSynchronizer</code></a> useful to keep track of the thread owning an exclusive synchronizer. You are encouraged to use them – this enables monitoring and diagnostic tools to assist users in determining which threads hold locks.</p><h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>条件队列相关,下文分析</p><h5 id="AQS-impl-example"><a href="#AQS-impl-example" class="headerlink" title="AQS impl example"></a>AQS impl example</h5><p>ReentrantLock中的实现,  重点看看tryAcquire tryRelease的实现,  这里以Sync的实现NonfairSync (默认的非公平锁,注意非公平体现 不能保证FIFO,会造成线程饥饿, 但是好处是减少上下文切换)分析</p><p>Sync:</p><pre><code class="java">abstract static class Sync extends AbstractQueuedSynchronizer {        //抽象方法 留给子类实现        abstract void lock();        // 尝试加锁,初始化或者重入可以加锁成功        final boolean nonfairTryAcquire(int acquires) {            final Thread current = Thread.currentThread();            int c = getState();            if (c == 0) {                if (compareAndSetState(0, acquires)) {                    setExclusiveOwnerThread(current);                    return true;                }            }            else if (current == getExclusiveOwnerThread()) {                int nextc = c + acquires;                if (nextc &lt; 0) // overflow                    throw new Error(&quot;Maximum lock count exceeded&quot;);                setState(nextc);                return true;            }            return false;        }        //尝试释放锁        protected final boolean tryRelease(int releases) {            int c = getState() - releases;            if (Thread.currentThread() != getExclusiveOwnerThread())                throw new IllegalMonitorStateException();            boolean free = false;            if (c == 0) {                free = true;                setExclusiveOwnerThread(null);            }            setState(c);            return free;        }        //当前线程是否持有锁        protected final boolean isHeldExclusively() {            // While we must in general read state before owner,            // we don&#39;t need to do so to check if current thread is owner            return getExclusiveOwnerThread() == Thread.currentThread();        }                   ...}</code></pre><p>NonfairSync :</p><pre><code class="java">static final class NonfairSync extends Sync {    private static final long serialVersionUID = 7316153563782823691L;    /**     * Performs lock.  Try immediate barge, backing up to normal     * acquire on failure.     */    final void lock() {        if (compareAndSetState(0, 1))            setExclusiveOwnerThread(Thread.currentThread());        else            acquire(1);    }    protected final boolean tryAcquire(int acquires) {        return nonfairTryAcquire(acquires);    }}</code></pre><h3 id="加锁-解锁分析-lock-unlock"><a href="#加锁-解锁分析-lock-unlock" class="headerlink" title="加锁/解锁分析 (lock /unlock)"></a>加锁/解锁分析 (lock /unlock)</h3><p>我们从<code>java.util.concurrent.locks.ReentrantLock.NonfairSync#lock</code>入手 , 来看看语言层面怎么实现同步语义( 注意,实现过程没有用到同步语义,所以我们要重点关注volidate,cas 以及顺序等)</p><pre><code class="java">/** * Performs lock.  Try immediate barge, backing up to normal * acquire on failure. */final void lock() {    //CAS设置state,成功则获取锁,并设置当前占有锁的线程    if (compareAndSetState(0, 1))        setExclusiveOwnerThread(Thread.currentThread());    else   //否则进行获取锁的操作(阻塞、入队等)        acquire(1);}</code></pre><p>如果CAS获取失败, 调用<code>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</code></p><pre><code class="java"> /**  * Acquires in exclusive mode, ignoring interrupts.  Implemented  * by invoking at least once {@link #tryAcquire},  * returning on success.  Otherwise the thread is queued, possibly  * repeatedly blocking and unblocking, invoking {@link  * #tryAcquire} until success.  This method can be used  * to implement method {@link Lock#lock}.  *  * @param arg the acquire argument.  This value is conveyed to  *  {@link #tryAcquire} but is otherwise uninterpreted and  *  can represent anything you like.  */public final void acquire(int arg) {    //获取失败 , 并且返回acquireQueued 返回true(阻塞状态被中断)     if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        //回放中断        selfInterrupt();}</code></pre><p>下面, 依次分析下面三个方法:</p><ul><li>tryAcquire</li><li>addWaiter</li><li>acquireQueued</li></ul><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><p>在阻塞之前, 再次(注意在一开始lock方法中就尝试过一次, 可能是作者有意为之,或是…)尝试获取</p><pre><code class="java">  protected final boolean tryAcquire(int acquires) {      return nonfairTryAcquire(acquires);  }  final boolean nonfairTryAcquire(int acquires) {      final Thread current = Thread.currentThread();      int c = getState();      //如果当前state为0, 再次尝试获取      if (c == 0) {    if (compareAndSetState(0, acquires)) {        setExclusiveOwnerThread(current);        return true;    }      }      //判断是否重入线程      else if (current == getExclusiveOwnerThread()) {    //这里操作无需加锁, 是线程安全的,其他线程是进不到这里    int nextc = c + acquires;    //最大可重入次数是Integer.MAX    if (nextc &lt; 0) // overflow        throw new Error(&quot;Maximum lock count exceeded&quot;);    setState(nextc);    return true;      }      return false;  }</code></pre><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p> 因为第一次CAS尝试逻辑和enq方法中一致, 所以我们只需要关注enq中的操作即可</p><pre><code class="java">/** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */private Node addWaiter(Node mode) {    //注意这里入参mode是EXCLUSIVE , 即上面Node中的mode    Node node = new Node(Thread.currentThread(), mode);    // Try the fast path of enq; backup to full enq on failure    Node pred = tail;    //当tail队列不为空的时候,说明已经初始化过了, 直接进行一次CAS操作    if (pred != null) {        node.prev = pred;        if (compareAndSetTail(pred, node)) {            pred.next = node;            return node;        }    }    //否则进入enq    enq(node);    return node;}  /**   * Inserts node into queue, initializing if necessary. See picture above.   * @param node the node to insert   * @return node&#39;s predecessor   */  private Node enq(final Node node) {    for (;;) {      Node t = tail;      //初始化队列      if (t == null) { // Must initialize        if (compareAndSetHead(new Node()))          tail = head;      } else {        //非原子操作, 会出现 &quot;队列在prev方向一致，next方向不一致&quot;        node.prev = t;        if (compareAndSetTail(t, node)) {          t.next = node;          return t;        }      }    }  }</code></pre><p>注意这里, 在插入过程中，会出现“node.prev指向旧的尾节点，但旧的尾节点.next为null未指向node（尽管，尾指针指向node）”的状态，即“<strong>队列在prev方向一致，next方向不一致</strong>”</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6aync8atgj30nq0b5q3c.jpg" alt="AQS@enqå¼±ä¸è´ç¶æ"></p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>经过上述操作, 只是插入了队列, 状态并未变更, 所以这里要做的就是状态的维护</p><pre><code class="java">/** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return {@code true} if interrupted while waiting */final boolean acquireQueued(final Node node, int arg) {    boolean failed = true;    try {        boolean interrupted = false;        for (;;) {            final Node p = node.predecessor();            //如果当前节点的前继节点是头节点,才开始尝试获取锁,获取成功则返回            if (p == head &amp;&amp; tryAcquire(arg)) {                //Head 一开始为空节点                setHead(node);                p.next = null; // help GC                failed = false;                return interrupted;            }            //否则,阻塞或处理中断            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><p>​    如果获取失败,  AQS.shouldParkAfterFailedAcquire()判断是否需要阻塞等待，如果需要，则通过AQS#parkAndCheckInterrupt()阻塞等待，直到被唤醒或被中断。</p><h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><p>​    请求获取锁失败后处理, 是否需要阻塞判断,以及队列状态的维护</p><pre><code class="java">  /**   * Checks and updates status for a node that failed to acquire.   * Returns true if thread should block. This is the main signal   * control in all acquire loops.  Requires that pred == node.prev.   *   * @param pred node&#39;s predecessor holding status   * @param node the node   * @return {@code true} if thread should block   */  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {    int ws = pred.waitStatus;    if (ws == Node.SIGNAL)      /*       * This node has already set status asking a release       * to signal it, so it can safely park.       */      return true;    //如果前继节点的状态大于0,则代表是取消状态,需要维护队列节点的状态    if (ws &gt; 0) {      /*       * Predecessor was cancelled. Skip over predecessors and       * indicate retry.       */      //因为当前node为尾节点,遍历队列, 找到未被取消的节点      do {        node.prev = pred = pred.prev;      } while (pred.waitStatus &gt; 0);      //非原子操作, 会出现 &quot;队列在prev方向一致，next方向不一致&quot;      pred.next = node;    } else {      /*       * waitStatus must be 0 or PROPAGATE.  Indicate that we       * need a signal, but don&#39;t park yet.  Caller will need to       * retry to make sure it cannot acquire before parking.       */      //CAS修改ws的状态,直到ws的状态修改成功,才返回true需要阻塞      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    }    return false;  }</code></pre><p>注意这里, 在插入过程中，会出现“node.prev指向非CACELLED的node，非CACELLED的node.next指向node（CACELLED）”的状态，即“<strong>队列在prev方向一致，next方向不一致</strong>”</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6aynd2ovpj31cm0jkab7.jpg" alt="image-20190824131725953"></p><h6 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h6><pre><code class="java">  /**   * Convenience method to park and then check if interrupted   *   * @return {@code true} if interrupted   */  private final boolean parkAndCheckInterrupt() {    LockSupport.park(this);    return Thread.interrupted();  }</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="队列状态"><a href="#队列状态" class="headerlink" title="队列状态"></a>队列状态</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ayndml1ij318w0j8q3z.jpg" alt="image-20190824114533939"></p><ul><li>除了头节点，剩余节点都被阻塞，线程处于<code>WAITING</code>状态。</li><li>除了尾节点，剩余节点都满足<code>waitStatus==SIGNAL</code>，表示释放后需要唤醒后继节点。</li></ul><p>tips:unlock的可以按照以上分析</p><h5 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h5><p>​    为什么要从尾节点向前遍历，而不能从node向后遍历？这是因为，AQS中的等待队列基于一个弱一致性双向链表实现，允许某些时刻下，<strong>队列在prev方向一致，next方向不一致</strong>。 (上述已经分析了,这里做个总结)</p><blockquote><p>理想情况下，队列每时每刻都处于一致的状态（强一致性模型），从node向后遍历找第一个未取消节点是更高效的做法。然而，维护一致性通常需要牺牲部分性能，为了进一步的提升性能，脑洞大开的神牛们想出了各种高性能的弱一致性模型。尽管模型允许了更多弱一致状态，但所有弱一致状态都在控制之下，不会出现一致性问题。</p></blockquote><h5 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h5><p>我们以tryRelease为例子, 看volidate的用法(对照tryAcquire分析tryRelease)</p><pre><code class="java">protected final boolean tryRelease(int releases) {    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) {        free = true;        //先写exclusiveOwnerThread C        setExclusiveOwnerThread(null);    }    //再写state D    setState(c);    return free;}//final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    //先读state  A    int c = getState();    if (c == 0) {      if (compareAndSetState(0, acquires)) {        setExclusiveOwnerThread(current);        return true;      }    }    //再读exclusiveOwnerThread B    else if (current == getExclusiveOwnerThread()) {      int nextc = c + acquires;      if (nextc &lt; 0) // overflow        throw new Error(&quot;Maximum lock count exceeded&quot;);      setState(nextc);      return true;    }    return false;  }</code></pre><p>核心是三条Happens-Before规则：</p><ul><li><code>程序顺序规则</code>：如果程序中操作A在操作B之前，那么在线程中操作A将在操作B之前执行。</li><li><code>传递性</code>：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。</li><li><code>volatile变量规则</code>：对volatile变量的写入操作必须在对该变量的读操作之前执行。</li></ul><p>下面分析为什么C和D要按照这样的顺序</p><p>根据h-b规则可见性分析:</p><ul><li>A-&gt;B</li><li>C-&gt;D</li><li>D-&gt;A</li><li>C-&gt;B</li></ul><p>推出:</p><p><strong>C(写exclusiveOwnerThread)-&gt;D(写state)-&gt;A(读state)-&gt;B(读exclusiveOwnerThread)</strong></p><p><strong>保证所有写对所有读可见</strong></p><hr><p>否则, 假设C和D操作互换下</p><ul><li>A(读state)-&gt;B(读ex)</li><li>C(写state)-&gt;D(写ex)</li><li>C-&gt;A</li><li>D-&gt;B</li></ul><p>推出:</p><ul><li>C-&gt;D-&gt;B</li><li>C-&gt;A-&gt;B</li></ul><p><strong>D(写ex)和A(读state)没有h-b关系</strong></p><h3 id="条件分析-Condition"><a href="#条件分析-Condition" class="headerlink" title="条件分析(Condition)"></a>条件分析(Condition)</h3><p>Lock接口对标内置锁，而Condition接口对标内置条件队列。Condition主要提供了await、signal两种语义，和两种语义的衍生品。</p><h4 id="类关系图-Class-Diagrams-1"><a href="#类关系图-Class-Diagrams-1" class="headerlink" title="类关系图(Class Diagrams)"></a>类关系图(Class Diagrams)</h4><p>与AQS skeleton类似,也是维护了一个条件队列,下面以await和signal()分析</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6aynfh4hvj30u0101gqh.jpg" alt="image-20190824151905654"></p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>可以先简单理解没有中断版本的,只是设置中断标记,不会抛出异常</p><pre><code class="java">public final void awaitUninterruptibly() {    Node node = addConditionWaiter();    int savedState = fullyRelease(node);    boolean interrupted = false;    while (!isOnSyncQueue(node)) {        LockSupport.park(this);        if (Thread.interrupted())            interrupted = true;    }    if (acquireQueued(node, savedState) || interrupted)        selfInterrupt();}</code></pre><p>注意调用await,会释放当前线程持有的Lock,知道被通知或中断(signal)</p><pre><code class="java">public final void await() throws InterruptedException {    if (Thread.interrupted())        throw new InterruptedException();    // 创建等待节点并放入队尾    Node node = addConditionWaiter();    //释放锁并保存释放前的状态(释放的是Lock,否则外部无法获取)        int savedState = fullyRelease(node);    /***** 无锁状态开始 *****/    int interruptMode = 0;    //如果不在AQS的同步队列中(signal中入队), 阻塞,直到收到信号或被中断    while (!isOnSyncQueue(node)) {        LockSupport.park(this);        //现在node的是AQS条件队列上的节点,后续的操作 与#lock方法的类似        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)            break;    }                        //恢复申请锁状态,并更新中断状态    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;     /***** 无锁状态结束 *****/    //清理已被取消的节点,则表示在doSignal中没有完成 =null的操作    if (node.nextWaiter != null) // clean up if cancelled        unlinkCancelledWaiters();    //如果之前发生中断,则更具中断模式重放中断    if (interruptMode != 0)        reportInterruptAfterWait(interruptMode);}</code></pre><p>ConditionObject#await()同ReentrantLock#lockInterruptibly()一样，都是可中断的：调用ConditionObject#await()后，当前线程将保持阻塞，直到收到信号或被中断。</p><h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#addConditionWaiter</p><p>创建节点, 并放入尾部</p><pre><code class="java">/** * Adds a new waiter to wait queue. * @return its new wait node */private Node addConditionWaiter() {    Node t = lastWaiter;    // If lastWaiter is cancelled, clean out.    // 维护队列状态    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {        unlinkCancelledWaiters();        t = lastWaiter;    }    Node node = new Node(Thread.currentThread(), Node.CONDITION);    //队列是否为空,初始化头节点    if (t == null)        firstWaiter = node;    else        t.nextWaiter = node;    lastWaiter = node;    return node;}</code></pre><p>需要提醒一下，尽管此处没有任何线程安全的保护，但实际使用时不会出现任何线程安全问题——因为<strong>条件队列的使用要求我们在调用await或signal时持有与该条件队列唯一相关的锁</strong>。(和AQS中的队列的操作相比,没有CAS操作)</p><p>到这里，得到两个ReentrantLock与ConditionObject在实现上的重要区别：</p><ul><li><p>ReentrantLock创建的节点，初始状态为0；而ConditionObject创建的节点，初始状态为<code>CONDITION==-2</code>。</p></li><li><p>ReentrantLock使用AQS内置的等待队列，由AQS维护；而每个ConditionObject都维护自己的等待队列。</p></li></ul><h5 id="fullyRelease-释放Lock"><a href="#fullyRelease-释放Lock" class="headerlink" title="fullyRelease(释放Lock)"></a>fullyRelease(释放Lock)</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer#fullyRelease</p><p>释放锁并保存释放前的状态,重入次数 (释放的是Lock,否则外部无法获取)</p><pre><code class="java">/** * Invokes release with current state value; returns saved state. * Cancels node and throws exception on failure. * @param node the condition node for this wait * @return previous sync state */final long fullyRelease(Node node) {    boolean failed = true;    try {        long savedState = getState();        if (release(savedState)) {            failed = false;            return savedState;        } else {            //必须在Lock之后才能调用wait(),与unlock()同理            throw new IllegalMonitorStateException();        }    } finally {        if (failed)            node.waitStatus = Node.CANCELLED;    }}</code></pre><p>release可以看之前的tryrelease分析,AQS#fullyRelease()返回后，调用ConditionObject#await()的线程就释放了锁(这里必须释放锁, 否则就会出现其他调用Lock的地方无法获取锁,阻塞)</p><h5 id="isOnSyncQueue-阻塞"><a href="#isOnSyncQueue-阻塞" class="headerlink" title="isOnSyncQueue(阻塞)"></a>isOnSyncQueue(阻塞)</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer#isOnSyncQueue</p><p>阻塞，直到收到信号或被中断</p><pre><code class="java">// Internal support methods for Conditions/** * Returns true if a node, always one that was initially placed on * a condition queue, is now waiting to reacquire on sync queue. * @param node the node * @return true if is reacquiring */final boolean isOnSyncQueue(Node node) {    //如果是头节点 或者当前节点是CONDITION    if (node.waitStatus == Node.CONDITION || node.prev == null)        return false;    if (node.next != null) // If has successor, it must be on queue        return true;    /*     * node.prev can be non-null, but not yet on queue because     * the CAS to place it on queue can fail. So we have to     * traverse from tail to make sure it actually made it.  It     * will always be near the tail in calls to this method, and     * unless the CAS failed (which is unlikely), it will be     * there, so we hardly ever traverse much.     */    return findNodeFromTail(node);}    /**     * Returns true if node is on sync queue by searching backwards from tail.     * Called only when needed by isOnSyncQueue.     * @return true if present     */    private boolean findNodeFromTail(Node node) {        Node t = tail;        for (;;) {            if (t == node)                return true;            if (t == null)                return false;            t = t.prev;        }    }</code></pre><p><strong>先 跳转到 signal 的分析</strong></p><p>AQS#isOnSyncQueue()判断节点node是否已经被放入了AQS内部的等待队列，是的话返回true，否则返回false。主要分几种情况：</p><ul><li>如果<code>node.waitStatus == CONDITION</code>，则一定未放入。因为AQS#transferForSignal()6行还没来得及执行。</li><li>如果<code>node.prev == null</code>，则一定未放入。因为AQS#transferForSignal()6行执行完但9行未执行完。</li><li>如果<code>node.next != null</code>，则一定已放入。因为已经有了后继节点，则node本身肯定已经完成入队（ConditionObject内部的等待使用的后继指针为<code>nextWaiter</code>）。</li><li>否则，说明满足<code>node.waitStatus != CONDITION &amp;&amp; node.prev != null &amp;&amp; node.next == null</code>，该状态无法确定node处于“未放入”还是“已放入”的状态。回忆AQS#enq()可知，<code>node.prev != null</code>时，可能正在尝试CAS插入node，无法确定是在插入前还是插入后，也无法确定是否插入成功。AQS#findNodeFromTail()从尾节点开始遍历，如果能够遍历到node，则一定已放入（当然，next方向不一定满足一致性）；否则，当前时刻还未插入或未插入成功，即一定未放入。</li></ul><h5 id="checkInterruptWhileWaiting-检查是否被中断"><a href="#checkInterruptWhileWaiting-检查是否被中断" class="headerlink" title="checkInterruptWhileWaiting (检查是否被中断)"></a>checkInterruptWhileWaiting (检查是否被中断)</h5><p>判断是被中断(因为await是允许中断的,所以需要注意catch中断异常的处理)还是被唤醒</p><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#checkInterruptWhileWaiting</p><ul><li>返回THROW_IE 如果中断发生在singnalled之前 ,抛出异常</li><li>返回REINTERRUPT 如果中断发生在signalled之后 , 只是简单设置状态</li><li>返回0 如果未发生过中断</li></ul><pre><code class="java">/** * Checks for interrupt, returning THROW_IE if interrupted * before signalled, REINTERRUPT if after signalled, or * 0 if not interrupted. */private int checkInterruptWhileWaiting(Node node) {    //是否发生了中断,否则返回0    return Thread.interrupted() ?        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :        0;} final boolean transferAfterCancelledWait(Node node) {        //发生在中断之前        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {            enq(node);            return true;        }        /*         * If we lost out to a signal(), then we can&#39;t proceed         * until it finishes its enq().  Cancelling during an         * incomplete transfer is both rare and transient, so just         * spin.         */        while (!isOnSyncQueue(node))            Thread.yield();        return false;    }</code></pre><p>首先，根据<code>Thread.interrupted()</code>判断是否发生了中断。<em>如果未发生中断</em>，则<code>Thread.interrupted()</code>返回false，<em>ConditionObject#checkInterruptWhileWaiting()最终返回0</em>。</p><p>否则，继续调用AQS#transferAfterCancelledWait()判断发生中断的时机。<em>如果是在收到信号前发生了中断</em>，AQS#transferForSignal()6行还没来得及执行，必然满足<code>node.waitStatus == CONDITION</code>，则CAS设置node.waitStatus并将node入队（等待后面调用AQS#acquireQueued()竞争锁），然后返回true，<em>ConditionObject#checkInterruptWhileWaiting()最终返回THROW_IE == -1</em>。</p><p>否则，一定是<em>在收到信号后发生了中断</em>，但可能AQS#transferForSignal()6行执行完但9行未执行完，即node未完成入队，因此，21-22行空等待至node完成入队，然后返回false，<em>ConditionObject#checkInterruptWhileWaiting()最终返回REINTERRUPT == 1</em>。</p><p>终于跳出了循环，要重新申请锁了。(与#lock方法类似的就不重复分析)</p><h6 id="信号前中断的特殊情况"><a href="#信号前中断的特殊情况" class="headerlink" title="信号前中断的特殊情况"></a>信号前中断的特殊情况</h6><p><strong>信号前中断会导致node同时处于AQS与ConditionObject两方的等待队列中</strong>（使用不同的指针连接节点）：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6ayngc1x4j30rj0h1wfi.jpg" alt="AQSä¸ConditionObjectå±äº«èç¹"></p><p>而另外两种情况下，节点都被迁入了AQS内部等待队列。</p><p>因此，只要ConditionObject内部等待队列中的节点满足<code>node.waitStatus == SIGNAL</code>或<code>node.waitStatus == 0</code>，就可以判断其同时位于于AQS与ConditionObject两方的等待队列中，也就能断定该节点属于信号前中断唤醒。</p><blockquote><p>信号前中断唤醒的节点是无效的，需要被清理，可以用该条件找出这部分节点。该结论将在分析ConditionObject#unlinkCancelledWaiters()时派上用场。</p></blockquote><h5 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#unlinkCancelledWaiters</p><p>实际上，ConditionObject#unlinkCancelledWaiters()用于清理ConditionObject内部等待队列中的非CONDITION节点。具体来说：</p><ul><li>如果ConditionObject#await()时（更确切的说，AQS#fullyRelease()完全释放锁时）失败，节点转为CANCELLED状态，需要被清理。</li><li>分析AQS#transferAfterCancelledWait()有一个结论，<strong>信号前中断会导致node同时处于AQS与ConditionObject两方的等待队列中（使用不同的指针连接节点）</strong>。这些节点将随着AQS#acquireQueued()的执行转为SIGNAL或0状态。但由于ConditionObject#await()在收到信号前（更确切的说，在AQS#fullyRelease()完全释放锁后、收到信号前）被中断，因此上述节点也是无效的，需要被清理。</li></ul><p>而被信号唤醒或信号后中断唤醒的节点，将首先移出ConditionObject内部等待队列，再进行状态转换。</p><p>综上，只需要清理ConditionObject内部等待队列中的非CONDITION节点</p><pre><code class="java">/** * Unlinks cancelled waiter nodes from condition queue. * Called only while holding lock. This is called when * cancellation occurred during condition wait, and upon * insertion of a new waiter when lastWaiter is seen to have * been cancelled. This method is needed to avoid garbage * retention in the absence of signals. So even though it may * require a full traversal, it comes into play only when * timeouts or cancellations occur in the absence of * signals. It traverses all nodes rather than stopping at a * particular target to unlink all pointers to garbage nodes * without requiring many re-traversals during cancellation * storms. */private void unlinkCancelledWaiters() {    //当前节点    Node t = firstWaiter;    //上一个节点    Node trail = null;    while (t != null) {        //下一个节点        Node next = t.nextWaiter;        //不是CONDITION,移除当前节点(就是把上个节点的nextWaiter执行下个节点)        if (t.waitStatus != Node.CONDITION) {            t.nextWaiter = null;            //如果trail为空,说明是头节点,直接替换firstWaiter            if (trail == null)                firstWaiter = next;            else   //否则把上一个节点指向下一个节点                trail.nextWaiter = next;            //设置尾节点            if (next == null)                lastWaiter = trail;        }        else  //保留当前节点为上个节点            trail = t;        //移动当前节点,开始下一轮        t = next;    }}</code></pre><h5 id="reportInterruptAfterWait"><a href="#reportInterruptAfterWait" class="headerlink" title="reportInterruptAfterWait"></a>reportInterruptAfterWait</h5><p>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#reportInterruptAfterWait</p><pre><code class="java">/** * Throws InterruptedException, reinterrupts current thread, or * does nothing, depending on mode. */private void reportInterruptAfterWait(int interruptMode)    throws InterruptedException {    if (interruptMode == THROW_IE)        throw new InterruptedException();    else if (interruptMode == REINTERRUPT)        selfInterrupt();}</code></pre><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p>唤醒一个等待在Conditon上的线程,该线程从等待方法返回前必须获得与Condition相关联的锁</p><pre><code class="java">    /**     * Moves the longest-waiting thread, if one exists, from the     * wait queue for this condition to the wait queue for the     * owning lock.     *     * @throws IllegalMonitorStateException if {@link #isHeldExclusively}     *     returns {@code false}     */    public final void signal() {      if (!isHeldExclusively())        throw new IllegalMonitorStateException();      Node first = firstWaiter;      //表示有节点进入了条件队列内部的等待队列，需要被唤醒      if (first != null)        doSignal(first);    }    /**     * Removes and transfers nodes until hit non-cancelled one or     * null. Split out from signal in part to encourage compilers     * to inline the case of no waiters.     * @param first (non-null) the first node on condition queue     */    private void doSignal(Node first) {      do {        //firstWaiter后移一位        if ((firstWaiter = first.nextWaiter) == null)          lastWaiter = null;        first.nextWaiter = null;      //试将条件队列内部的等待节点转换为AQS内部的等待节点，如果当前节点转换失败，就继续尝试下一节点      } while (!transferForSignal(first) &amp;&amp;(first = firstWaiter) != null);    }</code></pre><h5 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h5><pre><code class="java">/** * Transfers a node from a condition queue onto sync queue. * Returns true if successful. * @param node the node * @return true if successfully transferred (else the node was * cancelled before signal) */final boolean transferForSignal(Node node) {    /*     * If cannot change waitStatus, the node has been cancelled.     */    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))        return false;    /*     * Splice onto queue and try to set waitStatus of predecessor to     * indicate that thread is (probably) waiting. If cancelled or     * attempt to set waitStatus fails, wake up to resync (in which     * case the waitStatus can be transiently and harmlessly wrong).     */    //入队，返回旧的队尾节点，也就是新节点node的前继节点。    Node p = enq(node);    //只有正在执行AQS#acquireQueued()的线程T1能够与正在执行到这里的线程T2发生竞争。    int ws = p.waitStatus;    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))        LockSupport.unpark(node.thread);    return true;}</code></pre><p>回到ConditionObject#doSignal()与ConditionObject#signal()，成功结束。对于用户而言，线程此时已经被唤醒，尽管其大概率还在AQS内部阻塞排队，等待<strong>重新</strong>获得锁。</p><p>实际上，<em>就算去掉10-12行也是满足正确性要求的</em>。因为线程T2释放锁后，依然会将从队头开始的第一个非取消节点唤醒，该节点会继续ConditionObject#await()中的工作</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>await可以简单认为是用于维护ConditionObject队列,可以分为阻塞前和阻塞后操作</p><p> 阻塞前: 插入内部等待队列</p><p> 阻塞后: 根据是否中断(一致性问题),来维护状态</p><p>signal可以简单的认为 将ConditionObject队列中的节点移动到AQS队列</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_Synchronized</title>
      <link href="/2019/08/17/JVM-Synchronized/"/>
      <url>/2019/08/17/JVM-Synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM-Synchronized"><a href="#JVM-Synchronized" class="headerlink" title="JVM_Synchronized"></a>JVM_Synchronized</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g6696x82ypj31800t04qp.jpg" alt=""></p><p>浅谈下jvm对Synchronized的优化</p><ul><li>对象的分布</li><li>锁升级</li><li>锁优化</li></ul><a id="more"></a><h3 id="Java对象的组成"><a href="#Java对象的组成" class="headerlink" title="Java对象的组成"></a>Java对象的组成</h3><p>在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域 : 对象头(Header)、实例数据(Instance Data)、填充(Padding)</p><h4 id="Header-对象头"><a href="#Header-对象头" class="headerlink" title="Header (对象头)"></a>Header (对象头)</h4><p>Java对象的对象头由 mark word 和  klass pointer 、Array length</p><p>mark word: 存储了同步状态、标识、hashcode、GC状态等等。</p><p>klass pointer:存储对象的类型指针，该指针指向它的类元数据</p><p>Array length: 数组的长度(如果当前对象是数组)</p><p>值得注意的是，如果应用的对象过多，使用64位的指针将浪费大量内存。64位的JVM比32位的JVM多耗费50%的内存。</p><p>我们现在使用的64位 JVM会默认使用选项 +UseCompressedOops 开启指针压缩，将指针压缩至32位。</p><h5 id="mark-word存储结构"><a href="#mark-word存储结构" class="headerlink" title="mark word存储结构"></a>mark word存储结构</h5><p>以64位操作系统为例，对象头存储内容图例。(在运行期间,Mark Word里的存储数据会随着锁标记位的变化而变化)</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g62ri4y207j31d20h2diu.jpg" alt="img"></p><p>简单介绍一下各部分的含义</p><p>lock:  锁状态标记位，该标记的值不同，整个mark word表示的含义不同。</p><p>biased_lock：偏向锁标记，为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。</p><table><thead><tr><th>biased_lock</th><th>Lock</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>01</td><td>无锁</td></tr><tr><td>1</td><td>01</td><td>偏向锁</td></tr><tr><td>0</td><td>00</td><td>轻量级锁</td></tr><tr><td>0</td><td>10</td><td>重量级锁</td></tr><tr><td>0</td><td>11</td><td>GC标记</td></tr></tbody></table><p>age：Java GC标记位对象年龄。</p><p>identity_hashcode：对象标识Hash码，采用延迟加载技术。当对象使用HashCode()计算后，并会将结果写到该对象头中。当对象被锁定时，该值会移动到线程Monitor中。</p><p>thread：持有偏向锁的线程ID和其他信息。这个线程ID并不是JVM分配的线程ID号，和Java Thread中的ID是两个概念。</p><p>epoch：偏向时间戳。</p><p>ptr_to_lock_record：指向栈中锁记录的指针。</p><p>ptr_to_heavyweight_monitor：指向线程Monitor的指针。</p><h3 id="锁升级与对比"><a href="#锁升级与对比" class="headerlink" title="锁升级与对比"></a>锁升级与对比</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗,引入“偏向锁” 和 “轻量级锁” </p><p>锁一共有4种状态,级别从低到高依次是:无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态.</p><p>锁可以升级但不能降级(为了获得锁和释放锁的效率)</p><h4 id="JOL工具"><a href="#JOL工具" class="headerlink" title="JOL工具"></a>JOL工具</h4><p>借助jol工具打印对象实例分布</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;  &lt;artifactId&gt;jol-core&lt;/artifactId&gt;  &lt;version&gt;0.8&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>首先先来看看无锁状态下的对象实例数据分布,简单的一个Class对象</p><pre><code class="java">public class ObjectLayoutDemo {    public static class A {        boolean flag = false;    }    public static void main(String[] args) throws InterruptedException {        A a = new A();        System.out.println(ClassLayout.parseInstance(a).toPrintable());        // 手动调用hashCode 触发懒加载        System.out.println(Integer.toBinaryString(a.hashCode()));        System.out.println(ClassLayout.parseInstance(a).toPrintable());    }}</code></pre><p>看看输出结果</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g62s3w1yhzj31ks0980un.jpg" alt="img"></p><p>蓝色部分:lock </p><p>红色部分:hashcode</p><p>绿色部分:被指针压缩为32位的klass pointer</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）</p><h5 id="从无锁状态到偏向锁"><a href="#从无锁状态到偏向锁" class="headerlink" title="从无锁状态到偏向锁"></a>从无锁状态到偏向锁</h5><p>当一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储偏向的线程ID,以后该线程在进入和退出同步块时,不需要CAS操作来加锁和解锁 , 只需要测试一下对象头的Mark Word是否存储着指向当前线程的偏向锁</p><p>以后该线程进入同步块时，不需要CAS进行加锁，只会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数.</p><p>退出同步块释放偏向锁时，则依次删除对应Lock Record，但是不会修改对象头中的Thread Id；</p><h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>只有一个线程访问同步块</p><p>下图显示的</p><p>线程1演示了偏向锁初始化的流程</p><p>线程2演示了偏向锁的撤销的流程</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g686ckc6u2j30to0x4tap.jpg" width="70%" height="70%"></p><h5 id="偏向锁对象头"><a href="#偏向锁对象头" class="headerlink" title="偏向锁对象头"></a>偏向锁对象头</h5><pre><code class="java">public class BiasedLockDemo {    public static void main(String[] args) throws InterruptedException {        Thread.sleep(5000);        ObjectLayoutDemo.A a = new ObjectLayoutDemo.A();        System.out.println(ClassLayout.parseInstance(a).toPrintable());        Thread thread1 = new Thread(() -&gt; {            synchronized (a){                System.out.println(&quot;thread1 locking&quot;);                System.out.println(ClassLayout.parseInstance(a).toPrintable());            }        });        Thread thread2 = new Thread(() -&gt; {            synchronized (a){                //开始撤销， 直接return 模拟偏向锁撤销到未锁定                return;            }        });        thread1.start();        //让thread1执行完同步代码块中方法。        thread1.join();        System.out.println(&quot;thread1&#39;s state:&quot; + thread1.isAlive());        thread2.start();        System.out.println(&quot;after thread2:&quot;+ClassLayout.parseInstance(a).toPrintable());    }}</code></pre><p>结果</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g65dr635fgj31x20p8n38.jpg" alt="image-20190819225819224"></p><p>分析</p><p>这里注意偏向锁是在应用程序启动几秒钟之后才激活的,所以sleep</p><p>第一次打印,可以看到偏向锁是开启的.</p><p>第二次打印,可以看到记录了线程ID. </p><p>第三次偏向锁撤销</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁所适应的场景是线程交替执行同步块的情况</p><pre><code class="java">public class LightLockDemo {    public static void main(String[] args) throws InterruptedException {        Thread.sleep(5000);        ObjectLayoutDemo.A a = new ObjectLayoutDemo.A();        Thread thread1 = new Thread(){            @Override            public void run() {                synchronized (a){                    System.out.println(&quot;thread1 locking&quot;);                    System.out.println(ClassLayout.parseInstance(a).toPrintable());                }            }        };        Thread thread2 = new Thread(){            @Override            public void run() {                synchronized (a){                    System.out.println(&quot;thread2 locking&quot;);                    System.out.println(ClassLayout.parseInstance(a).toPrintable());                }            }        };        thread1.start();        //让thread1执行完同步代码块中方法,并退出线程        thread1.join();        System.out.println(&quot;thread1&#39;s state:&quot; + thread1.isAlive());        thread2.start();    }}</code></pre><p>结果</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g6741i6togj31m80hw78j.jpg" alt="image-20190820110735105"></p><p>分析</p><p>第一次是偏向锁</p><p>第二次撤销偏向锁, 升级为轻量级锁</p><p>注意 两次执行 指向栈的指针 也不一致了</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p><em>轻量级锁升级重量级</em></p><p>线程1首先尝试 CAS将对象头中的Mark Word替换为指向锁的指针.(在执行同步块前,JVM会先在当前线程的栈帧中创建用于存储锁记录的空间,并将对象头中的Mark Word复制到所记录中, Displaced Mark Word)</p><p>线程2 CAS 同样尝试,获取失败,尝试自旋获取(成功,说明线程1退出了同步块)失败升级为 重量级锁,阻塞等待唤醒</p><p><em>重量级锁解锁</em></p><p>线程1 解锁CAS 将Displace Mark Word替换回对象头, 失败,对象头已被线程2修改(膨胀为重量级锁),释放锁并唤醒等待的线程(同时清除指向栈的指针)</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g6741n0890j30ty0teang.jpg" width="70%" height="70%"></p><p>example</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {    Thread.sleep(5000);    ObjectLayoutDemo.A a = new ObjectLayoutDemo.A();    Thread thread1 = new Thread(() -&gt; {        synchronized (a) {            System.out.println(&quot;thread1 locking&quot;);            System.out.println(ClassLayout.parseInstance(a).toPrintable());            try {                //让线程晚点儿死亡，造成锁的竞争                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    });    Thread thread2 = new Thread(() -&gt; {        synchronized (a) {            System.out.println(&quot;thread2 locking&quot;);            System.out.println(ClassLayout.parseInstance(a).toPrintable());        }    });    thread1.start();    //模拟a从轻量级锁到重量级锁到转变    Thread.sleep(1000);    thread2.start();}</code></pre><p>结果</p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6gy1g6741rqho3j31nc0g0djm.jpg" alt="image-20190820110339698"></p><p>分析</p><p>第一次打印是轻量级锁</p><p>第二次打印为重量级锁</p><p>注意 两次执行的线程ID也不一致了</p><h4 id="重量级锁、轻量级锁和偏向锁之间转换"><a href="#重量级锁、轻量级锁和偏向锁之间转换" class="headerlink" title="重量级锁、轻量级锁和偏向锁之间转换"></a>重量级锁、轻量级锁和偏向锁之间转换</h4><p><img src="http://ww2.sinaimg.cn/large/006y8mN6gy1g6741wij92j30wy0fkack.jpg" width="70%" height="70%"></p><h4 id="重量级锁、轻量级锁和偏向锁之间对比"><a href="#重量级锁、轻量级锁和偏向锁之间对比" class="headerlink" title="重量级锁、轻量级锁和偏向锁之间对比"></a>重量级锁、轻量级锁和偏向锁之间对比</h4><table><thead><tr><th>锁</th><th style="text-align:left">优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td style="text-align:left">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td style="text-align:left">竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td style="text-align:left">线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="jvm层面"><a href="#jvm层面" class="headerlink" title="jvm层面"></a>jvm层面</h4><h5 id="适应式自旋"><a href="#适应式自旋" class="headerlink" title="适应式自旋"></a>适应式自旋</h5><p>适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指虚拟机即时编译器(JIT)在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><pre><code>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</code></pre><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><h4 id="语言编程"><a href="#语言编程" class="headerlink" title="语言编程"></a>语言编程</h4><h5 id="减少锁持有的时间"><a href="#减少锁持有的时间" class="headerlink" title="减少锁持有的时间"></a>减少锁持有的时间</h5><p>只对需要同步代码加锁</p><h5 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h5><p>ReadWriteLock</p><h5 id="减小锁的力度"><a href="#减小锁的力度" class="headerlink" title="减小锁的力度"></a>减小锁的力度</h5><p>ConcurrentHashMap</p><blockquote><p>link:<a href="https://houbb.github.io/2018/10/08/jvm-30-lock-optimize" target="_blank" rel="noopener">https://houbb.github.io/2018/10/08/jvm-30-lock-optimize</a></p><p>link:<a href="https://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">https://www.cnblogs.com/paddix/p/5405678.html</a></p><p>link : <a href="https://www.cnblogs.com/LemonFive/p/11246086.html" target="_blank" rel="noopener">https://www.cnblogs.com/LemonFive/p/11246086.html</a></p><p>link:<a href="https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon98ThinSlides.pdf" target="_blank" rel="noopener">https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon98ThinSlides.pdf</a></p><p>深入理解java虚拟机</p><p>java并发编程艺术</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview_Java Virtual Machine</title>
      <link href="/2019/08/11/Overview-Java-Virtual-Machine/"/>
      <url>/2019/08/11/Overview-Java-Virtual-Machine/</url>
      
        <content type="html"><![CDATA[<p>来易来去难去 数十载的人世游</p><p>分易分聚难聚 爱与恨的千古愁</p><p>于是不愿走的你 要告别已不见的我</p><p>至今世间人有隐约的耳语</p><p>滚滚红尘仍存隐约的耳语 跟随我的传说</p><a id="more"></a><p>基于官网指导文档整理 <a href="https://docs.oracle.com/en/java/javase/12/vm/java-virtual-machine-technology-overview.html#GUID-982B244A-9B01-479A-8651-CB6475019281" target="_blank" rel="noopener">详情🔎</a></p><p>更多资料💾:</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">相关规范</a></p><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning/introduction-garbage-collection-tuning.html#GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304" target="_blank" rel="noopener">HotSpot GC</a></p><p>书籍: 《深入理解Java虚拟机 —周志明》</p></blockquote><h2 id="虚拟机规范"><a href="#虚拟机规范" class="headerlink" title="虚拟机规范"></a>虚拟机规范</h2><p>指令集(虚拟机指令集)、运行内存数据区域(虚拟机结构)   </p><p>编译 </p><p>Class文件格式</p><p>类加载</p><blockquote><p><a href="https://docs.oracle.com/en/java/javase/12/vm/java-virtual-machine-technology-overview.html#GUID-982B244A-9B01-479A-8651-CB6475019281" target="_blank" rel="noopener">Spec-Java-Virtual-Machine</a></p></blockquote><h2 id="内存与线程模型"><a href="#内存与线程模型" class="headerlink" title="内存与线程模型"></a>内存与线程模型</h2><p>Memory model JSR133</p><p>屏蔽环境无关</p><blockquote><p><a href="https://zyumin.github.io/2019/06/14/Spec-JSR133/" target="_blank" rel="noopener">Spec-JSR133</a></p></blockquote><h2 id="hotspot"><a href="#hotspot" class="headerlink" title="hotspot"></a>hotspot</h2><p><strong>Rapid memory allocation and garbage collection</strong></p><p>Java HotSpot technology provides rapid memory allocation for objects and fast, efficient, state-of-the-art garbage collectors.</p><p>Java HotSpot技术为对象提供了快速的内存分配和快速、高效、最先进的垃圾收集器。</p><p><strong>Adaptive compiler</strong>:</p><p>A standard interpreter is used to launch the applications. When the application runs, the code is analyzed to detect performance bottlenecks, or <em>hot spots</em>. The Java HotSpot VM compiles the performance-critical portions of the code for a boost in performance, but does not compile the seldom-used code (most of the application). The Java HotSpot VM uses the adaptive compiler to decide how to optimize compiled code with techniques such as inlining.</p><p>​    使用标准解释器启动应用程序。当应用程序运行时，分析代码以检测性能瓶颈或热点。Java HotSpot VM编译代码的性能关键部分，以提高性能，但是不编译很少使用的代码(应用程序的大部分)。Java HotSpot VM使用自适应编译器来决定如何使用内联等技术来优化编译后的代码。</p><blockquote><p><a href="https://zyumin.github.io/2019/06/19/JVM-Garbage-Collection/" target="_blank" rel="noopener">JVM-Garbage-Collection</a></p><p><a href="https://zyumin.github.io/2019/06/05/Note_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/" target="_blank" rel="noopener">Note_深入理解java虚拟机</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_Packages_java_lang</title>
      <link href="/2019/08/11/JDK-Packages-java-lang/"/>
      <url>/2019/08/11/JDK-Packages-java-lang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>金风玉露一相逢，便胜却人间无数                                         ——秦观《鹊桥仙》</p></blockquote><p>语言基础包,lang包含Base, AutoBoxing ,Utils, VM ,Throwble</p><p>注解、字节码增强、动态语言支持、反射、管理等</p><p>相关资料:</p><ul><li>虚拟机规范</li><li>JLS   java language spec</li></ul><a id="more"></a><h2 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h2><p>Provides classes that are fundamental to the design of the Java programming language.</p><p>提供Java编程语言设计的基础类。</p><h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><p>Provides classes that are fundamental to the design of the Java programming language. The most important classes are <code>Object</code> ,<code>Class</code></p><p>提供Java编程语言设计的基础类。最重要的类是Object，它是类层次结构的根，类的实例表示运行时的类。</p><p>Class后续和ClassLoader一起分析</p><p>1 Byte =  8bit</p><p>1 Char =  2Byte </p><p>1 Integer = 4Byte </p><h3 id="AutoBoxing"><a href="#AutoBoxing" class="headerlink" title="AutoBoxing"></a>AutoBoxing</h3><p>Frequently it is necessary to represent a value of primitive type as if it were an object. The wrapper classes <code>Boolean</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, and <code>Double</code> serve this purpose. An object of type <code>Double</code>, for example, contains a field whose type is double, representing that value in such a way that a reference to it can be stored in a variable of reference type. These classes also provide a number of methods for converting among primitive values, as well as supporting such standard methods as equals and hashCode. The <code>Void</code> class is a non-instantiable class that holds a reference to a <code>Class</code> object representing the type void.</p><p>通常有必要将基元类型的值表示为对象。包装器类Boolean、Character、Integer、Long、Float和Double用于此目的。例如，Double类型的对象包含一个类型为Double的字段，以一种引用可以存储在引用类型变量中的方式表示该值。这些类还提供了许多方法来在基本值之间进行转换，并支持equals和hashCode等标准方法。Void类是一个不可实例化的类，它持有对表示类型Void的类对象的引用。</p><p>注意IntegerCache </p><h3 id="Utils-Math-String"><a href="#Utils-Math-String" class="headerlink" title="Utils (Math,String)"></a>Utils (Math,String)</h3><p>The class <code>Math</code> provides commonly used mathematical functions such as sine, cosine, and square root. The classes <code>String</code>, <code>StringBuffer</code>, and <code>StringBuilder</code> similarly provide commonly used operations on character strings.</p><h4 id="Math-amp-StrictMath"><a href="#Math-amp-StrictMath" class="headerlink" title="Math &amp; StrictMath"></a>Math &amp; StrictMath</h4><p>类Math提供常用的数学函数，如正弦、余弦和平方根。String、StringBuffer和StringBuilder类同样提供了对字符串的常用操作。</p><h4 id="String-amp-StringBuffer-synchronized-amp-StringBuilder"><a href="#String-amp-StringBuffer-synchronized-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer(synchronized) &amp; StringBuilder"></a>String &amp; StringBuffer(synchronized) &amp; StringBuilder</h4><p>Stringcoding</p><p>regex</p><p>StringJoiner</p><p>Formatter</p><p>Locale</p><p>AbstractStringBuilder</p><p>String不可变性</p><ul><li>常量池</li><li>hashcode</li><li>线程安全</li></ul><p><a href="https://zhuanlan.zhihu.com/p/94228628?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94228628?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p><p>⬅️⬅️⬅️⬅️⬅️</p><h3 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h3><p>Classes <code>ClassLoader</code>,<code>Thread</code>, <code>Process</code>, <code>ProcessBuilder</code>, <code>Runtime</code>, <code>SecurityManager</code>, and <code>System</code> provide “system operations” that manage the dynamic loading of classes, creation of external processes, host environment inquiries such as the time of day, and enforcement of security policies.</p><p>类ClassLoader、Process、ProcessBuilder、Runtime、SecurityManager和System提供“系统操作”，</p><p>管理类的动态加载、创建外部进程、主机环境查询(如一天的时间)和安全策略的执行。</p><h4 id="Class-amp-ClassLoader"><a href="#Class-amp-ClassLoader" class="headerlink" title="Class &amp; ClassLoader"></a>Class &amp; ClassLoader</h4><blockquote><p>link: JDK_CLass  &amp;&amp; JDK_ClassLoader</p></blockquote><h4 id="Process-amp-Thread-amp-Runnable"><a href="#Process-amp-Thread-amp-Runnable" class="headerlink" title="Process &amp; Thread &amp; Runnable"></a>Process &amp; Thread &amp; Runnable</h4><p>Process <a href="https://zhuanlan.zhihu.com/p/44957705" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44957705</a></p><blockquote><p>link:  JDK_Thread</p></blockquote><h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><p>The <code>System</code>Among the facilities provided by the <code>System</code> class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array.</p><p>java.lang.System#initializeSystemClass</p><p>相关方法和类 </p><p>​    SecurityManager </p><p>​    Runtime </p><p>​        Shutdown  java.lang.System#exit</p><p>​        Process</p><p>​        ClassLoader java.lang.System#load</p><p>​        java.lang.System#gc</p><p>​        </p><p>java.lang.System#currentTimeMillis</p><p>java.lang.System#nanoTime</p><p>java.lang.System#arraycopy</p><p>java.lang.System#getenv</p><p>java.lang.System#getProperties            </p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Class <code>Throwable</code> encompasses objects that may be thrown by the <code>throw</code> statement. Subclasses of <code>Throwable</code> represent errors and exceptions.</p><p>类可抛出性包含由抛出语句抛出的对象。Throwable的子类表示错误(Error)和异常(Exception 强制需要处理\ 运行时异常RuntimeException)。</p><p>通过一个JDK的例子来看看 Throwable的使用</p><pre><code class="java">public class Junk {      public static void main(String args[]) {          try {              a();          } catch(HighLevelException e) {              e.printStackTrace();          }      }      static void a() throws HighLevelException {          try {              b();          } catch(MidLevelException e) {              throw new HighLevelException(e);          }      }      static void b() throws MidLevelException {          c();      }      static void c() throws MidLevelException {          try {              d();          } catch(LowLevelException e) {              throw new MidLevelException(e);          }      }      static void d() throws LowLevelException {         e();      }      static void e() throws LowLevelException {          throw new LowLevelException();      }  }  class HighLevelException extends Exception {      HighLevelException(Throwable cause) { super(cause); }  }  class MidLevelException extends Exception {      MidLevelException(Throwable cause)  { super(cause); }  }  class LowLevelException extends Exception {  }</code></pre><p>运行结果如下</p><pre><code class="java">lang.Throwble.HighLevelException: lang.Throwble.MidLevelException: lang.Throwble.LowLevelException     at lang.Throwble.Junk.a(Junk.java:15)     at lang.Throwble.Junk.main(Junk.java:6)Caused by: lang.Throwble.MidLevelException: lang.Throwble.LowLevelException     at lang.Throwble.Junk.c(Junk.java:25)     at lang.Throwble.Junk.b(Junk.java:19)     at lang.Throwble.Junk.a(Junk.java:13)     ... 1 moreCaused by: lang.Throwble.LowLevelException     at lang.Throwble.Junk.e(Junk.java:32)     at lang.Throwble.Junk.d(Junk.java:29)     at lang.Throwble.Junk.c(Junk.java:23)     ... 3 more</code></pre><p>通过观察这个结果, 和分析 我们来看看Throwable都有哪些成员</p><pre><code class="java">private void printStackTrace(PrintStreamOrWriter s) {    // Guard against malicious overrides of Throwable.equals by    // using a Set with identity equality semantics.    //  IdentityHashMap 比较的是地址值 int h = System.identityHashCode(x);    Set&lt;Throwable&gt; dejaVu =        Collections.newSetFromMap(new IdentityHashMap&lt;Throwable, Boolean&gt;());    dejaVu.add(this);    synchronized (s.lock()) {        // Print our stack trace        s.println(this);        StackTraceElement[] trace = getOurStackTrace();        for (StackTraceElement traceElement : trace)            s.println(&quot;\tat &quot; + traceElement);        // Print suppressed exceptions, if any        for (Throwable se : getSuppressed())            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\t&quot;, dejaVu);        // Print cause, if any        Throwable ourCause = getCause();        if (ourCause != null)            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu);    }}</code></pre><p> s.println(this);</p><pre><code class="java">public String toString() {    String s = getClass().getName();    String message = getLocalizedMessage();    return (message != null) ? (s + &quot;: &quot; + message) : s;}</code></pre><p>可以看到其实就是  </p><ul><li>类名加Message</li><li>堆栈信息StackTraceElement</li><li>ourCause  Caused by:上层异常</li></ul><h2 id="java-lang-annotation"><a href="#java-lang-annotation" class="headerlink" title="java.lang.annotation"></a>java.lang.annotation</h2><p>Provides library support for the Java programming language annotation facility.</p><p>为Java编程语言注解工具提供库支持。</p><pre><code class="java">/* * More information about annotation types can be found in section 9.6 of * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. */</code></pre><p>注解（Annotation），也叫（metadata）元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。这些信息被存储在Annotation的“name=value”结构对中。</p><p>大致可分为三类：</p><ul><li><p>编写文档：通过代码里标识的元数据生成文档。</p></li><li><p>代码分析：通过代码里标识的元数据对代码进行分析。</p></li><li><p>编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查</p></li></ul><p>​    </p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>内置注解分为三类：</p><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解就是定义注解的注解，由 java API 提供，分别有四个元注解：</p><ul><li><p>@Target </p><p>  用于描述注解的使用范围。修饰的对象范围：packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如 catch 参数）。</p><p>  它的值在枚举类 ElemenetType 中：</p><ul><li>CONSTRUCTOR： 用于描述构造器</li><li>FIELD ： 用于描述域</li><li>LOCAL_VARIABLE： 用于描述局部变量</li><li>METHOD ： 用于描述方法</li><li>PACKAGE ： 用于描述包</li><li>PARAMETER ： 用于描述参数</li><li>TYPE ： 用于描述类、接口(包括注解类型) 或enum声明</li></ul></li><li><p>@Retention</p><p>  表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取。</p><p>  RetentionPoicy取值：</p><ul><li>SOURCE ： 在源文件中有效（即源文件保留）</li><li>CLASS ： 在class文件中有效（即class保留）</li><li>RUNTIME ： 在运行时有效（即运行时保留）</li></ul></li><li><p>@Documented</p><p>  用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，Documented 是一个标记注解，没有成员。将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。</p></li><li><p>@Inherited</p><p>  允许子类继承父类中的注解，是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p></li></ul><p>@link : <a href="https://www.jianshu.com/p/d124f24e685c" target="_blank" rel="noopener">https://www.jianshu.com/p/d124f24e685c</a></p><h2 id="java-lang-instrument"><a href="#java-lang-instrument" class="headerlink" title="java.lang.instrument"></a>java.lang.instrument</h2><p>Provides services that allow Java programming language agents to instrument programs running on the JVM.</p><p>提供允许Java编程语言代理对运行在JVM上的程序进行增强的服务。</p><p>JPDA体系概览</p><ul><li>JPDA 定义了一套如何开发调试工具的接口和规范。</li><li>JPDA 由三个独立的模块 JVMTI、JDWP、JDI 组成。<ul><li>调试者通过 JDI 发送接受调试命令。</li><li>JDWP 定义调试者和被调试者交流数据的格式。</li><li>JVMTI 可以控制当前虚拟机运行状态。</li></ul></li></ul><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html?ca=drs-</a></p><p><a href="https://www.cnblogs.com/yelao/p/9841810.html" target="_blank" rel="noopener">https://www.cnblogs.com/yelao/p/9841810.html</a></p><p>class</p><p>java.lang.instrument.ClassFileTransformer</p><p>java.lang.instrument.Instrumentation</p><p>java.lang.instrument.ClassDefinition</p><h2 id="java-lang-invoke"><a href="#java-lang-invoke" class="headerlink" title="java.lang.invoke"></a>java.lang.invoke</h2><p>The java.lang.invoke package contains dynamic language support provided directly by the Java core class libraries and virtual machine.</p><p>包含Java核心类库和虚拟机直接提供的动态语言支持。</p><p>java7在JSR 292中增加了对动态类型语言的支持，使Java也可以像C语言那样将方法作为参数传递，其实现在lava.lang.invoke包中。MethodHandle作用类似于反射中的Method类，但它比Method类要更加灵活和轻量级。通过MethodHandle进行方法调用一般需要以下几步：</p><ol><li>创建MethodType对象，指定方法的签名；</li><li>在MethodHandles.Lookup中查找类型为MethodType的MethodHandle；</li><li>传入方法参数并调用MethodHandle.invoke或者MethodHandle.invokeExact方法。</li></ol><p>InvokeDynamic</p><p><a href="https://www.cnblogs.com/sheeva/p/6344388.html" target="_blank" rel="noopener">https://www.cnblogs.com/sheeva/p/6344388.html</a></p><p>在看java虚拟机字节码执行引擎的时候，里面提到了java虚拟机里调用方法的字节码指令有5种：</p><ul><li>invokestatic　　//调用静态方法</li><li>invokespecial　　//调用私有方法、实例构造器方法、父类方法</li><li>invokevirtual　　//调用实例方法</li><li>invokeinterface　　//调用接口方法，会在运行时再确定一个实现此接口的对象</li><li><strong>invokedynamic</strong>　　//先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p>CallSite</p><p>从语言的静态类型和动态类型说起：</p><ul><li>静态类型就是每个变量在初始化的时候就要声明唯一的类型并且不能改变。</li><li>动态类型就是说变量没有固定类型，变量的类型取决于它里面元素的类型。</li></ul><p>java语言是静态类型的。有人可能会提到泛型，java的泛型是擦除式的，也就是说虽然在编写java源码时看起来好像不能确定变量类型，但是在java编译为字节码的过程中，每一个变量都是有确定的类型的。</p><p>所以从java语言的角度，之前的4条方法调用指令是完全够用的，但是要知道，jvm不只是跨平台的，还是跨语言的，当有人在jvm上试图开发动态类型语言的时候，问题就来了：</p><p>jvm大多数指令都是类型无关的，但是在方法调用的时候，却不是这样，每个方法调用在编译阶段就必须指明方法参数和返回值类型，但是动态类型语言的方法参数，直到运行时刻才能知道类型啊，因此jdk就做了这样一个“补丁”：用invokedynamic调用方法的时候，会转到bootstrap方法，在这个方法里可以动态获取参数类型，然后根据参数类型分派合适的方法作为CallSite(动态调用点)，最后真实调用的就是CallSize里的方法。如此便能在jvm上实现动态类型语言的方法调用了。</p><h2 id="java-lang-management"><a href="#java-lang-management" class="headerlink" title="java.lang.management"></a>java.lang.management</h2><p>Provides the management interfaces for monitoring and management of the Java virtual machine and other components in the Java runtime.</p><p>提供用于监视和管理Java虚拟机和Java运行时中的其他组件的管理接口。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/javax/management/package-summary.html" target="_blank" rel="noopener">JMX</a> Instrumentation Specification</p><p>访问MXBeans的方法</p><p><strong>1.直接访问MXBean接口</strong></p><p><strong>2.通过MBeanServer间接访问MXBean接口</strong></p><p>jmx规范</p><p> <a href="https://docs.oracle.com/javase/8/docs/api/javax/management/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/javax/management/package-summary.html</a></p><p>ManagementFactory</p><p>实现-&gt; sum包中 ?  😪</p><h2 id="java-lang-ref"><a href="#java-lang-ref" class="headerlink" title="java.lang.ref"></a>java.lang.ref</h2><p>Provides reference-object classes, which support a limited degree of interaction with the garbage collector.</p><p>提供引用对象类，该类支持与垃圾收集器进行有限程度的交互。</p><p><strong>表 1. 引用类型特性总结</strong></p><table><thead><tr><th><strong>引用类型</strong></th><th><strong>取得目标对象方式</strong></th><th><strong>垃圾回收条件</strong></th><th><strong>是否可能内存泄漏</strong></th></tr></thead><tbody><tr><td>强引用</td><td>直接调用</td><td>不回收</td><td>可能</td></tr><tr><td>软引用</td><td>通过 get() 方法</td><td>视内存情况回收</td><td>不可能</td></tr><tr><td>弱引用</td><td>通过 get() 方法</td><td>永远回收</td><td>不可能</td></tr><tr><td>虚引用</td><td>无法取得</td><td>不回收</td><td>可能</td></tr></tbody></table><p><strong>表 2：各个引用在 GC 后是否被回收？</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>GC 后是否回收</strong></th><th><strong>示例代码</strong></th><th><strong>运行结果</strong></th></tr></thead><tbody><tr><td>StrongReference</td><td>不回收</td><td>见清单 3</td><td>name:10</td></tr><tr><td>SoftReference</td><td>不回收</td><td>见清单 4</td><td>name:10</td></tr><tr><td>WeakReference</td><td>回收</td><td>见清单 5</td><td>name:10</td></tr><tr><td>PhantomReference</td><td>N/A</td><td>N/A</td><td>N/A</td></tr></tbody></table><p><a href="https://www.cnblogs.com/rollenholt/archive/2011/09/21/2183077.html" target="_blank" rel="noopener">https://www.cnblogs.com/rollenholt/archive/2011/09/21/2183077.html</a></p><h2 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h2><p>Provides classes and interfaces for obtaining reflective information about classes and objects.</p><p>提供用于获取有关类和对象的反射信息的类和接口。</p><p>Construct、Field、Method</p><p>Fastjson </p><p>Proxy </p><p><a href="https://www.cnblogs.com/xrq730/p/4918762.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4918762.html</a></p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> packages </tag>
            
            <tag> lang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_Packages_java_utils</title>
      <link href="/2019/08/11/JDK-Packages-java-utils/"/>
      <url>/2019/08/11/JDK-Packages-java-utils/</url>
      
        <content type="html"><![CDATA[<p>utils包需要关注的主要有</p><p>​    集合框架、并发包、函数式编程、观察者模式@see PropertyChangeSupport</p><a id="more"></a><h3 id="java-util-集合框架"><a href="#java-util-集合框架" class="headerlink" title="java.util(集合框架)"></a>java.util(集合框架)</h3><p>Contains the collections framework, legacy collection classes, event model, date and time facilities, internationalization, and miscellaneous utility classes (a string tokenizer, a random-number generator, and a bit array).</p><p>包含集合框架、遗留集合类、事件模型、日期和时间工具、国际化和杂项实用程序类(字符串记号赋予器、随机数生成器和位数组)。</p><blockquote><p><a href="https://zyumin.github.io/2019/07/29/JDK-The-Collections-Framework/" target="_blank" rel="noopener">JDK-The-Collections-Framework</a></p></blockquote><h3 id="java-util-concurrent-并发包-、-原子类、锁"><a href="#java-util-concurrent-并发包-、-原子类、锁" class="headerlink" title="java.util.concurrent (并发包 、 原子类、锁)"></a>java.util.concurrent (并发包 、 原子类、锁)</h3><p>Utility classes commonly useful in concurrent programming.</p><p>java.util.concurrent.atomic     A small toolkit of classes that support lock-free thread-safe programming on single variables.</p><p>java.util.concurrent.locks     Interfaces and classes providing a framework for locking and waiting for conditions that is distinct from built-in synchronization and monitors.</p><blockquote><p> <a href="https://zyumin.github.io/2019/08/10/JDK-The-Concurrent-Framework/" target="_blank" rel="noopener">JDK-The-Concurrent-Framework</a></p></blockquote><h3 id="java-util-function-函数式编程"><a href="#java-util-function-函数式编程" class="headerlink" title="java.util.function    (函数式编程)"></a>java.util.function    (函数式编程)</h3><p>Functional interfaces provide target types for lambda expressions and method references.</p><p>There are several basic function shapes,</p><p> including <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" target="_blank" rel="noopener"><code>Function</code></a> (unary function from <code>T</code> to <code>R</code>),</p><p> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" target="_blank" rel="noopener"><code>Consumer</code></a> (unary function from <code>T</code> to <code>void</code>),</p><p> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" target="_blank" rel="noopener"><code>Predicate</code></a> (unary function from <code>T</code> to <code>boolean</code>),</p><p> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" target="_blank" rel="noopener"><code>Supplier</code></a> (nilary function to <code>R</code>).</p><h3 id="java-util-stream-流式编程"><a href="#java-util-stream-流式编程" class="headerlink" title="java.util.stream(流式编程)"></a>java.util.stream(流式编程)</h3><p>Classes to support functional-style operations on streams of elements, such as map-reduce transformations on collections.</p><p>类来支持元素流上的函数式操作，例如集合上的映射-reduce转换。</p><p>java.util.stream.Stream</p><h3 id="java-util-logging-日志"><a href="#java-util-logging-日志" class="headerlink" title="java.util.logging(日志)"></a>java.util.logging(日志)</h3><p>Provides the classes and interfaces of the JavaTM 2 platform’s core logging facilities.</p><h3 id="java-util-prefs"><a href="#java-util-prefs" class="headerlink" title="java.util.prefs"></a>java.util.prefs</h3><p>This package allows applications to store and retrieve user and system preference and configuration data.</p><p>这个包允许应用程序存储和检索用户和系统首选项以及配置数据。</p><h3 id="java-util-regex"><a href="#java-util-regex" class="headerlink" title="java.util.regex"></a>java.util.regex</h3><p>Classes for matching character sequences against patterns specified by regular expressions.</p><p>用于根据正则表达式指定的模式匹配字符序列的类。</p><h3 id="java-util-spi"><a href="#java-util-spi" class="headerlink" title="java.util.spi"></a>java.util.spi</h3><p>Service provider classes for the classes in the java.util package.</p><p>用于java中的类的服务提供程序类</p><h3 id="java-util-zip-读写zip"><a href="#java-util-zip-读写zip" class="headerlink" title="java.util.zip(读写zip)"></a>java.util.zip(读写zip)</h3><p>Provides classes for reading and writing the standard ZIP and GZIP file formats.</p><h3 id="java-util-jar-jar包工具"><a href="#java-util-jar-jar包工具" class="headerlink" title="java.util.jar(jar包工具)"></a>java.util.jar(jar包工具)</h3><p>Provides classes for reading and writing the JAR (Java ARchive) file format, which is based on the standard ZIP file format with an optional manifest file.</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> packages </tag>
            
            <tag> utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_The Concurrent Framework</title>
      <link href="/2019/08/10/JDK-The-Concurrent-Framework/"/>
      <url>/2019/08/10/JDK-The-Concurrent-Framework/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5utotuddmj30f409gjrs.jpg" alt="img"></p><a id="more"></a><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p><img src="http://ww4.sinaimg.cn/large/006y8mN6gy1g6740ptmguj30lw0g0acz.jpg" alt="image-20190820172914051"></p><p>CAS实现 、volatile语意  -&gt; AQS(AbstractQueuedSynchronizer)</p><h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><p>Utility classes commonly useful in concurrent programming.This package includes a few small standardized extensible frameworks, as well as some classes that provide useful functionality and are otherwise tedious or difficult to implement.</p><p>实用程序类通常用于并发编程。这个包, 包括一些小型的标准化可扩展框架，以及一些提供有用功能的类，通常这些类是单调乏味或难以实现的。</p><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g62o7n38t1j324d0u0gt9.jpg" alt="image-20190817144324388"></p><p><strong>Interfaces</strong></p><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html" target="_blank" rel="noopener"><code>Executor</code></a> is a simple standardized interface for defining custom thread-like subsystems, including thread pools, asynchronous I/O, and lightweight task frameworks. </p><p>Depending on which concrete Executor class is being used, tasks may execute in a newly created thread, an existing task-execution thread, or the thread calling <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener"><code>execute</code></a>, and may execute sequentially or concurrently.</p><pre><code class="java">public interface Executor {    void execute(Runnable command);}</code></pre><h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h5><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g62obzhq7nj31ds0sujwc.jpg" alt="image-20190817144736755"></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener"><code>ExecutorService</code></a> provides a more complete asynchronous task execution framework. An ExecutorService manages queuing and scheduling of tasks, and allows controlled shutdown. </p><pre><code class="java">public interface ExecutorService extends Executor {   void shutdown();   List&lt;Runnable&gt; shutdownNow();   boolean isShutdown();   boolean isTerminated();   boolean awaitTermination(long timeout, TimeUnit unit)        throws InterruptedException;   &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);   &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);   Future&lt;?&gt; submit(Runnable task);   &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;   &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)        throws InterruptedException;   &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException;   &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><p>不同于submit</p><p>方法invokeAny,invokeAll具有阻塞性。</p><ul><li>invokeAny取得第一个方法的返回值,当第一个任务结束后，会调用interrupt方法中断其它任务。</li><li>invokeAll等线程任务执行完毕后,取得全部任务的结果值。</li></ul><h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener"><code>ScheduledExecutorService</code></a> subinterface and associated interfaces add support for delayed and periodic task execution. </p><pre><code class="java">public interface ScheduledExecutorService extends ExecutorService {   public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit);   public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay, TimeUnit unit);   public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,                                                  long initialDelay,                                                  long period,                                                  TimeUnit unit);  public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,                                                     long initialDelay,                                                     long delay,                                                     TimeUnit unit);}</code></pre><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p> ExecutorServices provide methods arranging asynchronous execution of any function expressed as <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html" target="_blank" rel="noopener"><code>Callable</code></a>, the result-bearing analog of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener"><code>Runnable</code></a></p><pre><code class="java">@FunctionalInterfacepublic interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}</code></pre><h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" target="_blank" rel="noopener"><code>Future</code></a> returns the results of a function, allows determination of whether execution has completed, and provides a means to cancel execution.</p><pre><code class="java">public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();     V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><h5 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h5><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RunnableFuture.html" target="_blank" rel="noopener"><code>RunnableFuture</code></a> is a <code>Future</code> that possesses a <code>run</code> method that upon execution, sets its results.</p><pre><code class="java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {    /**     * Sets this Future to the result of its computation     * unless it has been cancelled.     */    void run();}</code></pre><h5 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h5><pre><code class="java">public interface ThreadFactory {    /**     * Constructs a new {@code Thread}.  Implementations may also initialize     * priority, name, daemon status, {@code ThreadGroup}, etc.     *     * @param r a runnable to be executed by new thread instance     * @return constructed thread, or {@code null} if the request to     *         create a thread is rejected     */    Thread newThread(Runnable r);}</code></pre><p>构造新的线程,初始化 优先级 、名字 等</p><p><strong>Implementations</strong> </p><h5 id="ThreadPoolExecutor-amp-ScheduledThreadPoolExecutor"><a href="#ThreadPoolExecutor-amp-ScheduledThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor &amp; ScheduledThreadPoolExecutor"></a>ThreadPoolExecutor &amp; ScheduledThreadPoolExecutor</h5><pre><code class="java">public class ThreadPoolExecutor extends AbstractExecutorService {     /**     * The main pool control state, ctl, is an atomic integer packing     * two conceptual fields     *   workerCount, indicating the effective number of threads     *   runState,    indicating whether running, shutting down etc     */    private final class Worker extends AbstractQueuedSynchronizer implements Runnable{...}    public static class xxx implements rejectedExecution{...}    implements Executor{..}    implements ExecutorService{..}    ...}</code></pre><p>​    这个类很有意思呀,包含了运行状态,worker数量的计算,  Worker的实现,拒绝策略的实现,Executor的实现,另外注意构造函数,注意理解各个参数的含义⚠️</p><pre><code class="java">public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor        implements ScheduledExecutorService {    /*     * This class specializes ThreadPoolExecutor implementation by     *     * 1. Using a custom task type, ScheduledFutureTask for     *    tasks, even those that don&#39;t require scheduling (i.e.,     *    those submitted using ExecutorService execute, not     *    ScheduledExecutorService methods) which are treated as     *    delayed tasks with a delay of zero.     *     * 2. Using a custom queue (DelayedWorkQueue), a variant of     *    unbounded DelayQueue. The lack of capacity constraint and     *    the fact that corePoolSize and maximumPoolSize are     *    effectively identical simplifies some execution mechanics     *    (see delayedExecute) compared to ThreadPoolExecutor.     *     * 3. Supporting optional run-after-shutdown parameters, which     *    leads to overrides of shutdown methods to remove and cancel     *    tasks that should NOT be run after shutdown, as well as     *    different recheck logic when task (re)submission overlaps     *    with a shutdown.     *     * 4. Task decoration methods to allow interception and     *    instrumentation, which are needed because subclasses cannot     *    otherwise override submit methods to get this effect. These     *    don&#39;t have any impact on pool control logic though.     */     ...}</code></pre><p>​    与ThreadPoolExecutor不同的是,使用的是task,延迟队列,重写了onshutdown</p><h5 id="Executors-1"><a href="#Executors-1" class="headerlink" title="Executors"></a>Executors</h5><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html" target="_blank" rel="noopener"><code>Executors</code></a> class provides factory methods for the most common kinds and configurations of Executors, as well as a few utility methods for using them. </p><p>类似于Collections, Executors类为最常见的executor类型和配置提供工厂方法，以及一些使用它们的实用程序方法。</p><h5 id="FutureTask-amp-ExecutorCompletionService"><a href="#FutureTask-amp-ExecutorCompletionService" class="headerlink" title="FutureTask &amp; ExecutorCompletionService"></a>FutureTask &amp; ExecutorCompletionService</h5><p>Other utilities based on <code>Executors</code> include the concrete class <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html" target="_blank" rel="noopener"><code>FutureTask</code></a> providing a common extensible implementation of Futures, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorCompletionService.html" target="_blank" rel="noopener"><code>ExecutorCompletionService</code></a>, that assists in coordinating the processing of groups of asynchronous tasks.</p><p>基于executor的其他实用程序包括提供future公共可扩展实现的具体类FutureTask和ExecutorCompletionService，后者帮助协调异步任务组的处理。</p><h5 id="ForkJoinPool-amp-ForkJoinTask-amp-ForkJoinWorkerThread-since-1-7"><a href="#ForkJoinPool-amp-ForkJoinTask-amp-ForkJoinWorkerThread-since-1-7" class="headerlink" title="ForkJoinPool &amp; ForkJoinTask &amp; ForkJoinWorkerThread(@since 1.7)"></a>ForkJoinPool &amp; ForkJoinTask &amp; ForkJoinWorkerThread(@since 1.7)</h5><p>ForkJoinPool的优势在于，可以充分利用多cpu，多核cpu的优势，把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5utn9m71kj317y0tutgr.jpg" alt="image-20190810194656530"></p><h4 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h4><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g62ogwi8q8j32fw0gm0v5.jpg" alt="image-20190817145220963"></p><h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank" rel="noopener"><code>Queue</code></a> that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element.</p><p><code>BlockingQueue</code> methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: </p><p>one throws an exception, </p><p>the second returns a special value (either <code>null</code> or <code>false</code>, depending on the operation),</p><p>the third blocks the current thread indefinitely until the operation can succeed, </p><p>and the fourth blocks for only a given maximum time limit before giving up. </p><p>These methods are summarized in the following table:</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"><em>Throws exception</em></th><th style="text-align:left"><em>Special value</em></th><th style="text-align:left"><em>Blocks</em></th><th style="text-align:left"><em>Times out</em></th></tr></thead><tbody><tr><td style="text-align:left"><strong>Insert</strong></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#add-E-" target="_blank" rel="noopener"><code>add(e)</code></a></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-" target="_blank" rel="noopener"><code>offer(e)</code></a></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#put-E-" target="_blank" rel="noopener"><code>put(e)</code></a></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>offer(e, time, unit)</code></a></td></tr><tr><td style="text-align:left"><strong>Remove</strong></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#remove-java.lang.Object-" target="_blank" rel="noopener"><code>remove()</code></a></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>poll()</code></a></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#take--" target="_blank" rel="noopener"><code>take()</code></a></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>poll(time, unit)</code></a></td></tr><tr><td style="text-align:left"><strong>Examine</strong></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#element--" target="_blank" rel="noopener"><code>element()</code></a></td><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#peek--" target="_blank" rel="noopener"><code>peek()</code></a></td><td style="text-align:left"><em>not applicable</em></td><td style="text-align:left"><em>not applicable</em></td></tr></tbody></table><pre><code class="java">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; {    /*     * imple Queue     */    boolean add(E e);    boolean offer(E e);    /*     * imple Collection     */    boolean remove(Object o);    public boolean contains(Object o);    /*     * BlockingQueue methods  put take      */    void put(E e) throws InterruptedException;    boolean offer(E e, long timeout, TimeUnit unit)        throws InterruptedException;    /*     * Retrieves and removes the head of this queue     */    E take() throws InterruptedException;    E poll(long timeout, TimeUnit unit)        throws InterruptedException;}</code></pre><p>​    实现了Queue接口 , 而Queue接口又实现了Collection,  而BlockingQueue 新增的有阻塞式的 put和take ,</p><p>提供阻塞超时机制的, offer、poll(扩展了Queue的方法)</p><h5 id="BlockingDeque-since-1-6-amp-TransferQueue-since-1-7"><a href="#BlockingDeque-since-1-6-amp-TransferQueue-since-1-7" class="headerlink" title="BlockingDeque(@since 1.6) &amp; TransferQueue(@since 1.7)"></a>BlockingDeque(@since 1.6) &amp; TransferQueue(@since 1.7)</h5><p>BlockingDeque与BlockingQueue类似</p><p>LinkedBlockingDeque</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingDeque.html" target="_blank" rel="noopener"><code>BlockingDeque</code></a> interface extends <code>BlockingQueue</code> to support both FIFO and LIFO (stack-based) operations.</p><pre><code class="java">public interface BlockingDeque&lt;E&gt; extends BlockingQueue&lt;E&gt;, Deque&lt;E&gt; {    ...    void putFirst(E e) throws InterruptedException;    void putLast(E e) throws InterruptedException;    E takeFirst() throws InterruptedException;    E takeLast() throws InterruptedException;    ...}</code></pre><p>TransferQueue </p><p> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedTransferQueue.html" target="_blank" rel="noopener"><code>LinkedTransferQueue</code></a> introduce a synchronous <code>transfer</code> method (along with related features) in which a producer may optionally block awaiting its consumer</p><blockquote><p>TransferQueue是一个聪明的队列，它是ConcurrentLinkedQueue, SynchronousQueue (在公平模式下), 无界的LinkedBlockingQueues等的超集。</p></blockquote><p>🌟这是个很厉害的队列~ 只有在消费者等待的情况下才会生产,  解决消费者和生产者速度不匹配的问题, 例如 out of memory .</p><p>@see <a href="https://segmentfault.com/a/1190000011266361" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011266361</a></p><p><strong>Implementations.</strong> </p><p>Five implementations in <code>java.util.concurrent</code> support the extended <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html" target="_blank" rel="noopener"><code>BlockingQueue</code></a> interface, that defines blocking versions of put and take: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html" target="_blank" rel="noopener"><code>LinkedBlockingQueue</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html" target="_blank" rel="noopener"><code>ArrayBlockingQueue</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html" target="_blank" rel="noopener"><code>SynchronousQueue</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/PriorityBlockingQueue.html" target="_blank" rel="noopener"><code>PriorityBlockingQueue</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html" target="_blank" rel="noopener"><code>DelayQueue</code></a>. The different classes cover the most common usage contexts for producer-consumer, messaging, parallel tasking, and related concurrent designs.</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>有限阻塞队列,底层存储链表结构, 可以不指定大小, 默认Integer.MAX_VALUE</p><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>有限阻塞队列,底层存储是数组,需要指定大小初始化 , 另一个是可以指定ReentrantLock公平锁或者非公平锁</p><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>是一个空队列,用于传递数据</p><p>SynchronousQueue使用两个队列（一个用于正在等待的生产者、另一个用于正在等待的消费者）和一个用来保护两个队列的锁。而LinkedTransferQueue使用CAS操作实现一个非阻塞的方法，这是避免序列化处理任务的关键。</p><p>@see <a href="https://segmentfault.com/a/1190000011207824" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011207824</a></p><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>优先级队列, 实现上使用了数组, 默认初始化大小是 DEFAULT_INITIAL_CAPACITY = 11</p><p>使用PriorityQueue,用于Serializable</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue."></a>DelayQueue.</h5><p>延迟队列,实现上使用了PriorityQueue,默认初始化大小是 DEFAULT_INITIAL_CAPACITY = 11(没有实现java.io.Serializable)</p><h4 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h4><p>​    The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html" target="_blank" rel="noopener"><code>TimeUnit</code></a> class provides multiple granularities (including nanoseconds) for specifying and controlling time-out based operations. Most classes in the package contain operations based on time-outs in addition to indefinite waits. In all cases that time-outs are used, the time-out specifies the minimum time that the method should wait before indicating that it timed-out. Implementations make a “best effort” to detect time-outs as soon as possible after they occur. However, an indefinite amount of time may elapse between a time-out being detected and a thread actually executing again after that time-out. All methods that accept timeout parameters treat values less than or equal to zero to mean not to wait at all. To wait “forever”, you can use a value of <code>Long.MAX_VALUE</code>.</p><p>TimeUnit类提供了多个粒度(包括纳秒)，用于指定和控制基于超时的操作。</p><p>包中的大多数类除了不确定的等待之外，还包含基于超时的操作。在所有使用超时的情况下，超时指定方法在指示超时之前应该等待的最小时间。实现会在超时发生后“尽最大努力”尽快检测超时。然而，在检测到超时与实际在超时之后再次执行的线程之间可能会经过一段不确定的时间。</p><p>所有接受超时参数的方法都将小于或等于零的值视为根本不等待。要等待“永远”，可以使用Long.MAX_VALUE值。</p><pre><code class="java">public enum TimeUnit {    /**     * Time unit representing one thousandth of a microsecond     */    NANOSECONDS {        public long toNanos(long d)   { return d; }        public long toMicros(long d)  { return d/(C1/C0); }        public long toMillis(long d)  { return d/(C2/C0); }        public long toSeconds(long d) { return d/(C3/C0); }        public long toMinutes(long d) { return d/(C4/C0); }        public long toHours(long d)   { return d/(C5/C0); }        public long toDays(long d)    { return d/(C6/C0); }        public long convert(long d, TimeUnit u) { return u.toNanos(d); }        int excessNanos(long d, long m) { return (int)(d - (m*C2)); }    },           MICROSECONDS {    ...    },    ...            public long convert(long sourceDuration, TimeUnit sourceUnit) {        throw new AbstractMethodError();    }    abstract int excessNanos(long d, long m);        public void timedWait(Object obj, long timeout)            throws InterruptedException {        if (timeout &gt; 0) {            long ms = toMillis(timeout);            int ns = excessNanos(timeout, ms);            obj.wait(ms, ns);        }    }    public void timedJoin(Thread thread, long timeout)            throws InterruptedException {        if (timeout &gt; 0) {            long ms = toMillis(timeout);            int ns = excessNanos(timeout, ms);            thread.join(ms, ns);        }    }    public void sleep(long timeout) throws InterruptedException {        if (timeout &gt; 0) {            long ms = toMillis(timeout);            int ns = excessNanos(timeout, ms);            Thread.sleep(ms, ns);        }    }}</code></pre><h4 id="Synchronizers"><a href="#Synchronizers" class="headerlink" title="Synchronizers"></a>Synchronizers</h4><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g62op94yg7j31pe0nqdiy.jpg" alt="image-20190817150022024"></p><p>Five classes aid common special-purpose synchronization idioms.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html" target="_blank" rel="noopener"><code>Semaphore</code></a> is a classic concurrency tool.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="noopener"><code>CountDownLatch</code></a> is a very simple yet very common utility for blocking until a given number of signals, events, or conditions hold.</li><li>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html" target="_blank" rel="noopener"><code>CyclicBarrier</code></a> is a resettable multiway synchronization point useful in some styles of parallel programming.</li><li>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Phaser.html" target="_blank" rel="noopener"><code>Phaser</code></a> provides a more flexible form of barrier that may be used to control phased computation among multiple threads.</li><li>An <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html" target="_blank" rel="noopener"><code>Exchanger</code></a> allows two threads to exchange objects at a rendezvous point, and is useful in several pipeline designs.</li></ul><h5 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h5><p>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.<br>Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource.</p><p>计数信号量。从概念上讲，信号量维护一组许可证。</p><p>如果有必要，每个acquire()块都会被阻塞，直到获得许可证为止，然后获取许可证。</p><p>每个release()都会添加一个许可证，潜在地释放一个阻塞的收购者。</p><p>但是，没有使用实际的许可证对象;信号量只保留可用数量的计数，并相应地执行操作。</p><p>信号量通常用于限制能够访问某些(物理或逻辑)资源的线程数。</p><pre><code class="java">public class Semaphore implements java.io.Serializable {  private final Sync sync;    /**     * Synchronization implementation for semaphore.  Uses AQS state     * to represent permits. Subclassed into fair and nonfair     * versions.     */  abstract static class Sync extends AbstractQueuedSynchronizer {     ...     final int nonfairTryAcquireShared(int acquires) {         for (;;) {              int available = getState();              int remaining = available - acquires;              if (remaining &lt; 0 ||compareAndSetState(available, remaining))                    return remaining;         }      }  }      static final class NonfairSync extends Sync {       ...           protected int tryAcquireShared(int acquires) {           return nonfairTryAcquireShared(acquires);       }  }  static final class FairSync extends Sync {      ...      protected int tryAcquireShared(int acquires) {            for (;;) {                if (hasQueuedPredecessors())                    return -1;                int available = getState();                int remaining = available - acquires;                if (remaining &lt; 0 ||compareAndSetState(available, remaining))                    return remaining;            }        }  }  public Semaphore(int permits) {       sync = new NonfairSync(permits);  }  public Semaphore(int permits, boolean fair) {       sync = fair ? new FairSync(permits) : new NonfairSync(permits);  }  public void acquire(int permits) throws InterruptedException {        if (permits &lt; 0) throw new IllegalArgumentException();        sync.acquireSharedInterruptibly(permits);  }  public void release(int permits) {        if (permits &lt; 0) throw new IllegalArgumentException();        sync.releaseShared(permits);  }  ...}</code></pre><p>基于AbstractQueuedSynchronizer 实现,主要有acquire 和 release方法</p><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p><p>一种同步辅助，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。</p><pre><code class="java">public class CountDownLatch {    /**     * Synchronization control For CountDownLatch.     * Uses AQS state to represent count.     */    private static final class Sync extends AbstractQueuedSynchronizer {        private static final long serialVersionUID = 4982264981922014374L;        Sync(int count) {            setState(count);        }        int getCount() {            return getState();        }        protected int tryAcquireShared(int acquires) {            return (getState() == 0) ? 1 : -1;        }        protected boolean tryReleaseShared(int releases) {            // Decrement count; signal when transition to zero            for (;;) {                int c = getState();                if (c == 0)                    return false;                int nextc = c-1;                if (compareAndSetState(c, nextc))                    return nextc == 0;            }        }    }    private final Sync sync;    public CountDownLatch(int count) {        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);        this.sync = new Sync(count);    }    public void await() throws InterruptedException {        sync.acquireSharedInterruptibly(1);    }    public boolean await(long timeout, TimeUnit unit)        throws InterruptedException {        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));    }    public void countDown() {        sync.releaseShared(1);    }    public long getCount() {        return sync.getCount();    }}</code></pre><h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>与 CountDownLatch 类似, 最大的不同点在于调用时点是否阻塞 ,注意实现也是不同的</p><p>从使用场景上来说，CyclicBarrier是让多个线程互相等待某一事件的发生，然后同时被唤醒。而上文讲的CountDownLatch是让某一线程等待多个线程的状态，然后该线程被唤醒。</p><table><thead><tr><th style="text-align:left">CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td style="text-align:left">减计数方式</td><td>ReentrantLock</td></tr><tr><td style="text-align:left">计数为0时，无法重置</td><td>计数置为0,重新开始</td></tr><tr><td style="text-align:left">调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td><td>调用await()方法计数count减1，减1后的值不等于构造方法的值，则线程阻塞,否则执行barrierCommand</td></tr></tbody></table><pre><code class="java">public class CyclicBarrier {    public CyclicBarrier(int parties, Runnable barrierAction) {        if (parties &lt;= 0) throw new IllegalArgumentException();        this.parties = parties;        this.count = parties;        this.barrierCommand = barrierAction;    }    public CyclicBarrier(int parties) {        this(parties, null);    }    public int await() throws InterruptedException, BrokenBarrierException {        try {            return dowait(false, 0L);        } catch (TimeoutException toe) {            throw new Error(toe); // cannot happen        }    }    public boolean isBroken() {        final ReentrantLock lock = this.lock;        lock.lock();        try {            return generation.broken;        } finally {            lock.unlock();        }    }    public void reset() {        final ReentrantLock lock = this.lock;        lock.lock();        try {            breakBarrier();   // break the current generation            nextGeneration(); // start a new generation        } finally {            lock.unlock();        }    }    public int getNumberWaiting() {        final ReentrantLock lock = this.lock;        lock.lock();        try {            return parties - count;        } finally {            lock.unlock();        }    }        ...}</code></pre><p>​    </p><h5 id="Phaser-since-1-7"><a href="#Phaser-since-1-7" class="headerlink" title="Phaser(@since 1.7)"></a>Phaser(@since 1.7)</h5><p>A reusable synchronization barrier, similar in functionality to <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html" target="_blank" rel="noopener"><code>CyclicBarrier</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="noopener"><code>CountDownLatch</code></a> but supporting more flexible usage.</p><p><strong>Registration</strong> </p><p><strong>Synchronization</strong></p><p><strong>Termination</strong> </p><p><strong>Tiering</strong> (分层)</p><p><strong>Monitoring</strong></p><p>CountDownLatch和CyclicBarrier都是JDK 1.5引入的，而Phaser是JDK 1.7引入的。Phaser的功能与CountDownLatch和CyclicBarrier有部分重叠，同时也提供了更丰富的语义和更灵活的用法。</p><p>Phaser顾名思义，与阶段相关。Phaser比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。</p><p>这种场景可以使用多个CyclicBarrier来实现，每个CyclicBarrier负责等待一个阶段的任务全部完成。但是使用CyclicBarrier的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而Phaser可同时解决这两个问题。</p><blockquote><p>@see <a href="http://www.jasongj.com/java/thread_communication/" target="_blank" rel="noopener">http://www.jasongj.com/java/thread_communication/</a></p></blockquote><h5 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h5><p>A ==synchronization== point at which threads can pair and swap elements within pairs. </p><p>Each thread presents some object on entry to the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html#exchange-V-" target="_blank" rel="noopener"><code>exchange</code></a> method, matches with a partner thread, and receives its partner’s object on return. </p><p>An Exchanger may be viewed as a bidirectional form of a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html" target="_blank" rel="noopener"><code>SynchronousQueue</code></a>. </p><p>Exchangers may be useful in applications such as genetic algorithms and pipeline designs.</p><p>在以上的描述中，有几个要点：</p><ul><li>此类提供对外的操作是同步的；</li><li>用于成对出现的线程之间交换数据；</li><li>可以视作双向的同步队列；</li><li>可应用于基因算法、流水线设计等场景。</li></ul><pre><code class="java">public class Exchanger&lt;V&gt; {    @sun.misc.Contended static final class Node {        int index;              // Arena index        int bound;              // Last recorded value of Exchanger.bound        int collides;           // Number of CAS failures at current bound        int hash;               // Pseudo-random for spins        Object item;            // This thread&#39;s current item        volatile Object match;  // Item provided by releasing thread        volatile Thread parked; // Set to this thread when parked, else null    }    static final class Participant extends ThreadLocal&lt;Node&gt; {        public Node initialValue() { return new Node(); }    }    public Exchanger() {        participant = new Participant();    }    public V exchange(V x) throws InterruptedException {        Object v;        Object item = (x == null) ? NULL_ITEM : x; // translate null args        if ((arena != null ||             (v = slotExchange(item, false, 0L)) == null) &amp;&amp;            ((Thread.interrupted() || // disambiguates null return              (v = arenaExchange(item, false, 0L)) == null)))            throw new InterruptedException();        return (v == NULL_ITEM) ? null : (V)v;    }    public V exchange(V x, long timeout, TimeUnit unit)        throws InterruptedException, TimeoutException {        Object v;        Object item = (x == null) ? NULL_ITEM : x;        long ns = unit.toNanos(timeout);        if ((arena != null ||             (v = slotExchange(item, true, ns)) == null) &amp;&amp;            ((Thread.interrupted() ||              (v = arenaExchange(item, true, ns)) == null)))            throw new InterruptedException();        if (v == TIMED_OUT)            throw new TimeoutException();        return (v == NULL_ITEM) ? null : (V)v;    }}</code></pre><p>有点类似于生产者/消费者 </p><blockquote><p>@see <a href="https://blog.csdn.net/coslay/article/details/45242581" target="_blank" rel="noopener">https://blog.csdn.net/coslay/article/details/45242581</a></p></blockquote><h4 id="Concurrent-Collections"><a href="#Concurrent-Collections" class="headerlink" title="Concurrent Collections"></a>Concurrent Collections</h4><p>用于并发访问的集合(List、Map、Set)</p><p>Besides Queues, this package supplies Collection implementations designed for use in multithreaded contexts: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="noopener"><code>ConcurrentHashMap</code></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener"><code>ConcurrentSkipListMap</code></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListSet.html" target="_blank" rel="noopener"><code>ConcurrentSkipListSet</code></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="noopener"><code>CopyOnWriteArrayList</code></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArraySet.html" target="_blank" rel="noopener"><code>CopyOnWriteArraySet</code></a>    </p><p>When many threads are expected to access a given collection, a <code>ConcurrentHashMap</code> is normally preferable to a synchronized <code>HashMap</code>, and a <code>ConcurrentSkipListMap</code> is normally preferable to a synchronized <code>TreeMap</code>. A <code>CopyOnWriteArrayList</code> is preferable to a synchronized <code>ArrayList</code>when the expected number of reads and traversals greatly outnumber the number of updates to a list.</p><p>与synchronized封装的类不同, Concurrent开头的支持并发访问</p><p>The “Concurrent” prefix used with some classes in this package is a shorthand indicating several differences from similar “synchronized” classes. </p><p>For example <code>java.util.Hashtable</code> and <code>Collections.synchronizedMap(new HashMap())</code> are synchronized. But <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="noopener"><code>ConcurrentHashMap</code></a> is “concurrent”. A concurrent collection is thread-safe, but not governed by a single exclusion lock. In the particular case of ConcurrentHashMap, it safely permits any number of concurrent reads as well as a tunable number of concurrent writes. </p><p>“Synchronized” classes can be useful when you need to prevent all access to a collection via a single lock, at the expense of poorer scalability. In other cases in which multiple threads are expected to access a common collection, “concurrent” versions are normally preferable. And unsynchronized collections are preferable when either collections are unshared, or are accessible only when holding other locks.</p><p>提供弱一致的遍历,而不是快速失败</p><p>Most concurrent Collection implementations (including most Queues) also differ from the usual <code>java.util</code> conventions in that their <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">Iterators</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" target="_blank" rel="noopener">Spliterators</a> provide <em>weakly consistent</em> rather than fast-fail traversal:</p><ul><li>they may proceed concurrently with other operations</li><li>they will never throw <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ConcurrentModificationException.html" target="_blank" rel="noopener"><code>ConcurrentModificationException</code></a></li><li>they are guaranteed to traverse elements as they existed upon construction exactly once, and may (but are not guaranteed to) reflect any modifications subsequent to construction.</li></ul><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><h5 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h5><h5 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h5><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><h4 id="Memory-Consistency-Properties-内存一致性"><a href="#Memory-Consistency-Properties-内存一致性" class="headerlink" title="Memory Consistency Properties (内存一致性)"></a>Memory Consistency Properties (内存一致性)</h4><p>Java语言规范第17章定义了内存操作上的<em>happens-before</em>关系，比如共享变量的读写。只有当写操作发生时(在读操作之前)，一个线程的写操作的结果才保证对另一个线程的读操作可见。同步和volatile构造，以及Thread.start()和Thread.join()方法，可以形成happens-before关系。</p><p><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5" target="_blank" rel="noopener">Chapter 17 of the Java Language Specification</a> defines the <em>happens-before</em> relation on memory operations such as reads and writes of shared variables. The results of a write by one thread are guaranteed to be visible to a read by another thread only if the write operation <em>happens-before</em>  the read operation. The synchronized  and volatile constructs, as well as the Thread.start() and Thread.join() methods, can form <em>happens-before</em>  relationships. In particular:</p><ul><li>Each action in a thread <em>happens-before</em> every action in that thread that comes later in the program’s order.</li><li>An unlock (<code>synchronized</code> block or method exit) of a monitor <em>happens-before</em> every subsequent lock (<code>synchronized</code> block or method entry) of that same monitor. And because the <em>happens-before</em> relation is transitive, all actions of a thread prior to unlocking <em>happen-before</em> all actions subsequent to any thread locking that monitor.</li><li>A write to a <code>volatile</code> field <em>happens-before</em> every subsequent read of that same field. Writes and reads of <code>volatile</code> fields have similar memory consistency effects as entering and exiting monitors, but do <em>not</em> entail mutual exclusion locking.</li><li>A call to <code>start</code> on a thread <em>happens-before</em> any action in the started thread.</li><li>All actions in a thread <em>happen-before</em> any other thread successfully returns from a <code>join</code> on that thread.</li></ul><p>在juc中,所有classes的 <em>happens-before</em> 关系</p><p>The methods of all classes in <code>java.util.concurrent</code></p><ul><li>Actions in a thread prior to placing an object into any concurrent collection <em>happen-before</em> actions subsequent to the access or removal of that element from the collection in another thread.</li><li>Actions in a thread prior to the submission of a <code>Runnable</code> to an <code>Executor</code> <em>happen-before</em> its execution begins. Similarly for <code>Callables</code> submitted to an <code>ExecutorService</code>.</li><li>Actions taken by the asynchronous computation represented by a <code>Future</code> <em>happen-before</em> actions subsequent to the retrieval of the result via <code>Future.get()</code> in another thread.</li><li>Actions prior to “releasing” synchronizer methods such as <code>Lock.unlock</code>, <code>Semaphore.release</code>, and <code>CountDownLatch.countDown</code> <em>happen-before</em> actions subsequent to a successful “acquiring” method such as <code>Lock.lock</code>, <code>Semaphore.acquire</code>,<code>Condition.await</code>, and <code>CountDownLatch.await</code> on the same synchronizer object in another thread.</li><li>For each pair of threads that successfully exchange objects via an <code>Exchanger</code>, actions prior to the <code>exchange()</code> in each thread <em>happen-before</em> those subsequent to the corresponding <code>exchange()</code> in another thread.</li><li>Actions prior to calling <code>CyclicBarrier.await</code> and <code>Phaser.awaitAdvance</code> (as well as its variants) <em>happen-before</em> actions performed by the barrier action, and actions performed by the barrier action <em>happen-before</em> actions subsequent to a successful return from the corresponding <code>await</code> in other threads.</li></ul><h3 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h3><p>​    </p><p>一个支持单变量无锁线程安全编程的类的小工具包。本质上，这个包中的类将volatile值、字段和数组元素的概念扩展到那些还提供 <em>compareAndSet</em> 的原子条件更新操作的类</p><p>A small toolkit of classes that support lock-free thread-safe programming on single variables.</p><p>In essence, the classes in this package extend the notion of <code>volatile</code>  values, fields, and array elements to those that also provide an atomic conditional update operation of the form:</p><pre><code> boolean compareAndSet(expectedValue, updateValue);</code></pre><p>This method (which varies in argument types across different classes) atomically sets a variable to the <code>updateValue</code> if it currently holds the <code>expectedValue</code>, reporting <code>true</code> on success. </p><p>The classes in this package also contain methods to get and unconditionally set values, as well as a weaker conditional atomic update operation <code>weakCompareAndSet</code> described below.</p><p>The memory effects for accesses and updates of atomics generally follow the rules for volatiles, as stated in <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4" target="_blank" rel="noopener">The Java Language Specification (17.4 Memory Model)</a>:</p><ul><li><code>get</code> has the memory effects of reading a <code>volatile</code> variable.</li><li><code>set</code> has the memory effects of writing (assigning) a <code>volatile</code> variable.</li><li><code>lazySet</code> has the memory effects of writing (assigning) a <code>volatile</code> variable except that it permits reorderings with subsequent (but not previous) memory actions that do not themselves impose reordering constraints with ordinary non-<code>volatile</code> writes. Among other usage contexts, <code>lazySet</code> may apply when nulling out, for the sake of garbage collection, a reference that is never accessed again.</li><li><code>weakCompareAndSet</code> atomically reads and conditionally writes a variable but does <em>not</em> create any happens-before orderings, so provides no guarantees with respect to previous or subsequent reads and writes of any variables other than the target of the <code>weakCompareAndSet</code>.</li><li><code>compareAndSet</code> and all other read-and-update operations such as <code>getAndIncrement</code> have the memory effects of both reading and writing <code>volatile</code> variables.</li></ul><h4 id="Atomic-Values"><a href="#Atomic-Values" class="headerlink" title="Atomic Values"></a>Atomic Values</h4><p>Instances of classes <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicBoolean.html" target="_blank" rel="noopener"><code>AtomicBoolean</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" target="_blank" rel="noopener"><code>AtomicInteger</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html" target="_blank" rel="noopener"><code>AtomicLong</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html" target="_blank" rel="noopener"><code>AtomicReference</code></a> each provide access and updates to a single variable of the corresponding type. Each class also provides appropriate utility methods for that type. For example, classes <code>AtomicLong</code> and <code>AtomicInteger</code> provide atomic increment methods. </p><pre><code class="java">public class AtomicInteger extends Number implements java.io.Serializable {    private volatile int value;    /**     * Creates a new AtomicInteger with the given initial value.     *     * @param initialValue the initial value     */    public AtomicInteger(int initialValue) {        value = initialValue;    }    /**     * Creates a new AtomicInteger with initial value {@code 0}.     */    public AtomicInteger() {    }}</code></pre><h4 id="Atomic-Fields"><a href="#Atomic-Fields" class="headerlink" title="Atomic Fields"></a>Atomic Fields</h4><p>In addition to classes representing single values, this package contains <em>Updater</em> classes that can be used to obtain <code>compareAndSet</code> operations on any selected <code>volatile</code> field of any selected class. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html" target="_blank" rel="noopener"><code>AtomicReferenceFieldUpdater</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html" target="_blank" rel="noopener"><code>AtomicIntegerFieldUpdater</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLongFieldUpdater.html" target="_blank" rel="noopener"><code>AtomicLongFieldUpdater</code></a> are reflection-based utilities that provide access to the associated field types. These are mainly of use in atomic data structures in which several <code>volatile</code> fields of the same node (for example, the links of a tree node) are independently subject to atomic updates. These classes enable greater flexibility in how and when to use atomic updates, at the expense of more awkward reflection-based setup, less convenient usage, and weaker guarantees.</p><h4 id="Atomic-Arrays"><a href="#Atomic-Arrays" class="headerlink" title="Atomic Arrays"></a>Atomic Arrays</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicIntegerArray.html" target="_blank" rel="noopener"><code>AtomicIntegerArray</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLongArray.html" target="_blank" rel="noopener"><code>AtomicLongArray</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceArray.html" target="_blank" rel="noopener"><code>AtomicReferenceArray</code></a> classes further extend atomic operation support to arrays of these types. These classes are also notable in providing <code>volatile</code> access semantics for their array elements, which is not supported for ordinary arrays.</p><h4 id="Class-Summary"><a href="#Class-Summary" class="headerlink" title="Class Summary"></a>Class Summary</h4><table><thead><tr><th style="text-align:left">Class</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicBoolean.html" target="_blank" rel="noopener">AtomicBoolean</a></td><td style="text-align:left">A <code>boolean</code> value that may be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" target="_blank" rel="noopener">AtomicInteger</a></td><td style="text-align:left">An <code>int</code> value that may be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicIntegerArray.html" target="_blank" rel="noopener">AtomicIntegerArray</a></td><td style="text-align:left">An <code>int</code> array in which elements may be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html" target="_blank" rel="noopener">AtomicIntegerFieldUpdater</a><t></t></td><td style="text-align:left">A reflection-based utility that enables atomic updates to designated <code>volatile int</code> fields of designated classes.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html" target="_blank" rel="noopener">AtomicLong</a></td><td style="text-align:left">A <code>long</code> value that may be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLongArray.html" target="_blank" rel="noopener">AtomicLongArray</a></td><td style="text-align:left">A <code>long</code> array in which elements may be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLongFieldUpdater.html" target="_blank" rel="noopener">AtomicLongFieldUpdater</a><t></t></td><td style="text-align:left">A reflection-based utility that enables atomic updates to designated <code>volatile long</code> fields of designated classes.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicMarkableReference.html" target="_blank" rel="noopener">AtomicMarkableReference</a><v></v></td><td style="text-align:left">An <code>AtomicMarkableReference</code> maintains an object reference along with a mark bit, that can be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html" target="_blank" rel="noopener">AtomicReference</a><v></v></td><td style="text-align:left">An object reference that may be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceArray.html" target="_blank" rel="noopener">AtomicReferenceArray</a><e></e></td><td style="text-align:left">An array of object references in which elements may be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html" target="_blank" rel="noopener">AtomicReferenceFieldUpdater</a>&lt;T,V&gt;</td><td style="text-align:left">A reflection-based utility that enables atomic updates to designated <code>volatile</code> reference fields of designated classes.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicStampedReference.html" target="_blank" rel="noopener">AtomicStampedReference</a><v></v></td><td style="text-align:left">An <code>AtomicStampedReference</code> maintains an object reference along with an integer “stamp”, that can be updated atomically.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/DoubleAccumulator.html" target="_blank" rel="noopener">DoubleAccumulator</a></td><td style="text-align:left">One or more variables that together maintain a running <code>double</code> value updated using a supplied function.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/DoubleAdder.html" target="_blank" rel="noopener">DoubleAdder</a></td><td style="text-align:left">One or more variables that together maintain an initially zero <code>double</code> sum.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html" target="_blank" rel="noopener">LongAccumulator</a></td><td style="text-align:left">One or more variables that together maintain a running <code>long</code> value updated using a supplied function.</td></tr><tr><td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html" target="_blank" rel="noopener">LongAdder</a></td><td style="text-align:left">One or more variables that together maintain an initially zero <code>long</code> sum.</td></tr></tbody></table><h4 id="Designed"><a href="#Designed" class="headerlink" title="Designed"></a>Designed</h4><p>原子类主要设计为用于实现非阻塞数据结构和相关基础结构类的构建块。该<code>compareAndSet</code>方法不是锁定的一般替代方法。仅当对象的关键更新仅限于<em>单个</em>变量时，它才适用。</p><p>原子类不是通用替换 <code>java.lang.Integer</code>和相关类。他们<em>没有</em> 定义方法，如<code>equals</code>，<code>hashCode</code>和 <code>compareTo</code>。（因为预期原子变量会发生变异，所以它们对于散列表键的选择很差。）此外，只为那些在预期应用程序中常用的类型提供类。例如，没有用于表示的原子类<code>byte</code>。在您想要这样做的不常见的情况下，您可以使用a <code>AtomicInteger</code>来保存 <code>byte</code>值，并适当地进行投射。您还可以使用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#floatToRawIntBits-float-" target="_blank" rel="noopener"><code>Float.floatToRawIntBits(float)</code></a>和 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#intBitsToFloat-int-" target="_blank" rel="noopener"><code>Float.intBitsToFloat(int)</code></a>转换使用浮点数 ，并使用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#doubleToRawLongBits-double-" target="_blank" rel="noopener"><code>Double.doubleToRawLongBits(double)</code></a>和 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#longBitsToDouble-long-" target="_blank" rel="noopener"><code>Double.longBitsToDouble(long)</code></a>转换加倍。</p><p>原文  : </p><blockquote><p>Atomic classes are designed primarily as building blocks for implementing non-blocking data structures and related infrastructure classes. The <code>compareAndSet</code> method is not a general replacement for locking. It applies only when critical updates for an object are confined to a <em>single</em> variable.</p><p>Atomic classes are not general purpose replacements for <code>java.lang.Integer</code> and related classes. They do <em>not</em> define methods such as <code>equals</code>, <code>hashCode</code> and <code>compareTo</code>. (Because atomic variables are expected to be mutated, they are poor choices for hash table keys.) Additionally, classes are provided only for those types that are commonly useful in intended applications. For example, there is no atomic class for representing <code>byte</code>. In those infrequent cases where you would like to do so, you can use an <code>AtomicInteger</code>to hold <code>byte</code> values, and cast appropriately. You can also hold floats using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#floatToRawIntBits-float-" target="_blank" rel="noopener"><code>Float.floatToRawIntBits(float)</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#intBitsToFloat-int-" target="_blank" rel="noopener"><code>Float.intBitsToFloat(int)</code></a> conversions, and doubles using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#doubleToRawLongBits-double-" target="_blank" rel="noopener"><code>Double.doubleToRawLongBits(double)</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#longBitsToDouble-long-" target="_blank" rel="noopener"><code>Double.longBitsToDouble(long)</code></a>conversions.</p></blockquote><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html</a></strong></p><h3 id="java-util-concurrent-locks"><a href="#java-util-concurrent-locks" class="headerlink" title="java.util.concurrent.locks"></a>java.util.concurrent.locks</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g62ox5893vj32f50u0q7l.jpg" alt="image-20190817150757762"></p><p>注意ConditionObject (不知道为啥没有显示为AbstractQueuedSynchronizer inner class)</p><p>接口和类提供了一个框架，用于锁定和等待,与内置同步和监视器不同的条件。该框架允许在使用锁和条件方面具有更大的灵活性，但代价是语法更加笨拙。</p><p>Interfaces and classes providing a framework for locking and waiting for conditions that is distinct from built-in synchronization and monitors. The framework permits much greater flexibility in the use of locks and conditions, at the expense of more awkward syntax.</p><h4 id="Locks-锁"><a href="#Locks-锁" class="headerlink" title="Locks(锁)"></a>Locks(锁)</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html" target="_blank" rel="noopener"><code>Lock</code></a> interface supports locking disciplines that differ in semantics (reentrant, fair, etc), and that can be used in non-block-structured contexts including hand-over-hand and lock reordering algorithms. The main implementation is <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html" target="_blank" rel="noopener"><code>ReentrantLock</code></a>.</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html" target="_blank" rel="noopener"><code>ReadWriteLock</code></a> interface similarly defines locks that may be shared among readers but are exclusive to writers. Only a single implementation, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_blank" rel="noopener"><code>ReentrantReadWriteLock</code></a>, is provided, since it covers most standard usage contexts. But programmers may create their own implementations to cover nonstandard requirements.</p><p>Lock接口支持语义不同的锁定规则(可重入、公平等)，并且可以在非块结构上下文中使用，包括手动和锁重排序算法。主要实现是ReentrantLock。</p><p>ReadWriteLock接口也类似地定义了锁，这些锁可以在readers之间共享，但只能由writers使用。只提供了一个实现ReentrantReadWriteLock，因为它涵盖了大多数标准使用上下文。但是程序员可以创建他们自己的实现来满足非标准需求。</p><h5 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h5><h6 id="Lock与synchronized的异同"><a href="#Lock与synchronized的异同" class="headerlink" title="Lock与synchronized的异同"></a>Lock与synchronized的异同</h6><ul><li>内存语义相同</li></ul><p><em>Memory Synchronization</em></p><p>All <code>Lock</code> implementations <em>must</em> enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4" target="_blank" rel="noopener">The Java Language Specification (17.4 Memory Model)</a>:</p><ul><li>A successful <code>lock</code> operation has the same memory synchronization effects as a successful <em>Lock</em> action.</li><li>A successful <code>unlock</code> operation has the same memory synchronization effects as a successful <em>Unlock</em> action.</li></ul><p>Unsuccessful locking and unlocking operations, and reentrant locking/unlocking operations, do not require any memory synchronization effects.</p><ul><li><p>synchronization是关键字(可重入,非公平锁,锁的是对象Object), Lock是接口</p></li><li><p>synchronization 使用简单,无需手动释放锁,避免错误</p><p>  When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.</p></li><li><p>Lock 更加灵活,  支持非阻塞获取 ,可中断获取,和可超时获取.</p><p>  <code>Lock</code> implementations provide additional functionality over the use of <code>synchronized</code> methods and statements by providing a non-blocking attempt to acquire a lock (<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#tryLock--" target="_blank" rel="noopener"><code>tryLock()</code></a>), an attempt to acquire the lock that can be interrupted (<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#lockInterruptibly--" target="_blank" rel="noopener"><code>lockInterruptibly()</code></a>, and an attempt to acquire the lock that can timeout (<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#tryLock-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>tryLock(long, TimeUnit)</code></a>).</p></li></ul><h6 id="Implementation-Considerations"><a href="#Implementation-Considerations" class="headerlink" title="Implementation Considerations"></a>Implementation Considerations</h6><p>三种形式的锁获取(可中断、不可中断和定时)在性能特征、顺序保证或其他实现质量方面可能有所不同。</p><p>此外，中断正在进行的锁获取的功能可能在给定的锁类中不可用。因此，实现不需要为所有三种形式的锁获取定义完全相同的保证或语义，也不需要支持中断正在进行的锁获取。</p><p>需要一个实现来清楚地记录每种锁定方法提供的语义和保证。它还必须遵守这个接口中定义的中断语义，只要支持锁获取中断:要么完全支持，要么只支持方法入口。</p><p>由于中断通常意味着取消，并且对中断的检查通常不频繁，因此实现更倾向于响应中断而不是正常的方法返回。即使可以显示在另一个操作之后发生的中断可能已经解除了线程阻塞，这也是正确的。实现应该记录这种行为。</p><blockquote><p>The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. </p><p>Further, the ability to interrupt the <em>ongoing</em> acquisition of a lock may not be available in a given <code>Lock</code> class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. </p><p>An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.</p><p>As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action may have unblocked the thread. An implementation should document this behavior.</p></blockquote><pre><code class="java">public interface Lock {    void lock();    void lockInterruptibly() throws InterruptedException;    boolean tryLock();    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;    void unlock();    Condition newCondition();}</code></pre><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>Lock的标准实现, 一种可重入互斥锁，具有与使用同步方法和语句访问的隐式监视器锁相同的基本行为和语义，但具有扩展功能。(获取等待队列,当前线程是否获得锁等监控,见 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractOwnableSynchronizer.html" target="_blank" rel="noopener"><code>AbstractOwnableSynchronizer</code></a>)</p><p>ReentrantLock归最后一个成功锁定的线程所有，但还没有解锁它。当锁不属于其他线程时，调用锁的线程将返回并成功获取锁。如果当前线程已经拥有锁，该方法将立即返回。可以使用isHeldByCurrentThread()和getHoldCount()方法检查这一点。</p><blockquote><p>A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.</p><p>A ReentrantLock is owned by the thread last successfully locking, but not yet unlocking it. A thread invoking lock will return, successfully acquiring the lock, when the lock is not owned by another thread. The method will return immediately if the current thread already owns the lock. This can be checked using methods isHeldByCurrentThread(), and getHoldCount().</p></blockquote><pre><code class="java">public class ReentrantLock implements Lock, java.io.Serializable {    private final Sync sync;    abstract static class Sync extends AbstractQueuedSynchronizer {        }        static final class NonfairSync extends Sync{}        static final class FairSync extends Sync{}        public ReentrantLock() {        sync = new NonfairSync();    }    public ReentrantLock(boolean fair) {        sync = fair ? new FairSync() : new NonfairSync();    }    public int getHoldCount() {        return sync.getHoldCount();    }    protected Thread getOwner() {        return sync.getOwner();    }    public boolean hasWaiters(Condition condition) {        if (condition == null)            throw new NullPointerException();        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))            throw new IllegalArgumentException(&quot;not owner&quot;);        return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);    }    /**     * 获取队列的监控,省略了获取waitting的      */     protected Collection&lt;Thread&gt; getQueuedThreads() {        return sync.getQueuedThreads();    }    public final int getQueueLength() {        return sync.getQueueLength();    }    public final boolean hasQueuedThread(Thread thread) {        return sync.isQueued(thread);    }    public final int getQueueLength() {        return sync.getQueueLength();    }    protected Collection&lt;Thread&gt; getQueuedThreads() {        return sync.getQueuedThreads();    }    ...}</code></pre><h5 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h5><p>读写锁维护一对关联的锁，一个用于只读操作，另一个用于写操作。读锁可以由多个读线程同时持有，只要没有写线程。写锁是独占的。</p><p>A <code>ReadWriteLock</code> maintains a pair of associated <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html" target="_blank" rel="noopener"><code>locks</code></a>, one for read-only operations and one for writing. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html#readLock--" target="_blank" rel="noopener"><code>read lock</code></a> may be held simultaneously by multiple reader threads, so long as there are no writers. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html#writeLock--" target="_blank" rel="noopener"><code>write lock</code></a> is exclusive.</p><pre><code class="java">public interface ReadWriteLock {    /**     * Returns the lock used for reading.     *     * @return the lock used for reading     */    Lock readLock();    /**     * Returns the lock used for writing.     *     * @return the lock used for writing     */    Lock writeLock();}</code></pre><h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><p>可重入读写锁, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html" target="_blank" rel="noopener"><code>ReadWriteLock</code></a> 实现,类似<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html" target="_blank" rel="noopener"><code>ReentrantLock</code></a>.</p><p>This class has the following properties:</p><ul><li><strong>Acquisition order</strong>  请求顺序(公平、非公平)</li><li><strong>Reentrancy</strong>  可重入</li><li><strong>Lock downgrading</strong> 锁降级<ul><li>可重入性还允许从写锁降级为读锁，方法是获取写锁，然后是读锁，然后释放写锁。</li></ul></li><li><strong>Interruption of lock acquisition</strong> 可中断锁</li><li><strong>Condition support</strong> </li><li><strong>Instrumentation</strong>  监控</li></ul><pre><code class="java">/* * This lock supports a maximum of 65535 recursive write locks and 65535 read locks. */public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {    /** Inner class providing readlock */    private final ReentrantReadWriteLock.ReadLock readerLock;    /** Inner class providing writelock */    private final ReentrantReadWriteLock.WriteLock writerLock;    /** Performs all synchronization mechanics */    final Sync sync;    /**     * Creates a new {@code ReentrantReadWriteLock} with     * default (nonfair) ordering properties.     */    public ReentrantReadWriteLock() {        this(false);    }    /**     * Creates a new {@code ReentrantReadWriteLock} with     * the given fairness policy.     *     * @param fair {@code true} if this lock should use a fair ordering policy     */    public ReentrantReadWriteLock(boolean fair) {        sync = fair ? new FairSync() : new NonfairSync();        readerLock = new ReadLock(this);        writerLock = new WriteLock(this);    }                /*                 * ReadWriteLock impl                 */    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }    /**     * Synchronization implementation for ReentrantReadWriteLock.     * Subclassed into fair and nonfair versions.     */    abstract static class Sync extends AbstractQueuedSynchronizer {        static final int SHARED_SHIFT   = 16;        static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);        static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;        static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;       ...    }    static final long getThreadId(Thread thread) {        return UNSAFE.getLongVolatile(thread, TID_OFFSET);    }    ...    public static class ReadLock implements Lock, java.io.Serializable {       ...    }    public static class WriteLock implements Lock, java.io.Serializable {       ...    }}</code></pre><h4 id="Conditions-监视器"><a href="#Conditions-监视器" class="headerlink" title="Conditions(监视器)"></a>Conditions(监视器)</h4><p>条件将对象监视方法(wait、notify和notifyAll) 分解为不同的对象，通过将它们与任意锁实现相结合，从而实现每个对象具有多个等待集的效果。锁替换同步方法和语句的使用，条件替换对象监视器方法的使用。</p><p><code>Condition</code> factors out the <code>Object</code> monitor methods (<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--" target="_blank" rel="noopener"><code>wait</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--" target="_blank" rel="noopener"><code>notify</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--" target="_blank" rel="noopener"><code>notifyAll</code></a>) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html" target="_blank" rel="noopener"><code>Lock</code></a> implementations. </p><p>Where a <code>Lock</code> replaces the use of <code>synchronized</code> methods and statements, </p><p>a <code>Condition</code> replaces the use of the Object monitor methods.</p><pre><code class="java">public interface Condition {    void await() throws InterruptedException;    /*     * Causes the current thread to wait until it is signalled.     */    void awaitUninterruptibly();    long awaitNanos(long nanosTimeout) throws InterruptedException;    boolean await(long time, TimeUnit unit) throws InterruptedException;    boolean awaitUntil(Date deadline) throws InterruptedException;    void signal();    void signalAll();}</code></pre><p>主要实现 : java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject</p><h4 id="AbstractQueuedSynchronizers-阻塞队列"><a href="#AbstractQueuedSynchronizers-阻塞队列" class="headerlink" title="AbstractQueuedSynchronizers(阻塞队列)"></a>AbstractQueuedSynchronizers(阻塞队列)</h4><h5 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h5><p>AbstractQueuedSynchronizer类是一个有用的超类，用于定义依赖于排队阻塞线程的锁和其他同步器。</p><h6 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h6><p>To use this class as the basis of a synchronizer, redefine the following methods, as applicable, by inspecting and/or modifying the synchronization state using <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState--" target="_blank" rel="noopener"><code>getState()</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState-int-" target="_blank" rel="noopener"><code>setState(int)</code></a> and/or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState-int-int-" target="_blank" rel="noopener"><code>compareAndSetState(int, int)</code></a>:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire-int-" target="_blank" rel="noopener"><code>tryAcquire(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease-int-" target="_blank" rel="noopener"><code>tryRelease(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared-int-" target="_blank" rel="noopener"><code>tryAcquireShared(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared-int-" target="_blank" rel="noopener"><code>tryReleaseShared(int)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively--" target="_blank" rel="noopener"><code>isHeldExclusively()</code></a></li></ul><p>Each of these methods by default throws <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html" target="_blank" rel="noopener"><code>UnsupportedOperationException</code></a><em>only</em><code>final</code></p><p>You may also find the inherited methods from <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractOwnableSynchronizer.html" target="_blank" rel="noopener"><code>AbstractOwnableSynchronizer</code></a> useful to keep track of the thread owning an exclusive synchronizer. You are encouraged to use them – this enables monitoring and diagnostic tools to assist users in determining which threads hold locks.</p><pre><code class="java">public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer    implements java.io.Serializable {    public class ConditionObject implements Condition, java.io.Serializable {        /** First node of condition queue. */        private transient Node firstWaiter;        /** Last node of condition queue. */        private transient Node lastWaiter;                    /**         * Adds a new waiter to wait queue.         * @return its new wait node         */        private Node addConditionWaiter() {            Node t = lastWaiter;            // If lastWaiter is cancelled, clean out.            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {                unlinkCancelledWaiters();                t = lastWaiter;            }            Node node = new Node(Thread.currentThread(), Node.CONDITION);            if (t == null)                firstWaiter = node;            else                t.nextWaiter = node;            lastWaiter = node;            return node;        }                    }    static final class Node {        /** Marker to indicate a node is waiting in shared mode */        static final Node SHARED = new Node();        /** Marker to indicate a node is waiting in exclusive mode */        static final Node EXCLUSIVE = null;        /** waitStatus value to indicate thread has cancelled */        static final int CANCELLED =  1;        /** waitStatus value to indicate successor&#39;s thread needs unparking */        static final int SIGNAL    = -1;        /** waitStatus value to indicate thread is waiting on condition */        static final int CONDITION = -2;        /**         * waitStatus value to indicate the next acquireShared should         * unconditionally propagate         */        static final int PROPAGATE = -3;        volatile int waitStatus;        volatile Node prev;        volatile Node next;        volatile Thread thread;        Node nextWaiter;        final boolean isShared() {            return nextWaiter == SHARED;        }    }        public final void acquire(int arg) {        if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))            selfInterrupt();    }            public final void acquireShared(int arg) {        if (tryAcquireShared(arg) &lt; 0)            doAcquireShared(arg);    }    public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)            throws InterruptedException {        if (Thread.interrupted())            throw new InterruptedException();        return tryAcquireShared(arg) &gt;= 0 ||            doAcquireSharedNanos(arg, nanosTimeout);    }        public final boolean release(int arg) {        if (tryRelease(arg)) {            Node h = head;            if (h != null &amp;&amp; h.waitStatus != 0)                unparkSuccessor(h);            return true;        }        return false;    }    public final boolean releaseShared(int arg) {        if (tryReleaseShared(arg)) {            doReleaseShared();            return true;        }        return false;    }   }</code></pre><p>这个类比较关键, 复杂度太高了,涉及的细节太多,另单独分析</p><h5 id="AbstractQueuedLongSynchronizer"><a href="#AbstractQueuedLongSynchronizer" class="headerlink" title="AbstractQueuedLongSynchronizer"></a>AbstractQueuedLongSynchronizer</h5><p>AbstractQueuedLongSynchronizer类提供了相同的功能，但是扩展了对64位同步状态的支持。</p><h5 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h5><p>它们都扩展了AbstractOwnableSynchronizer类，这是一个简单的类，帮助记录当前持有独占同步的线程。</p><pre><code class="java">public abstract class AbstractOwnableSynchronizer    implements java.io.Serializable {    /** Use serial ID even though all fields transient. */    private static final long serialVersionUID = 3737899427754241961L;    /**     * Empty constructor for use by subclasses.     */    protected AbstractOwnableSynchronizer() { }    /**     * The current owner of exclusive mode synchronization.     */    private transient Thread exclusiveOwnerThread;    /**     * Sets the thread that currently owns exclusive access.     * A {@code null} argument indicates that no thread owns access.     * This method does not otherwise impose any synchronization or     * {@code volatile} field accesses.     * @param thread the owner thread     */    protected final void setExclusiveOwnerThread(Thread thread) {        exclusiveOwnerThread = thread;    }    /**     * Returns the thread last set by {@code setExclusiveOwnerThread},     * or {@code null} if never set.  This method does not otherwise     * impose any synchronization or {@code volatile} field accesses.     * @return the owner thread     */    protected final Thread getExclusiveOwnerThread() {        return exclusiveOwnerThread;    }}</code></pre><h4 id="LockSupports"><a href="#LockSupports" class="headerlink" title="LockSupports"></a>LockSupports</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html" target="_blank" rel="noopener"><code>LockSupport</code></a> class provides lower-level blocking and unblocking support that is useful for those developers implementing their own customized lock classes.</p><p>LockSupport类提供了较低级别的阻塞和解除阻塞支持，这对于实现自定义锁类的开发人员非常有用。</p><h3 id="Record📝"><a href="#Record📝" class="headerlink" title="Record📝"></a>Record📝</h3><ul><li><p>TimeUnit 为啥不都抽象方法?而是有些需要实现,有些需要抽象?</p></li><li><p>java.util.concurrent.Semaphore.Sync#nonfairTryAcquireShared 和java.util.concurrent.Semaphore.Sync#reducePermits 为啥需要重复实现?</p></li><li><p>java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock#newCondition ?</p><pre><code>  /**   * Throws {@code UnsupportedOperationException} because   * {@code ReadLocks} do not support conditions.   *   * @throws UnsupportedOperationException always   */</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_The Collections Framework</title>
      <link href="/2019/07/29/JDK-The-Collections-Framework/"/>
      <url>/2019/07/29/JDK-The-Collections-Framework/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5gqxyicllj30qo0f0gn7.jpg" alt="img"></p><a id="more"></a><h2 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h2><p>​    </p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>最近有个二货在线上使用Collections#sort()的时候报了个错, java.lang.IllegalArgumentException: Comparison method violates its general contract!  运行的JDK环境是1.7</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5grfa3sfgj30vq0s60v2.jpg" alt="image-20190729155205469"></p><p> 本着博爱的精神,看了看之前也遇到类似的问题.就决定总结下,其实这个是JDK1.6到1.7的兼容问题.在<a href="https://www.oracle.com/technetwork/java/javase/compatibility-417013.html#incompatibilities" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/compatibility-417013.html#incompatibilities</a> 中可以发现</p><pre><code>Area: API: UtilitiesSynopsis: Updated sort behavior for Arrays and Collections may throw an IllegalArgumentExceptionDescription: The sorting algorithm used by java.util.Arrays.sort and (indirectly) by java.util.Collections.sort has been replaced. The new sort implementation may throw an IllegalArgumentException if it detects a Comparable that violates the Comparable contract. The previous implementation silently ignored such a situation.If the previous behavior is desired, you can use the new system property, java.util.Arrays.useLegacyMergeSort, to restore previous mergesort behavior.Nature of Incompatibility: behavioralRFE: 6804124</code></pre><p>​    如果违法了比较的约束新的排序算法也许会抛出llegalArgumentException异常。JDK6中的实现则忽略了这种情况</p><h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>实现Comparable接口后，要满足一下三个特性：</p><ul><li>自反性：x,y 的比较结果和 y,x 的比较结果相反。 sgn(compare(x, y)) == -sgn(compare(y, x))</li><li>传递性：x&gt;y, y&gt;z, 则 x&gt;z。((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0</li><li>对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。    compare(x, y) == 0 implies that sgn(compare(x, z)) == sgn(compare(y, z)) for all z</li></ul><p>​    开头的那个小朋友实现类似如下,明显没有满足自反性</p><pre><code>return x &gt; y ? 1 : -1;</code></pre><p>当x == y时，sgn(compare(x, y))  = -1，-sgn(compare(y, x)) = 1，这违背了sgn(compare(x, y)) == -sgn(compare(y, x))约束，所以在JDK7中抛出了异常。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>这里贴个可以重现该错误的代码</p><pre><code class="java">import java.util.Arrays;import java.util.List;import java.util.function.Consumer;/** * * Collections sort 要满足自反性否则会有概率出错，在1.7中会有问题 * @author zhengyumin * @create 2019-07-18 10:24 */public class CollectionSort {    public static void main(String[] args) {        List&lt;Integer&gt; list = Arrays.asList(0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 2, 1, 0, 0, 0, 2, 30, 0, 3);        list.sort((o1, o2) -&gt; o1 &gt; o2 ? 1 : -1);        list.stream().forEach((Consumer) o -&gt; System.out.println(o));    }}</code></pre><p>上面描述的只是集合框架中的一个问题. 好了,回到我们今天的主题The Collections Framework.</p><p>相关资料可以参考:<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html</a></p><h2 id="The-Collections-Framework"><a href="#The-Collections-Framework" class="headerlink" title="The Collections Framework"></a>The Collections Framework</h2><h3 id="API-Enhancements-各版本API增强变化"><a href="#API-Enhancements-各版本API增强变化" class="headerlink" title="API Enhancements(各版本API增强变化)"></a>API Enhancements(各版本API增强变化)</h3><ul><li><p><strong>API Enhancements in Java SE 8</strong> - An annotated list of API changes between release 7 and 8.</p><ul><li>Support for Lambda Expressions, Streams, and Aggregate Operations</li><li>Performance Improvement for HashMaps with Key Collisions</li></ul></li><li><p><strong>API Enhancements in Java SE 7</strong> - An annotated list of API changes between release 6 and 7.</p><ul><li>New Interface, TransferQueue</li><li>Improved Hash Function</li></ul></li><li><p><strong>API Enhancements in Java SE 6</strong> - An annotated list of API changes between release 5.0 and 6.</p><ul><li>These new collection interfaces are provided:<ul><li><code>Deque</code></li><li><code>BlockingDeque</code></li><li><code>NavigableSet</code> </li><li><code>NavigableMap</code> </li><li><code>ConcurrentNavigableMap</code></li></ul></li></ul></li><li><p><strong>API Enhancements in J2SE 5.0</strong> - An annotated list of API changes between release 1.4 and 5.0.</p><ul><li>Three new collection interfaces are provided:<ul><li><code>Queue</code> </li><li><code>BlockingQueue</code> </li><li><code>ConcurrentMap</code></li></ul></li><li>Three new generic algorithms and one comparator converter were added to the <code>Collections</code> utility class:<ul><li><code>frequency(Collection&lt;?&gt; c, Object o)</code> </li><li><code>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code> </li><li><code>addAll(Collection&lt;? super T&gt; c, T... a)</code> </li><li><code>Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp)</code> </li></ul></li></ul></li><li><p><strong>API Enhancements in J2SDK 1.4</strong> - An annotated list of API changes between release 1.3 and 1.4.</p><ul><li><p>The <code>Collections</code> utility class has several new methods:</p><ul><li><code>rotate(List list, int distance)</code> </li><li><code>replaceAll(List list, Object oldVal, Object newVal)</code></li><li><code>indexOfSubList(List source, List target)</code> </li><li><code>lastIndexOfSubList(List source, List target)</code></li><li><code>swap(List list, int i, int j)</code> </li><li><code>list(Enumeration e)</code> </li></ul></li><li><p>New interface <code>RandomAccess</code> is a marker interface that allows <code>List</code> implementations to indicate that they support fast (generally constant time) random access.</p></li><li><p>New class <code>LinkedHashMap</code> provides an insertion-ordered <code>Map</code> implementation that runs nearly as fast as <code>HashMap</code>. </p></li><li><p>New class <code>IdentityHashMap</code> is an identity-based Map implementation based on a hash table. </p></li></ul></li></ul><h3 id="Introduction-to-Collections-集合介绍"><a href="#Introduction-to-Collections-集合介绍" class="headerlink" title="Introduction to Collections (集合介绍)"></a>Introduction to Collections (集合介绍)</h3><p>​    为什么需要集合框架?集合框架的组成?</p><h4 id="What-Is-a-Collections-Framework"><a href="#What-Is-a-Collections-Framework" class="headerlink" title="What Is a Collections Framework?"></a>What Is a Collections Framework?</h4><p>A <em>collections framework</em> is a unified architecture for representing and manipulating collections. All collections frameworks contain the following:</p><ul><li><strong>Interfaces:</strong> These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.</li><li><strong>Implementations:</strong> These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.</li><li><strong>Algorithms:</strong> These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be <em>polymorphic</em>: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.</li></ul><p>所有集合框架都包含如下: 接口、实现、算法</p><p>more details , The collections framework consists of:</p><ul><li><strong>Collection interfaces</strong> (接口). Represent different types of collections, such as sets, lists, and maps. These interfaces form the basis of the framework.<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="noopener"><strong>Collection</strong></a> - A group of objects. No assumptions are made about the order of the collection (if any) or whether it can contain duplicate elements.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html" target="_blank" rel="noopener"><strong>Set</strong></a> - The familiar set abstraction. No duplicate elements permitted. May or may not be ordered. Extends the <code>Collection</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener"><strong>List</strong></a> - Ordered collection, also known as a <em>sequence</em>. Duplicates are generally permitted. Allows positional access. Extends the <code>Collection</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank" rel="noopener"><strong>Queue</strong></a> - A collection designed for holding elements before processing. Besides basic <code>Collection</code> operations, queues provide additional insertion, extraction, and inspection operations.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html" target="_blank" rel="noopener"><strong>Deque</strong></a> - A <em>double ended queue</em>, supporting element insertion and removal at both ends. Extends the <code>Queue</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" target="_blank" rel="noopener"><strong>Map</strong></a> - A mapping from keys to values. Each key can map to one value.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html" target="_blank" rel="noopener"><strong>SortedSet</strong></a> - A set whose elements are automatically sorted, either in their <em>natural ordering</em> (see the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener"><code>Comparable</code></a> interface) or by a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"><code>Comparator</code></a> object provided when a <code>SortedSet</code> instance is created. Extends the <code>Set</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html" target="_blank" rel="noopener"><strong>SortedMap</strong></a> - A map whose mappings are automatically sorted by key, either using the <em>natural ordering</em> of the keys or by a comparator provided when a <code>SortedMap</code> instance is created. Extends the <code>Map</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/NavigableSet.html" target="_blank" rel="noopener"><strong>NavigableSet</strong></a> - A <code>SortedSet</code> extended with navigation methods reporting closest matches for given search targets. A <code>NavigableSet</code> may be accessed and traversed in either ascending or descending order.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html" target="_blank" rel="noopener"><strong>NavigableMap</strong></a> - A <code>SortedMap</code> extended with navigation methods returning the closest matches for given search targets. A <code>NavigableMap</code> can be accessed and traversed in either ascending or descending key order.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html" target="_blank" rel="noopener"><strong>BlockingQueue</strong></a> - A <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and that wait for space to become available in the queue when storing an element. (This interface is part of the <code>java.util.concurrent</code> package.)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TransferQueue.html" target="_blank" rel="noopener"><strong>TransferQueue</strong></a> - A <code>BlockingQueue</code> in which producers can wait for consumers to receive elements. (This interface is part of the <code>java.util.concurrent</code> package.)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingDeque.html" target="_blank" rel="noopener"><strong>BlockingDeque</strong></a> - A <code>Deque</code> with operations that wait for the deque to become nonempty when retrieving an element and wait for space to become available in the deque when storing an element. Extends both the <code>Deque</code> and <code>BlockingQueue</code> interfaces. (This interface is part of the <code>java.util.concurrent</code> package.)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html" target="_blank" rel="noopener"><strong>ConcurrentMap</strong></a> - A <code>Map</code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods. (This interface is part of the <code>java.util.concurrent</code> package.)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentNavigableMap.html" target="_blank" rel="noopener"><strong>ConcurrentNavigableMap</strong></a> - A <code>ConcurrentMap</code> that is also a <code>NavigableMap</code>.</li></ul></li><li><strong>General-purpose implementations</strong> (通常实现). Primary implementations of the collection interfaces.<ul><li><strong>HashSet</strong> - Hash table implementation of the <code>Set</code> interface. The best all-around implementation of the <code>Set</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html" target="_blank" rel="noopener"><strong>TreeSet</strong></a> - Red-black tree implementation of the <code>NavigableSet</code> interface.</li><li><strong>LinkedHashSet</strong> - Hash table and linked list implementation of the <code>Set</code> interface. An insertion-ordered <code>Set</code> implementation that runs nearly as fast as <code>HashSet</code>.</li><li><strong>ArrayList</strong> - Resizable array implementation of the <code>List</code> interface (an unsynchronized <code>Vector</code>). The best all-around implementation of the <code>List</code> interface.</li><li><strong>ArrayDeque</strong> - Efficient, resizable array implementation of the <code>Deque</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener"><strong>LinkedList</strong></a> - Doubly-linked list implementation of the <code>List</code> interface. Provides better performance than the <code>ArrayList</code> implementation if elements are frequently inserted or deleted within the list. Also implements the <code>Deque</code> interface. When accessed through the <code>Queue</code> interface, <code>LinkedList</code> acts as a FIFO queue.</li><li><strong>PriorityQueue</strong> - Heap implementation of an unbounded priority queue.</li><li><strong>HashMap</strong> - Hash table implementation of the <code>Map</code> interface (an unsynchronized <code>Hashtable</code> that supports <code>null</code> keys and values). The best all-around implementation of the <code>Map</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener"><strong>TreeMap</strong></a> Red-black tree implementation of the <code>NavigableMap</code> interface.</li><li><strong>LinkedHashMap</strong> - Hash table and linked list implementation of the <code>Map</code> interface. An insertion-ordered <code>Map</code> implementation that runs nearly as fast as <code>HashMap</code>. Also useful for building caches (see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#removeEldestEntry-java.util.Map.Entry-" target="_blank" rel="noopener">removeEldestEntry(Map.Entry)</a> ).</li></ul></li><li><strong>Legacy implementations</strong>. The collection classes from earlier releases, <code>Vector</code> and <code>Hashtable</code>, were retrofitted to implement the collection interfaces.<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html" target="_blank" rel="noopener"><strong>Vector</strong></a> - Synchronized resizable array implementation of the <code>List</code> interface with additional legacy methods.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html" target="_blank" rel="noopener"><strong>Hashtable</strong></a> - Synchronized hash table implementation of the <code>Map</code> interface that does not allow <code>null</code> keys or values, plus additional legacy methods.</li></ul></li><li><strong>Special-purpose implementations</strong> (特殊实现). Implementations designed for use in special situations. These implementations display nonstandard performance characteristics, usage restrictions, or behavior.<ul><li><strong>WeakHashMap</strong> - An implementation of the <code>Map</code> interface that stores only <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="noopener"><em>weak references</em></a> to its keys. Storing only weak references enables key-value pairs to be garbage collected when the key is no longer referenced outside of the <code>WeakHashMap</code>. This class is the easiest way to use the power of weak references. It is useful for implementing registry-like data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</li><li><strong>IdentityHashMap</strong> - Identity-based <code>Map</code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations (such as serialization or deep copying). To perform these transformations, you must maintain an identity-based “node table” that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in preventing “spoof attacks” resulting from intentionally perverse equals methods. (<code>IdentityHashMap</code> never invokes the equals method on its keys.) An added benefit of this implementation is that it is fast.</li><li><strong>CopyOnWriteArrayList</strong> - A <code>List</code> implementation backed by an copy-on-write array. All mutative operations (such as <code>add</code>, <code>set</code>, and <code>remove</code>) are implemented by making a new copy of the array. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw<code>ConcurrentModificationException</code>. This implementation is well-suited to maintaining event-handler lists (where change is infrequent, and traversal is frequent and potentially time-consuming).</li><li><strong>CopyOnWriteArraySet</strong> - A <code>Set</code> implementation backed by a copy-on-write array. This implementation is similar to <code>CopyOnWriteArrayList</code>. Unlike most <code>Set</code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is well suited to maintaining event-handler lists that must prevent duplicates.</li><li><strong>EnumSet</strong> - A high-performance <code>Set</code> implementation backed by a bit vector. All elements of each <code>EnumSet</code> instance must be elements of a single enum type.</li><li><strong>EnumMap</strong> - A high-performance <code>Map</code> implementation backed by an array. All keys in each <code>EnumMap</code> instance must be elements of a single enum type.</li></ul></li><li><strong>Concurrent implementations</strong> (并发实现). Implementations designed for highly concurrent use.<ul><li><strong>ConcurrentLinkedQueue</strong> - An unbounded first in, first out (FIFO) queue based on linked nodes.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html" target="_blank" rel="noopener"><strong>LinkedBlockingQueue</strong></a> - An optionally bounded FIFO blocking queue backed by linked nodes.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html" target="_blank" rel="noopener"><strong>ArrayBlockingQueue</strong></a> - A bounded FIFO blocking queue backed by an array.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/PriorityBlockingQueue.html" target="_blank" rel="noopener"><strong>PriorityBlockingQueue</strong></a> - An unbounded blocking priority queue backed by a priority heap.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html" target="_blank" rel="noopener"><strong>DelayQueue</strong></a> - A time-based scheduling queue backed by a priority heap.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html" target="_blank" rel="noopener"><strong>SynchronousQueue</strong></a> - A simple rendezvous mechanism that uses the <code>BlockingQueue</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingDeque.html" target="_blank" rel="noopener"><strong>LinkedBlockingDeque</strong></a> - An optionally bounded FIFO blocking deque backed by linked nodes.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedTransferQueue.html" target="_blank" rel="noopener"><strong>LinkedTransferQueue</strong></a> - An unbounded <code>TransferQueue</code> backed by linked nodes.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="noopener"><strong>ConcurrentHashMap</strong></a> - A highly concurrent, high-performance <code>ConcurrentMap</code> implementation based on a hash table. This implementation never blocks when performing retrievals and enables the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code>Hashtable</code>. In addition to implementing <code>ConcurrentMap</code>, it supports all of the legacy methods of <code>Hashtable</code>.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListSet.html" target="_blank" rel="noopener"><strong>ConcurrentSkipListSet</strong></a> - Skips list implementation of the <code>NavigableSet</code> interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener"><strong>ConcurrentSkipListMap</strong></a> - Skips list implementation of the <code>ConcurrentNavigableMap</code> interface.</li></ul></li><li><strong>Wrapper implementations</strong> . Add functionality, such as synchronization, to other implementations.<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableCollection-java.util.Collection-" target="_blank" rel="noopener"><strong>Collections.unmodifiableInterface</strong></a> - Returns an unmodifiable view of a specified collection that throws an <code>UnsupportedOperationException</code> if the user attempts to modify it.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-" target="_blank" rel="noopener"><strong>Collections.synchronizedInterface</strong></a> - Returns a synchronized collection that is backed by the specified (typically unsynchronized) collection. As long as all accesses to the backing collection are through the returned collection, thread safety is guaranteed.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-" target="_blank" rel="noopener"><strong>Collections.checkedInterface</strong></a> - Returns a dynamically type-safe view of the specified collection, which throws a <code>ClassCastException</code> if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type checking, but it is possible to bypass this mechanism. Dynamically type-safe views eliminate this possibility.</li></ul></li><li><strong>Convenience implementations</strong>. High-performance “mini-implementations” of the collection interfaces.<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-" target="_blank" rel="noopener"><strong>Arrays.asList</strong></a> - Enables an array to be viewed as a list.</li><li><strong>emptySet, emptyList and emptyMap</strong> - Return an immutable empty set, list, or map.</li><li><strong>singleton, singletonList, and singletonMap</strong> - Return an immutable singleton set, list, or map, containing only the specified object (or key-value mapping).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#nCopies-int-T-" target="_blank" rel="noopener"><strong>nCopies</strong></a> - Returns an immutable list consisting of n copies of a specified object.</li></ul></li><li><strong>Abstract implementations</strong>. Partial implementations of the collection interfaces to facilitate custom implementations.<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" target="_blank" rel="noopener"><strong>AbstractCollection</strong></a> - Skeletal <code>Collection</code> implementation that is neither a set nor a list (such as a “bag” or multiset).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSet.html" target="_blank" rel="noopener"><strong>AbstractSet</strong></a> - Skeletal <code>Set</code> implementation.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html" target="_blank" rel="noopener"><strong>AbstractList</strong></a> - Skeletal <code>List</code> implementation backed by a random access data store (such as an array).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSequentialList.html" target="_blank" rel="noopener"><strong>AbstractSequentialList</strong></a> - Skeletal <code>List</code> implementation backed by a sequential access data store (such as a linked list).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html" target="_blank" rel="noopener"><strong>AbstractQueue</strong></a> - Skeletal <code>Queue</code> implementation.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html" target="_blank" rel="noopener"><strong>AbstractMap</strong></a> - Skeletal <code>Map</code> implementation.</li></ul></li><li><strong>Algorithms</strong>. Static methods that perform useful functions on collections, such as sorting a list.<ul><li><strong>sort(List)</strong> - Sorts a list using a merge sort algorithm, which provides average case performance comparable to a high quality quicksort, guaranteed O(n<em>log n) performance (unlike quicksort), and </em>stability* (unlike quicksort). A stable sort is one that does not reorder equal elements.</li><li><strong>binarySearch(List, Object)</strong> - Searches for an element in an ordered list using the binary search algorithm.</li><li><strong>reverse(List)</strong> - Reverses the order of the elements in a list.</li><li><strong>shuffle(List)</strong> - Randomly changes the order of the elements in a list.</li><li><strong>fill(List, Object)</strong> - Overwrites every element in a list with the specified value.</li><li><strong>copy(List dest, List src)</strong> - Copies the source list into the destination list.</li><li><strong>min(Collection)</strong> - Returns the minimum element in a collection.</li><li><strong>max(Collection)</strong> - Returns the maximum element in a collection.</li><li><strong>rotate(List list, int distance)</strong> - Rotates all of the elements in the list by the specified distance.</li><li><strong>replaceAll(List list, Object oldVal, Object newVal)</strong> - Replaces all occurrences of one specified value with another.</li><li><strong>indexOfSubList(List source, List target)</strong> - Returns the index of the first sublist of source that is equal to target.</li><li><strong>lastIndexOfSubList(List source, List target)</strong> - Returns the index of the last sublist of source that is equal to target.</li><li><strong>swap(List, int, int)</strong> - Swaps the elements at the specified positions in the specified list.</li><li><strong>frequency(Collection, Object)</strong> - Counts the number of times the specified element occurs in the specified collection.</li><li><strong>disjoint(Collection, Collection)</strong> - Determines whether two collections are disjoint, in other words, whether they contain no elements in common.</li><li><strong>addAll(Collection&lt;? super T&gt;, T…)</strong> - Adds all of the elements in the specified array to the specified collection.</li></ul></li><li><strong>Infrastructure</strong>. Interfaces that provide essential support for the collection interfaces.<ul><li>Iterators- Similar to the familiarEnumeration interface, but more powerful, and with improved method names.<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener"><strong>Iterator</strong></a> - In addition to the functionality of the <code>Enumeration</code> interface, enables the user to remove elements from the backing collection with well-defined, useful semantics.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html" target="_blank" rel="noopener"><strong>ListIterator</strong></a> - Iterator for use with lists. In addition to the functionality of the <code>Iterator</code> interface, supports bidirectional iteration, element replacement, element insertion, and index retrieval.</li></ul></li><li>Ordering<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener"><strong>Comparable</strong></a> - Imparts a <em>natural ordering</em> to classes that implement it. The natural ordering can be used to sort a list or maintain order in a sorted set or map. Many classes were retrofitted to implement this interface.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"><strong>Comparator</strong></a> - Represents an order relation, which can be used to sort a list or maintain order in a sorted set or map. Can override a type’s natural ordering or order objects of a type that does not implement the <code>Comparable</code> interface.</li></ul></li><li>Runtime exceptions<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html" target="_blank" rel="noopener"><strong>UnsupportedOperationException</strong></a> - Thrown by collections if an unsupported optional operation is called.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ConcurrentModificationException.html" target="_blank" rel="noopener"><strong>ConcurrentModificationException</strong></a> - Thrown by iterators and list iterators if the backing collection is changed unexpectedly while the iteration is in progress. Also thrown by <em>sublist</em> views of lists if the backing list is changed unexpectedly.</li></ul></li><li>Performance<ul><li><strong>RandomAccess</strong> - Marker interface that lets <code>List</code> implementations indicate that they support fast (generally constant time) random access. This lets generic algorithms change their behavior to provide good performance when applied to either random or sequential access lists.</li></ul></li></ul></li><li><strong>Array Utilities</strong>. Utility functions for arrays of primitive types and reference objects. Not, strictly speaking, a part of the collections framework, this feature was added to the Java platform at the same time as the collections framework and relies on some of the same infrastructure.<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html" target="_blank" rel="noopener"><strong>Arrays</strong></a> - Contains static methods to sort, search, compare, hash, copy, resize, convert to <code>String</code>, and fill arrays of primitives and objects.</li></ul></li></ul><p>更多细节:<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/reference.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/collections/reference.html</a></p><h4 id="Benefits-of-the-Java-Collections-Framework-实现集合框架的好处"><a href="#Benefits-of-the-Java-Collections-Framework-实现集合框架的好处" class="headerlink" title="Benefits of the Java Collections Framework(实现集合框架的好处)"></a>Benefits of the Java Collections Framework(实现集合框架的好处)</h4><p>The Java Collections Framework provides the following benefits:</p><ul><li><strong>Reduces programming effort:</strong> By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level “plumbing” required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs.</li><li><strong>Increases program speed and quality:</strong> This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you’re freed from the drudgery of writing your own data structures, you’ll have more time to devote to improving programs’ quality and performance.</li><li><strong>Allows interoperability among unrelated APIs:</strong> The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently.</li><li><strong>Reduces effort to learn and to use new APIs:</strong> Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away.</li><li><strong>Reduces effort to design new APIs:</strong> This is the flip side of the previous advantage. Designers and implementers don’t have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces.</li><li><strong>Fosters software reuse:</strong> New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.</li></ul><h3 id="Collection-Interfaces"><a href="#Collection-Interfaces" class="headerlink" title="Collection Interfaces"></a>Collection Interfaces</h3><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5gt0ie7x3g30b6042aa5.gif" alt="Two interface trees, one starting with Collection and including Set, SortedSet, List, and Queue, and the other starting with Map and including SortedMap."></p><p>主要分成两部分,Collection和Map</p><p>The <em>collection interfaces</em> are divided into two groups. The most basic interface, <code>java.util.Collection</code>, has the following descendants:</p><ul><li><code>java.util.Set</code></li><li><code>java.util.SortedSet</code></li><li><code>java.util.NavigableSet</code></li><li><code>java.util.Queue</code></li><li><code>java.util.concurrent.BlockingQueue</code></li><li><code>java.util.concurrent.TransferQueue</code></li><li><code>java.util.Deque</code></li><li><code>java.util.concurrent.BlockingDeque</code></li></ul><p>The other collection interfaces are based on <code>java.util.Map</code> and are not true collections. However, these interfaces contain <em>collection-view</em> operations, which enable them to be manipulated as collections. <code>Map</code> has the following offspring:</p><ul><li><code>java.util.SortedMap</code></li><li><code>java.util.NavigableMap</code></li><li><code>java.util.concurrent.ConcurrentMap</code></li><li><code>java.util.concurrent.ConcurrentNavigableMap</code></li></ul><p>专业术语,  modifiable、mutable、variable-size、sequential access</p><p>Several terms are introduced to aid in this specification:</p><ul><li>Collections that do not support modification operations (such as <code>add</code>, <code>remove</code> and <code>clear</code>) are referred to as <em>unmodifiable</em>. Collections that are not unmodifiable are <em>modifiable.</em></li><li>Collections that additionally guarantee that no change in the <code>Collection</code> object will be visible are referred to as <em>immutable</em>. Collections that are not immutable are <em>mutable</em>.</li><li>Lists that guarantee that their size remains constant even though the elements can change are referred to as <em>fixed-size</em>. Lists that are not fixed-size are referred to as <em>variable-size</em>.</li><li>Lists that support fast (generally constant time) indexed element access are known as <em>random access</em> lists. Lists that do not support fast indexed element access are known as <em>sequential access</em> lists. The <code>RandomAccess</code> marker interface enables lists to advertise the fact that they support random access. This enables generic algorithms to change their behavior to provide good performance when applied to either random or sequential access lists.</li></ul><h3 id="Collection-Implementations"><a href="#Collection-Implementations" class="headerlink" title="Collection Implementations"></a>Collection Implementations</h3><p>Classes that implement the collection interfaces typically have names in the form of &lt;<em>Implementation-style</em>&gt;&lt;<em>Interface</em>&gt;. The general purpose implementations are summarized in the following table:</p><table><thead><tr><th>Interface</th><th>Hash Table</th><th>Resizable Array</th><th>Balanced Tree</th><th>Linked List</th><th>Hash Table + Linked List</th></tr></thead><tbody><tr><td><code>Set</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" target="_blank" rel="noopener"><code>HashSet</code></a></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html" target="_blank" rel="noopener"><code>TreeSet</code></a></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html" target="_blank" rel="noopener"><code>LinkedHashSet</code></a></td></tr><tr><td><code>List</code></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" target="_blank" rel="noopener"><code>ArrayList</code></a></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener"><code>LinkedList</code></a></td><td></td></tr><tr><td><code>Deque</code></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html" target="_blank" rel="noopener"><code>ArrayDeque</code></a></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener"><code>LinkedList</code></a></td><td></td></tr><tr><td><code>Map</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" target="_blank" rel="noopener"><code>HashMap</code></a></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener"><code>TreeMap</code></a></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener"><code>LinkedHashMap</code></a></td></tr></tbody></table><p>​    </p><p>The general-purpose implementations support all of the <em>optional operations</em> in the collection interfaces and have no restrictions on the elements they may contain. They are unsynchronized, but the <code>Collections</code> class contains static factories called <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-" target="_blank" rel="noopener"><em>synchronization wrappers</em></a> that can be used to add synchronization to many unsynchronized collections. All of the new implementations have <em>fail-fast iterators</em>, which detect invalid concurrent modification, and fail quickly and cleanly (rather than behaving erratically).</p><p>​    The <code>AbstractCollection</code>, <code>AbstractSet</code>, <code>AbstractList</code>, <code>AbstractSequentialList</code> and <code>AbstractMap</code> classes provide basic implementations of the core collection interfaces, to minimize the effort required to implement them. The API documentation for these classes describes precisely how each method is implemented so the implementer knows which methods must be overridden, given the performance of the basic operations of a specific implementation.</p><h3 id="Concurrent-Collections"><a href="#Concurrent-Collections" class="headerlink" title="Concurrent Collections"></a>Concurrent Collections</h3><p>Applications that use collections from more than one thread must be carefully programmed. In general, this is known as <em>concurrent programming</em>. The Java platform includes extensive support for concurrent programming. See <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/index.html" target="_blank" rel="noopener">Java Concurrency Utilities</a> for details.</p><p>Collections are so frequently used that various concurrent friendly interfaces and implementations of collections are included in the APIs. These types go beyond the synchronization wrappers discussed previously to provide features that are frequently needed in concurrent programming.</p><h4 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h4><p>These concurrent-aware interfaces are available:</p><ul><li><code>BlockingQueue</code></li><li><code>TransferQueue</code></li><li><code>BlockingDeque</code></li><li><code>ConcurrentMap</code></li><li><code>ConcurrentNavigableMap</code></li></ul><h4 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h4><p>The following concurrent-aware implementation classes are available. See the API documentation for the correct usage of these implementations.</p><ul><li><code>LinkedBlockingQueue</code></li><li><code>ArrayBlockingQueue</code></li><li><code>PriorityBlockingQueue</code></li><li><code>DelayQueue</code></li><li><code>SynchronousQueue</code></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingDeque.html" target="_blank" rel="noopener"><code>LinkedBlockingDeque</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedTransferQueue.html" target="_blank" rel="noopener"><code>LinkedTransferQueue</code></a></li><li><code>CopyOnWriteArrayList</code></li><li><code>CopyOnWriteArraySet</code></li><li><code>ConcurrentSkipListSet</code></li><li><code>ConcurrentHashMap</code></li><li><code>ConcurrentSkipListMap</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note_码农翻身</title>
      <link href="/2019/07/10/Note-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"/>
      <url>/2019/07/10/Note-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4v6oydtusj30u016fn56.jpg" alt="image-20190710235737581"></p><a id="more"></a><p>这几天看了本书,《码农翻身》 做个笔记总结下</p><p>先来个总评 ,很不错的入门书,趣味性比较强, 涉及知识范围比较广</p><p>主要有以下几个议题:</p><ul><li>计算机原理</li><li>java发展历史</li><li>web发展历史</li><li>其他(代码管理、JavaScript)</li></ul><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程状态 就绪 运行 等待</p><p>锁 获取顺序从大到小</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>三次握手建立链接</p><p>窗口协议控制速率</p><p>确认传达、重传机制</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>寄存器 程序计数器</p><p>程序都是由顺序、分支、循环组成的</p><p>缓存 L1 L2 L3  局部性原理</p><p>流水线</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>冯诺依曼 提出了存储程序-&gt;专用计算机 到 通用计算机</p><p>运算器 控制器 存储器 输入设备 输出设备</p><p>内存</p><p>内存分配算法</p><p>地址重定位</p><p>​    静态重定位(移动程序,需要重定位)</p><p>​    动态重定向 </p><p>​        记录每个程序的起始地址,寄存器(基址寄存器) </p><p>​        记录程序内存长度寄存器 防止越界 (两个寄存器封装为MMU 内存管理单元,完成地址的转换)</p><p>分时系统 CPU时间分片</p><p>分块装入内存(页框 Page Frame)</p><p>虚拟内存(分页Page)</p><p>分段(代码段,数据段,堆栈段)+分页</p><p>线程</p><p>共享进程的所有资源 地址空间、全局变量、文件源</p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>文件</p><p>文件存放</p><p>​    索引</p><p>​    间接块</p><p>​    日志文件系统 防止系统奔溃</p><p>管理空闲块</p><p>​    位图</p><p>文件系统</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>逻辑层 (查询语句解析、查询执行引擎、缓冲区管理、授权管理、事务管理)-&gt;文件的封装</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket抽象层 封装 TCP UDP和用户线程直接的连接</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>源程序-&gt;词法分析-&gt;语法分析-&gt;语义分析-&gt;中间代码生成-&gt;代码优化-&gt;代码生成-&gt;目标程序</p><p>对二进制书的所有位取反,然后加一 补码</p><p>在计算机内部,是使用补码来表示二进制的.如果是一个正数,补码就是它本身</p><p>如果是一个附属,则需要把除符号位之外的二进制数执行取反加1的操作</p><h2 id="java发展历史"><a href="#java发展历史" class="headerlink" title="java发展历史"></a>java发展历史</h2><p>持久化</p><p>​    序列化到磁盘</p><p>​    数据库 JDBC接口</p><p>​    EJB -&gt;轻量级O/R框架 Hibernate 、iBatis、Sping JdbcTemplate</p><p>​    EJB3.0 </p><p>JDBC </p><p>简单工厂</p><p>数据驱动</p><p>工厂方法</p><p>分布式</p><p>JSP</p><p>MVC</p><p>消息队列JMS</p><p>动态代理</p><p>注解</p><p>泛型 </p><p>日志系统</p><p>​    SLF4J API抽象层  LogBack</p><p>​    适配层</p><p>​    Log4j、JDK logging</p><h2 id="Web发展历史"><a href="#Web发展历史" class="headerlink" title="Web发展历史"></a>Web发展历史</h2><p>web起源</p><p>https</p><p>​    对称加密 公钥</p><p>​    非对称加密 RSA</p><p>​    对称加密+非对称加密 (效率低)</p><p>​    中间人劫持</p><p>​    证书</p><p>授权 </p><p>​    sso </p><p>​    token</p><p>从SOA到微服务</p><p>HTTP Server</p><p>1.0</p><p>2.0 多进程</p><p>3.0 select模型</p><p>4.0 epoll模型</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然覆盖的知识很广,但其实这些知识点比较零散,而且都比较浅显,都需要深入了解,只能说适合作为一本入门书籍 或者知识大纲用来查漏补缺</p><h2 id="技术感悟"><a href="#技术感悟" class="headerlink" title="技术感悟"></a>技术感悟</h2><p>最近思考了很多,为思故我在, 偶尔需要给自己点空闲时间思考, 自己到底想要什么,自己经历的问题是不是问题 </p><p>偶然看到一篇总结的很好的文章, 分享一下</p><p><strong>1. 一个人走得快，一群人走得远</strong></p><p><strong>2. 当你不舒服，难受或陷于困境时，应该停下来思考</strong></p><p><strong>3. 学习能力与思维模式是一个人的核心竞争力</strong></p><p><strong>3.1 首先承认自己的不足</strong></p><p>​    Stay foolish, stay hungry.</p><p>我们要承认一个基本的逻辑事实是: 任何事情不是天生就能精通，要通过训练才能达到优秀的程度。很多事物的判断能力，要是逐步建立的。只有意识到自己的不足，才能觉悟，去学习进步。</p><p>网上看到一张图《how to draw a horse》深有感触：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4v6w94j6kj30u017mwh8.jpg" alt="image-20190711000446974"></p><p>这个漫画显示的哲理：有时最后一步，你要付出非常多的努力。任何高水平的技术或思维模式，都需要付出努力，并非生而得来。</p><p><strong>3.2 掌握优秀的学习方法：</strong></p><p>如何证明一个人有比较优秀的学习能力？学习做到目到，口到，心到。</p><p><strong>3.3 掌握搜索信息的有效方式</strong></p><p>如何提升获取的信息质量，这里有一些建议：</p><ul><li><p>精确定位问题</p></li><li><p>梳理出关键字与概念</p></li><li><p>“全网”搜索</p></li><li><p>分析研究</p></li><li><p>实践&amp;结论&amp;假设</p></li></ul><p><strong>3.4 具备优秀的批判性思维模型</strong></p><p>在《批判性思维工具》一书中，对思维的水平分了三个层次：较差、中等、最佳水平的思考（如下图1）。当前很多同学可能在多数问题上都处于较差水平层次，很多认知来自直觉或者自我视角。最佳水平的思考要做到三点：全局、公正、客观。</p><p>文章来源:<a href="https://mp.weixin.qq.com/s/LxW4j7JOOrEGYWylP2j9Mg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LxW4j7JOOrEGYWylP2j9Mg</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK_ClassLoader</title>
      <link href="/2019/07/06/JDK-ClassLoader/"/>
      <url>/2019/07/06/JDK-ClassLoader/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4u7huu80gj30x30u0dlq.jpg" alt="image-20190710033943799"></p><p>today we’re  taking about classLoader </p><p>topic</p><ul><li>what is classLoader</li><li>parent classLoader</li><li>why need three classLoader</li><li>source of classLoader</li><li>more details</li></ul><p>​    ok, let‘s go</p><a id="more"></a><h2 id="what-is-classLoader"><a href="#what-is-classLoader" class="headerlink" title="what is classLoader"></a>what is classLoader</h2><p>首先 ,什么是classLoader ,首先看下官方解释</p><pre><code>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system.</code></pre><p>简单来说就是类加载器, 负责把class 文件 加载到虚拟机(将class文件从硬盘加载到内存的一个过程) </p><p>思考下, 加载某个class需要className , 接下来通过这个className去哪里查找,怎么查找</p><pre><code>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. </code></pre><p>通常, 虚拟机所加载的类来自文件系统,通过CLASSPATH 指定路径, 当然也可以来自网络传输(通过URL抽象出这些resource)</p><h2 id="parent-classLoader"><a href="#parent-classLoader" class="headerlink" title="parent classLoader"></a>parent classLoader</h2><p>parent classLoader, 通常被称为“双亲委派” , 一直觉得这个翻译有点问题 , 双亲 , 其实只有一个parent </p><pre><code>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine&#39;s built-in class loader, called the &quot;bootstrap class loader&quot;, does not itself have a parent but may serve as the parent of a ClassLoader instance.</code></pre><p>ClassLoader使用的是设计模式中的委派模式, 通过parent去加载,如果parent为空,则依赖BootstrapClassLoader, 注意这个类加载器是虚拟机实现的一部分.而且我们程序中是无法获取到的,例如如下代码</p><pre><code class="java">public class ClassLoaderDemo {    public static void main(String[] args) {        System.out.println(ClassLoaderDemo.class.getClassLoader());        System.out.println(String.class.getClassLoader());        System.out.println(Integer.class.getClassLoader());    }}</code></pre><p>运行结果如下(在看结果之前,先有自己的思考,不应该以结果导向作为推论)</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4u25hc2arj314g06smxy.jpg" alt="image-20190710003513353"></p><p>至于为什么,让我们先来了解类加载的层级关系,通常我们常见的classLoader有如下几个</p><ul><li><strong>Bootstrap ClassLoader</strong>：最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等；</li><li><strong>Extention ClassLoader</strong>：扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件；</li><li><strong>Appclass Loader</strong>：也称为SystemAppClass，加载当前应用的classpath的所有类；</li></ul><p>类关系图如下</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4u14r8zfpj317k0ruq5f.jpg" alt="image-20190709235952338"></p><p>OK,回到刚刚的问题,首先 classLoader也是一个class ,所以我们可以看到结果,我们自己定义的类<code>ClassLoaderDemo</code> 的类加载器是 <code>sun.misc.Launcher$AppClassLoader@18b4aac2</code>   ($表示内部类,@表示对象hashcode,ps:类名生成规则我找不到哪里有, 看了虚拟机规范、JLS都没有找到,应该是编译器的,讲道理应该是虚拟机)</p><p>从类名称我们可以知道,  加载我们自定义类的类加载的一些基本信息,首先它是 <code>sun.misc.Launcher</code>  类的一个内部类<code>AppClassLoader</code>   ,为了理解虚拟机的层级关系, 我们需要知道虚拟机的启动过程</p><p>至于String 、Integer 为啥获取为null, 这是因为是BootStrap加载的(至于为啥获取不到,因为在jdk是没有这个类的,安全性的考虑吧可能)</p><h3 id="虚拟机的启动过程"><a href="#虚拟机的启动过程" class="headerlink" title="虚拟机的启动过程"></a>虚拟机的启动过程</h3><p>详细参考 <a href="https://www.cnblogs.com/bhlsheji/p/4017816.html" target="_blank" rel="noopener">https://www.cnblogs.com/bhlsheji/p/4017816.html</a></p><p>或参阅OpenJDK下的sun.misc.Launcher</p><pre><code class="java">    public Launcher() {        // Create the extension class loader        ClassLoader extcl;        try {            extcl = ExtClassLoader.getExtClassLoader();        } catch (IOException e) {            throw new InternalError(                &quot;Could not create extension class loader&quot;, e);        }        // Now create the class loader to use to launch the application        try {            loader = AppClassLoader.getAppClassLoader(extcl);        } catch (IOException e) {            throw new InternalError(                &quot;Could not create application class loader&quot;, e);        }        // Also set the context class loader for the primordial thread.        Thread.currentThread().setContextClassLoader(loader);        // Finally, install a security manager if requested        String s = System.getProperty(&quot;java.security.manager&quot;);        if (s != null) {            SecurityManager sm = null;            if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) {                sm = new java.lang.SecurityManager();            } else {                try {                    sm = (SecurityManager)loader.loadClass(s).newInstance();                } catch (IllegalAccessException e) {                } catch (InstantiationException e) {                } catch (ClassNotFoundException e) {                } catch (ClassCastException e) {                }            }            if (sm != null) {                System.setSecurityManager(sm);            } else {                throw new InternalError(                    &quot;Could not create SecurityManager: &quot; + s);            }        }    }</code></pre><h3 id="双亲委派的好处"><a href="#双亲委派的好处" class="headerlink" title="双亲委派的好处"></a>双亲委派的好处</h3><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：<strong>类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。</p><p>例如类<code>java.lang.Object</code>，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对<code>java.lang.Object</code>的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此<strong>Object类在程序的各种类加载器环境中都是同一个类</strong>。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p><p>既然这样是不是只要一个classLoder就不会有上述的问题了?</p><h2 id="why-need-three-classLoader"><a href="#why-need-three-classLoader" class="headerlink" title="why need three classLoader"></a>why need three classLoader</h2><p>Java中有三种基础的类加载器 BootStrap, Extension and System<br>他们都有一个职能，就是从不同的包中加载类。<br>但是一个类加载器完全可以加载所有的类，为什么要有3种基础的类型的类加载器呢？</p><p>Java中有三种基础的类加载器主要为了安全。(另一个是为了扩展,所有应用都需要用同一个jar)<br>1.2版本的JVM中，只有一个类加载器，就是现在的“Bootstrap”类加载器。<br>类加载器加载类的方式是，加载器先调用父加载器对类进行加载，如果父加载器找不到该类，此加载器才会去加载该类。<br>最关键的是， 除非是同一个类加载器加载的类 ，否则JVM不会保证包访问级别（如果不指明private/public或protected，则方法和属性具有包访问级别）。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4u66v1hydj30k0064gly.jpg" alt="img"></p><p>因此，假如用户调用他编写的java.lang.MyClass类。理论上该类可以访问和改变java.lang包下其他类的默认访问修饰符的属性和方法的能力。Java语言本身并没有阻止这种行为。但是JVM则会阻止这种行为，因为java核心类库的java.lang包下的类是由bootstrap类加载器加载的。不是同一个类加载器加载的类等于不具有包级别的访问权限。<br>类加载器中的其他安全特性也会阻止这种类型侵入。<br>所以为什么有三种基础的类加载器？是因为他们代表三种不同的信任级别。最可信的级别是java核心API类。然后是安装的拓展类，最后才是在类路径中的类（属于你本机的类）。</p><p><strong>其他解释1</strong><br>类加载主要的应用场景是在应用服务器上。<br>如果你想启动Tomcat。这至少需要一个类加载器来运行Tomcat自己。<br>然后你想在Tomcat容器中部署项目。因此Tomcat需要加载和分析甚至在Tomcat启动前都不存在的类。<br>然后你又想在Tomcat中部署另外一个应用。 第二个应用可能也会用到第一个应用使用的库，但是版本不同。<br>因此你就需要每个应都有相互隔离的类加载器，否则第二个应用的类可能会覆盖第一个应用之前加载的类，从而造成一些意想不到的后果。<br>然后你想停掉某个web应用。该应用的类加载器应该会被销毁，垃圾也随之被回收，这样可以避免内存泄露。<br>或许类加载器还有其他用途，但这是我印象中最常见的用法。</p><p><strong>其他解释2</strong><br>多种类加载器待办可以同时加载多个应用程序（一个加载服务，另外的加载器用来服务器内部的部署）。<br>每种加载器都有对应的层级来加载某些特定的类，来保证他们之间的安全性。</p><p>参考</p><blockquote><p> <a href="https://zhuanlan.zhihu.com/p/54773662?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">为什么Java中有三种基础的类加载器？</a></p><p><a href="https://docs.oracle.com/javase/tutorial/ext/index.html" target="_blank" rel="noopener"> The Extension Mechanism</a> — How to make custom APIs available to all applications running on the Java platform.</p></blockquote><h2 id="source-of-classLoader"><a href="#source-of-classLoader" class="headerlink" title="source of classLoader"></a>source of classLoader</h2><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><pre><code class="java">protected Class&lt;?&gt; loadClass(String name, boolean resolve)        throws ClassNotFoundException{    synchronized (getClassLoadingLock(name)) {        // First, check if the class has already been loaded        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) {            long t0 = System.nanoTime();            try {                if (parent != null) {                    c = parent.loadClass(name, false);                } else {                    c = findBootstrapClassOrNull(name);                }            } catch (ClassNotFoundException e) {                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            }            if (c == null) {                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            }        }        if (resolve) {            resolveClass(c);        }        return c;    }}protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {    throw new ClassNotFoundException(name);}protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,                                     ProtectionDomain protectionDomain)    throws ClassFormatError{    protectionDomain = preDefineClass(name, protectionDomain);    String source = defineClassSourceLocation(protectionDomain);    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);    postDefineClass(c, protectionDomain);    return c;}</code></pre><p>findClass 见URLClassLoader实现,最后会调用defineClass</p><h3 id="URLClassLoder"><a href="#URLClassLoder" class="headerlink" title="URLClassLoder"></a>URLClassLoder</h3><pre><code class="java">protected Class&lt;?&gt; findClass(final String name)    throws ClassNotFoundException{    final Class&lt;?&gt; result;    try {        result = AccessController.doPrivileged(            new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() {                public Class&lt;?&gt; run() throws ClassNotFoundException {                    String path = name.replace(&#39;.&#39;, &#39;/&#39;).concat(&quot;.class&quot;);                    Resource res = ucp.getResource(path, false);                    if (res != null) {                        try {                            return defineClass(name, res);                        } catch (IOException e) {                            throw new ClassNotFoundException(name, e);                        }                    } else {                        return null;                    }                }            }, acc);    } catch (java.security.PrivilegedActionException pae) {        throw (ClassNotFoundException) pae.getException();    }    if (result == null) {        throw new ClassNotFoundException(name);    }    return result;}</code></pre><p>类加载的过程  加载 、验证、 准备、 链接 、初始化 、使用 、卸载</p><h2 id="more-details"><a href="#more-details" class="headerlink" title="more details"></a>more details</h2><ul><li><p>security(安全)</p><p>  Class loaders may typically be used by security managers to indicate security domains.</p></li><li><p>Parallel(并发)</p><p>Class loaders that support concurrent loading of classes are known as <em>parallel capable</em> class loaders and are required to register themselves at their class initialization time by invoking the<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#registerAsParallelCapable--" target="_blank" rel="noopener"><code>ClassLoader.registerAsParallelCapable</code></a> method. Note that the <code>ClassLoader</code> class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable.<br>In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#loadClass-java.lang.String-" target="_blank" rel="noopener"><code>loadClass</code></a> methods).</p><pre><code class="java">protected Object getClassLoadingLock(String className) {    Object lock = this;    if (parallelLockMap != null) {        Object newLock = new Object();        lock = parallelLockMap.putIfAbsent(className, newLock);        if (lock == null) {            lock = newLock;        }    }    return lock;}</code></pre></li><li><p>ClassNotFoundException and  NoClassDefFoundError(LinkageError)</p></li></ul><p>这个议题太大了,查阅了好多资料…</p><p>涉及虚拟机编译 、类格式、类加载过程、虚拟机启动过程、hotspot、openjdk</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> classLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-ApplicationContext启动流程和事件机制</title>
      <link href="/2019/07/03/spring-ApplicationContext%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/03/spring-ApplicationContext%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4mg6v52lnj30bj0at758.jpg" alt="喵.jpg"></p><p>当事猫罪行描述: 事情的经过是这样的,今天一如既往早早来到办公室,开始快乐的一天,本想着温故而知新一下,翻翻Servlet规范,看看之前的笔记, 忽然发现ServletContextListener , 想起我大哥的书中提到的一点 springBoot 的历史性意义,其中一点就包括,嵌入式(Embed)容器.</p><ul><li>在springBoot之前 ,web 应用依托web容器, 依赖servlet的监听事件(Event,EventListener) 即ServletContextListener,完成web应用的初始化. </li><li>在springBoot时, web应用的启动流程就不再依托servlet容器,而是自发创建、选择 web容器</li></ul><p>当然 , 我们今天的重点是SpringBoot之前,web应用是怎么启动的. </p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    前面提到过在SpringBoot之前, web应用的启动是基于servlet的回调,而其中涉及tomcat的生命周期和事件,所以有以下议题:</p><ul><li>​    <u>JDK事件机制</u></li><li>​    <u>Tomcat事件机制</u></li><li>​    <u>Spring-web应用启动流程</u></li><li>​    <u>Spring事件机制</u></li></ul><h2 id="JDK中的事件机制"><a href="#JDK中的事件机制" class="headerlink" title="JDK中的事件机制"></a>JDK中的事件机制</h2><p>JDK中对事件机制的各个角色提供了完善的抽象，主要包括3个角色：</p><ul><li>EventObject（事件）：事件发布时需要关注的内容。jdk中提供了EventObject接口。</li><li>EventListener（事件监听者）：事件监听对象，也就是对EventObject感兴趣的对象。jdk中提供了EventListener接口。</li><li>EventSource（事件源,我比较喜欢称为EventPublisher 事件发布者）：发布事件的对象，可以在该对象中组册EventListener，然后在特定的条件下发布EventObject给已经注册的EventListener。</li></ul><h2 id="Tomcat的事件机制"><a href="#Tomcat的事件机制" class="headerlink" title="Tomcat的事件机制"></a>Tomcat的事件机制</h2><h3 id="事件-LifecycleEvent"><a href="#事件-LifecycleEvent" class="headerlink" title="事件 (LifecycleEvent)"></a>事件 (LifecycleEvent)</h3><p>Tomcat容器,定义了很多生命周期相关的事件. <code>org.apache.catalina.LifecycleEvent</code> </p><p>主要的事件在<code>org.apache.catalina.Lifecycle</code></p><pre><code class="java">public final class LifecycleEvent extends EventObject {    //......    public LifecycleEvent(Lifecycle lifecycle, String type, Object data) {        super(lifecycle);        this.type = type;        this.data = data;    }    //......}public interface Lifecycle {    /**     * The LifecycleEvent type for the &quot;component after init&quot; event.     */    public static final String BEFORE_INIT_EVENT = &quot;before_init&quot;;    /**     * The LifecycleEvent type for the &quot;component after init&quot; event.     */    public static final String AFTER_INIT_EVENT = &quot;after_init&quot;;    /**     * The LifecycleEvent type for the &quot;component start&quot; event.     */    public static final String START_EVENT = &quot;start&quot;;    //......}</code></pre><h3 id="事件监听者-LifecycleListener"><a href="#事件监听者-LifecycleListener" class="headerlink" title="事件监听者(LifecycleListener)"></a>事件监听者(LifecycleListener)</h3><p>监听者使用LifecycleEvent参数用来在tomcat的各个阶段处理进行相应处理。<code>org.apache.catalina.LifecycleListener</code> 有众多实现,其中<code>org.apache.catalina.startup.ContextConfig</code> 这个类在解析server.xml的时候用来监听StandardContext的各个阶段的事件，并做出相应处理</p><pre><code class="java">public interface LifecycleListener {    public void lifecycleEvent(LifecycleEvent event);}public class ContextConfig implements LifecycleListener {    //......    @Override    public void lifecycleEvent(LifecycleEvent event) {        // Identify the context we are associated with        try {            context = (Context) event.getLifecycle();        } catch (ClassCastException e) {            log.error(sm.getString(&quot;contextConfig.cce&quot;, event.getLifecycle()), e);            return;        }        // Process the event that has occurred        if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {            configureStart();        } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) {            beforeStart();        } else if (event.getType().equals(Lifecycle.AFTER_START_EVENT)) {            // Restore docBase for management tools            if (originalDocBase != null) {                context.setDocBase(originalDocBase);            }        } else if (event.getType().equals(Lifecycle.CONFIGURE_STOP_EVENT)) {            configureStop();        } else if (event.getType().equals(Lifecycle.AFTER_INIT_EVENT)) {            init();        } else if (event.getType().equals(Lifecycle.AFTER_DESTROY_EVENT)) {            destroy();        }    }    //......}</code></pre><h3 id="事件发布者-LifecycleBase"><a href="#事件发布者-LifecycleBase" class="headerlink" title="事件发布者(LifecycleBase)"></a>事件发布者(LifecycleBase)</h3><p>LifecycleBase 把事件管理委派给了LifecycleSupport,它是监听对象的一个管理类，它把对监听对象的添加移除以及发布事件几个操作进行了统一管理，避免EventSource类中出现太多管理监听对象的逻辑。</p><pre><code class="java">public abstract class LifecycleBase implements Lifecycle{    //......    private LifecycleSupport lifecycle = new LifecycleSupport(this);    @Override    public void addLifecycleListener(LifecycleListener listener) {        lifecycle.addLifecycleListener(listener);    }    @Override    public void removeLifecycleListener(LifecycleListener listener) {        lifecycle.removeLifecycleListener(listener);    }    protected void fireLifecycleEvent(String type, Object data) {        lifecycle.fireLifecycleEvent(type, data);    }    //......}public final class LifecycleSupport {    //......    //监听对象集合    private LifecycleListener listeners[] = new LifecycleListener[0];    private final Object listenersLock = new Object(); // Lock object for changes to listeners    //添加监听对象    public void addLifecycleListener(LifecycleListener listener) {      synchronized (listenersLock) {          LifecycleListener results[] =            new LifecycleListener[listeners.length + 1];          for (int i = 0; i &lt; listeners.length; i++)              results[i] = listeners[i];          results[listeners.length] = listener;          listeners = results;      }    }    //发布监听对象    public void fireLifecycleEvent(String type, Object data) {        LifecycleEvent event = new LifecycleEvent(lifecycle, type, data);        LifecycleListener interested[] = listeners;        for (int i = 0; i &lt; interested.length; i++)            interested[i].lifecycleEvent(event);    }    //移除监听对象    public void removeLifecycleListener(LifecycleListener listener) {        synchronized (listenersLock) {            int n = -1;            for (int i = 0; i &lt; listeners.length; i++) {                if (listeners[i] == listener) {                    n = i;                    break;                }            }            if (n &lt; 0)                return;            LifecycleListener results[] =              new LifecycleListener[listeners.length - 1];            int j = 0;            for (int i = 0; i &lt; listeners.length; i++) {                if (i != n)                    results[j++] = listeners[i];            }            listeners = results;        }    }}</code></pre><h2 id="Spring-web应用启动流程"><a href="#Spring-web应用启动流程" class="headerlink" title="Spring web应用启动流程"></a>Spring web应用启动流程</h2><h3 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h3><p>在一个spring 的web项目中, 通常需要在web.xml配置 ContextLoaderListener</p><pre><code class="xml">&lt;listener&gt;   &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><p>首先看下这个类结构</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4mehmam01j30ta0deq3v.jpg" alt="image-20190703093735464"></p><p>可以看到继承了<code>ContextLoader</code> ,用来创建和初始化<code>WebApplicationContext</code> </p><p>同时也实现了<code>EventListener</code>,那么它监听的是什么事件呢,又是哪里发布的?</p><pre><code class="java">/** * Initialize the root web application context. */public void contextInitialized(ServletContextEvent event) {   this.contextLoader = createContextLoader();   if (this.contextLoader == null) {      this.contextLoader = this;   }   this.contextLoader.initWebApplicationContext(event.getServletContext());}</code></pre><p>可以看到是一个ServletContextEvent ,因为这里的Listener是配置在web.xml,所以它是tomcat容器的一个listener,那么事件的发布就是 LifecycleBase</p><h3 id="ServletContextEvent"><a href="#ServletContextEvent" class="headerlink" title="ServletContextEvent"></a>ServletContextEvent</h3><p>通过查看LifecycleBase的实现 ,最终发现Tomcat 具体的操作在<code>org.apache.catalina.core.StandardContext</code></p><h4 id="startInternal方法"><a href="#startInternal方法" class="headerlink" title="startInternal方法"></a>startInternal方法</h4><pre><code class="java">/** * Start this component and implement the requirements * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}. * * @exception LifecycleException if this component detects a fatal error *  that prevents this component from being used */@Overrideprotected synchronized void startInternal() throws LifecycleException {    if(log.isDebugEnabled())        log.debug(&quot;Starting &quot; + getBaseName());    // Send j2ee.state.starting notification    if (this.getObjectName() != null) {        Notification notification = new Notification(&quot;j2ee.state.starting&quot;,                this.getObjectName(), sequenceNumber.getAndIncrement());        broadcaster.sendNotification(notification);    }    setConfigured(false);    boolean ok = true;    // Currently this is effectively a NO-OP but needs to be called to    // ensure the NamingResources follows the correct lifecycle    if (namingResources != null) {        namingResources.start();    }    // Add missing components as necessary    if (webappResources == null) {   // (1) Required by Loader        if (log.isDebugEnabled())            log.debug(&quot;Configuring default Resources&quot;);        try {            String docBase = getDocBase();            if (docBase == null) {                setResources(new EmptyDirContext());            } else if (docBase.endsWith(&quot;.war&quot;)                    &amp;&amp; !(new File(getBasePath())).isDirectory()) {                setResources(new WARDirContext());            } else {                setResources(new FileDirContext());            }        } catch (IllegalArgumentException e) {            log.error(sm.getString(&quot;standardContext.resourcesInit&quot;), e);            ok = false;        }    }    if (ok) {        if (!resourcesStart()) {            throw new LifecycleException(&quot;Error in resourceStart()&quot;);        }    }    if (getLoader() == null) {        WebappLoader webappLoader = new WebappLoader(getParentClassLoader());        webappLoader.setDelegate(getDelegate());        setLoader(webappLoader);    }    // Initialize character set mapper    getCharsetMapper();    // Post work directory    postWorkDirectory();    // Validate required extensions    boolean dependencyCheck = true;    try {        dependencyCheck = ExtensionValidator.validateApplication            (getResources(), this);    } catch (IOException ioe) {        log.error(sm.getString(&quot;standardContext.extensionValidationError&quot;), ioe);        dependencyCheck = false;    }    if (!dependencyCheck) {        // do not make application available if dependency check fails        ok = false;    }    // Reading the &quot;catalina.useNaming&quot; environment variable    String useNamingProperty = System.getProperty(&quot;catalina.useNaming&quot;);    if ((useNamingProperty != null)        &amp;&amp; (useNamingProperty.equals(&quot;false&quot;))) {        useNaming = false;    }    if (ok &amp;&amp; isUseNaming()) {        if (getNamingContextListener() == null) {            NamingContextListener ncl = new NamingContextListener();            ncl.setName(getNamingContextName());            ncl.setExceptionOnFailedWrite(getJndiExceptionOnFailedWrite());            addLifecycleListener(ncl);            setNamingContextListener(ncl);        }    }    // Standard container startup    if (log.isDebugEnabled())        log.debug(&quot;Processing standard container startup&quot;);    // Binding thread    ClassLoader oldCCL = bindThread();    try {        if (ok) {            // Start our subordinate components, if any            Loader loader = getLoaderInternal();            if ((loader != null) &amp;&amp; (loader instanceof Lifecycle))                ((Lifecycle) loader).start();            // since the loader just started, the webapp classloader is now            // created.            // By calling unbindThread and bindThread in a row, we setup the            // current Thread CCL to be the webapp classloader            unbindThread(oldCCL);            oldCCL = bindThread();            // Initialize logger again. Other components might have used it            // too early, so it should be reset.            logger = null;            getLogger();            Cluster cluster = getClusterInternal();            if ((cluster != null) &amp;&amp; (cluster instanceof Lifecycle))                ((Lifecycle) cluster).start();            Realm realm = getRealmInternal();            if ((realm != null) &amp;&amp; (realm instanceof Lifecycle))                ((Lifecycle) realm).start();            DirContext resources = getResourcesInternal();            if ((resources != null) &amp;&amp; (resources instanceof Lifecycle))                ((Lifecycle) resources).start();            // Notify our interested LifecycleListeners            fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null);            // Start our child containers, if not already started            for (Container child : findChildren()) {                if (!child.getState().isAvailable()) {                    child.start();                }            }            // Start the Valves in our pipeline (including the basic),            // if any            if (pipeline instanceof Lifecycle) {                ((Lifecycle) pipeline).start();            }            // Acquire clustered manager            Manager contextManager = null;            Manager manager = getManagerInternal();            if (manager == null) {                if (log.isDebugEnabled()) {                    log.debug(sm.getString(&quot;standardContext.cluster.noManager&quot;,                            Boolean.valueOf((getCluster() != null)),                            Boolean.valueOf(distributable)));                }                if ( (getCluster() != null) &amp;&amp; distributable) {                    try {                        contextManager = getCluster().createManager(getName());                    } catch (Exception ex) {                        log.error(&quot;standardContext.clusterFail&quot;, ex);                        ok = false;                    }                } else {                    contextManager = new StandardManager();                }                manager = contextManager;            }            // Configure default manager if none was specified            if (contextManager != null) {                if (log.isDebugEnabled()) {                    log.debug(sm.getString(&quot;standardContext.manager&quot;,                            contextManager.getClass().getName()));                }                setManager(contextManager);            }            if (manager!=null &amp;&amp; (getCluster() != null) &amp;&amp; distributable) {                //let the cluster know that there is a context that is distributable                //and that it has its own manager                getCluster().registerManager(manager);            }        }    } finally {        // Unbinding thread        unbindThread(oldCCL);    }    if (!getConfigured()) {        log.error(sm.getString(&quot;standardContext.configurationFail&quot;));        ok = false;    }    // We put the resources into the servlet context    if (ok)        getServletContext().setAttribute            (Globals.RESOURCES_ATTR, getResources());    // Initialize associated mapper    mapper.setContext(getPath(), welcomeFiles, getResources());    // Binding thread    oldCCL = bindThread();    if (ok ) {        if (getInstanceManager() == null) {            javax.naming.Context context = null;            if (isUseNaming() &amp;&amp; getNamingContextListener() != null) {                context = getNamingContextListener().getEnvContext();            }            Map&lt;String, Map&lt;String, String&gt;&gt; injectionMap = buildInjectionMap(                    getIgnoreAnnotations() ? new NamingResources(): getNamingResources());            setInstanceManager(new DefaultInstanceManager(context,                    injectionMap, this, this.getClass().getClassLoader()));            getServletContext().setAttribute(                    InstanceManager.class.getName(), getInstanceManager());        }    }    try {        // Create context attributes that will be required        if (ok) {            getServletContext().setAttribute(                    JarScanner.class.getName(), getJarScanner());        }        // Set up the context init params        mergeParameters();        // Call ServletContainerInitializers        for (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :            initializers.entrySet()) {            try {                entry.getKey().onStartup(entry.getValue(),                        getServletContext());            } catch (ServletException e) {                log.error(sm.getString(&quot;standardContext.sciFail&quot;), e);                ok = false;                break;            }        }        // Configure and call application event listeners        if (ok) {            if (!listenerStart()) {                log.error(sm.getString(&quot;standardContext.listenerFail&quot;));                ok = false;            }        }        try {            // Start manager            Manager manager = getManagerInternal();            if ((manager != null) &amp;&amp; (manager instanceof Lifecycle)) {                ((Lifecycle) getManager()).start();            }        } catch(Exception e) {            log.error(sm.getString(&quot;standardContext.managerFail&quot;), e);            ok = false;        }        // Configure and call application filters        if (ok) {            if (!filterStart()) {                log.error(sm.getString(&quot;standardContext.filterFail&quot;));                ok = false;            }        }        // Load and initialize all &quot;load on startup&quot; servlets        if (ok) {            if (!loadOnStartup(findChildren())){                log.error(sm.getString(&quot;standardContext.servletFail&quot;));                ok = false;            }        }        // Start ContainerBackgroundProcessor thread        super.threadStart();    } finally {        // Unbinding thread        unbindThread(oldCCL);    }    // Set available status depending upon startup success    if (ok) {        if (log.isDebugEnabled())            log.debug(&quot;Starting completed&quot;);    } else {        log.error(sm.getString(&quot;standardContext.startFailed&quot;, getName()));    }    startTime=System.currentTimeMillis();    // Send j2ee.state.running notification    if (ok &amp;&amp; (this.getObjectName() != null)) {        Notification notification =            new Notification(&quot;j2ee.state.running&quot;, this.getObjectName(),                             sequenceNumber.getAndIncrement());        broadcaster.sendNotification(notification);    }    // Close all JARs right away to avoid always opening a peak number    // of files on startup    if (getLoader() instanceof WebappLoader) {        ((WebappLoader) getLoader()).closeJARs(true);    }    // Reinitializing if something went wrong    if (!ok) {        setState(LifecycleState.FAILED);    } else {        setState(LifecycleState.STARTING);    }}</code></pre><h4 id="listenerStart方法"><a href="#listenerStart方法" class="headerlink" title="listenerStart方法"></a>listenerStart方法</h4><p>注意<code>listenerStart</code>  ,Configure and call application event listeners 通知所有listeners</p><pre><code class="java">/** * Configure the set of instantiated application event listeners * for this Context.  Return &lt;code&gt;true&lt;/code&gt; if all listeners wre * initialized successfully, or &lt;code&gt;false&lt;/code&gt; otherwise. */public boolean listenerStart() {    if (log.isDebugEnabled())        log.debug(&quot;Configuring application event listeners&quot;);    // Instantiate the required listeners    ApplicationListener listeners[] = applicationListeners;    Object results[] = new Object[listeners.length];    boolean ok = true;    for (int i = 0; i &lt; results.length; i++) {        if (getLogger().isDebugEnabled())            getLogger().debug(&quot; Configuring event listener class &#39;&quot; +                listeners[i] + &quot;&#39;&quot;);        try {            ApplicationListener listener = listeners[i];            results[i] = getInstanceManager().newInstance(                    listener.getClassName());            if (listener.isPluggabilityBlocked()) {                noPluggabilityListeners.add(results[i]);            }        } catch (Throwable t) {            t = ExceptionUtils.unwrapInvocationTargetException(t);            ExceptionUtils.handleThrowable(t);            getLogger().error                (sm.getString(&quot;standardContext.applicationListener&quot;,                              listeners[i].getClassName()), t);            ok = false;        }    }    if (!ok) {        getLogger().error(sm.getString(&quot;standardContext.applicationSkipped&quot;));        return (false);    }    // Sort listeners in two arrays    ArrayList&lt;Object&gt; eventListeners = new ArrayList&lt;Object&gt;();    ArrayList&lt;Object&gt; lifecycleListeners = new ArrayList&lt;Object&gt;();    for (int i = 0; i &lt; results.length; i++) {        if ((results[i] instanceof ServletContextAttributeListener)            || (results[i] instanceof ServletRequestAttributeListener)            || (results[i] instanceof ServletRequestListener)            || (results[i] instanceof HttpSessionAttributeListener)) {            eventListeners.add(results[i]);        }        if ((results[i] instanceof ServletContextListener)            || (results[i] instanceof HttpSessionListener)) {            lifecycleListeners.add(results[i]);        }    }    // Listener instances may have been added directly to this Context by    // ServletContextInitializers and other code via the pluggability APIs.    // Put them these listeners after the ones defined in web.xml and/or    // annotations then overwrite the list of instances with the new, full    // list.    for (Object eventListener: getApplicationEventListeners()) {        eventListeners.add(eventListener);    }    setApplicationEventListeners(eventListeners.toArray());    for (Object lifecycleListener: getApplicationLifecycleListeners()) {        lifecycleListeners.add(lifecycleListener);        if (lifecycleListener instanceof ServletContextListener) {            noPluggabilityListeners.add(lifecycleListener);        }    }    setApplicationLifecycleListeners(lifecycleListeners.toArray());    // Send application start events    if (getLogger().isDebugEnabled())        getLogger().debug(&quot;Sending application start events&quot;);    // Ensure context is not null    getServletContext();    context.setNewServletContextListenerAllowed(false);    Object instances[] = getApplicationLifecycleListeners();    if (instances == null || instances.length == 0) {        return ok;    }    ServletContextEvent event = new ServletContextEvent(getServletContext());    ServletContextEvent tldEvent = null;    if (noPluggabilityListeners.size() &gt; 0) {        noPluggabilityServletContext = new NoPluggabilityServletContext(getServletContext());        tldEvent = new ServletContextEvent(noPluggabilityServletContext);    }    for (int i = 0; i &lt; instances.length; i++) {        if (instances[i] == null)            continue;        if (!(instances[i] instanceof ServletContextListener))            continue;        ServletContextListener listener =            (ServletContextListener) instances[i];        try {            fireContainerEvent(&quot;beforeContextInitialized&quot;, listener);            if (noPluggabilityListeners.contains(listener)) {                listener.contextInitialized(tldEvent);            } else {                listener.contextInitialized(event);            }            fireContainerEvent(&quot;afterContextInitialized&quot;, listener);        } catch (Throwable t) {            ExceptionUtils.handleThrowable(t);            fireContainerEvent(&quot;afterContextInitialized&quot;, listener);            getLogger().error                (sm.getString(&quot;standardContext.listenerStart&quot;,                              instances[i].getClass().getName()), t);            ok = false;        }    }    return (ok);}</code></pre><p>简单总结下,tomcat容器启动后,发出通知ServletContextEvent, ContextLoaderListener接收到后,初始化web应用</p><h2 id="Spring的事件"><a href="#Spring的事件" class="headerlink" title="Spring的事件"></a>Spring的事件</h2><h3 id="ApplicationEvent"><a href="#ApplicationEvent" class="headerlink" title="ApplicationEvent"></a>ApplicationEvent</h3><p>spring里面的主要实现是ApplicationEvent, 这里我们关注它的容器的事件, ApplicationContextEvent,是spring容器在启动时触发的事件对象：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4mw9xtrt9j31p60hydi8.jpg" alt="image-20190703195300527"></p><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><pre><code class="java">@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {   /**    * Handle an application event.    * @param event the event to respond to    */   void onApplicationEvent(E event);}</code></pre><p>那么在spring框架中是怎么发布这些事件的呢？</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><h4 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h4><p>查看<code>ApplicationContext</code> 发现继承了<code>ApplicationEventPublisher</code> </p><pre><code class="java">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,MessageSource, ApplicationEventPublisher, ResourcePatternResolver {        }@FunctionalInterfacepublic interface ApplicationEventPublisher {    /**     * Notify all &lt;strong&gt;matching&lt;/strong&gt; listeners registered with this     * application of an application event. Events may be framework events     * (such as RequestHandledEvent) or application-specific events.     * @param event the event to publish     * @see org.springframework.web.context.support.RequestHandledEvent     */    default void publishEvent(ApplicationEvent event) {                publishEvent((Object) event);    }    /**     * Notify all &lt;strong&gt;matching&lt;/strong&gt; listeners registered with this     * application of an event.     * &lt;p&gt;If the specified {@code event} is not an {@link ApplicationEvent},     * it is wrapped in a {@link PayloadApplicationEvent}.     * @param event the event to publish     * @since 4.2     * @see PayloadApplicationEvent     */    void publishEvent(Object event);}</code></pre><h4 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h4><p>然后publishEvent的实现在<code>AbstractApplicationContext</code> 中</p><pre><code class="java">protected void publishEvent(Object event, @Nullable ResolvableType eventType) {        Assert.notNull(event, &quot;Event must not be null&quot;);        // Decorate event as an ApplicationEvent if necessary        ApplicationEvent applicationEvent;        if (event instanceof ApplicationEvent) {            applicationEvent = (ApplicationEvent) event;        }        else {            applicationEvent = new PayloadApplicationEvent&lt;&gt;(this, event);            if (eventType == null) {                eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();            }        }        // Multicast right now if possible - or lazily once the multicaster is initialized        if (this.earlyApplicationEvents != null) {            this.earlyApplicationEvents.add(applicationEvent);        }        else {            getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);        }        // Publish event via parent context as well...        if (this.parent != null) {            if (this.parent instanceof AbstractApplicationContext) {                ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);            }            else {                this.parent.publishEvent(event);            }        }    }</code></pre><h4 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h4><p>其中调用了委派给了<code>ApplicationEventMulticaster</code>,具体实现在 <code>SimpleApplicationEventMulticaster</code></p><pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {    @Override    public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {        ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));        for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {            Executor executor = getTaskExecutor();            if (executor != null) {                executor.execute(() -&gt; invokeListener(listener, event));            }            else {                invokeListener(listener, event);            }        }    }}</code></pre><p> 至此,事件机制完事啦.  (啊!信息量有点大)</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>信息量有点大,就再附赠点东西吧…. 在<code>ContextLoader#initWebApplicationContext</code> 方法中有关于getContextClassLoader</p><pre><code class="java">public class ContextLoader {    public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {        if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {            throw new IllegalStateException(                    &quot;Cannot initialize context because there is already a root application context present - &quot; +                    &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);        }        Log logger = LogFactory.getLog(ContextLoader.class);        servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);        if (logger.isInfoEnabled()) {            logger.info(&quot;Root WebApplicationContext: initialization started&quot;);        }        long startTime = System.currentTimeMillis();        try {            // Store context in local instance variable, to guarantee that            // it is available on ServletContext shutdown.            if (this.context == null) {                this.context = createWebApplicationContext(servletContext);            }            if (this.context instanceof ConfigurableWebApplicationContext) {                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;                if (!cwac.isActive()) {                    // The context has not yet been refreshed -&gt; provide services such as                    // setting the parent context, setting the application context id, etc                    if (cwac.getParent() == null) {                        // The context instance was injected without an explicit parent -&gt;                        // determine parent for root web application context, if any.                        ApplicationContext parent = loadParentContext(servletContext);                        cwac.setParent(parent);                    }                    configureAndRefreshWebApplicationContext(cwac, servletContext);                }            }            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);            ClassLoader ccl = Thread.currentThread().getContextClassLoader();            if (ccl == ContextLoader.class.getClassLoader()) {                currentContext = this.context;            }            else if (ccl != null) {                currentContextPerThread.put(ccl, this.context);            }                   //....    }}</code></pre><p>其中, ClassLoader ccl = Thread.currentThread().getContextClassLoader(); </p><p>层次结构是WebAppClassLoader -&gt;URLClassLoader。-&gt;AppClassLoader-&gt;ExtClassLoader-&gt;null</p><p>注意⚠️ : 其中URLClassLoader 对应的是Tomcat ClassLoader中的common (可以看之前的一篇文章哈,servlet-tomcat)</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4mxg1xal0j311w06iq50.jpg" alt="img"></p><p>More details see:</p><blockquote><p><a href="http://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Tomcat Class Loader</a></p><p><a href="https://docs.oracle.com/javase/tutorial/ext/basics/load.html" target="_blank" rel="noopener">Java Class Loader</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> tomcat </tag>
            
            <tag> classLoader </tag>
            
            <tag> servlet </tag>
            
            <tag> event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview_Elasticsearch</title>
      <link href="/2019/06/26/Overview_Elasticsearch/"/>
      <url>/2019/06/26/Overview_Elasticsearch/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4eq0uiv34j30sg0sgdlr.jpg" alt="image-20190626181209162"></p><a id="more"></a><p>图先放好,字慢慢码</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Elasticsearch is a highly scalable open-source full-text search and analytics engine. It allows you to store, search, and analyze big volumes of data quickly and in near real time. It is generally used as the underlying engine/technology that powers applications that have complex search features and requirements.</p></blockquote><p>​    Elasticsearch是一个高度可扩展的开源全文搜索和分析引擎。它允许您快速，近实时地存储，搜索和分析大量数据。它通常用作底层引擎/技术，为具有复杂搜索功能和要求的应用程序提供支持。</p><h3 id="Elastic-Stack"><a href="#Elastic-Stack" class="headerlink" title="Elastic Stack"></a>Elastic Stack</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4fjxdjsklj31kc0u077y.jpg" alt="image-20190627112646014"></p><p>Elastic Stack 是原 ELK Stack 在 5.0 版本加入 Beats 套件后的新称呼</p><ul><li>Logstash用于数据采集 (新增轻量级Beats)</li><li>Kibana用于数据展示</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>您运行在线网上商店，允许您的客户搜索您销售的产品。</li><li>您运行价格警报平台，允许精通价格的客户指定一条规则，例如“我有兴趣购买特定的电子产品，如果小工具的价格在下个月内从任何供应商降至X美元以下，我希望收到通知” </li><li>您希望收集日志或交易数据，并且希望分析和挖掘此数据以查找趋势，统计信息，摘要或异常。在这种情况下，您可以使用Logstash（Elasticsearch / Logstash / Kibana堆栈的一部分）来收集，聚合和解析数据，然后让Logstash将此数据提供给Elasticsearch。</li><li>您有分析/商业智能需求，并希望快速调查，分析，可视化并询问有关大量数据的特定问题。使用Elasticsearch存储数据，然后使用Kibana（Elasticsearch / Logstash / Kibana堆栈的一部分）构建自定义仪表板，以便可视化数据</li></ul><h2 id="版本特征"><a href="#版本特征" class="headerlink" title="版本特征"></a>版本特征</h2><p>Shay Banon在2010年2月发布了Elasticsearch的第一个版本。</p><ul><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/breaking-changes-2.0.html" target="_blank" rel="noopener">2.x</a> (2015)</p><ul><li><strong>doc_values</strong>  排序聚合支持,默认开启</li><li><strong>Mapping 变化</strong> 字段名不要包含 dot 、type 不长于255字符等</li><li><strong>Filtered Query</strong> deprecated</li></ul></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/breaking-changes-5.0.html" target="_blank" rel="noopener">5.x</a> ( 2016) ES官方在5.x时代统一了 ELK体系的版本号</p><ul><li><p>支持Lucene6版本，其中最重要的特性就是 Dimensional Point Fields, “磁盘空间少一半；索引时间少一半；” ，Merge 时间和 JVM Heap 占用都会减少，索引本身的性能也提升。</p><p>  “查询性能提升25%；IPV6也支持了</p></li><li><p>ProfileAPI、ShrinkAPI、RolloverAPI、ReindexAPI</p></li><li><p>Search After ,search 接口的一个新实现，使得你可以深度翻页。这个弥补了 scroll 和 search 的不足</p></li><li><p>String类型被text/keyword 两个类型取代,分别代表分词和部分词</p></li><li><p>索引级别设置不能再写到yml配置文件,需要为每个索引单独设置或写到模板中</p></li><li><p>TaskManager,重建索引等任务被管理,可以观察任务状态</p></li></ul></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/breaking-changes-6.0.html" target="_blank" rel="noopener">6.x</a> (2017)</p><ul><li>每个索引支持一个_type</li><li>默认禁用_all字段</li><li>优化了doc_values,占用磁盘空间更少,读写速度更快</li><li>模板规则定义方式由template改为index_patterns</li><li>增加序列ID,加快索引恢复速度</li></ul></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/breaking-changes-7.0.html" target="_blank" rel="noopener">7.x</a>(2019) </p><ul><li><strong>查询相关性速度优化</strong> Weak-AND算法在Term Query查询场景有3700%的性能提升。</li><li>引入新的集群协调子系统</li><li>默认分片数不再是5，而是1</li><li>安装包自带JDK环境</li><li>集群中默认节点名字不再随机提供，改为获取hostname</li><li>mapping与query阶段不再支持多type操作</li></ul></li></ul><blockquote><p><a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch" target="_blank" rel="noopener">release note</a></p><p><a href="https://www.elastic.co/cn/about/history-of-elasticsearch#group-3" target="_blank" rel="noopener">history</a></p></blockquote><h2 id="初识Elasticsearch"><a href="#初识Elasticsearch" class="headerlink" title="初识Elasticsearch"></a>初识Elasticsearch</h2><p>基于Elasticsearch 6.x</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html#_near_realtime_nrt" target="_blank" rel="noopener">Near Realtime (NRT)</a></p><p>  Elasticsearch is a near real time search platform. What this means is there is a slight latency (normally one second) from the time you index a document until the time it becomes searchable.</p><p>  Elasticsearch是一个近乎实时的搜索平台。这意味着从索引文档到可搜索文档的时间有一点延迟（通常是一秒）</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html#_cluster" target="_blank" rel="noopener">Cluster</a></p><p>  A cluster is a collection of one or more nodes (servers) that together holds your entire data and provides federated indexing and search capabilities across all nodes.</p><p>  集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html#_node" target="_blank" rel="noopener">Node</a></p><p>  A node is a single server that is part of your cluster, stores your data, and participates in the cluster’s indexing and search capabilities.</p><p>  节点是作为群集一部分的单个服务器，存储数据并参与群集的索引和搜索功能。</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html#_index" target="_blank" rel="noopener">Index</a></p><p>  An index is a collection of documents that have somewhat similar characteristics</p><p>  索引是具有某些类似特征的文档集合。</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html#_type" target="_blank" rel="noopener">Type</a></p><p>  A type used to be a logical category/partition of your index to allow you to store different types of documents in the same index</p><p>  一种类型，曾经是索引的逻辑类别/分区，允许您在同一索引中存储不同类型的文档. Deprecated in 6.0.0.</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html#_document" target="_blank" rel="noopener">Document</a></p><p>  A document is a basic unit of information that can be indexed. This document is expressed in <a href="http://json.org/" target="_blank" rel="noopener">JSON</a> (JavaScript Object Notation) which is a ubiquitous internet data interchange format.Within an index/type, you can store as many documents as you want. Note that although a document physically resides in an index, a document actually must be indexed/assigned to a type inside an index.</p><p>  文档是可以编制索引的基本信息单元。该文档以JSON（JavaScript Object Notation）表示，JSON是一种普遍存在的互联网数据交换格式。</p></li><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html#getting-started-shards-and-replicas" target="_blank" rel="noopener">Shards &amp; Replicas</a></p><ul><li>Sharding is important for two primary reasons:<ul><li>It allows you to horizontally split/scale your content volume</li><li>It allows you to distribute and parallelize operations across shards (potentially on multiple nodes) thus increasing performance/throughput</li></ul></li><li><p>Replication is important for two primary reasons:</p><ul><li>It provides high availability in case a shard/node fails. For this reason, it is important to note that a replica shard is never allocated on the same node as the original/primary shard that it was copied from.</li><li>It allows you to scale out your search volume/throughput since searches can be executed on all replicas in parallel.</li></ul><p>分片: 水平扩展、提高并发度</p><p>副本: 高可用(副本不会在同个节点上)、提高并发度</p></li></ul></li></ul><pre><code>关系图![img](http://ww3.sinaimg.cn/large/006tNc79gy1g4l8acf7qoj30ry07nq47.jpg)</code></pre><blockquote><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/_basic_concepts.html" target="_blank" rel="noopener">More details see</a></p></blockquote><h3 id="集群健康度"><a href="#集群健康度" class="headerlink" title="集群健康度"></a>集群健康度</h3><ul><li>Green - everything is good (cluster is fully functional)</li><li>Yellow - all data is available but some replicas are not yet allocated (cluster is fully functional)</li><li>Red - some data is not available for whatever reason (cluster is partially functional)</li></ul><h3 id="集群节点角色"><a href="#集群节点角色" class="headerlink" title="集群节点角色"></a>集群节点角色</h3><ul><li><p>主节点(Master node)</p><blockquote><p>The master node is responsible for lightweight cluster-wide actions such as creating or deleting an index, tracking which nodes are part of the cluster, and deciding which shards to allocate to which nodes. It is important for cluster health to have a stable master node.</p><p>Indexing and searching your data is CPU-, memory-, and I/O-intensive work which can put pressure on a node’s resources. To ensure that your master node is stable and not under pressure, it is a good idea in a bigger cluster to split the roles between dedicated master-eligible nodes and dedicated data nodes.</p><p>To prevent data loss, it is vital to configure the <code>discovery.zen.minimum_master_nodes</code> setting (which defaults to <code>1</code>) so that each master-eligible node knows the <em>minimum number of master-eligible nodes</em> that must be visible in order to form a cluster.</p><p>This setting should be set to a <em>quorum</em> of master-eligible nodes:</p><pre><code>(master_eligible_nodes / 2) + 1</code></pre></blockquote><p>  负责集群层面的相关操作,管理集群变更.也可以作为数据节点,但尽可能做少量的工作,尽量分离主节点和数据节点,同时为了防止网络分区时多主的情况(脑裂),需要设置有资格成为主节点的数量.</p></li><li><p>数据节点(Data node)</p><p>  Data nodes hold the shards that contain the documents you have indexed. Data nodes handle data related operations like CRUD, search, and aggregations. These operations are I/O-, memory-, and CPU-intensive. It is important to monitor these resources and to add more data nodes if they are overloaded.</p><p>  负责保存数据、执行数据相关操作:CRUD、搜索、聚合等.  </p></li><li><p>预处理节点(Ingest node)</p><p>  Ingest nodes can execute pre-processing pipelines, composed of one or more ingest processors. Depending on the type of operations performed by the ingest processors and the required resources, it may make sense to have dedicated ingest nodes, that will only perform this specific task.</p><p>  5.0引入.预处理操作允许在索引文档之前,即写入数据之前.通过事先定义好的一系列processors和pipeline,对数据进行某种转换、富化.  拦截bluk和index请求</p></li><li><p>协调节点(Coordinating node)</p><p>  If you take away the ability to be able to handle master duties, to hold data, and pre-process documents, then you are left with a <em>coordinating</em> node that can only route requests, handle the search reduce phase, and distribute bulk indexing. Essentially, coordinating only nodes behave as smart load balancers.</p><p>  协调节点将请求转发给保存数据的节点,每个数据节点在本地执行请求,并将结果返回协调节点.协调节点收集完数据后,将每个数据节点的结果合并为单个全局结果.对结果手机和排序的过程可能需要很多CPU和内存资源(协调节点过多也会成为负担,主节点必须等待各节点集群状态更新)</p></li><li><p>部落节点(Tribe node)</p><p>  A tribe node, configured via the <code>tribe.*</code> settings, is a special type of coordinating only node that can connect to multiple clusters and perform search and other operations across all connected clusters.</p><p>  允许部落节点在多个集群间充当联合客户端</p></li></ul><p>​    By default a node is a master-eligible node and a data node, plus it can pre-process documents through ingest pipelines. This is very convenient for small clusters but, as the cluster grows, it becomes important to consider separating dedicated master-eligible nodes from dedicated data nodes.</p><pre><code class="yaml">node.master: true node.data: true node.ingest: true search.remote.connect: true </code></pre><blockquote><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/modules-node.html" target="_blank" rel="noopener">More details see</a></p></blockquote><h3 id="内部模块简介"><a href="#内部模块简介" class="headerlink" title="内部模块简介"></a>内部模块简介</h3><ul><li><p>Cluster</p><p>  Cluster模块是主节点执行集群管理的封装实现,管理集群状态,维护集群层面的配置信息.</p><p>  主要功能如下:</p><ul><li>管理集群状态</li><li>调用allocation模块执行分片分配,决策哪些分片应该分配到哪个节点</li><li>在集群各节点中直接迁移分片,保持数据平衡</li></ul></li><li><p>allocation</p><p>  封装了分片分配相关的功能和策略,包括主分片的分配和副分配的分配,本模块由主节点调用.</p><p>  创建新索引、集群完全重启都需要分片分配的过程.</p></li><li><p>Discovery</p><p>  发现模块负责发现集群中的节点,以及选举主节点.当节点加入或退出集群时,主节点回采取相应的行动(类似Zookeeper)</p></li><li><p>gateway</p><p>  负责对收到Master广播下看来对集群状态(cluster state)数据持久化存储,并在集群完全重启时恢复它们</p></li><li><p>indices</p><p>  索引模块管理全局级的索引设置,不包含索引级的(索引设置分为全局级和每个索引级)</p><p>  它还封装了索引数据恢复功能.集群启动阶段需要主分片恢复和副分片恢复就是在这个模块实现的.</p></li><li><p>HTTP</p><p>  允许通过HTTP的方式访问ES的API,HTTP模块本质上是完全异步的,解决了C10K问题(10K量级的并发连接),部分场景可以考虑使用HTTP keepalive提升性能</p></li><li><p>Transport</p><p>  传输模块用于集群内节点之间的内部通信.传输本质也是完全异步的,使用TCP通信,每个节点都与其他节点维持若干TCP长连接.</p></li><li><p>Engine</p><p>  Engine模块封装了对Lucene的操作以及translog的调用,它是对一个分片读写操作的最终提供者</p></li></ul><p>Es使用Guice框架(Google开发的轻量级依赖注入框架IoC)进行模块画管理</p><h2 id="集群启动流程"><a href="#集群启动流程" class="headerlink" title="集群启动流程"></a>集群启动流程</h2><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4ladwvzp1j30dg05w0t6.jpg" alt="img"></p><ul><li><p>选举主节点</p><p>  ​    选主是对Bully算法的改进，主要思路是对节点 ID 排序，取最大值做 master，每个节点都运行这个流程。</p><ul><li>参数人数过半</li><li>得票数过半</li><li><p>探测节点离开时,判断当前节点过半</p><p>选举集群元信息</p><p>被选出的 Master 和集群元信息的新旧程度没有关系。因此他的第一个任务是选举元信息， 让各节点把其各自存储的元信息发过来，根据版本号确定最新的元信息，然后把这个信息广播下去，这样，集群的所有节点都有了最新的元信息。</p><p>元信息的选举包括两个级别的：集群级和索引级。</p></li></ul></li><li><p>allocation 过程</p><p>  选举 shard 级元信息，构建路由表，是在 allocation 模块完成的。初始阶段，所有的 shard 都处于UNASSIGNED状态。此时，首先要做的是分配主分片。</p></li><li><p>index recovery</p><ul><li><p>主分片 recovery</p><p>  对于主分片来说，这些未刷盘数据可以从 translog 恢复，每次刷盘完毕，translog 都会被清空，因此把 translog 中的数据全部重放，建立 lucene 索引，如此完成主分片的 recovery。</p></li><li><p>副分片 recovery</p><p>  副分片需要恢复成与主分片一致，同时，恢复期间允许新的索引操作。因此在主分片所在节点，调用 lucene 接口把 shard 做快照。恢复进入：</p><ul><li>第一阶段：把 shard 数据拷贝到副本节点。如果主副两 shard 有相同的 syncid 且 doc 数相同，则跳过这个阶段。在第一阶段完毕前，会向副分片阶段发送告知对方启动 engine，<strong>在第二阶段开始之前，副分片就可以正常处理写请求了</strong>。</li><li>第二阶段：对 translog 做快照，这个快照里包含从第一个节点开始的新增索引.</li></ul></li></ul></li></ul><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4laj0gvvxj30hq0wlwih.jpg" alt="img"></p><blockquote><p><a href="https://www.easyice.cn/archives/261" target="_blank" rel="noopener">More details see</a></p></blockquote><h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p><em>新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本</em></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4koc1e4jej30ku09dt91.jpg" alt="img"></p><h3 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h3><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4kod03zfbj318n0u0k1z.jpg" alt="img"></p><p><a href="https://www.easyice.cn/archives/180" target="_blank" rel="noopener">More details see</a></p><h2 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h2><h3 id="GET流程"><a href="#GET流程" class="headerlink" title="GET流程"></a>GET流程</h3><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4koszf6fyj30rw0aagmk.jpg" alt="img"></p><p>整体分为五个阶段:准备集群信息,内容路由,协调请求,数据读取,回复客户端。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4kohccg9aj30za0t0dj9.jpg" alt="img"></p><h3 id="Search流程"><a href="#Search流程" class="headerlink" title="Search流程"></a>Search流程</h3><h4 id="索引和搜索"><a href="#索引和搜索" class="headerlink" title="索引和搜索"></a>索引和搜索</h4><p>ES中的数据可以分成两类 : 精确值和全文(mapping中指定类型)</p><ul><li>精确值 , 日期和用户id、IP地址等</li><li>全文 , 指文本内容,日志或邮件内容  (会经过分析器 , 字符过滤器、分词器Tokenizer、Tonken过滤器、语言处理, 生成词Term ,生成倒排和正排索引)</li></ul><h4 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h4><p>增删改查操作只对单个文档进行处理,通常由 _index, _type, 和 _id三元组来确定唯一文档。但搜索需要一种更复杂的模型，因为不知道查询会命中哪些文档。一个搜索请求必须询问指定索引的<strong>所有分片中的某个副本</strong>来进行匹配。假设一个索引有5个主分片，1个副本分片，共10个分片，一次搜索请求会由5个分片来共同完成，他们有可能是主分片，也可能是副分片。也就是说，<strong>一次搜索请求只会命中所有副本中的一个</strong>。</p><p>找到匹配文档仅仅完成了一半，多分片中的结果必须组合成单个排序列表。集群的任意节点都可以接受搜索请求，接收客户端请求的节点成为协调节点，在协调节点，搜索任务被执行成一个两阶段过程，称之为 query then fetch 。 真正执行搜索任务的节点暂且称为数据节点。</p><p>#### </p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4koo5tl4tj30fq0lrmzz.jpg" alt="img"></p><h2 id="相关优化"><a href="#相关优化" class="headerlink" title="相关优化"></a>相关优化</h2><h3 id="写入速度优化"><a href="#写入速度优化" class="headerlink" title="写入速度优化"></a>写入速度优化</h3><p>综合来说提升写入速度从以下几方面入手:</p><ul><li><p>加大translog flush间隔 ,目的降低iops、writeblock</p><p>  允许接受部分数据丢失,可以调整translog持久化策略的周期性和大小(Es2.x 开始,默认配置为每次请求都“flush”)</p><pre><code class="yaml">  index.translog.durability : async  Index.translog.sync_interval : 5s  Index.translog.flush_threshod_size : 512mb</code></pre></li><li><p>加大index refresh间隔,除了降低I/O,更重要的是降低了segment merge频率</p><p>  每次索引refresh会产生一个新的Lucene段,这会导致频繁的segment merge(I/O和内存占用都比较高)行为</p><pre><code class="yaml">  index.refresh_interval : 1s</code></pre></li><li><p>调整bluk请求</p><ul><li>bulk线程池和队列(建立索引属于计算密集型)</li><li><p>并发执行bulk请求(瓶颈在CPU)</p><p>为避免给集群带来内存压力,每个请求最好避免超过几十兆字节</p></li></ul></li><li><p>优化磁盘间的任务均匀情况,将shard尽量均匀分布在物理主机的各个磁盘</p><ul><li>简单轮询 : 在系统初始化阶段,简单轮询的效果是最均匀的</li><li>基于可用空间的动态加权轮询 : 以可用空间作为权重,在磁盘之间加权轮询</li></ul></li><li><p>优化节点间的任务分布,将任务尽量均匀地发到各节点</p><p>  数据写入客户端应该把bulk请求轮询发送到各个节点</p></li><li><p>优化Lucene层建立索引过程,目的降低CPU占用率及I/O,例如禁用_all字段</p><ul><li>自动生成doc ID</li><li>调整字段Mappings<ul><li>减少字段数量</li><li>减少建立索引的字段</li><li>减少字段内容</li><li>使用不同分析器(analyzer)</li></ul></li><li>调整_source字段</li><li>禁用_all字段</li><li>对Analyzed字段禁用Norms(评分)</li><li>index_options设置</li></ul></li></ul><h3 id="搜索速度优化"><a href="#搜索速度优化" class="headerlink" title="搜索速度优化"></a>搜索速度优化</h3><ul><li>为文件系统cache预留足够的内存 (第一性能因子)</li><li>使用更快的硬件</li><li>搜索尽可能少的字段</li><li>预索引数据</li><li>预热 (全局预热、文件系统)</li><li>副本(ARS 一主二副)</li><li>冷热分离(通过索引区分冷、热数据)</li><li>模型设计(仅需要索引的字段放在es,完整数据放在Hbase)</li><li>分页优化(不允许深度分页,使用scroll api)</li></ul><blockquote><p>现在假设你有一个2分片索引和两个节点。在一种情况下，副本的数量是0，这意味着每个节点拥有一个分片。在第二种情况下，副本的数量是1，这意味着每个节点具有两个分片。哪种设置在搜索性能方面表现最佳？通常，每个节点总共具有较少分片的设置将表现得更好。原因是它为每个分片提供了更大的可用文件系统缓存份额，而文件系统缓存可能是Elasticsearch的第一性能因子。同时，请注意，在单节点发生故障的情况下，没有副本的设置会出现故障，因此在吞吐量和可用性之间需要进行权衡。</p></blockquote><p>参考:</p><blockquote><p><a href="https://www.easyice.cn/%e6%89%80%e6%9c%89%e6%96%87%e7%ab%a0" target="_blank" rel="noopener">ELASTICSEARCH 源码解析与优化实战</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">官方文档</a></p></blockquote><p>冷热思路</p><p><a href="https://zhuanlan.zhihu.com/p/99718374?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/99718374?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J.U.C_ConcurrentHashMap</title>
      <link href="/2019/06/24/J-U-C-ConcurrentHashMap/"/>
      <url>/2019/06/24/J-U-C-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4cgatpl82j30qo0k03zd.jpg" alt="img"></p><a id="more"></a><h2 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h2><p>​    做为办公室的游泳健将,鱼是不可能不摸的. 今天在查找接口文档的时候,发现一些业务,像商详、秒杀,这些抗流都是使用的本地缓存,  第二层再是redis. </p><p>​    那么本地缓存一般会使用的都是Map结构(例如key为skuId), 现在使用最多的就是Guava Cache,  然而Spring5即将放弃掉Guava Cache作为缓存机制，而改用Caffeine作为新的本地Cache的组件.(至于为啥,不是一两句能够讲清的 主要是性能,其次是语言方面 函数式编程) 这些实现都是基于今天要讲的CHM</p><p>​    PS:以下内容基于JDK 1.8</p><h2 id="Map-Implementations"><a href="#Map-Implementations" class="headerlink" title="Map Implementations"></a>Map Implementations</h2><p>CHM是Map 的一种实现, 这里再简单说说Map的其他实现. Map的实现分为通用实现(General-Purpose Map Implementations)，专用实现(Special-Purpose Map Implementations)和并发实现(Concurrent Map Implementations)。</p><p><a href="https://docs.oracle.com/javase/tutorial/collections/implementations/map.html" target="_blank" rel="noopener">More see here</a>  (Map接口在1.8有挺多改动的,例如complete 、merge)</p><h3 id="General-Purpose-Map-Implementations"><a href="#General-Purpose-Map-Implementations" class="headerlink" title="General-Purpose Map Implementations"></a>General-Purpose Map Implementations</h3><blockquote><p>The three general-purpose <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" target="_blank" rel="noopener"><code>Map</code></a> implementations are <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" target="_blank" rel="noopener"><code>HashMap</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener"><code>TreeMap</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener"><code>LinkedHashMap</code></a>.If you need <code>SortedMap</code> operations or key-ordered <code>Collection</code>-view iteration, use <code>TreeMap</code>; if you want maximum speed and don’t care about iteration order, use <code>HashMap</code>; if you want near-<code>HashMap</code> performance and insertion-order iteration, use <code>LinkedHashMap</code></p></blockquote><p>TreeMap 用于排序 </p><p>LinkedHashMap 额外维护一个队列, 可以用它来简单实现一个LRU算法</p><h3 id="Special-Purpose-Map-Implementations"><a href="#Special-Purpose-Map-Implementations" class="headerlink" title="Special-Purpose Map Implementations"></a>Special-Purpose Map Implementations</h3><blockquote><p>There are three special-purpose Map implementations — <a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html" target="_blank" rel="noopener"><code>EnumMap</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html" target="_blank" rel="noopener"><code>WeakHashMap</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html" target="_blank" rel="noopener"><code>IdentityHashMap</code></a>. <code>EnumMap</code>, which is internally implemented as an <code>array</code>, is a high-performance <code>Map</code> implementation for use with enum keys. This implementation combines the richness and safety of the <code>Map</code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code>EnumMap</code> in preference to an array.</p><p><code>WeakHashMap</code> is an implementation of the <code>Map</code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code>WeakHashMap</code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing “registry-like” data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p><p><code>IdentityHashMap</code> is an identity-based <code>Map</code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based “node table” that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting “spoof attacks” that are a result of intentionally perverse <code>equals</code> methods because <code>IdentityHashMap</code> never invokes the <code>equals</code> method on its keys. An added benefit of this implementation is that it is fast</p></blockquote><p>IdentityHashMap 不用调用equals ,而是使用==判断</p><h3 id="Concurrent-Map-Implementations"><a href="#Concurrent-Map-Implementations" class="headerlink" title="Concurrent Map Implementations"></a>Concurrent Map Implementations</h3><blockquote><p><code>ConcurrentHashMap</code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code>Hashtable</code>: in addition to implementing <code>ConcurrentMap</code>, it supports all the legacy methods peculiar to <code>Hashtable</code>. Again, if you don’t need the legacy operations, be careful to manipulate it with the <code>ConcurrentMap</code> interface.</p></blockquote><p>​    CHM是Hashtable的代替者, 至于原因嘛, 当然是性能啦. Hashtable 的实现是简单的在方法上面加synchronized ,这样会导致锁的竞争对象是实例本身.(如果是static 方法 锁的是整个类对象)</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>通常我们应该站在实现者的角度,而不仅仅是使用者的角度, 通过猜测作者的意图, 换位思考,换成我来实现我会怎么做</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><pre><code class="java">/*     * Overview:     *     * The primary design goal of this hash table is to maintain     * concurrent readability (typically method get(), but also     * iterators and related methods) while minimizing update     * contention. Secondary goals are to keep space consumption about     * the same or better than java.util.HashMap, and to support high     * initial insertion rates on an empty table by many threads.     *     * This map usually acts as a binned (bucketed) hash table.  Each     * key-value mapping is held in a Node.  Most nodes are instances     * of the basic Node class with hash, key, value, and next     * fields. However, various subclasses exist: TreeNodes are     * arranged in balanced trees, not lists.  TreeBins hold the roots     * of sets of TreeNodes. ForwardingNodes are placed at the heads     * of bins during resizing. ReservationNodes are used as     * placeholders while establishing values in computeIfAbsent and     * related methods.  The types TreeBin, ForwardingNode, and     * ReservationNode do not hold normal user keys, values, or     * hashes, and are readily distinguishable during search etc     * because they have negative hash fields and null key and value     * fields. (These special nodes are either uncommon or transient,     * so the impact of carrying around some unused fields is     * insignificant.)     *     * The table is lazily initialized to a power-of-two size upon the     * first insertion.  Each bin in the table normally contains a     * list of Nodes (most often, the list has only zero or one Node).     * Table accesses require volatile/atomic reads, writes, and     * CASes.  Because there is no other way to arrange this without     * adding further indirections, we use intrinsics     * (sun.misc.Unsafe) operations.     *     * We use the top (sign) bit of Node hash fields for control     * purposes -- it is available anyway because of addressing     * constraints.  Nodes with negative hash fields are specially     * handled or ignored in map methods.     *     * Insertion (via put or its variants) of the first node in an     * empty bin is performed by just CASing it to the bin.  This is     * by far the most common case for put operations under most     * key/hash distributions.  Other update operations (insert,     * delete, and replace) require locks.  We do not want to waste     * the space required to associate a distinct lock object with     * each bin, so instead use the first node of a bin list itself as     * a lock. Locking support for these locks relies on builtin     * &quot;synchronized&quot; monitors.     *     * Using the first node of a list as a lock does not by itself     * suffice though: When a node is locked, any update must first     * validate that it is still the first node after locking it, and     * retry if not. Because new nodes are always appended to lists,     * once a node is first in a bin, it remains first until deleted     * or the bin becomes invalidated (upon resizing).     *     * The main disadvantage of per-bin locks is that other update     * operations on other nodes in a bin list protected by the same     * lock can stall, for example when user equals() or mapping     * functions take a long time.  However, statistically, under     * random hash codes, this is not a common problem.  Ideally, the     * frequency of nodes in bins follows a Poisson distribution     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a     * parameter of about 0.5 on average, given the resizing threshold     * of 0.75, although with a large variance because of resizing     * granularity. Ignoring variance, the expected occurrences of     * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The     * first values are:     *     * 0:    0.60653066     * 1:    0.30326533     * 2:    0.07581633     * 3:    0.01263606     * 4:    0.00157952     * 5:    0.00015795     * 6:    0.00001316     * 7:    0.00000094     * 8:    0.00000006     * more: less than 1 in ten million     *     * Lock contention probability for two threads accessing distinct     * elements is roughly 1 / (8 * #elements) under random hashes.     *     * Actual hash code distributions encountered in practice     * sometimes deviate significantly from uniform randomness.  This     * includes the case when N &gt; (1&lt;&lt;30), so some keys MUST collide.     * Similarly for dumb or hostile usages in which multiple keys are     * designed to have identical hash codes or ones that differs only     * in masked-out high bits. So we use a secondary strategy that     * applies when the number of nodes in a bin exceeds a     * threshold. These TreeBins use a balanced tree to hold nodes (a     * specialized form of red-black trees), bounding search time to     * O(log N).  Each search step in a TreeBin is at least twice as     * slow as in a regular list, but given that N cannot exceed     * (1&lt;&lt;64) (before running out of addresses) this bounds search     * steps, lock hold times, etc, to reasonable constants (roughly     * 100 nodes inspected per operation worst case) so long as keys     * are Comparable (which is very common -- String, Long, etc).     * TreeBin nodes (TreeNodes) also maintain the same &quot;next&quot;     * traversal pointers as regular nodes, so can be traversed in     * iterators in the same way.     *     * The table is resized when occupancy exceeds a percentage     * threshold (nominally, 0.75, but see below).  Any thread     * noticing an overfull bin may assist in resizing after the     * initiating thread allocates and sets up the replacement array.     * However, rather than stalling, these other threads may proceed     * with insertions etc.  The use of TreeBins shields us from the     * worst case effects of overfilling while resizes are in     * progress.  Resizing proceeds by transferring bins, one by one,     * from the table to the next table. However, threads claim small     * blocks of indices to transfer (via field transferIndex) before     * doing so, reducing contention.  A generation stamp in field     * sizeCtl ensures that resizings do not overlap. Because we are     * using power-of-two expansion, the elements from each bin must     * either stay at same index, or move with a power of two     * offset. We eliminate unnecessary node creation by catching     * cases where old nodes can be reused because their next fields     * won&#39;t change.  On average, only about one-sixth of them need     * cloning when a table doubles. The nodes they replace will be     * garbage collectable as soon as they are no longer referenced by     * any reader thread that may be in the midst of concurrently     * traversing table.  Upon transfer, the old table bin contains     * only a special forwarding node (with hash field &quot;MOVED&quot;) that     * contains the next table as its key. On encountering a     * forwarding node, access and update operations restart, using     * the new table.     *     * Each bin transfer requires its bin lock, which can stall     * waiting for locks while resizing. However, because other     * threads can join in and help resize rather than contend for     * locks, average aggregate waits become shorter as resizing     * progresses.  The transfer operation must also ensure that all     * accessible bins in both the old and new table are usable by any     * traversal.  This is arranged in part by proceeding from the     * last bin (table.length - 1) up towards the first.  Upon seeing     * a forwarding node, traversals (see class Traverser) arrange to     * move to the new table without revisiting nodes.  To ensure that     * no intervening nodes are skipped even when moved out of order,     * a stack (see class TableStack) is created on first encounter of     * a forwarding node during a traversal, to maintain its place if     * later processing the current table. The need for these     * save/restore mechanics is relatively rare, but when one     * forwarding node is encountered, typically many more will be.     * So Traversers use a simple caching scheme to avoid creating so     * many new TableStack nodes. (Thanks to Peter Levart for     * suggesting use of a stack here.)     *     * The traversal scheme also applies to partial traversals of     * ranges of bins (via an alternate Traverser constructor)     * to support partitioned aggregate operations.  Also, read-only     * operations give up if ever forwarded to a null table, which     * provides support for shutdown-style clearing, which is also not     * currently implemented.     *     * Lazy table initialization minimizes footprint until first use,     * and also avoids resizings when the first operation is from a     * putAll, constructor with map argument, or deserialization.     * These cases attempt to override the initial capacity settings,     * but harmlessly fail to take effect in cases of races.     *     * The element count is maintained using a specialization of     * LongAdder. We need to incorporate a specialization rather than     * just use a LongAdder in order to access implicit     * contention-sensing that leads to creation of multiple     * CounterCells.  The counter mechanics avoid contention on     * updates but can encounter cache thrashing if read too     * frequently during concurrent access. To avoid reading so often,     * resizing under contention is attempted only upon adding to a     * bin already holding two or more nodes. Under uniform hash     * distributions, the probability of this occurring at threshold     * is around 13%, meaning that only about 1 in 8 puts check     * threshold (and after resizing, many fewer do so).     *     * TreeBins use a special form of comparison for search and     * related operations (which is the main reason we cannot use     * existing collections such as TreeMaps). TreeBins contain     * Comparable elements, but may contain others, as well as     * elements that are Comparable but not necessarily Comparable for     * the same T, so we cannot invoke compareTo among them. To handle     * this, the tree is ordered primarily by hash value, then by     * Comparable.compareTo order if applicable.  On lookup at a node,     * if elements are not comparable or compare as 0 then both left     * and right children may need to be searched in the case of tied     * hash values. (This corresponds to the full list search that     * would be necessary if all elements were non-Comparable and had     * tied hashes.) On insertion, to keep a total ordering (or as     * close as is required here) across rebalancings, we compare     * classes and identityHashCodes as tie-breakers. The red-black     * balancing code is updated from pre-jdk-collections     * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)     * based in turn on Cormen, Leiserson, and Rivest &quot;Introduction to     * Algorithms&quot; (CLR).     *     * TreeBins also require an additional locking mechanism.  While     * list traversal is always possible by readers even during     * updates, tree traversal is not, mainly because of tree-rotations     * that may change the root node and/or its linkages.  TreeBins     * include a simple read-write lock mechanism parasitic on the     * main bin-synchronization strategy: Structural adjustments     * associated with an insertion or removal are already bin-locked     * (and so cannot conflict with other writers) but must wait for     * ongoing readers to finish. Since there can be only one such     * waiter, we use a simple scheme using a single &quot;waiter&quot; field to     * block writers.  However, readers need never block.  If the root     * lock is held, they proceed along the slow traversal path (via     * next-pointers) until the lock becomes available or the list is     * exhausted, whichever comes first. These cases are not fast, but     * maximize aggregate expected throughput.     *     * Maintaining API and serialization compatibility with previous     * versions of this class introduces several oddities. Mainly: We     * leave untouched but unused constructor arguments refering to     * concurrencyLevel. We accept a loadFactor constructor argument,     * but apply it only to initial table capacity (which is the only     * time that we can guarantee to honor it.) We also declare an     * unused &quot;Segment&quot; class that is instantiated in minimal form     * only when serializing.     *     * Also, solely for compatibility with previous versions of this     * class, it extends AbstractMap, even though all of its methods     * are overridden, so it is just useless baggage.     *     * This file is organized to make things a little easier to follow     * while reading than they might otherwise: First the main static     * declarations and utilities, then fields, then main public     * methods (with a few factorings of multiple public methods into     * internal ones), then sizing methods, trees, traversers, and     * bulk operations.     */</code></pre><p>以上内容摘自 java.util.concurrent.ConcurrentHashMap 的Overview 部分,下面是基于这段的一个简单翻译</p><h4 id="Design-golds"><a href="#Design-golds" class="headerlink" title="Design golds"></a>Design golds</h4><ol><li>The primary design goal of this hash table is to maintain concurrent readability (typically method get(), but also iterators and related methods) while minimizing update contention(竞争). </li><li>Secondary goals are to keep space consumption(消耗) about the same or better tha java.util.HashMap, and to support high initial insertion rates on an empty table by many threads.</li></ol><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><pre><code class="java">/* * This map usually acts as a binned (bucketed) hash table.  Each * key-value mapping is held in a Node.  Most nodes are instances * of the basic Node class with hash, key, value, and next * fields. However, various subclasses exist: TreeNodes are * arranged in balanced trees, not lists.  TreeBins hold the roots * of sets of TreeNodes. ForwardingNodes are placed at the heads * of bins during resizing. ReservationNodes are used as * placeholders while establishing values in computeIfAbsent and * related methods.  The types TreeBin, ForwardingNode, and * ReservationNode do not hold normal user keys, values, or * hashes, and are readily distinguishable during search etc * because they have negative hash fields and null key and value * fields. (These special nodes are either uncommon or transient, * so the impact of carrying around some unused fields is * insignificant.) */</code></pre><p>其底层实现形式也是bucket数组的形式，且&lt;key, value&gt;存储在Node中。Node存在以下子类，包括TreeBin、TreeNode、ForwardingNode、ReservationNode，后三种一般有其特殊用途。</p><pre><code class="java">/* * The table is lazily initialized to a power-of-two size upon the * first insertion.  Each bin in the table normally contains a * list of Nodes (most often, the list has only zero or one Node). * Table accesses require volatile/atomic reads, writes, and * CASes.  Because there is no other way to arrange this without * adding further indirections, we use intrinsics * (sun.misc.Unsafe) operations. */</code></pre><p>ConcurrentHashMap使用延迟初始化策略，在第一次insert时，才分配一个2^n大小的bucket数组，一般的bucket为list形式，通过Node中next属性来实现链表(通常链表为空或者只有一个)。</p><p>通过volatie 和CAS 来控制其原子性,底层使用的是sun.misc.Unsafe</p><h4 id="hash-conflict"><a href="#hash-conflict" class="headerlink" title="hash conflict"></a>hash conflict</h4><pre><code class="java">/* * We use the top (sign) bit of Node hash fields for control * purposes -- it is available anyway because of addressing * constraints.  Nodes with negative hash fields are specially * handled or ignored in map methods. */</code></pre><p>使用bit的高位来存储的目的是为了减少冲突</p><pre><code class="java">/* * Insertion (via put or its variants) of the first node in an * empty bin is performed by just CASing it to the bin.  This is * by far the most common case for put operations under most * key/hash distributions.  Other update operations (insert, * delete, and replace) require locks.  We do not want to waste * the space required to associate a distinct lock object with * each bin, so instead use the first node of a bin list itself as * a lock. Locking support for these locks relies on builtin * &quot;synchronized&quot; monitors. * * Using the first node of a list as a lock does not by itself * suffice though: When a node is locked, any update must first * validate that it is still the first node after locking it, and * retry if not. Because new nodes are always appended to lists, * once a node is first in a bin, it remains first until deleted * or the bin becomes invalidated (upon resizing). */</code></pre><p>​    当在一个空bin中insert第一个node时，其使用CAS操作来同步，而对于其他的update操作(insert,delete, and replace)则需要使用锁来同步。而在每一个bucket中，一般使用此bin中第一个node作为这个bin的锁，锁住整个bucket。（因为新放入bin的node总会添加到list的末尾，故除了delete掉第一个节点或resize数组之外，这个节点总是此bin的第一个node，具有稳定性）。</p><pre><code class="java">/* * The main disadvantage of per-bin locks is that other update * operations on other nodes in a bin list protected by the same * lock can stall, for example when user equals() or mapping * functions take a long time.  However, statistically, under * random hash codes, this is not a common problem.  Ideally, the * frequency of nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average, given the resizing threshold * of 0.75, although with a large variance because of resizing * granularity. Ignoring variance, the expected occurrences of * list size k are (exp(-0.5)  * pow(0.5, k) / factorial(k)). The * first values are: * * 0:    0.60653066 * 1:    0.30326533 * 2:    0.07581633 * 3:    0.01263606 * 4:    0.00157952 * 5:    0.00015795 * 6:    0.00001316 * 7:    0.00000094 * 8:    0.00000006 * more: less than 1 in ten million * * Lock contention probability for two threads accessing distinct * elements is roughly 1 / (8  * #elements) under random hashes. */</code></pre><p>​    当使用锁,锁住bin节点的第一个节点的时候, 最大的问题是其他访问这个bin需要等待(例如equals 和mapping 的过程花费了很长时间 ) 然而,  其实就像上面提到过的通常链表为空或者只有一个.  因为冲突的概率很低</p><pre><code class="java">/* * Actual hash code distributions encountered in practice * sometimes deviate significantly from uniform randomness.  This * includes the case when N &gt; (1&lt;&lt;30), so some keys MUST collide. * Similarly for dumb or hostile usages in which multiple keys are * designed to have identical hash codes or ones that differs only * in masked-out high bits. So we use a secondary strategy that * applies when the number of nodes in a bin exceeds a * threshold. These TreeBins use a balanced tree to hold nodes (a * specialized form of red-black trees), bounding search time to * O(log N).  Each search step in a TreeBin is at least twice as * slow as in a regular list, but given that N cannot exceed * (1&lt;&lt;64) (before running out of addresses) this bounds search * steps, lock hold times, etc, to reasonable constants (roughly * 100 nodes inspected per operation worst case) so long as keys * are Comparable (which is very common -- String, Long, etc). * TreeBin nodes (TreeNodes) also maintain the same &quot;next&quot; * traversal pointers as regular nodes, so can be traversed in * iterators in the same way. */</code></pre><p>在实际使用中,哈希码分布有时会明显偏离均匀随机性。像一些错误使用,使用相同的hash codes,或低位不同会导致该问题.为了解决该问题,引入了红黑树</p><h4 id="resized"><a href="#resized" class="headerlink" title="resized"></a>resized</h4><pre><code class="java">/* * The table is resized when occupancy exceeds a percentage * threshold (nominally, 0.75, but see below).  Any thread * noticing an overfull bin may assist in resizing after the * initiating thread allocates and sets up the replacement array. * However, rather than stalling, these other threads may proceed * with insertions etc.  The use of TreeBins shields us from the * worst case effects of overfilling while resizes are in * progress.  Resizing proceeds by transferring bins, one by one, * from the table to the next table. However, threads claim small * blocks of indices to transfer (via field transferIndex) before * doing so, reducing contention.  A generation stamp in field * sizeCtl ensures that resizings do not overlap. Because we are * using power-of-two expansion, the elements from each bin must * either stay at same index, or move with a power of two * offset. We eliminate unnecessary node creation by catching * cases where old nodes can be reused because their next fields * won&#39;t change.  On average, only about one-sixth of them need * cloning when a table doubles. The nodes they replace will be * garbage collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of concurrently * traversing table.  Upon transfer, the old table bin contains * only a special forwarding node (with hash field &quot;MOVED&quot;) that * contains the next table as its key. On encountering a * forwarding node, access and update operations restart, using * the new table. */</code></pre><p>重新扩容当负载因子超过0.75  , 扩容通常是power-of-two ,渐进式的方式,多次扩容(通过transferIndex)  ,</p><p>使用字段sizeCtl来确保不会重复扩容. </p><p>这种扩容通常是相同的索引,或者移动power-of-two 位置(1/6的概率需要cloning) 旧表只包含forwarding node（具有散列字段“MOVED”）做为新表的key</p><pre><code class="java">/* * Each bin transfer requires its bin lock, which can stall * waiting for locks while resizing. However, because other * threads can join in and help resize rather than contend for * locks, average aggregate waits become shorter as resizing * progresses.  The transfer operation must also ensure that all * accessible bins in both the old and new table are usable by any * traversal.  This is arranged in part by proceeding from the * last bin (table.length - 1) up towards the first.  Upon seeing * a forwarding node, traversals (see class Traverser) arrange to * move to the new table without revisiting nodes.  To ensure that * no intervening nodes are skipped even when moved out of order, * a stack (see class TableStack) is created on first encounter of * a forwarding node during a traversal, to maintain its place if * later processing the current table. The need for these * save/restore mechanics is relatively rare, but when one * forwarding node is encountered, typically many more will be. * So Traversers use a simple caching scheme to avoid creating so * many new TableStack nodes. (Thanks to Peter Levart for * suggesting use of a stack here.) */</code></pre><p>​    调整大小时,每个bin移动的时候都需要对bin锁定。但是，因为其他线程可以加入并帮助调整大小而不是争用锁，总耗时会更多(多线程帮助扩容)。扩容时还必须确保旧表和新表中的所有可访问的bin都可以被任何遍历使用更多细节看<code>TableStack</code>、 <code>Traverser</code></p><pre><code class="java">/* * The element count is maintained using a specialization of * LongAdder. We need to incorporate a specialization rather than * just use a LongAdder in order to access implicit * contention-sensing that leads to creation of multiple * CounterCells.  The counter mechanics avoid contention on * updates but can encounter cache thrashing if read too * frequently during concurrent access. To avoid reading so often, * resizing under contention is attempted only upon adding to a * bin already holding two or more nodes. Under uniform hash * distributions, the probability of this occurring at threshold * is around 13%, meaning that only about 1 in 8 puts check * threshold (and after resizing, many fewer do so). */</code></pre><p>​    使用<code>LongAdder</code> 来统计元素的个数</p><h4 id="TreeBins"><a href="#TreeBins" class="headerlink" title="TreeBins"></a>TreeBins</h4><pre><code class="java">/* * TreeBins use a special form of comparison for search and * related operations (which is the main reason we cannot use * existing collections such as TreeMaps). TreeBins contain * Comparable elements, but may contain others, as well as * elements that are Comparable but not necessarily Comparable for * the same T, so we cannot invoke compareTo among them. To handle * this, the tree is ordered primarily by hash value, then by * Comparable.compareTo order if applicable.  On lookup at a node, * if elements are not comparable or compare as 0 then both left * and right children may need to be searched in the case of tied * hash values. (This corresponds to the full list search that * would be necessary if all elements were non-Comparable and had * tied hashes.) On insertion, to keep a total ordering (or as * close as is required here) across rebalancings, we compare * classes and identityHashCodes as tie-breakers. The red-black * balancing code is updated from pre-jdk-collections * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java) * based in turn on Cormen, Leiserson, and Rivest &quot;Introduction to * Algorithms&quot; (CLR). *  * TreeBins also require an additional locking mechanism.  While * list traversal is always possible by readers even during * updates, tree traversal is not, mainly because of tree-rotations * that may change the root node and/or its linkages.  TreeBins * include a simple read-write lock mechanism parasitic on the * main bin-synchronization strategy: Structural adjustments * associated with an insertion or removal are already bin-locked * (and so cannot conflict with other writers) but must wait for * ongoing readers to finish. Since there can be only one such * waiter, we use a simple scheme using a single &quot;waiter&quot; field to * block writers.  However, readers need never block.  If the root * lock is held, they proceed along the slow traversal path (via * next-pointers) until the lock becomes available or the list is * exhausted, whichever comes first. These cases are not fast, but * maximize aggregate expected throughput. */</code></pre><p>​    TreeBins , On insertion, to keep a total ordering (or as close as is required here) across rebalancings, we compare classes and identityHashCodes as tie-breakers.</p><p>​    TreeBins还需要额外的锁定机制。 尽管在更新期间readers总是可以进行列表遍历，但是树遍历不是，主要是因为可以改变根节点和/或其链接的树旋转。使用读写锁实现,读不会阻塞</p><h4 id="baggage"><a href="#baggage" class="headerlink" title="baggage"></a>baggage</h4><pre><code class="java">/*      * Maintaining API and serialization compatibility with previous * versions of this class introduces several oddities. Mainly: We * leave untouched but unused constructor arguments refering to * concurrencyLevel. We accept a loadFactor constructor argument, * but apply it only to initial table capacity (which is the only * time that we can guarantee to honor it.) We also declare an * unused &quot;Segment&quot; class that is instantiated in minimal form * only when serializing. * * Also, solely for compatibility with previous versions of this * class, it extends AbstractMap, even though all of its methods * are overridden, so it is just useless baggage. * */</code></pre><p>一些兼容API ,  concurrencyLevel ,loadFactor,Segment (1.7的实现分段锁) , 继承了AbstractMap,但重写了所有方法</p><h3 id="Sources-Code"><a href="#Sources-Code" class="headerlink" title="Sources Code"></a>Sources Code</h3><pre><code class="java">/*      * This file is organized to make things a little easier to follow * while reading than they might otherwise: First the main static * declarations and utilities, then fields, then main public * methods (with a few factorings of multiple public methods into * internal ones), then sizing methods, trees, traversers, and * bulk operations. */</code></pre><p>​    ConcurrentHashMap 的源码可读性非常高,按照如上方式组织代码</p><h4 id="main-declarations"><a href="#main-declarations" class="headerlink" title="main declarations"></a>main declarations</h4><pre><code class="java">//默认bin数组的大小，必须为2的n次方private static final int DEFAULT_CAPACITY = 16;            //默认装填因子private static final float LOAD_FACTOR = 0.75f;//当bin中大于8个node时，将此bin由list转换为treestatic final int TREEIFY_THRESHOLD = 8;//tree退化static final int UNTREEIFY_THRESHOLD = 6;//大于64个bucket了，才会考虑tree化static final int MIN_TREEIFY_CAPACITY = 64;//to place bounds on some sizingsstatic final int NCPU = Runtime.getRuntime().availableProcessors();/** For serialization compatibility.  兼容*/private static final ObjectStreamField[] serialPersistentFields = {   new ObjectStreamField(&quot;segments&quot;, Segment[].class),   new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),   new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)};//兼容private static final int DEFAULT_CONCURRENCY_LEVEL = 16;/* * Encodings for Node hash fields. See above for explanation. */static final int MOVED     = -1; // hash for forwarding nodesstatic final int TREEBIN   = -2; // hash for roots of treesstatic final int RESERVED  = -3; // hash for transient reservationsstatic final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash</code></pre><h4 id="Node-1"><a href="#Node-1" class="headerlink" title="Node"></a>Node</h4><pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    volatile V val;    volatile Node&lt;K,V&gt; next;    Node(int hash, K key, V val, Node&lt;K,V&gt; next) {        this.hash = hash;        this.key = key;        this.val = val;        this.next = next;    }    public final K getKey()       { return key; }    public final V getValue()     { return val; }    public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }    public final String toString(){ return key + &quot;=&quot; + val; }    public final V setValue(V value) {        throw new UnsupportedOperationException();    }    public final boolean equals(Object o) {        Object k, v, u; Map.Entry&lt;?,?&gt; e;        return ((o instanceof Map.Entry) &amp;&amp;                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp;                (v = e.getValue()) != null &amp;&amp;                (k == key || k.equals(key)) &amp;&amp;                (v == (u = val) || v.equals(u)));    }    /**     * Virtualized support for map.get(); overridden in subclasses.     */    Node&lt;K,V&gt; find(int h, Object k) {        Node&lt;K,V&gt; e = this;        if (k != null) {            do {                K ek;                if (e.hash == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                    return e;            } while ((e = e.next) != null);        }        return null;    }}</code></pre><h4 id="Static-utilities"><a href="#Static-utilities" class="headerlink" title="Static utilities"></a>Static utilities</h4><pre><code class="java">/** * Spreads (XORs) higher bits of hash to lower and also forces top * bit to 0. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.)  So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don&#39;t benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */static final int spread(int h) {    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;}/** * Returns a power of two table size for the given desired capacity. * See Hackers Delight, sec 3.2 */private static final int tableSizeFor(int c) {    int n = c - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}/** * Returns x&#39;s Class if it is of the form &quot;class C implements * Comparable&lt;C&gt;&quot;, else null. */static Class&lt;?&gt; comparableClassFor(Object x) {    if (x instanceof Comparable) {        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;        if ((c = x.getClass()) == String.class) // bypass checks            return c;        if ((ts = c.getGenericInterfaces()) != null) {            for (int i = 0; i &lt; ts.length; ++i) {                if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;                    ((p = (ParameterizedType)t).getRawType() ==                     Comparable.class) &amp;&amp;                    (as = p.getActualTypeArguments()) != null &amp;&amp;                    as.length == 1 &amp;&amp; as[0] == c) // type arg is c                    return c;            }        }    }    return null;}/** * Returns k.compareTo(x) if x matches kc (k&#39;s screened comparable * class), else 0. */@SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {    return (x == null || x.getClass() != kc ? 0 :            ((Comparable)k).compareTo(x));}</code></pre><h4 id="Main-public-methods"><a href="#Main-public-methods" class="headerlink" title="Main public methods"></a>Main public methods</h4><h5 id="Construct"><a href="#Construct" class="headerlink" title="Construct"></a>Construct</h5><pre><code class="java">/** * Creates a new, empty map with the default initial table size (16). */public ConcurrentHashMap() {}/** * Creates a new, empty map with an initial table size * accommodating the specified number of elements without the need * to dynamically resize. */public ConcurrentHashMap(int initialCapacity) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException();    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    this.sizeCtl = cap;}/** * Creates a new map with the same mappings as the given map. */public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.sizeCtl = DEFAULT_CAPACITY;    putAll(m);}/** * Creates a new, empty map with an initial table size based on * the given number of elements ({@code initialCapacity}) and * initial table density ({@code loadFactor}). * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements, * given the specified load factor. * @param loadFactor the load factor (table density) for * establishing the initial table size * @throws IllegalArgumentException if the initial capacity of * elements is negative or the load factor is nonpositive * * @since 1.6 */public ConcurrentHashMap(int initialCapacity, float loadFactor) {    this(initialCapacity, loadFactor, 1);}/** * Creates a new, empty map with an initial table size based on * the given number of elements ({@code initialCapacity}), table * density ({@code loadFactor}), and number of concurrently * updating threads ({@code concurrencyLevel}). * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements, * given the specified load factor. * @param loadFactor the load factor (table density) for * establishing the initial table size * @param concurrencyLevel the estimated number of concurrently * updating threads. The implementation may use this value as * a sizing hint. * @throws IllegalArgumentException if the initial capacity is * negative or the load factor or concurrencyLevel are * nonpositive */public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel) {    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)        throw new IllegalArgumentException();    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins        initialCapacity = concurrencyLevel;   // as estimated threads    long size = (long)(1.0 + (long)initialCapacity / loadFactor);    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?        MAXIMUM_CAPACITY : tableSizeFor((int)size);    this.sizeCtl = cap;}</code></pre><h5 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h5><pre><code class="java">public int size() {    long n = sumCount();    return ((n &lt; 0L) ? 0 :            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :            (int)n);}/* ---------------- Counter support -------------- *//** * A padded cell for distributing counts.  Adapted from LongAdder * and Striped64.  See their internal docs for explanation. */@sun.misc.Contended static final class CounterCell {    volatile long value;    CounterCell(long x) { value = x; }}final long sumCount() {    CounterCell[] as = counterCells; CounterCell a;    long sum = baseCount;    if (as != null) {        for (int i = 0; i &lt; as.length; ++i) {            if ((a = as[i]) != null)                sum += a.value;        }    }    return sum;}</code></pre><h5 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h5><pre><code class="java">public boolean containsKey(Object key) {    return get(key) != null;}public V get(Object key) {    Node&lt;K,V&gt;[] tab;     Node&lt;K,V&gt; e, p;     int n, eh;     K ek;    //通过位运算取得bit高位来使key分布更均匀,当key=null时，会抛出空指针异常    int h = spread(key.hashCode());        //e 取得bin中的first node    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) {        if ((eh = e.hash) == h) {                                                  if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))                return e.val;        }        else if (eh &lt; 0)            return (p = e.find(h, key)) != null ? p.val : null;        //遍历链表        while ((e = e.next) != null) {                  if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))                return e.val;        }    }    return null;}</code></pre><h5 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h5><pre><code class="java">/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) {    if (key == null || value == null) throw new NullPointerException();    int hash = spread(key.hashCode());    int binCount = 0;    for (Node&lt;K,V&gt;[] tab = table;;) {        Node&lt;K,V&gt; f; int n, i, fh;            //延迟初始化        if (tab == null || (n = tab.length) == 0)            tab = initTable();                           //当向empty bin 中添加node时，并不使用锁，而使用CAS操作来添加        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {            if (casTabAt(tab, i, null,                         new Node&lt;K,V&gt;(hash, key, value, null)))                break;                           }        //处于扩容状态,帮助扩容        else if ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        else {            V oldVal = null;                //锁住bin节点            synchronized (f) {                if (tabAt(tab, i) == f) {                    if (fh &gt;= 0) {                        binCount = 1;                        for (Node&lt;K,V&gt; e = f;; ++binCount) {                            K ek;                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) {                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            }                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) {                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            }                        }                    }                    else if (f instanceof TreeBin) {                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != null) {                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        }                    }                }            }            //先插入再转换成tree            if (binCount != 0) {                if (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            }        }    }    addCount(1L, binCount);    return null;}</code></pre><p>可以看到ConcurrentHashMap 为了提高性能做了很多事情</p><ul><li>​    只有哈希冲突才会锁住bin,否则使用CAS </li><li>​    多线程帮助扩容</li><li>​    当链表过长树化,提高查询速度,防止锁住时间过长    </li></ul><p>More details to continues …..</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_Garbage Collection</title>
      <link href="/2019/06/19/JVM-Garbage-Collection/"/>
      <url>/2019/06/19/JVM-Garbage-Collection/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4c1nxma40j30u00gwdig.jpg" alt="https://image.ipaiban.com/upload-ueditor-image-20190616-1560688476336071298.jpg"></p><a id="more"></a><p>基于<a href="https://docs.oracle.com/en/java/javase/12/gctuning/hotspot-virtual-machine-garbage-collection-tuning-guide.pdf" target="_blank" rel="noopener">HotSpot Virtual Machine Garbage Collection Tuning Guide</a>的整理( ´ー`) , jDK12</p><p>Or <a href="https://docs.oracle.com/en/java/javase/12/gctuning/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/gctuning/index.html</a></p><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote><p>The <em>Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection<br>Tuning Guide</em> describes the garbage collection methods included in the Java HotSpot<br>Virtual Machine (Java HotSpot VM) and helps you determine which one is the best for<br>your needs.</p></blockquote><p>介绍HotSpot虚拟机垃圾回收算法、 以及怎么选择最合适的一个算法</p><h2 id="Introduction-to-Garbage-Collection-Tuning"><a href="#Introduction-to-Garbage-Collection-Tuning" class="headerlink" title="Introduction to Garbage Collection Tuning"></a>Introduction to Garbage Collection Tuning</h2><blockquote><p>Java SE selects the most appropriate garbage collector based on the class of the computer on which the application is run.<br>However, this selection may not be optimal for every application. </p><p>Users, developers,and administrators with strict performance goals or other requirements may need to<br>explicitly select the garbage collector and tune certain parameters to achieve the<br>desired level of performance.</p></blockquote><p>通常需要选择合适的垃圾收集器、并调整某些参数以实现所需的性能级别(吞吐和停顿)</p><p>Topics</p><ul><li>What Is a Garbage Collector?  </li><li>Why Does the Choice of Garbage Collector Matter? </li><li>Supported Operating Systems in Documentation</li></ul><p>简单介绍了</p><ul><li>什么是垃圾回收、以及使用什么优化技术(分代、并发、压缩)</li><li>为什么选择垃圾回收算法很重要</li><li>支持的操作系统</li></ul><h2 id="Ergonomics"><a href="#Ergonomics" class="headerlink" title="Ergonomics"></a>Ergonomics</h2><p>简单介绍如何提高性能,从吞吐、响应时间、堆空间</p><p>Topics</p><ol><li>Garbage Collector, Heap, and Runtime Compiler Default Selections </li><li>Behavior-Based Tuning <ul><li>Maximum Pause-Time Goal </li><li>Throughput Goal  </li><li>Footprint </li></ul></li><li>Tuning Strategy </li></ol><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><ul><li>Garbage-First (G1) collector </li><li>The maximum number of GC threads is limited by heap size and available CPU </li><li>resources </li><li>Initial heap size of 1/64 of physical memory </li><li>Maximum heap size of 1/4 of physical memory </li><li>Tiered compiler, using both C1 and C2 </li></ul><h3 id="基于特性调整"><a href="#基于特性调整" class="headerlink" title="基于特性调整"></a>基于特性调整</h3><ul><li><p>Maximum Pause-Time Goal</p><ul><li><p>These adjustments may cause garbage collection to occur more frequently, reducing the overall throughput of the application.</p></li><li><p>command-line option -XX:MaxGCPauseMillis=<em><nnn></nnn></em></p></li></ul></li><li><p>Throughput Goal</p><ul><li>If the throughput goal isn’t being met, then one possible action for the garbage<br>  collector is to increase the size of the heap so that the time spent in the application<br>  between collection pauses can be longer.</li><li><p>command-line option -XX:GCTimeRatio=<em>nnn</em>  (The ratio of</p><p>  garbage collection time to application time is 1/ (1+<em>nnn</em>))</p></li></ul></li><li>Footprint(占用空间 -堆大小)<ul><li>If the throughput and maximum pause-time goals have been met, then the garbage<br>  collector reduces the size of the heap until one of the goals (invariably the throughput<br>  goal) can’t be met.</li></ul></li></ul><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>​    The heap grows or shrinks to a size that supports the chosen throughput goal. Learn about heap tuning strategies such as choosing a maximum heap size, and choosing maximum pause-time goal. </p><p>​    <strong>Don’t choose a maximum value for the heap unless you know that you need a heap greater than the default maximum heap size</strong> </p><p>​    <strong>If the heap grows to its maximum size and the throughput goal isn’t being met, then</strong><br><strong>the maximum heap size is too small for the throughput goal.</strong></p><p>​    <strong>If the throughput goal can be met, but pauses are too long, then select a maximum</strong><br><strong>pause-time goal</strong></p><h2 id="Garbage-Collector-Implementation"><a href="#Garbage-Collector-Implementation" class="headerlink" title="Garbage Collector Implementation"></a>Garbage Collector Implementation</h2><blockquote><p>However, when garbage collection is the principal bottleneck, it’s useful to understand<br>some aspects of the implementation. Garbage collectors make assumptions about the<br>way applications use objects, and these are reflected in tunable parameters that can<br>be adjusted for improved performance without sacrificing the power of the abstraction.</p></blockquote><p>当垃圾收集成为虚拟机瓶颈的时候,了解其具体实现细节就很重要了</p><p><strong>Topics</strong> </p><ul><li>Generational Garbage Collection </li><li>Generations </li><li>Performance Considerations </li><li>Throughput and Footprint Measurement </li></ul><h3 id="垃圾回收分代策略"><a href="#垃圾回收分代策略" class="headerlink" title="垃圾回收分代策略"></a>垃圾回收分代策略</h3><p>The Java HotSpot VM incorporates a number of different garbage collection algorithms that all use a technique called generational collection.</p><p>每次都遍历每个可到到达对象,这种效率是不可取的,所以需要选择合适的回收策略</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g466cazspsj30f309w74j.jpg" alt="Description of Figure 3-1 follows"></p><p><strong><em>Typical Distribution for Lifetimes of Objects</em></strong></p><p>从上图可以发现,大多数对象都是年轻对象 (x轴为当前生命周期存活的大小,y轴为对象内存分配分代位置)</p><h3 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h3><blockquote><p>To optimize for this scenario, memory is managed in generations (memory pools holding objects of different ages). Garbage collection occurs in each generation when the generation fills up.<br>The vast majority of objects are allocated in a pool dedicated to young objects (the young generation), and most objects die there.</p></blockquote><p>为了解决对象都是 朝生夕灭,这种问题,对堆内存使用了分代管理</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g466krgf27j30co03hq2w.jpg" alt="Description of Figure 3-2 follows"></p><p><strong>Young</strong></p><p>The young generation consists of eden and two survivor spaces.</p><p>One survivor space is empty at any time, and serves as the destination of live objects in eden and the other survivor space during garbage collection; </p><p>after garbage collection, eden and the source survivor space are empty</p><p><strong>Old</strong></p><p>Objects are copied between survivor spaces in this way until they’ve<br>been copied a certain number of times or there isn’t enough space left there.</p><p>These objects are copied into the old region.</p><h3 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h3><p>In general, choosing the size for a particular generation is a trade-off between these considerations. For example, a very large young generation may maximize throughput, but does so at the expense of footprint, promptness, and pause times.  Young generation pauses can be minimized by using a small young generation at the expense of throughput. The sizing of one generation doesn’t affect the collection frequency and pause times for another generation.</p><p>年轻一代越大,吞吐越高,minor gc 越少,总gc时间变少</p><p>但是同时会导致 内存占用变高,单次需要收集垃圾的时间变长,响应时间变长</p><h3 id="吞吐和占用空间测量"><a href="#吞吐和占用空间测量" class="headerlink" title="吞吐和占用空间测量"></a>吞吐和占用空间测量</h3><p>The command-line option -verbose:gc prints information about the heap and garbage collection at each collection.</p><p>可以通过打印gc日志,看gc情况</p><h2 id="Factors-Affecting-Garbage-Collection-Performance"><a href="#Factors-Affecting-Garbage-Collection-Performance" class="headerlink" title="Factors Affecting Garbage Collection Performance"></a>Factors Affecting Garbage Collection Performance</h2><blockquote><p>The two most important factors affecting garbage collection performance are <strong>total</strong><br><strong>available memory and proportion of the heap dedicated to the young generation.</strong></p></blockquote><p>影响垃圾收集性能的两个重要因素 堆总大小和年轻代堆堆比例</p><p><strong>Topics</strong> </p><ul><li>Total Heap <ul><li>–  Heap Options Affecting Generation Size </li><li>–  Default Option Values for Heap Size </li><li>–  Conserving Dynamic Footprint by Minimizing Java Heap Size </li></ul></li><li>The Young Generation <ul><li>–  Young Generation Size Options </li><li>–  Survivor Space Sizing </li></ul></li></ul><h3 id="堆总大小"><a href="#堆总大小" class="headerlink" title="堆总大小"></a>堆总大小</h3><p>Because collections occur when generations fill up, throughput is inversely proportional to the amount of memory available.</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g467ufa9uoj30fo04rwem.jpg" alt="Description of Figure 4-1 follows"></p><p><strong>Heap Options</strong></p><p>其中图中的Virtual 表示 -Xms 小于 -Xmx 的部分</p><h4 id="默认配置-1"><a href="#默认配置-1" class="headerlink" title="默认配置"></a>默认配置</h4><p><strong><em>Default Options for 64-Bit Solaris Operating System</em></strong></p><table><thead><tr><th style="text-align:left">Option</th><th style="text-align:left">Default Value</th></tr></thead><tbody><tr><td style="text-align:left"><code>-XX:MinHeapFreeRatio</code></td><td style="text-align:left">40</td></tr><tr><td style="text-align:left"><code>-XX:MaxHeapFreeRatio</code></td><td style="text-align:left">70</td></tr><tr><td style="text-align:left"><code>-Xms</code></td><td style="text-align:left">6656 KB</td></tr><tr><td style="text-align:left"><code>-Xmx</code></td><td style="text-align:left">calculated</td></tr></tbody></table><p>The following are general guidelines regarding heap sizes for server applications:</p><ul><li><p>Unless you have problems with pauses, try granting as much memory as possible to the virtual machine. The default size is often too small. </p></li><li><p>Setting -Xms and -Xmx to the same value increases predictability by removing the most important sizing decision from the virtual machine. However, the virtual machine is then unable to compensate if you make a poor choice. </p></li><li><p>In general, increase the memory as you increase the number of processors, because allocation can be made parallel. </p></li></ul><p>​    </p><h4 id="动态缩小堆空间"><a href="#动态缩小堆空间" class="headerlink" title="动态缩小堆空间"></a>动态缩小堆空间</h4><p>Lowering - XX:MaxHeapFreeRatio to as low as 10% and -XX:MinHeapFreeRatio has shown to successfully reduce the heap size without too much performance degradation; </p><p>In addition, you can specify -XX:-ShrinkHeapInSteps, which immediately reduces the Java heap to the target size (specified by the parameter -XX:MaxHeapFreeRatio) </p><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><blockquote><p>The bigger the young generation, the less often minor collections occur. However, for a bounded heap size, a larger young generation implies a smaller old generation, which will increase the frequency of major collections. The optimal choice depends on the lifetime distribution of the objects allocated by the application.</p></blockquote><p>年轻代越大,需要minor GC的次数越少,  major GC的次数越多 ,实际使用取决于应用内对象的生命周期分布</p><table><thead><tr><th style="text-align:left">Option</th><th style="text-align:left">Default Value</th></tr></thead><tbody><tr><td style="text-align:left"><code>-XX:NewRatio</code></td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><code>-XX:NewSize</code></td><td style="text-align:left">1310 MB</td></tr><tr><td style="text-align:left"><code>-XX:MaxNewSize</code></td><td style="text-align:left">not limited</td></tr><tr><td style="text-align:left"><code>-XX:SurvivorRatio</code></td><td style="text-align:left">8</td></tr></tbody></table><p><strong><em>Default Option Values for Survivor Space Sizing</em></strong></p><p>The following are general guidelines for server applications:</p><ul><li>First decide on the maximum heap size that you can afford to give the virtual machine. Then, plot your performance metric against the young generation sizes to find the best setting.<ul><li>Note that the maximum heap size should always be smaller than the amount of memory installed on the machine to avoid excessive page faults and thrashing.</li></ul></li><li>If the total heap size is fixed, then increasing the young generation size requires reducing the old generation size. Keep the old generation large enough to hold all the live data used by the application at any given time, plus some amount of slack space (10 to 20% or more).</li><li>Subject to the previously stated constraint on the old generation:<ul><li>Grant plenty of memory to the young generation.</li><li>Increase the young generation size as you increase the number of processors because allocation can be parallelized.</li></ul></li></ul><p>好吧,感觉这个准则在讲废话</p><h2 id="Available-Collectors"><a href="#Available-Collectors" class="headerlink" title="Available Collectors"></a>Available Collectors</h2><p>介绍垃圾收集器,和怎么挑选合适的垃圾收集器</p><p><strong>Topics</strong> </p><ul><li><p>Serial Collector </p></li><li><p>Parallel Collector </p></li><li><p>The Mostly Concurrent Collectors </p></li><li><p>Selecting a Collector </p></li></ul><p>​    </p><h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>It’s best-suited to single processor machines because it can’t take advantage of multiprocessor hardware, although it can be useful on multiprocessors for applications with small data sets (up to approximately 100 MB).  </p><p>收集过程,不会执行用户线程,一般适用于单处理器机器,也可以用于多处理器的小内存应用(100MB左右)</p><h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><p>The parallel collector is also known as <em>throughput collector</em>, it’s a generational collector similar to the serial collector. The primary difference between the serial and parallel collectors is that the parallel collector has multiple threads that are used to speed up garbage collection. </p><p>The parallel collector is intended for applications with medium-sized to large-sized data sets that are run on multiprocessor or multithreaded hardware. You can enable it by using the -XX:+UseParallelGC option. </p><p>也称为吞吐量收集器,与串行类型,不同的是多线程并行</p><h3 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h3><ul><li><p>G1 garbage collector: This server-style collector is for multiprocessor machines with a large amount of memory. It meets garbage collection pause-time goals with high probability, while achieving high throughput. </p><p>  G1 is selected by default on certain hardware and operating system configurations, or can be explicitly enabled using-XX:+UseG1GC . </p></li><li><p>CMS collector : This collector is for applications that prefer shorter garbage collection pauses and can afford to share processor resources with the garbage collection. </p><p>  Use the option -XX:+UseConcMarkSweepGC to enable the CMS collector </p><p>  The CMS collector is deprecated as of JDK 9. </p></li></ul><p>并发收集器指在垃圾收集的过程同时还可以执行用户线程(会有短暂停止)</p><h3 id="Z收集器"><a href="#Z收集器" class="headerlink" title="Z收集器"></a>Z收集器</h3><p>The Z Garbage Collector (ZGC) is a scalable low latency garbage collector. ZGC performs all expensive work concurrently, without stopping the execution of application threads. </p><p>ZGC is intended for applications which require low latency (less than 10 ms pauses) and/or use a very large heap (multi-terabytes). You can enable is by using the -XX: +UseZGC option. </p><p>ZGC is available as an experimental feature, starting with JDK 11. </p><p>适用于低延迟(10ms)和大堆的应用程序</p><h3 id="选择收集器"><a href="#选择收集器" class="headerlink" title="选择收集器"></a>选择收集器</h3><blockquote><p>Unless your application has rather strict pause-time requirements, first run your application and allow the VM to select a collector.If necessary, adjust the heap size to improve performance. </p></blockquote><p>除非有严格的短暂时间要求,否则使用默认的收集器.(或者调整堆大小)</p><p>If the performance still doesn’t meet your goals, then use the following guidelines as a starting point for selecting a collector:</p><ul><li><p>If the application has a small data set (up to approximately 100 MB), then select the serial collector with the option -XX:+UseSerialGC. </p></li><li><p>If the application will be run on a single processor and there are no pause-time requirements, then select the serial collector with the option -XX:+UseSerialGC. </p></li><li><p>If (a) peak application performance is the first priority and (b) there are no pause- time requirements or pauses of one second or longer are acceptable, then let the VM select the collector or select the parallel collector with -XX:+UseParallelGC. </p></li><li><p>If response time is more important than overall throughput and garbage collection pauses must be kept shorter than approximately one second, then select a mostly concurrent collector with -XX:+UseG1GC or -XX:+UseConcMarkSweepGC. </p></li><li><p>If response time is a high priority, and/or you are using a very large heap, then select a fully concurrent collector with -XX:UseZGC. </p></li></ul><p>选择合适的垃圾收集器只是一个起点, 仍需要通过调整VM参数 来达到需要的性能</p><h2 id="Collectors-Implementation"><a href="#Collectors-Implementation" class="headerlink" title="Collectors  Implementation"></a>Collectors  Implementation</h2><h3 id="The-Parallel-Collector"><a href="#The-Parallel-Collector" class="headerlink" title="The Parallel Collector"></a>The Parallel Collector</h3><blockquote><p>The parallel collector is enabled with the command-line option -XX:+UseParallelGC.<br>By default, with this option, both minor and major collections are run in parallel to<br>further reduce garbage collection overhead.</p></blockquote><p><strong>Topics</strong> </p><ul><li><p>Number of Parallel Collector Garbage Collector Threads </p></li><li><p>Arrangement of Generations in Parallel Collectors </p></li><li><p>Parallel Collector Ergonomics </p><ul><li><p>–  Options to Specify Parallel Collector Behaviors </p><ul><li><p>–  Priority of Parallel Collector Goals </p></li><li><p>–  Parallel Collector Generation Size Adjustments </p></li><li><p>–  Parallel Collector Default Heap Size </p></li></ul><p>* Specification of Parallel Collector Initial and Maximum Heap Sizes </p></li></ul></li><li><p>Excessive Parallel Collector Time and OutOfMemoryError </p></li><li><p>Parallel Collector Measurements </p></li></ul><h3 id="The-Mostly-Concurrent-Collectors"><a href="#The-Mostly-Concurrent-Collectors" class="headerlink" title="The Mostly Concurrent Collectors"></a>The Mostly Concurrent Collectors</h3><blockquote><p>On an <em>N</em> processor system, the concurrent part of the collection uses <em>K</em>/<em>N</em> of the available processors, where 1 &lt;= <em>K</em> &lt;= ceiling<em>{N/4</em>}. </p><p>In addition to the use of processors during concurrent phases, additional overhead is incurred to enable concurrency. Thus, while garbage collection pauses are typically much shorter with the concurrent collector, application throughput also tends to be slightly lower than with the other collectors. </p><p>As <em>N</em> increases, the reduction in processor resources due to concurrent garbage collection becomes smaller, and the benefit from concurrent collection increases. </p><p>Because at least one processor is used for garbage collection during the concurrent phases, the concurrent collectors don’t normally provide any benefit on a uniprocessor (single-core) machine.</p></blockquote><p>在多核处理器上,垃圾收集线程为 1 &lt;= <em>K</em> &lt;= ceiling<em>{N/4</em>} , 随着N的增多收益越大 , 同时注意在单核上并不适用</p><h4 id="Concurrent-Mark-Sweep-CMS-Collector"><a href="#Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="Concurrent Mark Sweep (CMS) Collector"></a>Concurrent Mark Sweep (CMS) Collector</h4><blockquote><p>The Concurrent Mark Sweep (CMS) collector is designed for applications that prefer<br>shorter garbage collection pauses and that can afford to share processor resources<br>with the garbage collector while the application is running.</p></blockquote><p><strong>Topics</strong> </p><ul><li>Concurrent Mark Sweep Collector Performance and Structure </li><li>Concurrent Mode Failure </li><li>Excessive GC Time and OutOfMemoryError </li><li>Concurrent Mark Sweep Collector and Floating Garbage </li><li>Concurrent Mark Sweep Collector Pauses </li><li>Concurrent Mark Sweep Collector Concurrent Phases </li><li>Starting a Concurrent Collection Cycle </li><li>Scheduling Pauses </li><li>Concurrent Mark Sweep Collector Measurements </li></ul><h5 id="CMS-性能和结构"><a href="#CMS-性能和结构" class="headerlink" title="CMS 性能和结构"></a>CMS 性能和结构</h5><p><img src="http://media.licdn.com/dms/image/C4E12AQH4VHeTMCfxmA/article-cover_image-shrink_720_1280/0?e=1566432000&amp;v=beta&amp;t=ECo_SPDpBCkQlyNbEXoIgmVeTTaxLrfz7pC66OJ2mlc" alt="JVM"></p><p>标记和清除,更多细节参考如下</p><blockquote><p><a href="https://www.linkedin.com/pulse/jvm-why-cms-garbage-collector-deprecating-kunal-saxena" target="_blank" rel="noopener">why-cms-garbage-collector-deprecating</a></p><p><a href="https://juejin.im/post/5c152fefe51d45366873544a" target="_blank" rel="noopener">CMS七个阶段</a></p></blockquote><h5 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h5><blockquote><p>As described previously, in normal operation, the CMS collector does most of its<br>tracing and sweeping work with the application threads still running, so only brief<br>pauses are seen by the application threads. However, if the CMS collector is unable to<br>finish reclaiming the unreachable objects before the old generation fills up, or if an<br>allocation cannot be satisfied with the available free space blocks in the old<br>generation, then the application is paused and the collection is completed with all the<br>application threads stopped. </p><p>If a concurrent collection is interrupted by an explicit garbage<br>collection (System.gc()) or for a garbage collection needed to provide information<br>for diagnostic tools, then a concurrent mode interruption is reported.</p></blockquote><p>CMS在并发标记阶段收集失败时候(用户线程并发运行,所以会产生垃圾,如果这时候old区满了,会stop the world,退化成单线程) 至于为什么用单线程,这个是个历史遗留问题,<a href="https://www.zhihu.com/question/50398881" target="_blank" rel="noopener">传送门</a></p><p>如果在并发标记阶段被其他打断(System.gc()),会被报告</p><h5 id="GC时间过长和OutOfMemoryError"><a href="#GC时间过长和OutOfMemoryError" class="headerlink" title="GC时间过长和OutOfMemoryError"></a>GC时间过长和OutOfMemoryError</h5><p>The CMS collector throws an OutOfMemoryError if too much time is being spent in<br>garbage collection: If more than 98% of the total time is spent in garbage collection<br>and less than 2% of the heap is recovered, then an OutOfMemoryError is thrown.</p><h5 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h5><blockquote><p>Because application threads and the garbage collector thread run concurrently during a major collection, objects that are traced by the garbage collector thread may subsequently become unreachable by the time collection process ends. Such unreachable objects that haven’t yet been reclaimed are referred to as <em>floating garbage</em>.</p></blockquote><p>因为存在垃圾收集线程和工作线程并发标记的阶段, 所以在这个阶段,新产生的垃圾就无法回收,称之为浮动垃圾</p><p>CMS解决这个问题的方式是通过设置 多少次cms收集后运行一次压缩</p><p>关于Remake 为什么没办法回收浮动垃圾</p><blockquote><p><strong>重新标记（Remark）</strong> 的作用在于：<br>之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 <strong>从 GC Roots 不可达</strong> 的对象，因为用户程序的（并发）运行，<strong>又可达</strong> 了，<strong>Remark</strong> 的作用就是将这部分对象又标记为 <strong>可达对象</strong>。</p><p>至于 “浮动垃圾”，因为 <strong>CMS</strong> 在 <strong>并发标记</strong> 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 <strong>重新标记</strong> 的作用只是修改之前 <strong>并发标记</strong> 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。</p></blockquote><h5 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h5><blockquote><p>The CMS collector pauses an application twice during a concurrent collection cycle. The first pause is to mark as live the objects directly reachable from the roots (for example, object references from application thread stacks and registers, static objects, and so on) and from elsewhere in the heap (for example, the young generation). </p><p>This first pause is referred to as the <em>initial mark pause</em>. The second pause comes at the end of the concurrent tracing phase and finds objects that were missed by the concurrent tracing due to updates by the application threads of references in an object after the CMS collector had finished tracing that object. This second pause is referred to as the <em>remark pause</em>. </p></blockquote><ul><li>初始标记 <ul><li>初始标记 只是简单标记roots可以直接到达的对象,暂停时间短</li></ul></li><li>重新标记<ul><li>重新标记 在并发标记阶段 遗漏的对象,暂停时间会初始标记久</li></ul></li></ul><h5 id="回收时机"><a href="#回收时机" class="headerlink" title="回收时机"></a>回收时机</h5><blockquote><p>There are several ways to start a concurrent collection.</p><p>Based on recent history, the CMS collector maintains estimates of the time remaining<br>before the old generation will be exhausted and of the time needed for a concurrent<br>collection cycle. Using these dynamic estimates, a concurrent collection cycle is<br>started with the aim of completing the collection cycle before the old generation is<br>exhausted. These estimates are padded for safety because concurrent mode failure<br>can be very costly.</p><p>A concurrent collection also starts if the occupancy of the old generation exceeds an<br>initiating occupancy (a percentage of the old generation). The default value for this<br>initiating occupancy threshold is approximately 92%, but the value is subject to change<br>from release to release. This value can be manually adjusted using the command-line<br>option -XX:CMSInitiatingOccupancyFraction=<n>, where <n> is an integral<br>percentage (0 to 100) of the old generation size.</n></n></p></blockquote><p>根据最近的历史记录，CMS收集器维护对旧一代用尽之前剩余时间的估计以及并发收集周期所需的时间。</p><p>Old区使用率占比 </p><h5 id="暂停调度"><a href="#暂停调度" class="headerlink" title="暂停调度"></a>暂停调度</h5><blockquote><p>The pauses for the young generation collection and the old generation collection occur independently.<br>They don’t overlap, but may occur in quick succession such that the pause from one collection, immediately followed by one from the other collection, can appear to be a single, longer pause. To avoid this, the CMS collector attempts to schedule the remark pause roughly midway between the previous and next young generation pauses. This scheduling is currently not done for the initial mark pause, which is usually much shorter than the remark pause.</p></blockquote><p>因为old区和young区的收集是独立的,所以可以同时发生,这样会导致长暂停</p><p>为了避免这个问题, remake pause 会安排在两次young gc中间</p><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><pre><code>[121,834s][info][gc] GC(657) Pause Initial Mark 191M-&gt;191M(485M) (121,831s, 121,834s) 3,433ms[121,835s][info][gc] GC(657) Concurrent Mark (121,835s)[121,889s][info][gc] GC(657) Concurrent Mark (121,835s, 121,889s) 54,330ms[121,889s][info][gc] GC(657) Concurrent Preclean (121,889s)[121,892s][info][gc] GC(657) Concurrent Preclean (121,889s, 121,892s) 2,781ms[121,892s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s)[121,949s][info][gc] GC(658) Pause Young (Allocation Failure) 324M-&gt;199M(485M) (121,929s, 121,949s) 19,705ms[122,068s][info][gc] GC(659) Pause Young (Allocation Failure) 333M-&gt;200M(485M) (122,043s, 122,068s) 24,892ms[122,075s][info][gc] GC(657) Concurrent Abortable Preclean (121,892s, 122,075s) 182,989ms[122,087s][info][gc] GC(657) Pause Remark 209M-&gt;209M(485M) (122,076s, 122,087s) 11,373ms[122,087s][info][gc] GC(657) Concurrent Sweep (122,087s)[122,193s][info][gc] GC(660) Pause Young (Allocation Failure) 301M-&gt;165M(485M) (122,181s, 122,193s) 12,151ms[122,254s][info][gc] GC(657) Concurrent Sweep (122,087s, 122,254s) 166,758ms[122,254s][info][gc] GC(657) Concurrent Reset (122,254s)[122,255s][info][gc] GC(657) Concurrent Reset (122,254s, 122,255s) 0,952ms[122,297s][info][gc] GC(661) Pause Young (Allocation Failure) 259M-&gt;128M(485M) (122,291s, 122,297s) 5,797ms</code></pre><p>The output for the CMS collection (GC ID 657) is interspersed with the output from the minor collections (GC IDs 658, 659 and 660);</p><p>The initial mark pause is typically short relative to the minor collection pause time. The concurrent phases (concurrent mark, concurrent preclean, and concurrent sweep) normally last significantly longer than a minor collection pause, as indicated in the CMS collector output example</p><p>从gc log 可以看到young gc 是会并存的,同时cms的主要耗时是  Concurrent phases</p><p>同时注意每次stop the world 算一次full gc</p><h4 id="Garbage-First-Garbage-Collector"><a href="#Garbage-First-Garbage-Collector" class="headerlink" title="Garbage-First Garbage Collector"></a>Garbage-First Garbage Collector</h4><p>This section describes the Garbage-First (G1) Garbage Collector (GC).</p><p>Topics</p><ul><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42" target="_blank" rel="noopener">Introduction to Garbage-First Garbage Collector</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-CE6F94B6-71AF-45D5-829E-DEADD9BA929D" target="_blank" rel="noopener">Enabling G1</a></li><li>Basic Concepts<ul><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-15921907-B297-43A4-8C48-DC88035BC7CF" target="_blank" rel="noopener">Heap Layout</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180" target="_blank" rel="noopener">Garbage Collection Cycle</a></li></ul></li><li>Garbage-First Internals<ul><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3" target="_blank" rel="noopener">Determining Initiating Heap Occupancy</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-AC383806-7FA7-4698-8B92-4FD092B9F368" target="_blank" rel="noopener">Marking</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-BE157AF6-29E7-461A-82CF-50C1978785DA" target="_blank" rel="noopener">Behavior in Very Tight Heap Situations</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-572C9203-AB27-46F1-9D33-42BA4F3C6BF3" target="_blank" rel="noopener">Determining Initiating Heap Occupancy</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-D74F3CC7-CC9F-45B5-B03D-510AEEAC2DAC" target="_blank" rel="noopener">Humongous Objects</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-C268549C-7D95-499C-9B24-A6670B44E49C" target="_blank" rel="noopener">Young-Only Phase Generation Sizing</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-6D6B18B1-063B-48FF-99E3-5AF059C43CE8" target="_blank" rel="noopener">Space-Reclamation Phase Generation Sizing</a></li></ul></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016" target="_blank" rel="noopener">Ergonomic Defaults for G1 GC</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector.html#GUID-98E80C82-24D8-41D4-BC39-B2583F04F1FF" target="_blank" rel="noopener">Comparison to Other Collectors</a></li></ul><p>与CMS类似 , 但长时间运行后受碎片化影响的CMS，G1会增量式的整理/压缩堆里的数据，避免受碎片化影响</p><h5 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h5><p>​    将堆分为多个Region, G1 preferentially collects regions with the least amount of live data, or “garbage first”,即收集垃圾最多的Region ,”incremental collection”</p><h5 id="CardTable"><a href="#CardTable" class="headerlink" title="CardTable"></a>CardTable</h5><p>​    因为G1只回收一部分Region, 所以回收的时候需要知道哪些其他Region的对象引用着自己Region的对象，因为采用的copying算法需要移动对象，所以要更新引用为对象的新地址</p><p>​    在普通的分代收集中也是如此，分代收集中年轻代收集需要老年代到年轻代的引用的记录，通常叫做remembered set(简称RS)</p><p> concurrent mode failure后的并行化</p><p><a href="http://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/307" target="_blank" rel="noopener">JEP 307: Parallel Full GC for G1</a></p><h4 id="Garbage-First-Garbage-Collector-Tuning"><a href="#Garbage-First-Garbage-Collector-Tuning" class="headerlink" title="Garbage-First Garbage Collector Tuning"></a>Garbage-First Garbage Collector Tuning</h4><p>This section describes how to adapt Garbage-First garbage collector (G1 GC) behavior in case it does not meet your requirements.</p><p>Topics</p><ul><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6" target="_blank" rel="noopener">General Recommendations for G1</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-E26056D1-02A5-4367-94EF-72C66D314AF7" target="_blank" rel="noopener">Moving to G1 from Other Collectors</a></li><li>Improving G1 Performance<ul><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-0DD93225-0BCF-4605-B365-E9833F5BD2FC" target="_blank" rel="noopener">Observing Full Garbage Collections</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-2428DA90-B93D-48E6-B336-A849ADF1C552" target="_blank" rel="noopener">Humongous Object Fragmentation</a></li><li>Tuning for Latency<ul><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-8D9B2530-E370-4B8B-8ADD-A43674FC6658" target="_blank" rel="noopener">Unusual System or Real-Time Usage</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-40B64CD4-9844-4E3E-A0BB-81556AC04C74" target="_blank" rel="noopener">Reference Object Processing Takes Too Long</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-5FD5BDB1-DB7D-4E31-9296-19C0A28F810C" target="_blank" rel="noopener">Young-Only Collections Within the Young-Only Phase Take Too Long</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469" target="_blank" rel="noopener">Mixed Collections Take Too Long</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-A0343B53-A690-4DDE-98F9-9877096DBF0F" target="_blank" rel="noopener">High Update RS and Scan RS Times</a></li></ul></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9" target="_blank" rel="noopener">Tuning for Throughput</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-0770AB01-E334-4E23-B307-FD2114B16E0E" target="_blank" rel="noopener">Tuning for Heap Size</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/garbage-first-garbage-collector-tuning.html#GUID-379B3888-FE24-4C3F-9E38-26434EB04F89" target="_blank" rel="noopener">Tunable Defaults</a></li></ul></li></ul><h3 id="The-Z-Garbage-Collector"><a href="#The-Z-Garbage-Collector" class="headerlink" title="The Z Garbage Collector"></a>The Z Garbage Collector</h3><p>The Z Garbage Collector is available as an experimental feature, and is enabled with the command-line options <code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>.</p><h4 id="Setting-the-Heap-Size"><a href="#Setting-the-Heap-Size" class="headerlink" title="Setting the Heap Size"></a>Setting the Heap Size</h4><p>In general, the more memory you give to ZGC the better. But at the same time, wasting memory is undesirable, so it’s all about finding a balance between memory usage and how often the GC needs to run.</p><h4 id="Setting-Number-of-Concurrent-GC-Threads"><a href="#Setting-Number-of-Concurrent-GC-Threads" class="headerlink" title="Setting Number of Concurrent GC Threads"></a>Setting Number of Concurrent GC Threads</h4><p>-XX:ConcGCThreads</p><p>This option essentially dictates how much CPU-time the GC should be given. </p><h2 id="Other-Considerations"><a href="#Other-Considerations" class="headerlink" title="Other Considerations"></a>Other Considerations</h2><p>This section covers other situations that affect garbage collection.</p><p>Topics</p><ul><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-A7B0991C-661F-47BE-AEDB-74C6BDBDE181" target="_blank" rel="noopener">Finalization and Weak, Soft, and Phantom References</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-9E3E5371-20F5-4B70-A003-9D7851B115AF" target="_blank" rel="noopener">Explicit Garbage Collection</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-BFB89453-60C0-42AC-81CA-87D59B0ACE2E" target="_blank" rel="noopener">Soft References</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/gctuning/other-considerations.html#GUID-B29C9153-3530-4C15-9154-E74F44E3DAD9" target="_blank" rel="noopener">Class Metadata</a></li></ul><blockquote><p>These features can create performance artifacts at the Java programming language level. An example of this is relying on finalization to close file descriptors, which makes an external resource (descriptors) dependent on garbage collection promptness. Relying on garbage collection to manage resources other than memory is almost always a bad idea.</p><p>In previous releases of Java Hotspot VM, the class metadata was allocated in the so-called permanent generation. Starting with JDK 8, the permanent generation was removed and the class metadata is allocated in native memory</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J.U.C_InterruptedException</title>
      <link href="/2019/06/16/J-U-C-InterruptedException/"/>
      <url>/2019/06/16/J-U-C-InterruptedException/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g432asdjwvj30u00k040o.jpg" alt="https://image.ipaiban.com/upload-ueditor-image-20190608-1559957563271017590.jpg"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    前几天在看JSR-133的时候发现 ,Sleep和Yield ,然后忽然想起Thread 线程中有几个被@Deprecation 的方法,</p><p>主要有如下几个<code>suspended</code>、<code>stop</code>  、 <code>resume</code> 官方的解释如下:</p><blockquote><p>Why are <code>Thread.suspend</code> and <code>Thread.resume</code> deprecated?</p><p><code>Thread.suspend</code> is inherently deadlock-prone. If the target thread holds a lock on the monitor protecting a critical system resource when it is suspended, no thread can access this resource until the target thread is resumed. If the thread that would resume the target thread attempts to lock this monitor prior to calling <code>resume</code>, deadlock results. Such deadlocks typically manifest themselves as “frozen” processes.</p></blockquote><p>原因就是会有线程安全问题(死锁), <code>suspended</code> 期间还是会占有锁,<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html" target="_blank" rel="noopener">更多相关</a></p><p>然后就看到了<code>InterruptedException</code>这个异常. 之前了解过,但是没有深入理解.所以就打算好好了解下记录</p><h2 id="java-lang-Thread-interrupt"><a href="#java-lang-Thread-interrupt" class="headerlink" title="java.lang.Thread#interrupt"></a>java.lang.Thread#interrupt</h2><p>首先先来看看线程相关的方法,中断线程, </p><pre><code class="java">    public void interrupt() {        if (this != Thread.currentThread())            checkAccess();        synchronized (blockerLock) {            Interruptible b = blocker;            if (b != null) {                interrupt0();           // Just to set the interrupt flag                b.interrupt(this);                return;            }        }        interrupt0();    }</code></pre><p>当然这个interrupt的作用只是把线程设置一个标记, Just to set the interrupt flag </p><p>至于这里为什么只是设置了一个标记, 在core java中有提到</p><blockquote><p>There is no language requirement that a thread which is interrupted should ter- minate. Interrupting a thread simply grabs its attention. The interrupted thread can decide how to react to the interruption. </p></blockquote><p>即什么时候终止, 应该由被中断的线程去处理,所以使用这个的场景一般配合<code>Thread.currentThread().isInterrupted()</code> 来判断标记位(注意标记 默认为 false),退出循环 ,但是如果中断的是wait、sleep 等阻塞状态等线程,则会抛出InterruptedException</p><h2 id="InterruptedException是什么"><a href="#InterruptedException是什么" class="headerlink" title="InterruptedException是什么"></a>InterruptedException是什么</h2><p>直接看类的解释</p><pre><code class="java">package java.lang;/** * Thrown when a thread is waiting, sleeping, or otherwise occupied, * and the thread is interrupted, either before or during the activity. * Occasionally a method may wish to test whether the current * thread has been interrupted, and if so, to immediately throw * this exception.  The following code can be used to achieve * this effect: * &lt;pre&gt; *  if (Thread.interrupted())  // Clears interrupted status! *      throw new InterruptedException(); * &lt;/pre&gt; * * @author  Frank Yellin * @see     java.lang.Object#wait() * @see     java.lang.Object#wait(long) * @see     java.lang.Object#wait(long, int) * @see     java.lang.Thread#sleep(long) * @see     java.lang.Thread#interrupt() * @see     java.lang.Thread#interrupted() * @since   JDK1.0 */publicclass InterruptedException extends Exception {    private static final long serialVersionUID = 6700697376100628473L;    /**     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with no detail  message.     */    public InterruptedException() {        super();    }    /**     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with the     * specified detail message.     *     * @param   s   the detail message.     */    public InterruptedException(String s) {        super(s);    }}</code></pre><p>简单直译就是被中断的异常. 如果当前线程处于阻塞状态,sleep 、wait时候 被其他线程中断了,就会抛出该异常  </p><p>下面我们再看看wait方法对其中的解释</p><pre><code class="java"> /**     * Causes the current thread to wait until another thread invokes the     * {@link java.lang.Object#notify()} method or the     * {@link java.lang.Object#notifyAll()} method for this object.     * In other words, this method behaves exactly as if it simply     * performs the call {@code wait(0)}.     * &lt;p&gt;     * The current thread must own this object&#39;s monitor. The thread     * releases ownership of this monitor and waits until another thread     * notifies threads waiting on this object&#39;s monitor to wake up     * either through a call to the {@code notify} method or the     * {@code notifyAll} method. The thread then waits until it can     * re-obtain ownership of the monitor and resumes execution.     * &lt;p&gt;     * As in the one argument version, interrupts and spurious wakeups are     * possible, and this method should always be used in a loop:     * &lt;pre&gt;     *     synchronized (obj) {     *         while (&amp;lt;condition does not hold&amp;gt;)     *             obj.wait();     *         ... // Perform action appropriate to condition     *     }     * &lt;/pre&gt;     * This method should only be called by a thread that is the owner     * of this object&#39;s monitor. See the {@code notify} method for a     * description of the ways in which a thread can become the owner of     * a monitor.     *     * @throws  IllegalMonitorStateException  if the current thread is not     *               the owner of the object&#39;s monitor.     * @throws  InterruptedException if any thread interrupted the     *             current thread before or while the current thread     *             was waiting for a notification.  The &lt;i&gt;interrupted     *             status&lt;/i&gt; of the current thread is cleared when     *             this exception is thrown.     * @see        java.lang.Object#notify()     * @see        java.lang.Object#notifyAll()     */    public final void wait() throws InterruptedException {        wait(0);    }</code></pre><p>注意一点,wait会抛出两个异常,其中 <code>IllegalMonitorStateException</code> 是如果当前线程没有获取到对象的monitor,然后使用对象的wait方法时就会出现</p><p>另一个就是我们的<code>InterruptedException</code> 了 ,这里的解释也是和上面一样就不做重复赘述了.</p><p><strong>但是需要注意的是有一句</strong></p><blockquote><p>The interrupted  status of the current thread is cleared when this exception is thrown.</p></blockquote><p>也就是线程中断标记位会被重置 ,所以可以看到如果对这个异常不做处理,那么这个线程可能永远都不能被中断</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><pre><code> 当我们在使用多线程并发调度的时候, (多线程的使用场景一般用在IO阻塞比较多的情况) 为了防止线程的频繁创建带来的损耗,一般会使用 `ThreadPoolExecutor`  </code></pre><pre><code class="java">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             threadFactory, defaultHandler);}</code></pre><p><a href="[https://zyumin.github.io/2019/06/06/java%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/#%E4%BD%BF%E7%94%A8](https://zyumin.github.io/2019/06/06/java并发深入浅出/#使用">关于ThreadPoolExecutor的使用细节</a>)</p><p>当容器退出的时候,那么我们应该如何停止这个线程池的任务</p><h3 id="Graceful-stop"><a href="#Graceful-stop" class="headerlink" title="Graceful stop"></a>Graceful stop</h3><p>​    既然提到了graceful ,在平时工作中,我们不能因为容器的退出,而导致运行中的任务执行失败,强制退出,一般会通过钩子方法</p><pre><code class="java">    Runtime.getRuntime().addShutdownHook(new Thread() {    @Override    public void run() {        try {            logger.info(&quot;stop the Executor....&quot;);            shutDown();        } catch (Exception e) {            logger.error(&quot;shutDown error,msg:&quot;, e);        }    }});</code></pre><p>​    在<code>ThreadPoolExecutor</code>中,我们可以使用 <code>java.util.concurrent.ThreadPoolExecutor#shutdown</code>  方法</p><p>但是对于下面的这种<code>Runnable</code> ,是停止不了的</p><pre><code class="java">public class Worker implements Runnable {    @Override    public void run() {         while (true) {             dosomething();         }    }}</code></pre><h4 id="常见的做法"><a href="#常见的做法" class="headerlink" title="常见的做法"></a>常见的做法</h4><p>所以我们一般会通过设置一个条件变量判断</p><pre><code class="java">public class Worker implements Runnable {    private volatile boolean stopFlag =  false;    public void stop(){        stopFlag = true;    }    @Override    public void run() {        while (stopFlag) {            dosomething();        }    }}</code></pre><h4 id="更为通用的做法"><a href="#更为通用的做法" class="headerlink" title="更为通用的做法"></a>更为通用的做法</h4><p>但是这种方式很麻烦,需要遍历线程池去调用stop方法,所以更为通用的方法是利用interrupted 标记来处理</p><pre><code class="java">public class Worker implements Runnable {//        private volatile boolean stopFlag =  false;//        public void stop(){//            stopFlag = true;//        }    @Override    public void run() {        while (!Thread.currentThread().isInterrupted()) {            System.out.println(&quot;i&#39;m running &quot; + Thread.currentThread().getName());        }    }}</code></pre><p>这个时候调用 <code>java.util.concurrent.ThreadPoolExecutor#shutdown</code> 会发现线程没有停下来,那么为什么标记位没有被设置~</p><h3 id="shutdown-和-shutdownNow"><a href="#shutdown-和-shutdownNow" class="headerlink" title="shutdown 和 shutdownNow"></a>shutdown 和 shutdownNow</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>上面为什么没有停下来,debug进入shutdown</p><pre><code class="java">public void shutdown() {    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        checkShutdownAccess();        advanceRunState(SHUTDOWN);        interruptIdleWorkers();        onShutdown(); // hook for ScheduledThreadPoolExecutor    } finally {        mainLock.unlock();    }    tryTerminate();}</code></pre><p>再进入interruptIdleWorkers,会发现遍历worker进行interrupt</p><pre><code class="java">private void interruptIdleWorkers(boolean onlyOne) {    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        for (Worker w : workers) {            Thread t = w.thread;            if (!t.isInterrupted() &amp;&amp; w.tryLock()) {                try {                    t.interrupt();                } catch (SecurityException ignore) {                } finally {                    w.unlock();                }            }            if (onlyOne)                break;        }    } finally {        mainLock.unlock();    }}</code></pre><p>发现 <code>w.tryLock()</code> 返回false ,这里取不到锁的原因是因为ThreadPoolExecutor 内部封装了Worker, Worker在运行的时候会调用w.lock(); </p><pre><code class="java">final void runWorker(Worker w) {    Thread wt = Thread.currentThread();    Runnable task = w.firstTask;    w.firstTask = null;    w.unlock(); // allow interrupts    boolean completedAbruptly = true;    try {        while (task != null || (task = getTask()) != null) {            w.lock();            // If pool is stopping, ensure thread is interrupted;            // if not, ensure thread is not interrupted.  This            // requires a recheck in second case to deal with            // shutdownNow race while clearing interrupt            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try {                beforeExecute(wt, task);                Throwable thrown = null;                try {                    task.run();                } catch (RuntimeException x) {                    thrown = x; throw x;                } catch (Error x) {                    thrown = x; throw x;                } catch (Throwable x) {                    thrown = x; throw new Error(x);                } finally {                    afterExecute(task, thrown);                }            } finally {                task = null;                w.completedTasks++;                w.unlock();            }        }        completedAbruptly = false;    } finally {        processWorkerExit(w, completedAbruptly);    }}</code></pre><p>所以,shutdown方法 是不会对运行中的线程设置标记位</p><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p> <code>java.util.concurrent.ThreadPoolExecutor#shutdownNow</code>  , 注意这个方法并不是强制退出哈, 它和 shutdown区别如下</p><ul><li>只是它会对运行中的线程设置中断标记</li><li>还有不再执行等待队列的任务,返回未执行任务</li></ul><pre><code class="java">public List&lt;Runnable&gt; shutdownNow() {    List&lt;Runnable&gt; tasks;    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        checkShutdownAccess();        advanceRunState(STOP);        interruptWorkers();        tasks = drainQueue();    } finally {        mainLock.unlock();    }    tryTerminate();    return tasks;}/** * Drains the task queue into a new list, normally using * drainTo. But if the queue is a DelayQueue or any other kind of * queue for which poll or drainTo may fail to remove some * elements, it deletes them one by one. */private List&lt;Runnable&gt; drainQueue() {    BlockingQueue&lt;Runnable&gt; q = workQueue;    ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;();    q.drainTo(taskList);    if (!q.isEmpty()) {        for (Runnable r : q.toArray(new Runnable[0])) {            if (q.remove(r))                taskList.add(r);        }    }    return taskList;}</code></pre><p>所以我们就可以愉快的使用<code>shutdownNow</code> 和  <code>Thread.currentThread().isInterrupted()</code></p><p>最后再提醒一波,不要忘记对InterruptedException的处理</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spec_JSR133</title>
      <link href="/2019/06/14/Spec-JSR133/"/>
      <url>/2019/06/14/Spec-JSR133/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g42sqb05mrj30qo0hnaem.jpg" alt="image-20190616103858903"></p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Memory Model and Thread Specification , 内存模型和线程规范 </p><p>These semantics do not describe how a multithreaded program should be executed. Rather,they describe the behaviors that multithreaded programs are allowed to exhibit</p><p>规范的标准内容将合并到<em>JavaTM语言规范</em>、<em>JavaTM虚拟机规范</em>以及<code>java.lang</code>包的类说明中</p><p>因为线程的行为，尤其是未正确同步时的行为，可能会让人困惑和违背直觉 ,所以规范规定了</p><ul><li>用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果</li><li>规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</li></ul><h2 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h2><blockquote><p> There are multiple mechanisms for communicating between threads.most basic of these<br>methods is synchronization, which is implemented using monitors. </p><p>Each object is associated witha monitor, which a thread can lock or unlock.</p><p> Only one thread at a time may hold a lock on amonitor.</p><p> Any other threads attempting to lock that monitor are blocked until they can obtain a<br>lock on that monitor.</p><p>Other mechanisms, such as reads and writes of volatile variables and classes provided in the<br>java.util.concurrent package, provide alternative mechanisms for synchronization.</p></blockquote><p>同步语义的实现  synchronized 的实现,volatile,juc 包</p><h2 id="Incorrectly-Synchronized-Programs-Exhibit-Surprising-Behav-iors"><a href="#Incorrectly-Synchronized-Programs-Exhibit-Surprising-Behav-iors" class="headerlink" title="Incorrectly Synchronized Programs Exhibit Surprising Behav-iors"></a>Incorrectly Synchronized Programs Exhibit Surprising Behav-iors</h2><blockquote><p>The semantics of the Java programming language allow compilers and microprocessors to perform optimizations that can interact with incorrectly synchronized code in ways that can produce behaviors that seem paradoxical.</p><p>However,it was forbidden by the original Java memory model in the JLS and JVMS: this was one of the first indications that the original JMM needed to be replaced.</p></blockquote><p>Java 的语义允许编译器和微处理器进行优化、重排 会改变语义,所以需要重新定义JMM内存模型</p><h2 id="Informal-Semantics"><a href="#Informal-Semantics" class="headerlink" title="Informal Semantics"></a>Informal Semantics</h2><p>There are two key ideas to understanding whether a program is correctly synchronized:</p><ol><li>Conflicting Accesses</li><li>Happens-Before Relationship</li></ol><p>There are a number of ways to induce a happens-before ordering, including: </p><ul><li><p>Each action in a thread happens-before every subsequent action in that thread. • An unlock on a monitor happens-before every subsequent lock on that monitor. • A write to a volatile field happens-before every subsequent read of that volatile. </p></li><li><p>A call to start() on a thread happens-before any actions in the started thread. </p></li><li>All actions in a thread happen-before any other thread successfully returns from a join() on that thread. </li><li>If an action a happens-before an action b, and b happens before an action c, then a happens- before c. </li></ul><blockquote><p>When a program contains two conflicting accesses that are not ordered by a happens-before relationship, it is said to contain a data race. </p></blockquote><p>理解一个程序是否被正确的同步了，有两个关键概念: 冲突访问和H-B</p><blockquote><p>Sequential Consistency</p><p> As noted before, sequential consistency and/or freedom from data races still allows errors arising from<br>groups of operations that need to be perceived atomically and are not.</p><p>If we were to use sequential consistency as our memory model, many of the compiler and<br>processor optimizations that we have discussed would be illegal.</p><p>Final Fields</p></blockquote><p>顺序一致性模型 也不能解决语义问题,同时还会让优化失效</p><h2 id="What-is-a-Memory-Model"><a href="#What-is-a-Memory-Model" class="headerlink" title="What is a Memory Model?"></a>What is a Memory Model?</h2><blockquote><p>A memory model describes, given a program and an execution trace of that program, whether<br>the execution trace is a legal execution of the program. For the Java programming language, the<br>memory model works by examining each read in an execution trace and checking that the write<br>observed by that read is valid according to certain rules.</p></blockquote><p>内存模型 描述程序的执行行为是否合法 对于Java 来说,内存共享型, 需要关注的是当前线程读取到的信息是否是最新的, 因为各个线程都有一个本地缓存(栈、cpu缓存),通过堆来共享</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g40xyu6xf8j30cb0amq36.jpg" alt="img"></p><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><p>Shared variables/Heap memory  共享变量/堆内存</p><p> Inter-thread Actions 线程间的动作</p><p>Program Order 程序顺序</p><p>Intra-thread semantics 线程内语义</p><p>Synchronization Actions  同步动作</p><p>Synchronization Order  同步顺序</p><p>Happens-Before and Synchronizes-With Edges  Happens-Before 与 Synchronizes-With 边缘</p><p> synchronizes-with，同步动作上的偏序关系。 </p><p>happens-before，动作上的偏序关系。</p><h2 id="Approximations-to-a-Java-Memory-Model"><a href="#Approximations-to-a-Java-Memory-Model" class="headerlink" title="Approximations to a Java Memory Model"></a>Approximations to a Java Memory Model</h2><ul><li>Sequential Consistency Memory Model</li><li>Happens-Before Memory Model</li><li>Causality<ul><li>Happens-Before is too Weak</li><li>Causality is Subtle</li></ul></li></ul><p>顺序一致性模型 约束太强了,不利于优化</p><p>Happens-Before 太弱了,执行结果不可预测 </p><p>Happens-before 模型最致命的弱点是其允许值“凭空出现(out of thin air)”</p><h2 id="Word-Tearing"><a href="#Word-Tearing" class="headerlink" title="Word Tearing"></a>Word Tearing</h2><p>One implementation consideration for Java virtual machines is that every field and array element<br>is considered distinct; updates to one field or element must not interact with reads or updates<br>of any other field or element. In particular, two threads that update adjacent elements of a byte<br>array separately must not interfere or interact and do not need synchronization to ensure sequential<br>consistency.</p><h2 id="Non-atomic-Treatment-of-double-and-long"><a href="#Non-atomic-Treatment-of-double-and-long" class="headerlink" title="Non-atomic Treatment of double and long"></a>Non-atomic Treatment of double and long</h2><p>For efficiency’s sake, this<br>behavior is implementation specific; JavaTM virtual machines are free to perform writes to long<br>and double values atomically or in two parts.</p><p>Final Field Semantics 、Fairness、Wait Sets and Notification、Sleep and Yield、Finalization</p><p>source :<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf?spm=a2c4e.10696291.0.0.3c5419a4WH2pe1&amp;file=jsr133.pdf" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf?spm=a2c4e.10696291.0.0.3c5419a4WH2pe1&amp;file=jsr133.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> Spec </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview_JDK</title>
      <link href="/2019/06/13/Overview_JDK/"/>
      <url>/2019/06/13/Overview_JDK/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g3zrf66tunj30u00gvgmz.jpg" alt="img"></p><a id="more"></a><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3zrgn8nvsj317s0ouagk.jpg" alt="image-20190613193823571"></p><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/desc_jdk_structure.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/desc_jdk_structure.html</a></p><p>平时接触较多应该就是如下包Lang、Beans、io、math、net、security、sql、collections 等</p><h2 id="JDK-Java-Development-ToolKit"><a href="#JDK-Java-Development-ToolKit" class="headerlink" title="JDK(Java Development ToolKit)"></a>JDK(Java Development ToolKit)</h2><p>包含了Java运行环境（JRE）和开发工具（编译器，调试器，javadoc等）。</p><p>javac 将Java代码编译成字节码</p><h2 id="JRE-Java-Runtime-Environment"><a href="#JRE-Java-Runtime-Environment" class="headerlink" title="JRE(Java Runtime Environment)"></a>JRE(Java Runtime Environment)</h2><p>它为Java提供了运行环境，其中重要的一环就是通过JVM将字节码解释成可执行的机器码。<br> JRE由JVM，SEAPI (动态链接库、java包)</p><h2 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h2><p>Java虚拟机，可以看做是一台<em>抽象化的计算机</em>，它有一套完整的体系架构，包括处理器、堆栈 、寄存器等。<br>在运行时环境，JVM会将Java字节码解释成机器码。</p><p>机器码和平台相关的（不同硬件环境、不同操作系统，产生的机器码不同），所以JVM在不同平台有不同的实现。<br>目前JDK默认使用的实现是Hotspot VM。</p><h2 id="官网结构"><a href="#官网结构" class="headerlink" title="官网结构"></a>官网结构</h2><p>最新官网文档</p><p><a href="https://docs.oracle.com/en/java/javase/12/" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/</a></p><ul><li><p>Overview</p><ul><li><a href="https://www.oracle.com/technetwork/java/javase/12-relnote-issues-5211422.html" target="_blank" rel="noopener">Release Notes</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/12-relnote-issues-5211422.html#NewFeature" target="_blank" rel="noopener">What’s New</a></li><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSMIG-GUID-C25E2B1D-6C24-4403-8540-CFEA875B994A" target="_blank" rel="noopener">Migration Guide</a></li><li><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Download the JDK</a></li><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSJIG-GUID-8677A77F-231A-40F7-98B9-1FD0B48C346A" target="_blank" rel="noopener">Install Guide</a></li><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSJIG-GUID-DCA60310-6565-4BB6-8D24-6FF07C1C4B4E" target="_blank" rel="noopener">Version String</a></li></ul></li><li><p>Tools</p><ul><li><p><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSWOR-GUID-55DE52DF-5774-4AAB-B334-E026FBAE6F34" target="_blank" rel="noopener">Tools Reference</a></p><p>1 Tools and Commands Reference<br>2 Main Tools to Create and Build Applications<br>3 Language Shell<br>4 Security Tools and Commands<br>5 Remote Method Invocation (RMI) Tools and Commands<br>6 Java Deployment Tools and Commands<br>7 Monitoring Tools and Commands<br>8 Java Accessibility Utilities and Commands<br>9 Troubleshooting Tools and Commands<br>10 Script Commands</p></li><li><p><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8" target="_blank" rel="noopener">JShell User’s Guide</a></p></li><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSJAV-GUID-7A344353-3BBF-45C4-8B28-15025DDCC643" target="_blank" rel="noopener">Javadoc Guide</a></li></ul></li><li><p>Language and Libraries</p><ul><li>Language Updates</li><li>Core Libraries</li><li>JDK HTTP Client</li><li><a href="https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html" target="_blank" rel="noopener">Java Tutorials</a></li><li>Modular JDK</li><li>Java Scripting Guide</li><li>Nashorn User’s Guide</li></ul></li><li><p>Specifications</p><ul><li><a href="https://docs.oracle.com/en/java/javase/12/docs/api/overview-summary.html" target="_blank" rel="noopener">API Documentation</a></li><li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">Language and VM</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/specs/security/standard-names.html" target="_blank" rel="noopener">Java Security Standard Algorithm Names</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/specs/jar/jar.html" target="_blank" rel="noopener">JAR</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/specs/jni/index.html" target="_blank" rel="noopener">Java Native Interface (JNI)</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/specs/jvmti.html" target="_blank" rel="noopener">JVM Tool Interface (JVM TI)</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/specs/serialization/index.html" target="_blank" rel="noopener">Serialization</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/specs/jdwp/jdwp-spec.html" target="_blank" rel="noopener">Java Debug Wire Protocol (JDWP)</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/specs/doc-comment-spec.html" target="_blank" rel="noopener">Standard Doclet</a></li></ul></li><li><p>Security</p><ul><li><a href="https://www.oracle.com/technetwork/java/seccodeguide-139067.html" target="_blank" rel="noopener">Secure Coding Guidelines</a></li><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSSEC-GUID-2EF91196-D468-4D0F-8FDC-DA2BEA165D10" target="_blank" rel="noopener">Security Guide</a></li></ul></li><li><p>HotSpot Virtual Machine</p><ul><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSJVM-GUID-982B244A-9B01-479A-8651-CB6475019281" target="_blank" rel="noopener">Java Virtual Machine Guide</a></li><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSGCT-GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304" target="_blank" rel="noopener">Garbage Collection Tuning</a></li><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JRHMG107" target="_blank" rel="noopener">JRockit to HotSpot Migration Guide</a></li></ul></li><li><p>Manage and Troubleshoot</p><ul><li><a href="https://www.oracle.com/pls/topic/lookup?ctx=javase12&amp;id=JSJMX-GUID-72DCB4C1-93F8-4F37-B46E-2C708139C8A5" target="_blank" rel="noopener">JMX Guide</a></li></ul></li><li><p>Client Technologies</p></li></ul><h2 id="OpenJDK"><a href="#OpenJDK" class="headerlink" title="OpenJDK"></a>OpenJDK</h2><p>openJDK下载<br><a href="http://hg.openjdk.java.net/jdk8u/jdk8u60/hotspot/archive/37240c1019fd.tar.gz" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u60/hotspot/archive/37240c1019fd.tar.gz</a><br><a href="http://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/archive/tip.tar.gz" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/archive/tip.tar.gz</a></p><p>例如,我们想看<code>java.lang.Thread#sleep(long)</code>的实现</p><pre><code class="java">/** * Causes the currently executing thread to sleep (temporarily cease * execution) for the specified number of milliseconds, subject to * the precision and accuracy of system timers and schedulers. The thread * does not lose ownership of any monitors. * * @param  millis *         the length of time to sleep in milliseconds * * @throws  IllegalArgumentException *          if the value of {@code millis} is negative * * @throws  InterruptedException *          if any thread has interrupted the current thread. The *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is *          cleared when this exception is thrown. */public static native void sleep(long millis) throws InterruptedException;</code></pre><p>native方法, 即我们常说的JNI——java native Interface ,调用本地接口,一般是将其它编程语言(如 C、C++ 和汇编语言）通过编译生成的动态链接库(编译过程是利用C／C++编译器实现的，在windows平台上，编译和连接的结果是动态链接库DLL文件。当要使用生成的动态链接库时，调用者类中需要显式调用该链接库dll文件。)</p><p>这些动态链接库是在JVM启动的时候装载进来的.</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/25713880" target="_blank" rel="noopener">更多相关</a> 或阅读 JNI规范</p></blockquote><p>好了回到正题,首先在下载的jdk包中,以下路径<code>src/share/native/java/lang/Thread.c</code></p><pre><code class="c">/* * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. * * This code is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License version 2 only, as * published by the Free Software Foundation.  Oracle designates this * particular file as subject to the &quot;Classpath&quot; exception as provided * by Oracle in the LICENSE file that accompanied this code. * * This code is distributed in the hope that it will be useful, but WITHOUT * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License * version 2 for more details (a copy is included in the LICENSE file that * accompanied this code). * * You should have received a copy of the GNU General Public License version * 2 along with this work; if not, write to the Free Software Foundation, * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. *//*- *      Stuff for dealing with threads. *      originally in threadruntime.c, Sun Sep 22 12:09:39 1991 */#include &quot;jni.h&quot;#include &quot;jvm.h&quot;#include &quot;java_lang_Thread.h&quot;#define THD &quot;Ljava/lang/Thread;&quot;#define OBJ &quot;Ljava/lang/Object;&quot;#define STE &quot;Ljava/lang/StackTraceElement;&quot;#define STR &quot;Ljava/lang/String;&quot;#define ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))static JNINativeMethod methods[] = {    {&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread},    {&quot;stop0&quot;,            &quot;(&quot; OBJ &quot;)V&quot;, (void *)&amp;JVM_StopThread},    {&quot;isAlive&quot;,          &quot;()Z&quot;,        (void *)&amp;JVM_IsThreadAlive},    {&quot;suspend0&quot;,         &quot;()V&quot;,        (void *)&amp;JVM_SuspendThread},    {&quot;resume0&quot;,          &quot;()V&quot;,        (void *)&amp;JVM_ResumeThread},    {&quot;setPriority0&quot;,     &quot;(I)V&quot;,       (void *)&amp;JVM_SetThreadPriority},    {&quot;yield&quot;,            &quot;()V&quot;,        (void *)&amp;JVM_Yield},    {&quot;sleep&quot;,            &quot;(J)V&quot;,       (void *)&amp;JVM_Sleep},    {&quot;currentThread&quot;,    &quot;()&quot; THD,     (void *)&amp;JVM_CurrentThread},    {&quot;countStackFrames&quot;, &quot;()I&quot;,        (void *)&amp;JVM_CountStackFrames},    {&quot;interrupt0&quot;,       &quot;()V&quot;,        (void *)&amp;JVM_Interrupt},    {&quot;isInterrupted&quot;,    &quot;(Z)Z&quot;,       (void *)&amp;JVM_IsInterrupted},    {&quot;holdsLock&quot;,        &quot;(&quot; OBJ &quot;)Z&quot;, (void *)&amp;JVM_HoldsLock},    {&quot;getThreads&quot;,        &quot;()[&quot; THD,   (void *)&amp;JVM_GetAllThreads},    {&quot;dumpThreads&quot;,      &quot;([&quot; THD &quot;)[[&quot; STE, (void *)&amp;JVM_DumpThreads},    {&quot;setNativeName&quot;,    &quot;(&quot; STR &quot;)V&quot;, (void *)&amp;JVM_SetNativeThreadName},};#undef THD#undef OBJ#undef STE#undef STRJNIEXPORT void JNICALLJava_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls){    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));}</code></pre><p>一般，从jdk目录下的native目录(可能跟os平台相关)下根据包名路径去找相关的Class名.c文件(Thread.c)，如 即可找到对应的native方法；</p><p>如果间接调用了hotspot的实现(jvm会以动态库的形式被加载，<code>prims</code>定义了hotspot与其他模块的接口及其实现)，那么从<code>hotspot/src/share/vm/prims/jvm.cpp</code>文件中可找到JVM_XXX函数(例如JVM_Sleep)的实现。</p><pre><code class="c">JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))  JVMWrapper(&quot;JVM_Sleep&quot;);  if (millis &lt; 0) {    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);  }  if (Thread::is_interrupted (THREAD, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {    THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);  }  // Save current thread state and restore it at the end of this block.  // And set new thread state to SLEEPING.  JavaThreadSleepState jtss(thread);#ifndef USDT2  HS_DTRACE_PROBE1(hotspot, thread__sleep__begin, millis);#else /* USDT2 */  HOTSPOT_THREAD_SLEEP_BEGIN(                             millis);#endif /* USDT2 */  EventThreadSleep event;  if (millis == 0) {    // When ConvertSleepToYield is on, this matches the classic VM implementation of    // JVM_Sleep. Critical for similar threading behaviour (Win32)    // It appears that in certain GUI contexts, it may be beneficial to do a short sleep    // for SOLARIS    if (ConvertSleepToYield) {      os::yield();    } else {      ThreadState old_state = thread-&gt;osthread()-&gt;get_state();      thread-&gt;osthread()-&gt;set_state(SLEEPING);      os::sleep(thread, MinSleepInterval, false);      thread-&gt;osthread()-&gt;set_state(old_state);    }  } else {    ThreadState old_state = thread-&gt;osthread()-&gt;get_state();    thread-&gt;osthread()-&gt;set_state(SLEEPING);    if (os::sleep(thread, millis, true) == OS_INTRPT) {      // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on      // us while we were sleeping. We do not overwrite those.      if (!HAS_PENDING_EXCEPTION) {        if (event.should_commit()) {          event.set_time(millis);          event.commit();        }#ifndef USDT2        HS_DTRACE_PROBE1(hotspot, thread__sleep__end,1);#else /* USDT2 */        HOTSPOT_THREAD_SLEEP_END(                                 1);#endif /* USDT2 */        // TODO-FIXME: THROW_MSG returns which means we will not call set_state()        // to properly restore the thread state.  That&#39;s likely wrong.        THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);      }    }    thread-&gt;osthread()-&gt;set_state(old_state);  }  if (event.should_commit()) {    event.set_time(millis);    event.commit();  }#ifndef USDT2  HS_DTRACE_PROBE1(hotspot, thread__sleep__end,0);#else /* USDT2 */  HOTSPOT_THREAD_SLEEP_END(                           0);#endif /* USDT2 */JVM_END</code></pre><p>贴个Hotspot目录结构(openjdk/hotspot/src/share/tools/launcher/java.c,openjdk8 中，这个启动器不见了，被放在 <code>openjdk/jdk</code> 文件夹下)</p><pre><code>├─agent                            Serviceability Agent的客户端实现├─make                             用来build出HotSpot的各种配置文件├─src                              HotSpot VM的源代码│  ├─cpu                            CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现）│  ├─os                             操作系相关代码│  ├─os_cpu                         操作系统+CPU的组合相关的代码│  └─share                          平台无关的共通代码│      ├─tools                        工具│      │  ├─hsdis                      反汇编插件│      │  ├─IdealGraphVisualizer       将server编译器的中间代码可视化的工具│      │  ├─launcher                   启动程序“java”│      │  ├─LogCompilation             将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具│      │  └─ProjectCreator             生成Visual Studio的project文件的工具│      └─vm                           HotSpot VM的核心代码│          ├─adlc                       平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器│          ├─asm                        汇编器接口│          ├─c1                         client编译器（又称“C1”）│          ├─ci                         动态编译器的公共服务/从动态编译器到VM的接口│          ├─classfile                  类文件的处理（包括类加载和系统符号表等）│          ├─code                       动态生成的代码的管理│          ├─compiler                   从VM调用动态编译器的接口│          ├─gc_implementation          GC的实现│          │  ├─concurrentMarkSweep      Concurrent Mark Sweep GC的实现│          │  ├─g1                       Garbage-First GC的实现（不使用老的分代式GC框架）│          │  ├─parallelScavenge         ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架）│          │  ├─parNew                   ParNew GC的实现│          │  └─shared                   GC的共通实现│          ├─gc_interface               GC的接口│          ├─interpreter                解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用）│          ├─libadt                     一些抽象数据结构│          ├─memory                     内存管理相关（老的分代式GC框架也在这里）│          ├─oops                       HotSpot VM的对象系统的实现│          ├─opto                       server编译器（又称“C2”或“Opto”）│          ├─prims                      HotSpot VM的对外接口，包括部分标准库的native部分和JVMTI实现│          ├─runtime                    运行时支持库（包括线程管理、编译器调度、锁、反射等）│          ├─services                   主要是用来支持JMX之类的管理功能的接口│          ├─shark                      基于LLVM的JIT编译器（官方版里没有使用）│          └─utilities                  一些基本的工具类└─test                             单元测试</code></pre>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> hotspot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spec_Java Virtual Machine</title>
      <link href="/2019/06/13/Spec-Java-Virtual-Machine/"/>
      <url>/2019/06/13/Spec-Java-Virtual-Machine/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g3znqgyeikj30hs0cgglr.jpg" alt="img"></p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>JSR-000924 JavaTM Virtual Machine Specification<br><strong>(Close of Maintenance Review: 19 July 2004)</strong></p><blockquote><p>Memory Model (Chapter 8) - JSR 133 has changed the memory model. Chapter 8 of the Java Virtual Machine Specification, Second Edition is superseded by JSR 133. See chapter 17 of the <a href="https://jcp.org/aboutJava/communityprocess/maintenance/JLS/index2.html" target="_blank" rel="noopener">Java Language Specification, Third Edition</a> for details.</p></blockquote><p>Java SE 7 开始内存模型被移除,相关规范在java语言规范第17章</p><p>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式——Class 文件<br>格式所关联，Class 文件中包含了 Java 虚拟机指令集(或者称为字节码、Bytecodes)和符号<br>表，还有一些其他辅助信息。</p><p>基于安全方面的考虑，Java 虚拟机要求在 Class 文件中使用了许多强制性的语法和结构化<br>约束，但任一门功能性语言都可以表示为一个能被 Java 虚拟机接收的有效的 Class 文件。</p><p>作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将 Java 虚拟机作为他们语言的<br>产品交付媒介。</p><p><strong>Summary of Chapters</strong></p><p>The rest of this book is structured as follows: </p><ul><li><p>Chapter 2 gives an overview of the Java Virtual Machine architecture.  </p><p>  Java 虚拟机结构</p></li><li><p>Chapter 3 introduces compilation of code written in the Java programming language into the instruction set of the Java Virtual Machine. </p></li><li><p>Chapter 4 specifies the class file format, the hardware- and operating system- independent binary format used to represent compiled classes and interfaces. </p></li><li><p>Chapter 5 specifies the start-up of the Java Virtual Machine and the loading, linking, and initialization of classes and interfaces. </p></li><li><p>Chapter 6 specifies the instruction set of the Java Virtual Machine, presenting the instructions in alphabetical order of opcode mnemonics. </p></li><li><p>Chapter 7 gives a table of Java Virtual Machine opcode mnemonics indexed by opcode value. </p></li></ul><h2 id="The-Structure-of-the-Java-Virtual-Machine"><a href="#The-Structure-of-the-Java-Virtual-Machine" class="headerlink" title="The Structure of the Java Virtual Machine"></a>The Structure of the Java Virtual Machine</h2><p>运行时内存结构  、相关的包、  帧</p><h2 id="Compiling-for-the-Java-Virtual-Machine"><a href="#Compiling-for-the-Java-Virtual-Machine" class="headerlink" title="Compiling for the Java Virtual Machine"></a>Compiling for the Java Virtual Machine</h2><p>将java文件编译成字节码, </p><p>Double和Long 的占据两个位置</p><p>synchronized 会加入monitorenter  monitorexit</p><p>异常表</p><h2 id="The-class-File-Format"><a href="#The-class-File-Format" class="headerlink" title="The class File Format"></a>The class File Format</h2><p>类文件结构 </p><h2 id="Loading-Linking-and-Initializing"><a href="#Loading-Linking-and-Initializing" class="headerlink" title="Loading, Linking, and Initializing"></a>Loading, Linking, and Initializing</h2><p>类加载 </p><h2 id="The-Java-Virtual-Machine-Instruction-Set"><a href="#The-Java-Virtual-Machine-Instruction-Set" class="headerlink" title="The Java Virtual Machine Instruction Set"></a>The Java Virtual Machine Instruction Set</h2><p>字节码指令集</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机规范 并不包含如下</p><ul><li><strong>Adaptive compiler</strong>: A standard interpreter is used to launch the applications. When the application runs, the code is analyzed to detect performance bottlenecks, or <em>hot spots</em>. The Java HotSpot VM compiles the performance-critical portions of the code for a boost in performance, but does not compile the seldom-used code (most of the application). The Java HotSpot VM uses the adaptive compiler to decide how to optimize compiled code with techniques such as inlining.</li><li><strong>Rapid memory allocation and garbage collection</strong>: Java HotSpot technology provides rapid memory allocation for objects and fast, efficient, state-of-the-art garbage collectors.</li><li><strong>Thread synchronization</strong>: Java HotSpot technology provides a thread-handling capability that is designed to scale for use in large, shared-memory multiprocessor servers.</li></ul><blockquote><p><a href="https://docs.oracle.com/en/java/javase/12/vm/java-virtual-machine-technology-overview.html#GUID-982B244A-9B01-479A-8651-CB6475019281" target="_blank" rel="noopener">HotSpot实现</a> </p><p><a href="https://files-cdn.cnblogs.com/files/chanshuyi/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%EF%BC%88JavaSE7%EF%BC%89.pdf" target="_blank" rel="noopener">中文资料</a></p><p><a href="https://www.oracle.com/technetwork/java/whitepaper-135217.html#1" target="_blank" rel="noopener">JDK1.7中的介绍</a></p><p><a href="https://www.zhihu.com/question/50398881" target="_blank" rel="noopener">jvm相关推荐一个大佬</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> Spec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka深入浅出</title>
      <link href="/2019/06/12/Overview_Kafka/"/>
      <url>/2019/06/12/Overview_Kafka/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3ymojzxi2j30u00u0gp5.jpg" alt="image-20190612200726343"></p><a id="more"></a><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>为什么快</p><p>​    producer-&gt;broker-&gt;comsumer    </p><p>​    </p><p><strong>segment文件命名规则</strong></p><p>​    磁盘顺序读</p><p>​    topic (1)-&gt;partition(n) 分布在broker 负载均衡(根据key hash取模)</p><p>​    文件分段 数据文件分段(顺序读写、分段命令、二分查找)</p><p>​                         <img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyek8wkwjj31720fqdik.jpg" alt="image-20200311212633833"></p><p>​    数据文件索引(分段索引、稀疏存储)</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd0jx2heztj316w0smdq5.jpg" alt="image-20200320180603193" style="zoom:67%;"></p><p>查找的算法是</p><ol><li><p>根据offset的值，查找segment段中的index索引文件。由于索引文件命名是以上一个文件的最后 一个offset进行命名的，所以，使用二分查找算法能够根据offset快速定位到指定的索引文件。</p></li><li><p>找到索引文件后，根据offset进行定位，找到索引文件中的符合范围的索引。(kafka采用稀疏索引的方式来提高查找性能)</p></li><li><p>得到position以后，再到对应的log文件中，从position出开始查找offset对应的消息，将每条消息</p><p> 的offset与目标offset进行比较，直到找到消息</p></li></ol><p>比如说，我们要查找offset=2490这条消息，那么先找到00000000000000000000.index, 然后找到 [2487,49111]这个索引，再到log文件中，根据49111这个position开始查找，比较每条消息的offset是 否大于等于2490。最后查找到对应的消息以后返回</p><p><strong>Log文件的消息内容分析</strong></p><p>根据kafka提供的命令</p><pre><code> offset: 5371 position: 102124 CreateTime: 1531477349286 isvalid: true keysize:-1 valuesize: 12 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1sequence: -1 isTransactional: false headerKeys: [] payload: message_5371</code></pre><p>offset和position这两个前面已经讲过了、 </p><p>createTime表示创建时间、</p><p>keysize和valuesize表示key和 value的大小、 </p><p>compresscodec表示压缩编码、</p><p>payload:表示消息的具体内容    </p><p>日志的清除策略以及压缩策略</p><p><strong>日志清除策略</strong></p><p>前面提到过，日志的分段存储，一方面能够减少单个文件内容的大小，另一方面，方便kafka进行日志 清理。日志的清理策略有两个</p><ul><li>根据消息的保留时间，当消息在kafka中保存的时间超过了指定的时间，就会触发清理过程</li><li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阀值，则可以开始删除最旧的消息。kafka会启动一个后台线程，定期检查是否存在可以删除的消息 </li></ul><p>通过log.retention.bytes和log.retention.hours这两个参数来设置，当其中任意一个达到要求，都会执行删除。</p><p><strong>日志压缩策略</strong></p><p>Kafka还提供了“日志压缩(Log Compaction)”功能，通过这个功能可以有效的减少日志文件的大小， 缓解磁盘紧张的情况，在很多实际场景中，消息的key和value的值之间的对应关系是不断变化的，就像 数据库中的数据会不断被修改一样，消费者只关心key对应的最新的value。因此，我们可以开启kafka 的日志压缩功能，服务端会在后台启动启动Cleaner线程池，定期将相同的key进行合并，只保留最新的 value值。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><strong>磁盘存储的性能优化</strong> <strong>顺序写</strong></p><p>​    我们现在大部分企业仍然用的是机械结构的磁盘，如果把消息以随机的方式写入到磁盘，那么磁盘首先 要做的就是寻址，也就是定位到数据所在的物理地址，在磁盘上就要找到对应的柱面、磁头以及对应的 扇区;这个过程相对内存来说会消耗大量时间，为了规避随机读写带来的时间消耗，kafka采用顺序写 的方式存储数据。即使是这样，但是频繁的I/O操作仍然会造成磁盘的性能瓶颈</p><p><strong>零拷贝</strong></p><p>消息从发送到落地保存，broker维护的消息日志本身就是文件目录，每个文件都是二进制保存，生产者 和消费者使用相同的格式来处理。在消费者获取消息时，服务器先从硬盘读取数据到内存，然后把内存 中的数据原封不动的通过socket发送给消费者。虽然这个操作描述起来很简单，但实际上经历了很多步 骤。</p><p>操作系统将数据从磁盘读入到内核空间的页缓存</p><ul><li>应用程序将数据从内核空间读入到用户空间缓存中</li><li>应用程序将数据写回到内核空间到socket缓存中</li><li>操作系统将数据从socket缓冲区复制到网卡缓冲区，以便将数据经网络发出</li></ul><p>通过“零拷贝”技术，可以去掉这些没必要的数据复制操作，同时也会减少上下文切换次数。现代的unix 操作系统提供一个优化的代码路径，用于将数据从页缓存传输到socket;在Linux中，是通过sendfile系 统调用来完成的。Java提供了访问这个系统调用的方法:FileChannel.transferTo API</p><p>使用sendfile，只需要一次拷贝就行，允许操作系统将数据直接从页缓存发送到网络上。所以在这个优 化的路径中，只有最后一步将数据拷贝到网卡缓存中是需要的</p><p><strong>页缓存</strong></p><p>页缓存是操作系统实现的一种主要的磁盘缓存，但凡设计到缓存的，基本都是为了提升i/o性能，所以页 缓存是用来减少磁盘I/O操作的。</p><p>磁盘高速缓存有两个重要因素:</p><p>第一，访问磁盘的速度要远低于访问内存的速度，若从处理器L1和L2高速缓存访问则速度更快。 </p><p>第二，数据一旦被访问，就很有可能短时间内再次访问。正是由于基于访问内存比磁盘快的多，所 以磁盘的内存缓存将给系统存储性能带来质的飞越。</p><p>Kafka中大量使用了页缓存， 这是Kafka实现高吞吐的重要因素之 一 。 虽然消息都是先被写入页缓存， 然后由操作系统负责具体的刷盘任务的， 但在Kafka中同样提供了同步刷盘及间断性强制刷盘(fsync), 可以通过 log.flush.interval.messages 和 log.flush.interval.ms 参数来控制。</p><p>同步刷盘能够保证消息的可靠性，避免因为宕机导致页缓存数据还未完成同步时造成的数据丢失。但是 实际使用上，我们没必要去考虑这样的因素以及这种问题带来的损失，消息可靠性可以由多副本来解 决，同步刷盘会带来性能的影响。 刷盘的操作由操作系统去完成即可</p><h3 id="一些配置"><a href="#一些配置" class="headerlink" title="一些配置"></a>一些配置</h3><p><strong>group.id</strong></p><p><strong>enable.auto.commit</strong></p><p><strong>auto.offset.reset</strong></p><p><strong>max.poll.records</strong></p><h3 id="Kafka消息的可靠性"><a href="#Kafka消息的可靠性" class="headerlink" title="Kafka消息的可靠性"></a>Kafka消息的可靠性</h3><p>副本机制</p><p>分区副本， 你可以创建更多的分区来提升可靠性，但是分区数过多也会带来性能上的开销，一般 来说，3个副本就能满足对大部分场景的可靠性要求</p><p>确认机制</p><p>Producer</p><p>acks，生产者发送消息的可靠性，也就是我要保证我这个消息一定是到了broker并且完成了多副 本的持久化，但这种要求也同样会带来性能上的开销。它有几个可选项 1, -1(全部) ,0</p><p>Consumer</p><p>保障消息到了broker之后，消费者也需要有一定的保证，因为消费者也可能出现某些问题导致消 息没有消费到</p><p>enable.auto.commit默认为true，也就是自动提交offset，自动提交是批量执行的，有一个时间窗 口，这种方式会带来重复提交或者消息丢失的问题，所以对于高可靠性要求的程序，要使用手动提 交。 对于高可靠要求的应用来说，宁愿重复消费也不应该因为消费异常而导致消息丢失</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p><strong>异步发送</strong></p><p>kafka客户端会积累一定量的消息统一组装成一个批量消息发送出 去，触发条件是前面提到的batch.size和linger.ms</p><p><strong>batch.size</strong></p><p>生产者发送多个消息到broker上的同一个分区时，为了减少网络请求带来的性能开销，通过批量的方式 来提交消息，可以通过这个参数来控制批量提交的字节数大小，默认大小是16384byte,也就是16kb， 意味着当一批消息大小达到指定的batch.size的时候会统一发送</p><p><strong>linger.ms</strong></p><p>Producer默认会把两次发送时间间隔内收集到的所有Requests进行一次聚合然后再发送，以此提高吞 吐量，而linger.ms就是为每次发送到broker的请求增加一些delay，以此来聚合更多的Message请求。 这个有点想TCP里面的Nagle算法，在TCP协议的传输中，为了减少大量小数据包的发送，采用了Nagle 算法，也就是基于小包的等-停协议。</p><p>batch.size和linger.ms这两个参数是kafka性能优化的关键参数，很多同学会发现batch.size和 linger.ms这两者的作用是一样的，如果两个都配置了，那么怎么工作的呢?实际上，当二者都配 置的时候，只要满足其中一个要求，就会发送请求到broker上</p><p>​    负载均衡</p><p>​    批量</p><p>​    压缩</p><p>0:表示producer不需要等待broker的消息确认。这个选项时延最小但同时风险最大(因为当server宕</p><p>机时，数据将会丢失)。 1:表示producer只需要获得kafka集群中的leader节点确认即可，这个选择时延较小同时确保了</p><p>leader节点确认接收成功。 all(-1):需要ISR中所有的Replica给予接收确认，速度最慢，安全性最高，但是由于ISR可能会缩小到仅</p><p>包含一个Replica，所以设置参数为all并不能一定避免数据丢失.</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>在实际生产过程中，每个topic都会有多个partitions，多个partitions的好处在于，</p><p>一方面能够对 broker上的数据进行分片有效减少了消息的容量从而提升io性能。</p><p>另外一方面，为了提高消费端的消费 能力，一般会通过多个consumer去消费同一个topic ，也就是消费端的负载均衡机制</p><p>consumer和partition的数量建议</p><ol><li>如果consumer比partition多，是浪费，因为kafka的设计是在一个partition上是不允许并发的， 所以consumer数不要大于partition数</li><li>如果consumer比partition少，一个consumer会对应于多个partitions，这里主要合理分配 consumer数和partition数，否则会导致partition里面的数据被取的不均匀。最好partiton数目是 consumer数目的整数倍，所以partition数目很重要，比如取24，就很容易设定consumer数目</li><li>如果consumer从多个partition读到数据，不保证数据间的顺序性，kafka只保证在一个partition 上数据是有序的，但多个partition，根据你读的顺序会有不同</li><li>增减consumer，broker，partition会导致rebalance，所以rebalance后consumer对应的 partition会发生变化</li></ol><p><strong>什么时候会触发这个策略呢?</strong></p><p>当出现以下几种情况时，kafka会进行一次分区分配操作，也就是kafka consumer的rebalance</p><p>1.同一个consumer group内新增了消费者</p><p>2.消费者离开当前所属的consumer group，比如主动停机或者宕机 </p><p>3.topic新增了分区(也就是分区数量发生了变化)</p><p><strong>分区分配策略</strong></p><p>一种是Range(默认)、 另一种是RoundRobin(轮询)、 StickyAssignor(粘性)。</p><p><strong>StrickyAssignor</strong> **分配策略</p><p>** kafka在0.11.x版本支持了StrickyAssignor, 翻译过来叫粘滞策略，它主要有两个目的</p><p>分区的分配尽可能的均匀<br>分区的分配尽可能和上次分配保持相同</p><p><strong>谁来执行Rebalance以及管理consumer的group呢?</strong></p><p>Kafka提供了一个角色:coordinator来执行对于consumer group的管理，Kafka提供了一个角色: coordinator来执行对于consumer group的管理，</p><p>当consumer group的第一个consumer启动的时 候，它会去和kafka server确定谁是它们组的coordinator。</p><p>之后该group内的所有成员都会和该 coordinator进行协调通信</p><p><strong>如何保存消费端的消费位置</strong></p><p><strong>什么是</strong> <strong>offset</strong></p><p>前面在讲解partition的时候，提到过offset， 每个topic可以划分多个分区(每个Topic至少有一个分 区)，同一topic下的不同分区包含的消息是不同的。每个消息在被添加到分区时，都会被分配一个 offset(称之为偏移量)，它是消息在此分区中的唯一编号，kafka通过offset保证消息在分区内的顺 序，offset的顺序不跨分区，即kafka只保证在同一个分区内的消息是有序的; 对于应用层的消费来 说，每次消费一个消息并且提交以后，会保存当前消费到的最近的一个offset。那么offset保存在哪 里?</p><p><strong>offset在哪里维护</strong></p><p>在kafka中，提供了一个<strong>consumer_offsets_*</strong>的一个topic, 把offset信息写入到这个topic中. consumer_offsets——按保存了每个consumer group某一时刻提交的offset信息。 __consumer_offsets 默认有50个分区。</p><p>Math.abs(“groupid”.hashCode())%groupMetadataTopicPartitionCount ; </p><p><strong>分区的副本机制 </strong>(副本机制,导致kafka的partition不能过多, 文件句柄,同步,写入确认)</p><p>我们已经知道Kafka的每个topic都可以分为多个Partition，并且多个partition会均匀分布在集群的各个 节点下。虽然这种方式能够有效的对数据进行分片，但是对于每个partition来说，都是单点的，当其中 一个partition不可用的时候，那么这部分消息就没办法消费。所以kafka为了提高partition的可靠性而 提供了副本的概念(Replica),通过副本机制来实现冗余备份。</p><p>每个分区可以有多个副本，并且在副本集合中会存在一个leader的副本，所有的读写请求都是由leader 副本来进行处理。剩余的其他副本都做为follower副本，follower副本会从leader副本同步消息日志。 这个有点类似zookeeper中leader和follower的概念，但是具体的时间方式还是有比较大的差异。所以 我们可以认为，副本集会存在一主多从的关系。</p><p>一般情况下，同一个分区的多个副本会被均匀分配到集群中的不同broker上，当leader副本所在的 broker出现故障后，可以重新选举新的leader副本继续对外提供服务。通过这样的副本机制来提高 kafka集群的可用性</p><p>Kafka分区下有可能有很多个副本(replica)用于实现冗余，从而进一步实现高可用。副本根据角色的不同</p><p>可分为3类:<br> <strong>leader</strong>副本:响应clients端读写请求的副本</p><p> <strong>follower</strong>副本:被动地备份leader副本中的数据，不能响应clients端读写请求。</p><p><strong>ISR</strong>副本:包含了leader副本和所有与leader副本保持同步的follower副本——如何判定是否与leader同 步后面会提到每个Kafka副本对象都有两个重要的属性:LEO和HW。注意是所有的副本，而不只是 leader副本。</p><p><strong>LEO</strong>:即日志末端位移(log end offset)，记录了该副本底层日志(log)中下一条消息的位移值。注意是下 一条消息!也就是说，如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0, 9]。另外， leader LEO和follower LEO的更新是有区别的。我们后面会详细说</p><p><strong>HW</strong>:即上面提到的水位值。对于同一个副本对象而言，其HW值不会大于LEO值。小于等于HW值的所 有消息都被认为是“已备份”的(replicated)。同理，leader副本和follower副本的HW更新是有区别的</p><p>从生产者发出的 一 条消息首先会被写入分区的leader 副本，不过还需要等待ISR集合中的所有 follower副本都同步完之后才能被认为已经提交，之后才会更新分区的HW, 进而消费者可以消费 到这条消息。</p><p>ISR集合中的副本必须满足两个条件</p><p>\1. 副本所在节点必须维持着与zookeeper的连接</p><p>\2. 副本最后一条消息的offset与leader副本的最后一条消息的offset之间的差值不能超过指定的阈值 (replica.lag.time.max.ms) replica.lag.time.max.ms:如果该follower在此时间间隔内一直没有追 上过leader的所有消息，则该follower就会被剔除isr列表</p><p>\3. ISR数据保存在Zookeeper的 /brokers/topics/<topic>/partitions/<partitionid>/state 节点中</partitionid></topic></p><p>参考:</p><blockquote><p>Kafka权威指南</p></blockquote><p>实践: <a href="https://www.infoq.cn/article/Q0o*QzLQiay31MWiOBJH" target="_blank" rel="noopener">https://www.infoq.cn/article/Q0o*QzLQiay31MWiOBJH</a></p><p>版本<a href="https://blog.csdn.net/lidazhou/article/details/95909496?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/lidazhou/article/details/95909496?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><p>0.7</p><p>0.8 副本机制</p><p>0.9</p><p>0.10 <strong>Kafka Streams</strong></p><p>0.11 一个是提供幂等性 Producer API 以及事务（Transaction） API；另一个是对 Kafka 消息格式做了重构。 </p><p>1.0  Kafka Streams改进</p><p>2.0</p><p>官方文档</p><p><a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener">https://kafka.apache.org/documentation/</a></p><p>rocketmq的优化</p><p><a href="https://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/" target="_blank" rel="noopener">https://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/</a></p><p><a href="https://rocketmq.apache.org/docs/motivation/" target="_blank" rel="noopener">https://rocketmq.apache.org/docs/motivation/</a></p><p>区别</p><p><a href="https://zhuanlan.zhihu.com/p/73431430?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73431430?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p><p>怎么合理选择分区</p><p> <a href="https://www.confluent.io/blog/how-choose-number-topics-partitions-kafka-cluster/" target="_blank" rel="noopener">https://www.confluent.io/blog/how-choose-number-topics-partitions-kafka-cluster/</a></p><p>高可用 复制机制</p><p><a href="https://zhuanlan.zhihu.com/p/46658003?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46658003?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p><h3 id="深入分析Kafka高可用性"><a href="#深入分析Kafka高可用性" class="headerlink" title="深入分析Kafka高可用性"></a>深入分析Kafka高可用性</h3><h4 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h4><p>①kafka复制机制</p><p>②分区leader副本宕掉怎么选新的leader </p><p>③高水位与leader epoch的详细分析</p><p>④一些相关配置</p><p>​    </p><p>所有的生产者请求和消费者请求都经过leader副本，leader副本以外的副本都是follower副本，follower副本不处理来自客户端的请求，它们唯一的任务就是从leader副本那里复制消息，保持与leader副本一致的状态。如果leader 副本发生崩溃，其中的一个follower副本会被提升为新的leader副本。</p><p>Kafka复制协议有两个阶段，</p><p>第一阶段，follower从leader获取到消息；</p><p>第二阶段，在下一轮的RPC中向leader发送fetch request确认收到消息。假设其他的follower也都确认了，那么leader会更新HW，并在接下来的RPC中响应给follower。</p><p>同时，在重启一个follower时，这个follower可能会把日志截断到HW处（意味着此follower将会删除一些消息），然后从leader获取消息。</p><p>会导致数据不一致 或者数据丢失</p><p>在0.11版本使用leader epoch解决这两个问题。</p><p>rocketmq和kafka</p>]]></content>
      
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis深入浅出</title>
      <link href="/2019/06/10/Overview_Redis/"/>
      <url>/2019/06/10/Overview_Redis/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g3x0bypob8j30u70u0kjl.jpg" alt="image-20190611102836454"></p><a id="more"></a><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>官网介绍    </p><p>​    Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. </p><p>​    It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams.</p><p>​     Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster</p><p>简单翻译下</p><p>​    内存数据结构存储 ,被当成数据库、缓存、消息代理使用</p><p>​    支持的数据结构,字符串 、哈希、列表、集合等</p><p>​    副本集(主从复制)、Lua脚本、LRU淘汰策略(Least Recently Used、Least Frequently Used)、事务(不可回滚)、不同级别的磁盘持久、用Sentinel保证高可用、用集群来自动分区</p><p>​    </p><p>单线程 、简单、高性能的key-value数据库</p><p>Redis 的特性:<br> 1)更丰富的数据类型 </p><p> 2)进程内与跨进程;单机与分布式</p><p> 3)功能丰富:持久化机制、过期策略</p><p> 4)支持多种编程语言</p><p> 5)高可用，集群</p><h2 id="版本特征"><a href="#版本特征" class="headerlink" title="版本特征"></a>版本特征</h2><p><strong>1.Redis2.6</strong></p><p>Redis2.6在2012年正式发布，相对于Redis2.4，主要特性如下：</p><ul><li>支持Lua脚本</li><li>键的过期时间支持毫秒</li><li>从节点支持只读功能</li></ul><p><strong>2.Redis2.8</strong></p><p>Redis2.8在2013年11月22日正式发布，相比于Redis2.6，主要特性如下：</p><ul><li>PSYNC 添加部分主从复制的功能</li><li>Redis Sentinel生产可用</li><li>新增命令：SCAN、SSCAN、HSCAN和ZSCAN</li></ul><p><strong>3.Redis3.0（里程碑）</strong></p><p>Redis3.0在2015年4月1日正式发布，相比于Redis2.8主要特性如下：</p><ul><li><strong>Redis Cluster：Redis的官方分布式实现</strong>。</li><li>全新的embedded string对象编码结果，优化小对象内存访问，在特定的工作负载下载速度大幅提升</li></ul><p><strong>4.Redis3.2</strong></p><p>Redis3.2在2016年5月6日正式发布，相比于Redis3.0主要特征如下：</p><ul><li>新的List编码类型：quicklist。</li></ul><p><strong>5.Redis4.0</strong></p><p>Redis4.0在2016年底正式发布，相比于Redis3.2主要特征如下： <a href="http://antirez.com/news/110" target="_blank" rel="noopener">http://antirez.com/news/110</a></p><ul><li>模块化</li><li>PSYNC2.0：优化了之前版本中，主从节点切换必然引起全量复制的问题。</li><li>提供了新的缓存剔除算法：LFU（Last Frequently Used），并对已有算法进行了优化。</li><li>提供了非阻塞del和flushall/flushdb功能，有效解决删除了bigkey可能造成的Redis阻塞。</li><li>提供了RDB-AOF混合持久化格式，充分利用了AOF和RDB各自优势。</li></ul><p><strong>6.Redis5.0</strong></p><p>Redis5.0在2018年5月正式发布相比于Redis4.0主要特征如下：</p><ul><li>Stream data type</li></ul><p> more: <a href="https://raw.githubusercontent.com/antirez/redis/5.0/00-RELEASENOTES" target="_blank" rel="noopener">https://raw.githubusercontent.com/antirez/redis/5.0/00-RELEASENOTES</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>​    Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。 当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p><h4 id="存储-实现-原理"><a href="#存储-实现-原理" class="headerlink" title="存储(实现)原理"></a>存储(实现)原理</h4><h5 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h5><pre><code class="c">/*dict.h*/typedef struct dictEntry {    void *key; /* key 关键字定义 */    union {        void *val; uint64_t u64; /* value 定义 */    int64_t s64; double d;    } v;    struct dictEntry *next; /* 指向下一个键值对节点 */} dictEntry;</code></pre><p>以set hello world 为例子</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8qxitborj312y0fajz4.jpg" alt="image-20200225165251801" style="zoom:50%;"></p><p>key 是字符串，但是 Redis 没有直接使用 C 的字符数组，而是存储在自定义的 SDS 中。</p><p>value 既不是直接作为字符串存储，也不是直接存储在 SDS 中，而是存储在 redisObject 中。实际上五种常用的数据类型的任何一种，都是通过 redisObject 来存储 的。</p><h5 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h5><pre><code class="c">/* server.h */typedef struct redisObject {    unsigned type:4; /* 对象的类型，包括:OBJ_STRING、OBJ_LIST、OBJ_HASH、OBJ_SET、OBJ_ZSET */             unsigned encoding:4; /* 具体的数据结构 */    unsigned lru:LRU_BITS; /* 24 位，对象最后一次被命令程序访问的时间，与内存回收有关 */    int refcount; /* 引用计数。当refcount为0的时候，表示该对象不被任何对象引用，可以进行垃圾回收了*/    void *ptr; /* 指向对象实际的数据结构 */} robj;</code></pre><p>可以使用 type 命令来查看对外的类型。</p><p>可以使用 object encoding 来查看具体的数据结构。</p><h5 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h5><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8r6meyqsj31040a8djs.jpg" alt="image-20200225170138936" style="zoom:50%;"></p><p>字符串类型的内部编码有三种:<br> 1、int，存储 8 个字节的长整型(long，2^63-1)。<br> 2、embstr, 代表 embstr 格式的 SDS(Simple Dynamic String 简单动态字符串)，</p><p>存储小于 44 个字节的字符串。<br> 3、raw，存储大于 44 个字节的字符串(3.2 版本之前是 39 字节)</p><p>问题 1、什么是 SDS? Redis 中字符串的实现?</p><p>​    在 3.2 以后的版本中，SDS 又有多种结构(sds.h):    sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64，用于存储不同的长度的字符串，分别代表 2^5=32byte， 2^8=256byte，2^16=65536byte=64KB，2^32byte=4GB。</p><pre><code class="c">/* sds.h */struct __attribute__ ((__packed__)) sdshdr8 {    uint8_t len; /* 当前字符数组的长度 */    uint8_t alloc; /*当前字符数组总共分配的内存大小 */    unsigned char flags; /* 当前字符数组的属性、用来标识到底是 sdshdr8 还是 sdshdr16 等 */     char buf[]; /* 字符串真正的值 */};</code></pre><p>问题 2、为什么 Redis 要用 SDS 实现字符串?</p><table><thead><tr><th><strong>C</strong> 字符串</th><th><strong>SDS</strong></th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为 O(N)</td><td>获取字符串长度的复杂度为 O(1)</td></tr><tr><td>API 是不安全的，可能会造成缓冲区溢出</td><td>API 是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度 N 次必然需要执行 N 次内存重分配</td><td>修改字符串长度 N 次最多需要执行 N 次内存重分配</td></tr><tr><td>只能保存文本数据</td><td><code>可以保存文本或者二进制数据</code></td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p>问题 3、embstr 和 raw 的区别?</p><p>​    embstr 的使用只分配一次内存空间(因为 RedisObject 和 SDS 是连续的,只读)，而 raw 需要分配两次内存空间(分别为 RedisObject 和 SDS 分配空间)。</p><p>问题 4、int 和 embstr 什么时候转化为 raw?</p><p>​    当int数据不再是整数，或大小超过了 long 的范围 (2^63-1=9223372036854775807)时，自动转化为 raw</p><p>​    对于 embstr，由于其实现是只读的，因此在对 embstr对象进行修改时，都会先转化为raw 再进行修改。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>缓存</p><p>数据共享分布式</p><p>分布式锁</p><p>​    STRING 类型 setnx 方法，只有不存在时才能添加成功，返回 true。</p><p>全局 ID</p><p>​    INT 类型，INCRBY，利用原子性</p><p>计数器</p><p>​    INT 类型，INCR 方法</p><p>限流</p><p>​    INT 类型，INCR 方法</p><p>位统计</p><p>​    bit count</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>​    Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash(在concurrentHashMap中也是渐进式,而且是多线程)。</p><p>Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。(操作的时候会触发rehash,同时后台会有个定时任务在执行)</p><p>​    相比字符串 ,可以进行部分获取,减少网络传输.  但hash 结构的存储消耗要高于单个字符串.</p><h4 id="存储-实现-原理-1"><a href="#存储-实现-原理-1" class="headerlink" title="存储(实现)原理"></a>存储(实现)原理</h4><p>​    外层的哈希(Redis KV 的实现)只用到了 hashtable。当存储 hash 数据类型时， 我们把它叫做内层的哈希。</p><p>内层的哈希底层可以使用两种数据结构实现:</p><p>ziplist:OBJ_ENCODING_ZIPLIST(压缩列表) </p><p>hashtable:OBJ_ENCODING_HT(哈希表)</p><h5 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist 压缩列表"></a>ziplist 压缩列表</h5><p>ziplist 是一个经过特殊编码的双向链表，它不存储指向上一个链表节点和指向下一 个链表节点的指针，而是存储上一个节点长度和当前节点长度，通过牺牲部分读写性能， 来换取高效的内存空间利用率，是一种时间换空间的思想。只用在字段个数少，字段值 小的场景里面。</p><p>内部结构</p><pre><code class="c">typedef struct zlentry {    unsigned int prevrawlensize;     /* 上一个链表节点占用的长度 */    unsigned int prevrawlen;             /* 存储上一个链表节点的长度数值所需要的字节数 */     unsigned int lensize;                 /* 存储当前链表节点长度数值所需要的字节数 */    unsigned int len;                         /* 当前链表节点占用的长度 */    unsigned int headersize; /* 当前链表节点的头部大小(prevrawlensize + lensize)，即非数据域的大小 */    unsigned char encoding;  /* 编码方式 */    unsigned char *p; /* 压缩链表以字符串的形式保存，该指针指向当前节点起始位置 */} zlentry;</code></pre><p>编码 encoding(ziplist.c 源码第 204 行)</p><pre><code class="c">#define ZIP_STR_06B (0 &lt;&lt; 6) //长度小于等于 63 字节#define ZIP_STR_14B (1 &lt;&lt; 6) //长度小于等于 16383 字节 #define ZIP_STR_32B (2 &lt;&lt; 6) //长度小于等于 4294967295 字节</code></pre><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8t03187tj31500oyk4q.jpg" alt="image-20200225180434113" style="zoom:50%;"></p><p>什么时候使用?</p><p>当 hash 对象同时满足以下两个条件的时候，使用 ziplist 编码:</p><p> 1)所有的键值对的健和值的字符串长度都小于等于 64byte(一个英文字母一个字节);</p><p>2)哈希对象保存的键值对数量小于 512 个。</p><h5 id="hashtable-dict"><a href="#hashtable-dict" class="headerlink" title="hashtable(dict)"></a>hashtable(dict)</h5><p>在 Redis 中，hashtable 被称为字典(dictionary)，它是一个数组+链表的结构。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8tkih1qwj31hg0piav8.jpg" alt="image-20200225182411033"></p><h6 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h6><pre><code class="c">/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */ typedef struct dictht {    dictEntry **table; /* 哈希表数组 */    unsigned long size; /* 哈希表大小 */    unsigned long sizemask; /* 掩码大小，用于计算索引值。总是等于 size-1 */     unsigned long used; /* 已有节点数 */} dictht;</code></pre><h6 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h6><pre><code class="c">typedef struct dict {    dictType *type; /* 字典类型 */    void *privdata; /* 私有数据 */    dictht ht[2]; /* 一个字典有两个哈希表 */    long rehashidx; /* rehash 索引 */    unsigned long iterators; /* 当前正在使用的迭代器数量 */} dict;</code></pre><h6 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h6><p>步骤:<br> 1、为字符 ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及 ht[0]当前包含的键值对的数量。<br> 扩展:ht[1]的大小为第一个大于等于 ht[0].used*2。<br> 2、将所有的 ht[0]上的节点 rehash 到 ht[1]上，重新计算 hash 值和索引，然后放入指定的位置。<br> 3、当 ht[0]全部迁移到了 ht[1]之后，释放 ht[0]的空间，将 ht[1]设置为 ht[0]表，并创建新的 ht[1]，为下次 rehash 做准备</p><p><a href="https://blog.csdn.net/wangmaohong0717/article/details/84611426" target="_blank" rel="noopener">https://blog.csdn.net/wangmaohong0717/article/details/84611426</a></p><p>扩容缩容?</p><p>负载因子</p><pre><code class="c">static int dict_can_resize = 1;static unsigned int dict_force_resize_ratio = 5;</code></pre><p>ratio = used / size，已使用节点与字典大小的比例</p><p>dict_can_resize 为 1 并且 dict_force_resize_ratio 已使用节点数和字典大小之间的 比率超过 1:5，触发扩容</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>string</p><p>存储对象类型的数据</p><p>购物车</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>​    Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。 常用于异步队列。</p><p>​    <img src="http://ww4.sinaimg.cn/large/006tNc79gy1g3xeyqvqyoj30zk03d3za.jpg" alt="image-20190611185500346"></p><p>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <code>ziplist</code>，也即是压缩列表。</p><p>​    当数据量比较多的时候才会改成 <code>quicklist</code>。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 <code>int</code> 类型的数据，结构上还需要两个额外的指针 <code>prev</code> 和 <code>next</code> 。所以 Redis 将链表和 <code>ziplist</code> 结合起来组成了 <code>quicklist</code>。也就是将多个 <code>ziplist</code> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h4 id="存储-实现-原理-2"><a href="#存储-实现-原理-2" class="headerlink" title="存储(实现)原理"></a>存储(实现)原理</h4><p>在早期的版本中，数据量较小时用 ziplist 存储，达到临界值时转换为 linkedlist 进 行存储，分别对应 OBJ_ENCODING_ZIPLIST 和 OBJ_ENCODING_LINKEDLIST 。</p><p>3.2 版本之后，统一用 quicklist 来存储。quicklist 存储了一个双向链表，每个节点 都是一个 ziplist。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8xdedczwj31bk0qoql7.jpg" alt="image-20200225203545120"></p><h5 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h5><p>quicklist(快速列表)是 ziplist 和 linkedlist 的结合体。</p><pre><code class="c">typedef struct quicklist {    quicklistNode *head; /* 指向双向列表的表头 */     quicklistNode *tail; /* 指向双向列表的表尾 */    unsigned long count; /* 所有的 ziplist 中一共存了多少个元素 */     unsigned long len;    /* 双向链表的长度，node 的数量 */    int fill : 16; /* fill factor for individual nodes */    unsigned int compress : 16;  /* 压缩深度，0:不压缩; */} quicklist;    </code></pre><h5 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a>quicklistNode</h5><p> quicklistNode 中的*zl 指向一个 ziplist，一个 ziplist 可以存放多个元素。</p><pre><code class="c">typedef struct quicklistNode {    struct quicklistNode *prev; /* 前一个节点 */    struct quicklistNode *next; /* 后一个节点 */    unsigned char *zl; /* 指向实际的 ziplist */    unsigned int sz; /* 当前 ziplist 占用多少字节 */    unsignedintcount:16;/* 当前ziplist中存储了多少个元素，占16bit(下同)，最大65536个*/ unsigned int        encoding : 2; /* 是否采用了 LZF 压缩算法压缩节点，1:RAW 2:LZF */    unsigned int   container : 2; /* 2:ziplist，未来可能支持其他结构存储 */    unsigned int   recompress : 1; /* 当前 ziplist 是不是已经被解压出来作临时使用 */    unsigned int   attempted_compress : 1; /* 测试用 */    unsigned int   extra : 10; /* 预留给未来使用 */} quicklistNode;</code></pre><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>用户消息时间线 timeline</p><p>消息队列</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>​    Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值<code>NULL</code>。</p><h4 id="存储-实现-原理-3"><a href="#存储-实现-原理-3" class="headerlink" title="存储(实现)原理"></a>存储(实现)原理</h4><p>​    Redis 用 intset 或 hashtable 存储 set。如果元素都是整数类型，就用 inset 存储。 如果不是整数类型，就用 hashtable(数组+链表的存来储结构)。</p><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="抽奖"><a href="#抽奖" class="headerlink" title="抽奖"></a>抽奖</h5><p>​    随机获取元素 spop myset</p><h5 id="点赞、签到、打卡"><a href="#点赞、签到、打卡" class="headerlink" title="点赞、签到、打卡"></a>点赞、签到、打卡</h5><p>​    这条微博的 ID 是 t1001，用户 ID 是 u3001。</p><p>​     用 like:t1001 来维护 t1001 这条微博的所有点赞用户。 </p><p>​    点赞了这条微博:sadd like:t1001 u3001 </p><p>​    取消点赞:srem like:t1001 u3001 </p><p>​    是否点赞:sismember like:t1001 u3001 </p><p>​    点赞的所有用户:smembers like:t1001 </p><p>​    点赞数:scard like:t1001</p><h5 id="商品标签"><a href="#商品标签" class="headerlink" title="商品标签"></a>商品标签</h5><p>用 tags:i5001 来维护商品所有的标签。</p><p>sadd tags:i5001 画面清晰细腻 sadd tags:i5001 真彩清晰显示屏 sadd tags:i5001 流畅至极</p><h5 id="商品筛选"><a href="#商品筛选" class="headerlink" title="商品筛选"></a>商品筛选</h5><p>​    获取差集</p><p>​        sdiff set1 set2</p><p>​    获取交集(intersection ) </p><p>​        sinter set1 set2<br>     获取并集<br>​         sunion set1 set2</p><p>sadd brand:apple iPhone11<br> sadd brand:ios iPhone11<br> sad screensize:6.0-6.24 iPhone11 sad screentype:lcd iPhone11</p><p>筛选商品，苹果的，iOS 的，屏幕在 6.0-6.24 之间的，屏幕材质是 LCD 屏幕</p><p>​     sinter brand:apple brand:ios screensize:6.0-6.24 screentype:lcd</p><h5 id="用户关注、推荐模型"><a href="#用户关注、推荐模型" class="headerlink" title="用户关注、推荐模型"></a>用户关注、推荐模型</h5><p>思考</p><p>1)相互关注? 2)我关注的人也关注了他? 3)可能认识的人?</p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>​    zset 可能是 Redis 提供的最为特色的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。</p><p>​    我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，所以 它的内部实现用的是一种叫做「跳跃列表」的数据结构。</p><p>数据结构对比:</p><table><thead><tr><th>数据结构</th><th>是否允许重复元素</th><th>是否有序</th><th>有序实现方式</th></tr></thead><tbody><tr><td>列表 list</td><td>是</td><td>是</td><td>索引下标</td></tr><tr><td>集合 set</td><td>否</td><td>否</td><td>无</td></tr><tr><td>有序集合 zset</td><td>否</td><td>是</td><td>分值 score</td></tr></tbody></table><h4 id="存储-实现-原理-4"><a href="#存储-实现-原理-4" class="headerlink" title="存储(实现)原理"></a>存储(实现)原理</h4><p>同时满足以下条件时使用 ziplist 编码:<br>     元素数量小于 128 个<br>     所有 member 的长度都小于 64 字节</p><p>超过阈值之后，使用 skiplist+dict 存储。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geagbtcrfdj319y08e0xw.jpg" alt="image-20200429105750619"></p><p>什么是 skiplist?</p><p>二分查找法只适用于有序数组，不适用于链表。所以为了解决这个问题</p><p>插入一个数据的时候，决定要放到那一层，取决于一个算法 ,zslRandomLevel</p><pre><code class="c">/* t_zset.c */int zslRandomLevel(void) {    int level = 1;    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))    level += 1;    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;}</code></pre><p>为什么不用 AVL 树或者红黑树?因为 skiplist 更加简洁。</p><pre><code class="c">typedef struct zskiplistNode {    sds ele; /* zset 的元素 */    double score; /* 分值 */    struct zskiplistNode *backward; /* 后退指针 */   struct zskiplistLevel {        struct zskiplistNode *forward; /* 前进指针，对应 level 的下一个节点 */        unsigned long span; /* 从当前节点到下一个节点的跨度(跨越的节点数) */   }   level[]; /* 层 */} zskiplistNode; typedef struct zskiplist {    struct zskiplistNode *header, *tail; /* 指向跳跃表的头结点和尾节点 */   unsigned long length; /* 跳跃表的节点数 */    int level; /* 最大的层数 */} zskiplist; typedef struct zset {    dict *dict;    zskiplist *zsl; } zset;</code></pre><p>结构图</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdtcli9r5pj310u0o6n6x.jpg" alt="image-20200414155358585"></p><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>排行榜</p><h4 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h4><h5 id="BitMaps"><a href="#BitMaps" class="headerlink" title="BitMaps"></a>BitMaps</h5><p>Bitmaps 是在字符串类型上面定义的位操作。一个字节由 8 个二进制位组成。</p><p>应用场景:<br>    用户访问统计<br>    在线用户统计</p><h5 id="Hyperloglogs"><a href="#Hyperloglogs" class="headerlink" title="Hyperloglogs"></a>Hyperloglogs</h5><p>Hyperloglogs:提供了一种不太准确的基数统计方法，比如统计网站的 UV，存在 一定的误差</p><h5 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h5><p>5.0 推出的数据类型。支持多播的可持久化的消息队列，用于实现发布订阅功能，借 鉴了 kafka 的设计。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8yt7wf1tj31cu0i0gsu.jpg" alt="image-20200225212533444"></p><h4 id="编码转换总结"><a href="#编码转换总结" class="headerlink" title="编码转换总结"></a>编码转换总结</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8ytljqnaj31g80nmagp.jpg" alt="image-20200225212555266"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>管道（Pipelining）</p><p>  一次发送多个命令，可以包含Batch命令,节省往返时间。 </p></li><li><p>淘汰策略 LRU LFU</p><p>  Least Recently Used    按照访问时间  这个可以用LinkHashMap 简单实现<br>  Least Frequently Used  按照访问次数  需要额外的队列记录访问频率</p></li><li><p>Batch 命令</p><p>  批量相同指令</p></li><li><p>事务  </p><p>  Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p></li><li><p>分布式锁</p><p>  Lua脚本实现原子性</p></li><li><p>TTL 过期删除 </p><p>  惰性、异步 删除, 注意过期时间要采用 一个常量加一个随机时间戳 防止大批量的key同一时间过期</p></li></ul><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h4 id="传统list队列局限"><a href="#传统list队列局限" class="headerlink" title="传统list队列局限"></a>传统list队列局限</h4><p>1、如果生产者生产消息的速度远大于消费者消费消息的速度，List 会占用大量的内 存。</p><p>2、消息的实时性降低。</p><p>基于 list 实现的消息队列，不支持一对多的消息分发。</p><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><h5 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h5><p>​    我们有很多的频道(channel)，我们也可以把这个频道理解成 queue。订 阅者可以订阅一个或者多个频道。消息的发布者(生产者)可以给指定的频道发</p><p>订阅</p><p>​    subscribe channel-1 channel-2 channel-3</p><p>发布</p><p>​    publish channel-1 2673</p><h5 id="按规则-Pattern-订阅频道"><a href="#按规则-Pattern-订阅频道" class="headerlink" title="按规则(Pattern)订阅频道"></a>按规则(Pattern)订阅频道</h5><p>支持?和<em>占位符。?代表一个字符，</em>代表 0 个或者多个字符。</p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 的事务有两个特点: </p><p>1、按进入队列的顺序执行。</p><p> 2、不会受到其他客户端的请求的影响。</p><p>Redis 的事务涉及到四个命令:multi(开启事务)，exec(执行事务)，discard (取消事务)，watch(监视)</p><h4 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h4><p>它可以为 Redis 事务提供 CAS 乐观锁行为(Check and Set / Compare and Swap)</p><p>我们可以用 watch 监视一个或者多个 key，如果开启事务之后，至少有一个被监视 key 键在 exec 执行之前被修改了， 那么整个事务都会被取消(key 提前过期除外)。可 以用 unwatch 取消。</p><h4 id="事务可能遇到的问题"><a href="#事务可能遇到的问题" class="headerlink" title="事务可能遇到的问题"></a>事务可能遇到的问题</h4><h5 id="在执行-exec-之前发生错误"><a href="#在执行-exec-之前发生错误" class="headerlink" title="在执行 exec 之前发生错误"></a>在执行 exec 之前发生错误</h5><p>比如:入队的命令存在语法错误，包括参数数量，参数名等等(编译器错误)。</p><p>在这种情况下事务会被拒绝执行，也就是队列中所有的命令都不会得到执行。</p><h5 id="在执行-exec-之后发生错误"><a href="#在执行-exec-之后发生错误" class="headerlink" title="在执行 exec 之后发生错误"></a>在执行 exec 之后发生错误</h5><p>比如，类型错误，比如对 String 使用了 Hash 的命令，这是一种运行时错误。</p><p>为什么在一个事务中存在错误，Redis 不回滚?</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><h3 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h3><p>Lua/ˈluə/是一种轻量级脚本语言，它是用 C 语言编写的，跟数据的存储过程有点类 似。 使用 Lua 脚本来执行 Redis 命令的好处:</p><p>1、一次发送多个命令，减少网络开销。</p><p>2、Redis 会将整个脚本作为一个整体执行，不会被其他请求打断，保持原子性。 </p><p>3、对于复杂的组合命令，我们可以放在文件中，可以实现程序之间的命令集复用。</p><h4 id="Lua应用"><a href="#Lua应用" class="headerlink" title="Lua应用"></a>Lua应用</h4><p>分布式锁</p><p>限流</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul><li><p>快照RDB</p><p>  全量备份</p></li><li><p>AOF 指令 </p><ul><li>1条指令执行一次刷盘</li><li>1段时间执行一次刷盘</li><li>1s执行一次刷盘</li></ul></li><li><p>RDB快照 +AOF同步</p></li></ul><p>​    </p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>​    高可用 主从同步(RDB快照 +AOF同步) 、raft 一致性算法 、gossip 通信协议</p><p>​    高性能 读写分离</p><p>​    分片 横向扩展 算法槽</p><p><a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">https://redis.io/topics/cluster-spec</a></p><p>参考:</p><blockquote><p>redis深度历险</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note_java并发编程的艺术</title>
      <link href="/2019/06/06/Note_java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2019/06/06/Note_java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g3rn5ridk4j30rs0czgo9.jpg" alt="image-20190606190506267"></p><a id="more"></a><h2 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h2><p>​        </p><p>多线程一定快吗</p><p>上下文切换<br>            上下文切换次数和时长<br>            如何减少上下文切换</p><p>死锁</p><p>资源限制的挑战</p><h2 id="Java并发机制的底层实现原理"><a href="#Java并发机制的底层实现原理" class="headerlink" title="Java并发机制的底层实现原理"></a>Java并发机制的底层实现原理</h2><h3 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h3><h4 id="cpu术语"><a href="#cpu术语" class="headerlink" title="cpu术语"></a>cpu术语</h4><p>​        内存屏障</p><h4 id="lock前缀指令"><a href="#lock前缀指令" class="headerlink" title="lock前缀指令"></a>lock前缀指令</h4><p>​        缓存写回内存<br>​        其他处理器的缓存无效</p><h4 id="volatile优化"><a href="#volatile优化" class="headerlink" title="volatile优化"></a>volatile优化</h4><p>​                队列集合类LinkedTransferQueue、队列64位</p><h3 id="synchronnized的实现原理与应用"><a href="#synchronnized的实现原理与应用" class="headerlink" title="synchronnized的实现原理与应用"></a>synchronnized的实现原理与应用</h3><h4 id="jdk1-6的改进"><a href="#jdk1-6的改进" class="headerlink" title="jdk1.6的改进"></a>jdk1.6的改进</h4><p>​        偏向锁<br>​        轻量级锁<br>​        锁的存储结构<br>​        升级过程</p><h4 id="实现同步的基础"><a href="#实现同步的基础" class="headerlink" title="实现同步的基础"></a>实现同步的基础</h4><p>​        普通同步方法，锁是当前实例对象<br>​        静态同步方法，锁是当前类的Class对象<br>​        同步方法块，锁是括号里配置的对象</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><h5 id="32bit"><a href="#32bit" class="headerlink" title="32bit"></a>32bit</h5><p>​                    锁状态<br>​                    25bit 对象的hascode<br>​                    4bit 对象的分代年龄<br>​                    1bit 是否偏向锁<br>​                    2bit 锁标志位</p><h5 id="64bit"><a href="#64bit" class="headerlink" title="64bit"></a>64bit</h5><h4 id="锁的升级和对比"><a href="#锁的升级和对比" class="headerlink" title="锁的升级和对比"></a>锁的升级和对比</h4><p>​        偏向锁<br>​                    偏向锁标识<br>​        轻量级锁<br>​                    CAS、自旋<br>​        重量级锁<br>​        追求吞吐</p><h3 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>​        比较并交换<br>​        CPU流水线<br>​                    将一条执行分成5-6步再由这些电路单元分别执行<br>​        内存顺序冲突</p><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><h5 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h5><p>​    把CPU和内存之间的通信都锁住了</p><h5 id="使用缓存锁定来保证原子性"><a href="#使用缓存锁定来保证原子性" class="headerlink" title="使用缓存锁定来保证原子性"></a>使用缓存锁定来保证原子性</h5><p>​    某个内存地址的操作是原子性即可<br>失效场景<br>​        操作数据不能备缓存在处理器内存，或操作的数据跨多个缓存行<br>​        有些处理器不支持</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>​            处理器提供的CMPXCHG指令<br>​            存在的问题<br>​                        ABA问题<br>​                        循环时间开销大<br>​                        只能保证一个共享变量的原子操作</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h3><h4 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h4><ul><li>如何通信—何种机制来交换信息</li><li>何时同步—控制发生相对顺序的机制</li></ul><h4 id="线程之间的通信机制"><a href="#线程之间的通信机制" class="headerlink" title="线程之间的通信机制"></a>线程之间的通信机制</h4><ul><li>共享内存—线程之间共享程序的公共状态，通过读-写内存中的公共状态进行隐式通信</li><li>消息传递—线程之间没有公共状态，线程之间必须通过发生消息来显式进行通信</li></ul><h4 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h4><p>JMM定义了线程和主内存之间的抽象关系,从源代码到指令序列的重排序,处理器通过内存屏障保证顺序</p><ul><li><p>编译器优化的重排序<br>  编译器在不改变单线程程序予以的前提下，可以重新安排语句的执行顺序</p></li><li><p>指令级并行的重排序<br>  现代处理器采用了指令级并行技术来将多条指令重叠执行</p></li><li><p>内存系统的重排序</p><p>  缓存和读/写缓冲区</p></li></ul><h4 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h4><h5 id="写缓冲区（写读的顺序）"><a href="#写缓冲区（写读的顺序）" class="headerlink" title="写缓冲区（写读的顺序）"></a>写缓冲区（写读的顺序）</h5><p>写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟<br>通过以批处理的方式刷新写缓冲区，以及合并写缓存区中对一内存地址的多次写，减少内存总线的占用<br>存在的问题<br>        写缓存区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际操作顺序不一致</p><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><ul><li>LoadLoad</li><li>StoreStore</li><li>LoadStore</li><li>StoreLoad<br>  确保了Store的数据对其他处理器变得可见（指刷新到内存）</li></ul><h4 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h4><p>阐述操作之间的内存可见性<br>两个操作之间存在happens- before关系，并不意味着前一个操作必须在后一个操作之前执行</p><h3 id="重排序（为了提高并行度）"><a href="#重排序（为了提高并行度）" class="headerlink" title="重排序（为了提高并行度）"></a>重排序（为了提高并行度）</h3><h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>​                编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序，前提是单个处理器执行的指令续集和单个线程中执行的操作</p><h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>​                不管怎么重排序，程序执行结果不能改变（单线程）</p><h4 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h4><h4 id="对多线程的影响"><a href="#对多线程的影响" class="headerlink" title="对多线程的影响"></a>对多线程的影响</h4><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><p>​                在一个线程中写一个变量<br>​                在另一个线程读同一个变量<br>​                而且写和读没有通过同步来排序</p><h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>​                特征<br>​                    一个线程中所有操作必须按照程序的顺序来执行<br>​                    所有线程都只能看到一个单一的操作执行顺序，每个操作都必须原子执行且立即对所有线程所见<br>​                任意时间点最多只能有一个线程可以连接到内存，串行化</p><h4 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h4><p>​                JMM临界区内的代码可以重排序</p><h4 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h4><p>​                JMM只提供最小安全性，线程执行时读取到的值，要么时之前某个线程写入的值，要么时默认值<br>​                差异<br>​                    JMM不保证对64位的long和double型的变量具有原子性，而顺序一致模型保证所有内存读/写都具有原子性</p><h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>​                可见性<br>​                原子性<br>​                    复合操作不支持，支持64 long/double</p><h4 id="建立的happens-before关系"><a href="#建立的happens-before关系" class="headerlink" title="建立的happens-before关系"></a>建立的happens-before关系</h4><h4 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h4><p>​                当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存<br>​                当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，从主内存中读取共享变量</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>​                编译器<br>​                    生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序，采用保守的方式<br>​                    在volatile读后插入内存屏障<br>​                        LoadLoad<br>​                        LoadStore<br>​                    在volatile写前后插入内存屏障<br>​                        StoreStore 前<br>​                        StoreLoad 后<br>​                            也可以读前插入StoreLoad，但考虑读多写少情况<br>​                优化<br>​                    省略不必要的屏障<br>​                    不同处理器，入x86仅会对写-读操作做重排序</p><p>旧模型不允许volatile变量之间重排序，但旧的Java模型允许volatile变量与普通变量重排序</p><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>锁是java并发变成中最重要的同步机制，除了让临界区互斥执行，还可以让释放锁的线程向获取同一个锁的线程发送消息<br>释放锁时，会把线程对应的本地内存中的共享变量刷新到主内存中<br>获取锁时，会把线程对应的本地内存置为无效</p><h4 id="CAS-1"><a href="#CAS-1" class="headerlink" title="CAS"></a>CAS</h4><p>​                同时具有volatile读和写的内存语义<br>​                程序根据处理器是否为cmpxchg指令添加lock前缀<br>​                intel对lock前缀的解释<br>​                    缓存锁定<br>​                    禁止指令重排<br>​                    把写缓冲区中的所有数据刷新到内存</p><h4 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h4><p>​                通用化模式<br>​                    声明共享变量<br>​                    使用CAS的条件更新来实现线程之间的同步<br>​                    配合以volatile读/写 和 CAS所具有的volatile读/写 语义来实现线程之间的通信</p><h3 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h3><h4 id="final域的重排序规则"><a href="#final域的重排序规则" class="headerlink" title="final域的重排序规则"></a>final域的重排序规则</h4><p>​                在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序<br>​                初次读一个包含final域的对象的引用，与随后初次读取这个final域，这两个操作之间不能重排序</p><h4 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h4><p>​                JMM禁止编译器把final域的写重排序到构造函数之外</p><h4 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h4><p>​                在读一个对象的final域之前，一定先读包含这个final域的对象引用</p><h4 id="final引用不能从构造函数内‘溢出’"><a href="#final引用不能从构造函数内‘溢出’" class="headerlink" title="final引用不能从构造函数内‘溢出’"></a>final引用不能从构造函数内‘溢出’</h4><h4 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h4><p>​                写final域的重排序规则会要求编译器在final域写之后，构造函数return之前插入一个StoreStore屏障<br>​                读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><h4 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h4><p>​                两个关键因素<br>​                    程序员对内存模型对使用<br>​                    编译器和处理器对内存模型对实现<br>​                happens-before要求禁止对重排序<br>​                    会改变程序执行结果对重排序<br>​                        JMM禁止<br>​                    不会改变程序执行结果的重排序<br>​                        JMM不禁止</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​                as-if-serial语义保证单线程的执行结果不被改变，happens-before关系保证正确同步的多线程执行结果不被改变</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>​                程序顺序规则<br>​                监视器锁规则<br>​                volatile变量规则<br>​                传递性<br>​                start规则<br>​                join规则</p><h3 id="双重检查锁定与延迟初始化"><a href="#双重检查锁定与延迟初始化" class="headerlink" title="双重检查锁定与延迟初始化"></a>双重检查锁定与延迟初始化</h3><h4 id="错误的根源"><a href="#错误的根源" class="headerlink" title="错误的根源"></a>错误的根源</h4><p>​                1.分配对象的内存空间<br>​                2.初始化对象<br>​                3.设置instance执行分配的内存地址<br>​            重排序 2 和 3，获取一个未初始化的对象</p><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>​                不允许2和3重排序<br>​                    volatile<br>​                允许2和3重排序，但不允许其他线程‘看到’这个重排序<br>​                    在执行类初始化期间，JVM会去获取一个锁，这个锁可以同步多个线程对同一个类对初始化</p><h4 id="类对初始化"><a href="#类对初始化" class="headerlink" title="类对初始化"></a>类对初始化</h4><p>​                一个类或接口类型立即被初始化对情况<br>​                    T是一个类，T对示例被创建<br>​                    T是一个类，且T中声明对一个静态方法被调用<br>​                    T中声明对一个静态字段被赋值<br>​                    T中声明对一个静态字段被使用，而且这个字段不是一个常量字段<br>​                    T是一个顶级类，而且一个断言语句嵌套在T内部被执行</p><h3 id="Java内存模型综述"><a href="#Java内存模型综述" class="headerlink" title="Java内存模型综述"></a>Java内存模型综述</h3><h4 id="处理器的内存模型"><a href="#处理器的内存模型" class="headerlink" title="处理器的内存模型"></a>处理器的内存模型</h4><p>​                JMM屏蔽了不同处理器内存模型的差异</p><h4 id="各种内存模型之间的关系"><a href="#各种内存模型之间的关系" class="headerlink" title="各种内存模型之间的关系"></a>各种内存模型之间的关系</h4><p>​                处理器内存模型是硬件级的内存模型<br>​                JMM语言级内存模型<br>​                顺序一致性内存模型是一个理论参考模型</p><h4 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h4><h4 id="JSR-133对内存语义的修复"><a href="#JSR-133对内存语义的修复" class="headerlink" title="JSR-133对内存语义的修复"></a>JSR-133对内存语义的修复</h4><h2 id="Java并发编程基础"><a href="#Java并发编程基础" class="headerlink" title="Java并发编程基础"></a>Java并发编程基础</h2><h3 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h3><h3 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h3><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><h4 id="通知-等待"><a href="#通知-等待" class="headerlink" title="通知/等待"></a>通知/等待</h4><p>​    监视器<br>​    对象<br>​    等待队列<br>​    同步队列</p><h4 id="等待方"><a href="#等待方" class="headerlink" title="等待方"></a>等待方</h4><p>​                获取对象锁<br>​                如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件<br>​                条件满足则执行对应逻辑</p><h4 id="通知方"><a href="#通知方" class="headerlink" title="通知方"></a>通知方</h4><p>​                获得对象的锁<br>​                改变条件<br>​                通知所有等待在对象上的线程<br>​        </p><h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>​            主要使用方式是继承，推荐被定义为自定义同步组件的静态内部类</p><h3 id="与锁的关系"><a href="#与锁的关系" class="headerlink" title="与锁的关系"></a>与锁的关系</h3><p>​                锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节<br>​                同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理，线程的排队，等待与唤醒等底层操作</p><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>​                    节点<br>​                        是什么<br>​                            当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构成一个节点，当同步状态释放时，会把首节点唤醒，再次尝试获取同步状态<br>​                        属性<br>​                            等待状态<br>​                            前驱节点<br>​                            后继节点<br>​                            等待队列中的后继节点<br>​                            获取同步状态的线程<br>​                    FIFO双向队列<br>​                        通过CAS设置尾节点</p><h3 id="ReenLock"><a href="#ReenLock" class="headerlink" title="ReenLock"></a>ReenLock</h3><h2 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h2><h3 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h3><p>​            降低资源消耗<br>​                通过重复利用已创建的线程降低线程创建和销毁造成的消耗<br>​            提高响应速度<br>​                当任务到达时，任务可以不需要等到线程创建就能立即执行<br>​            提高线程的可管理性<br>​                线程是稀有资源，使用线程池可以进行统一分配、调优和监控</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>​            线程池处理流程<br>​                1.首先，判断核心线程池里的线程是否都在执行任务，如果不是，创建任务，否则进入下个流程<br>​                2.判断工作队列是否已经满了，如果不是，存储在工作队列，否则进入下个流程<br>​                3.判断线程池的线程是否都处于工作状态，如果没有，创建一个新的线程执行任务（需要全局锁），否则交给饱和策略来处理<br>​            为什么<br>​                尽可能地避免获取全局锁，因为从处理流程来看，在完成预热后，几乎执行步骤都是落在2上</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p>corePoolSize（线程池的基本大小）<br>  提交一个任务到线程池时，线程池会创建一个任务，即使其他空闲到基本线程能够执行新任务，等需要执行的任务数大于线程池基本大小时就不再创建<br>  可以提前调用prestartAllCoreThreads提前创建并启动所有基本线程</p></li><li><p>runnableTaskQueue（任务队列）</p><pre><code>                  ArrayBlockingQueue                      基于数组结构的有界阻塞队列，FIFO                  LinkedBlockingQueue                      基于链表的阻塞队列，FIFO                  SynchronousQueue                      不存储元素的阻塞队列(使用场景是防止服务器重启或者down了 丢失队列中的数据)                  PriorityBlockQueue                      具有优先级的无限阻塞队列</code></pre><p>  注意 , 建议使用有界队列</p></li><li><p>maximumPoolSize(线程池最大数量)</p><pre><code>  注意，如果使用无界的任务队列，这个参数就没有意义了, 建议指定线程最大值,每个线程在分配时候的大小默认是512K</code></pre></li><li><p>ThreadFactory<br>  用于创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字,方便问题定位</p></li><li><p>RejectedExecutionHandler(饱和策略)</p><pre><code>                  AbortPolicy（默认）                      直接抛出异常                  CallerRunsPolicy                      只用调用者所在线程来运行任务                  DiscardOldestPolicy                      丢弃队列里最近的一个任务，并执行当前任务                  DiscardPolicy                      丢弃不处理</code></pre><p>  注意 也可以实现RejectExecutionHandler接口自定义策略,一般比较重要的,可以持久化到文件,或者另外的队列</p></li><li><p>keepAliveTime(线程活动保持时间)</p><pre><code>                  线程池的工作线程空闲后，保持存活的时间                  TimeUnit(单位)</code></pre></li></ul><h4 id="提交任务方式"><a href="#提交任务方式" class="headerlink" title="提交任务方式"></a>提交任务方式</h4><ul><li>execute 不带返回结果</li><li>submit 携带返回结果</li></ul><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><ul><li><p>shutdown</p></li><li><p>shutdownNow</p><p>  都是设置中断标记, 两者的差异只是在于shutdownNow不会执行等待队列中的任务</p></li></ul><h4 id="合理使用"><a href="#合理使用" class="headerlink" title="合理使用"></a>合理使用</h4><h5 id="任务性质"><a href="#任务性质" class="headerlink" title="任务性质"></a>任务性质</h5><p>​                    CPU密集型<br>​                        Cpu+1<br>​                    IO密集型<br>​                        2*Cpu</p><h5 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h5><p>​                    优先级队列</p><h5 id="任务执行时间"><a href="#任务执行时间" class="headerlink" title="任务执行时间"></a>任务执行时间</h5><p>​                    使用优先级队列，让时间短的任务先执行<br>​                    交给不同规模的线程池处理</p><h5 id="任务的依赖性"><a href="#任务的依赖性" class="headerlink" title="任务的依赖性"></a>任务的依赖性</h5><p>​                    依赖数据库链接池的任务，因为提交需要等待数据库返回结果，等待时间越长，空闲时间越长，所以设置线程数应该尽量大，同时注意针对这种昂贵的资源，记得使用超时机制</p><h5 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h5><p>​        largestPoolSize-最大线程数<br>​        getPoolSize-线程池的线程数量<br>​        getActiveCount-获取活动的线程数</p><p>​        扩展，继承线程池</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> note </tag>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty深入浅出</title>
      <link href="/2019/06/05/Overview_Netty/"/>
      <url>/2019/06/05/Overview_Netty/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3qmnkhrfcj30xc0m8ag3.jpg" alt="image-20190605220200987"></p><a id="more"></a><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>​    Netty is <em>an asynchronous event-driven network application framework</em> for rapid development of maintainable high performance protocol servers &amp; clients.</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g3qn7tloh8j30gg09o758.jpg" alt="img"></p><p>​    使用场景  zk ,redis proxy ,dubbo等</p><p>more : <a href="https://netty.io/" target="_blank" rel="noopener">https://netty.io/</a></p><h2 id="版本特征"><a href="#版本特征" class="headerlink" title="版本特征"></a>版本特征</h2><p>3.x </p><p>4.x  RECOMMENDED VERSION</p><p>5.x   ABANDONED VERSION - NOT SUPPORTED</p><p>more : <a href="https://netty.io/wiki/user-guide.html" target="_blank" rel="noopener">https://netty.io/wiki/user-guide.html</a></p><h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><ul><li>IO模型 (NIO)</li><li>数据协议(零拷贝、序列化框架)</li><li>线程模型(锁)</li></ul><h2 id="高性能之道"><a href="#高性能之道" class="headerlink" title="高性能之道"></a>高性能之道</h2><h3 id="异步非阻塞通信"><a href="#异步非阻塞通信" class="headerlink" title="异步非阻塞通信"></a>异步非阻塞通信</h3><p>​    NIO、多路复用I/O(JNI epoll)</p><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p>​    JDK1.4 提供了对非阻塞 IO(NIO)的支持，JDK1.5_update10 版本使用 epoll 替代了传统的 select/poll，极大的提升了 NIO 通信的性能</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc6j70n7vmj311u0mk4al.jpg" alt="image-20200223185404876"></p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>​    Zero-Copy describes computer operations in which the CPU does not perform the task of copying data from one memory area to another.</p><h4 id="直接堆外内存"><a href="#直接堆外内存" class="headerlink" title="直接堆外内存"></a>直接堆外内存</h4><p>​        Netty 的接收和发送 ByteBuffer 采用 DIRECTBUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝</p><p>​    如果使用传统的堆内存分配，当我们需要将数据通过socket发送的时候，就需要从堆内存拷贝到直接内存，然后再由直接内存拷贝到网卡接口层。<br>Netty提供的直接Buffer，直接将数据分配到内存空间，从而避免了数据的拷贝，实现了零拷贝。</p><h4 id="组合Buffer对象"><a href="#组合Buffer对象" class="headerlink" title="组合Buffer对象"></a>组合Buffer对象</h4><p>​        Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p><h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>​        Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。(Linux对零拷贝的支持) </p><h3 id="堆外内存的内存池"><a href="#堆外内存的内存池" class="headerlink" title="堆外内存的内存池"></a>堆外内存的内存池</h3><p>​    为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制</p><h3 id="高效的-Reactor-线程模型"><a href="#高效的-Reactor-线程模型" class="headerlink" title="高效的 Reactor 线程模型"></a>高效的 Reactor 线程模型</h3><ul><li><p>Reactor 单线程模型</p><p>  <img src="https://tva1.sinaimg.cn/large/0082zybply1gc7ais1pqtj31cu0ncwkk.jpg" alt="image-20200224103935683"></p></li><li><p>Reactor 多线程模型         </p><p>IO pool</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc7aje0bvej31280u0aj8.jpg" alt="image-20200224104010414"></p></li><li><p>主从 Reactor 多线程模型</p></li></ul><p>​        Acceptor pool</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc7akg94p4j310s0u012c.jpg" alt="image-20200224104111981"></p><h3 id="无锁化的串行设计理念"><a href="#无锁化的串行设计理念" class="headerlink" title="无锁化的串行设计理念"></a>无锁化的串行设计理念</h3><p>​    Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到 用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的 竞争，从性能角度看是最优的。</p><h3 id="高效的并发编程"><a href="#高效的并发编程" class="headerlink" title="高效的并发编程"></a>高效的并发编程</h3><ul><li>volatile 的大量、正确使用</li><li>CAS 和原子类的广泛使用</li><li>线程安全容器的使用</li><li>通过读写锁提升并发性能</li></ul><h3 id="高性能的序列化框架"><a href="#高性能的序列化框架" class="headerlink" title="高性能的序列化框架"></a>高性能的序列化框架</h3><p>​    影响序列化性能的关键因素</p><ul><li>序列化后的码流大小(网络带宽的占用)</li><li>序列化&amp;反序列化的性能(CPU 资源占用)</li><li>是否支持跨语言(异构系统的对接和开发语言切换)<br>  ​    通过扩展 Netty 的编解码接口，用户可以实 现其它的高性能序列化框架</li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc7e210rqvj31hc0tydvx.jpg" alt="image-20200224124152950"></p><h3 id="灵活的-TCP-参数配置能力"><a href="#灵活的-TCP-参数配置能力" class="headerlink" title="灵活的 TCP 参数配置能力"></a>灵活的 TCP 参数配置能力</h3><p>​    SO_RCVBUF 和 SO_SNDBUF<br>​        通常建议值为 128K 或者 256K<br>​    SO_TCPNODELAY<br>​        NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止 大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关 闭该优化算法。<br>​    软中断<br>​        RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu</p><p>​                </p>]]></content>
      
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> netty </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note_深入理解java虚拟机</title>
      <link href="/2019/06/05/Note_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2019/06/05/Note_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g3qlkg3awoj30yg0mx4qp.jpg" alt="image-20190605212425037"></p><a id="more"></a><p>​    这里只是简单的列出书中的知识点, 其实本书是对相关规范(JVM和JLS)和基于虚拟机规范官方实现(HotSpot)的总结 ,更多详细可以看下面的扩展链接</p><h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>​    线程独立，在虚拟机概念模型里，字节码解释器工作时通过这个计数器来选取下一条需要执行的指令</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>​    线程独立，每个方法在执行时会创建一个栈帧，调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>​    与虚拟机栈类似，不过它为Native方法服务</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>​    线程共享，所有对象实例以及数组都要在堆上分配（不绝对）<br>​    不绝对的原因：JIT编译器发展与逃逸分析技术逐渐成熟，栈上分配、标量替换</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>​    线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码<br>​    运行时常量池, 用于存放编译器生成的各种字面量和符号引用</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>​    并不是虚拟机运行时数据区的一部分，会收到本机总内存大小以及处理器寻址空间的限制<br>​    NIO，引入一种基于通道与缓冲区的I/O方式</p><h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li>检查</li><li>类加载</li><li>分配内存</li><li>初始化零值</li><li>对象头处理</li><li><init>初始化</init></li></ol><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象头<br>        对象自身的运行时数据<br>                        对象哈希码、对象分代年龄<br>                        GC分代年龄<br>                        锁状态标记<br>                        线程持有的锁<br>                        偏向线程ID<br>                        偏向时间戳<br>        类型指针<br>实例数据<br>对齐填充<br>        对象大小必须是8字节的整数倍</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>使用句柄<br>        reference存储的对象的句柄地址,句柄包含了实例数据和数据类型各种的地址<br>        优势,在对象被移动时，只会改变句柄中的实例数据指针，而reference本身不需要修改<br>直接指针（HotSpot虚拟机使用）<br>        reference存储的是对象地址<br>        优势,速度快，节省了一次指针定位的时间开销</p><hr><h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="对象可回收判断"><a href="#对象可回收判断" class="headerlink" title="对象可回收判断"></a>对象可回收判断</h3><p>​            引用计数算法<br>​                缺点是很难解决对象相互引用问题<br>​            可达性分析算法 GC Roots对象<br>​                虚拟机栈中引用的对象<br>​                方法区中类静态属性引用的对象<br>​                方法区中常量引用的对象<br>​                本地方法栈中JNI引用的对象<br>​            引用<br>​                强引用<br>​                软引用<br>​                    在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收<br>​                弱引用<br>​                    只能生存到下一次垃圾收集发生之前<br>​                虚引用<br>​            生存还是死亡<br>​                1.第一次标记<br>​                2.是否覆盖finalize方法，或者finalize方法已经被虚拟机调用过<br>​                3.放置在F-Queue队列<br>​            回收方法区<br>​                废弃常量<br>​                    无引用<br>​                无用的类<br>​                    该类的所有实例都已经被回收<br>​                    加载该类的ClassLoader已经被回收<br>​                    该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>​    不足<br>​            效率问题<br>​            空间问题</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>不足：将内存缩小为原来的一半<br>优化：由于新生代对象大部分都是朝生夕死，所以将内存划分为8：1（Eden和Survivor）</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>老年代</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存划分为几块，根据各个年代的特点采用最适合的收集算法</p><h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3><p>枚举根节点<br>                使用OopMap的数据结构来得知哪些地方存放这对象引用（执行上下文和全局的引用位置）<br>安全点<br>HotSpot没有为每条指令都生成OopMap，只有在特定的位置，这些位置称为安全点<br>程序执行时，只有达到安全点才能暂停<br>GC时候怎么让线程都在最近安全点停止<br>        抢先式中断<br>            GC时候，先把所有线程中断，如果发现有线程没有在安全点上，就恢复线程，让它跑到安全点<br>        主动式中断<br>            GC需要中断的时候，不直接对线程操作，通过设置一个标记，各个线程在安全点时候去轮询这个标识，发现中断标识为真时候就自动挂起<br>安全区域<br>                是指在一段代码片段之中引用关系不会发生变化<br>                进入safe Region中的代码，会标识自己进入safe Region</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>Serial收集器<br>                运行在Client模式下的单线程垃圾收集器的虚拟机<br>ParNew收集器<br>                运行在Server模式下的多线程垃圾收集器的虚拟机<br>Parallel Scavenge收集器<br>                可控制的吞吐量<br>Serial Old收集器<br>ParOld收集器<br>CMS收集器<br>        最短回收停顿时间为目标的收集器<br>                运行过程<br>                    初始标记<br>                        标记一下GC Roots能直接关联到的对象，STop The World<br>                    并发标记<br>                        GC Roots Tracing的过程<br>                    重新标记<br>                        修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录,STop The World<br>                    并发清除<br>                缺点<br>                    对CPU资源非常敏感<br>                    无法处理浮动垃圾<br>                    标记清除，碎片过多的解决方案<br>                        UseCMSCompactAtFullCollection<br>                            FullGC前先内存合并<br>                        CMSFullGCsBeforeCompaction<br>                            执行多少次不压缩的FullGC后，跟着来一次带压缩的<br>G1收集器（JDK1.7）<br>                特点<br>                    并行与并发<br>                    分代收集<br>                    空间整合<br>                    可预测的停顿<br>                        基于Region，维护一个优先列表，有计划的回收区域垃圾，优先回收价值大的Region<br>                        Remembered Set来避免全堆扫描，保存Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用<br>                步骤<br>                    初始标记<br>                    并发标记<br>                    最终标记<br>                        虚拟机将并发标记期间对象的变化记录在线程Remembered Set Logs里，合并到Remember Set中，需停顿，可并行<br>                    筛选回收<br>                        对Region的回收价值和成本进行排序，根据用户期待的GC停顿时间来制定回收计划</p><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><h3 id="垃圾收集器参数"><a href="#垃圾收集器参数" class="headerlink" title="垃圾收集器参数"></a>垃圾收集器参数</h3><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>​            对象优先在Eden分配<br>​            大对象直接进入老年代<br>​            长期存活的对象将进入老年代<br>​            动态对象年龄判断<br>​            空间分配担保</p><hr><h2 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h2><h3 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h3><p>​            jps<br>​                JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程<br>​            jstat<br>​                JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据<br>​            jinfo<br>​                Configuration Info for Java，显示虚拟机配置信息<br>​            jmap<br>​                Memory Map for Java，生成虚拟机的内存快照（heapdump文件），另外finalize执行队列、Java堆、永久代的详细信息<br>​            jhat<br>​                JVM Heap Dump Browser，用于分析headdump文件，建立一个HTTP/HTML服务器<br>​            jstack<br>​                Stack Trace for Java ，显示虚拟机的线程快照，主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源</p><h3 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h3><h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><p>​        概述 jps<br>​        内存 jstat<br>​        线程 jstack<br>​        类<br>​        VM概要 jinfo<br>​        VMBean</p><h4 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h4><p>​                功能<br>​                    显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）<br>​                    监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）<br>​                    dump以及分析堆转储快照（jmap、jhat）<br>​                    方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法<br>​                    离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立ige快照<br>​                    …<br>​                插件<br>​                    BTrace动态日志跟踪</p><hr><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h3><p>​            平台无关性<br>​                操作系统的应用层面上，虚拟机载入和执行同一种平台无关的字节码<br>​            语言无关系<br>​                Groovy<br>​                Scala<br>​                …</p><h3 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h3><p>​            魔数与Class文件的版本<br>​            常量池<br>​            访问标志<br>​            类索引、父类索引与接口索引集合<br>​            字段表集合<br>​            方法表集合<br>​            属性表集合</p><h3 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h3><p>​            字节码与数据类型<br>​            加载和存储指令<br>​            运算指令<br>​            类型转换指令<br>​            对象创建与访问指令<br>​            操作数栈管理指令<br>​            控制转移指令<br>​            方法调用和返回指令<br>​            异常处理指令<br>​            同步指令</p><hr><h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>必须初始化的情况<br>​                遇见字节码指令<br>​                    new<br>​                        使用new关键字实例化对象的时候<br>​                    getstatic<br>​                    putstatic<br>​                    invokestatic<br>​                    读取或设置一个类的静态字段，调用一个类的静态方法的时候<br>​                使用java.lang.reflect包对类进行反射调用的时候，触发其初始化<br>​                初始一个类的时候，如果发现其父类没有进行初始化，对其父类进行初始化<br>​                虚拟机启动时，用户需要指定一个要执行的主类，会先初始化这个主类<br>​                MethodHandle实例最后解析结果REF_(..)static的方法句柄，句柄对应的类没有初始化，需要先触发其初始化<br>类的生命周期<br>加载<br>连接<br>​                    验证<br>​                    准备<br>​                    解析<br>初始化<br>使用<br>卸载<br>​                </p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>​            加载<br>​                1.通过一个类的全限定名来获取定义此类的二进制字节流<br>​                    从ZIP包获取<br>​                    从网络中获取<br>​                    运行时计算生成，动态代理<br>​                    其他文件，JSP<br>​                    从数据库中读取<br>​                2.将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构<br>​                3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口<br>​            连接<br>​                验证<br>​                    1.文件格式<br>​                        Class文件格式规范<br>​                    2.元数据<br>​                        对字节码的语义分析<br>​                    3.字节码<br>​                        通过数据流和控制流，语义是否合法和符合逻辑的<br>​                    4.符合引用<br>​                        将符号引用转化为直接引用的时候<br>​                    基于方法区的存储结构进行<br>​                准备<br>​                    为类变量分配内存并设置类变量初始化值的阶段<br>​                解析<br>​                    虚拟机将常量池内的符号引用替换为直接引用的过程<br>​                    定义解释<br>​                        符号引用<br>​                            与虚拟机布局无关，但是符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范Class文件格式汇总<br>​                        直接引用<br>​                            是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，与虚拟机布局相关<br>​                    优化<br>​                        对第一次解析的结果进行缓存，在运行时常量池中记录直接引用，并把常量标识为已解析状态（除了invokedynamic）<br>​                    针对<br>​                        类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点<br>​            初始化</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>​            类与类加载器<br>​                类是否相等的比较，前提是这两个类由同一个类加载器加载的前提下才有意义<br>​            双亲委派模型<br>​                启动类加载器<br>​                扩展类加载器<br>​                应用程序类加载器<br>​            破坏双亲委派模型<br>​                第一次破坏<br>​                    原因：向前兼容<br>​                    解决方法：ClassLoader新增一个protected方法findClass<br>​                第二次破坏<br>​                    原因：基础类想要调用SPI（Service Provider Interface）<br>​                    解决方法：线程上下文类加载器<br>​                第三次破坏<br>​                    原因：追求程序的动态性，代码热替换，模块热部署<br>​                    解决方法：OSGI</p><hr><h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>​            局部变量表<br>​                是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Slot为最小单位<br>​                局部变量表不像类变量，并不会赋默认值<br>​            操作栈<br>​                LIFO栈<br>​            动态连接<br>​                每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接<br>​            返回地址<br>​                正常执行返回<br>​                异常退出<br>​            …</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>​            唯一任务就是确定被调用方法的版本（即调用哪一个方法）<br>​            解析<br>​                字节码指令<br>​                    invokestatic<br>​                        调用静态方法<br>​                    invokespecial<br>​                        调用实例构造器<init>方法、私有方法和父类方法<br>​                    invokevirtual<br>​                        调用所有虚方法<br>​                    invokeinterface<br>​                        调用接口方法，会在运行时再缺点一个实现此接口的对象<br>​                    invokedynamic<br>​                        先在运行时动态解析出调用点限定符所引用的的方法，然后执行，分派逻辑是用户所设定的引导方法决定的<br>​                    非虚方法，除了这两个指令，还包含被final修饰的方法<br>​            分派<br>​                静态分派<br>​                    所有依赖静态类型来定位方法执行版本的分派动作称为静态分派<br>​                动态分派<br>​                    invokevirtual指令的运行时解析过程<br>​                        1.找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C<br>​                        2.如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行权限校验<br>​                            通过，则返回这个方法的直接引用，查找过程结束<br>​                            否则，则返回java.lang.IllegalAccessError异常<br>​                        3.否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程<br>​                        4.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常<br>​                单分派与多分派<br>​                    Java语言是一门静态多分派、动态单分派的语言<br>​                虚拟机动态分派的实现<br>​                    虚方法表<br>​                        虚方法表中存放着各个方法的实际入口地址<br>​                    非稳定“激进”优化<br>​                        内联缓存<br>​                        基于“类型继承关系分析技术”的守护内联</init></p><h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>​            动态类型语言<br>​                关键特征是它的类型检查的主题过程是在运行期而不是编译期<br>​            JDK1.7与动态类型<br>​                1.7之前，虚拟机实现动态类型语言的方式，留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配<br>​            java.lang.invoke包<br>​                本质上<br>​                    MethodHandle是在模拟字节码层次的方法调用<br>​                        findStatic<br>​                            invokestatic<br>​                        findVirtual<br>​                            invokevirtual<br>​                        findSpecial<br>​                            invokespecial<br>​                    Reflection是在模拟Java代码层次的方法调用<br>​                内容上<br>​                    MethodHandle仅仅包含与执行方法相关的信息 轻量级<br>​                    Reflection包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，执行权限等运行期信息 重量级<br>​                性能上<br>​                    MethodHandle 是对字节码的方法指令调用模拟，所以可以复用虚拟机的各种优化，例如方法内联等<br>​                    Reflection 没有相应的优化<br>​            invokedynamic指令</p><h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><p>​            解释执行<br>​                程序源码<br>​                词法分析<br>​                单词流<br>​                语法分析<br>​                抽象语法树<br>​                指令流<br>​                解释器<br>​                解释执行<br>​                优化器<br>​                中间代码<br>​                生成器<br>​                目标代码<br>​                步骤一： javac执行<br>​                步骤二：解释执行<br>​                步骤二：传统编译原理<br>​            基于栈的指令集与基于寄存器的指令集<br>​                基于栈的指令集<br>​                    优点<br>​                        可移植<br>​                    缺点<br>​                        性能慢<br>​                基于寄存器的指令集</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​            Tomcat正统的类加载器架构<br>​                需要满足的要求<br>​                    部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离<br>​                    部署在同一个服务器上的两个Web应用程序所使用的Java类库可以相互共享<br>​                    服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响<br>​                    支持JSP应用的Web服务器<br>​                Tomcat目录<br>​                    /common目录<br>​                        类库可被Tomcat和所有的Web应用程序共同使用<br>​                    /server目录<br>​                        类库可被Tomcat使用，对所有的Web应用程序都不可见<br>​                    /shared目录<br>​                        类库可被所有的Web应用程序共同使用，但对Tomcat自身不可见<br>​                    /WEB-INF目录<br>​                        类库仅对此Web应用程序使用<br>​                    Tomcat 6.x版本 合并到一个lib目录<br>​            OSGi 灵活类加载器架构<br>​                Bundle<br>​                    声明它所依赖的Java Package（通过Import-Package描述）<br>​                    声明允许导出发布的Java Package（通过Export-Package描述）<br>​                类加载的查找规则<br>​                    以java.*开头的类，委托给父类加载器加载<br>​                    否则，委托列表名单内的类，委托给父类加载器<br>​                    否则，Import列表中的类，委托给Export这个类的Bundle的类加载器假期<br>​                    否则，查找当前Bundle的Classpath，使用自己的类加载器加载<br>​                    否则，查找是否在在自己Fragment Bundle中，如果是，则委派给Fragment Bundle的类加载器<br>​                    否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器<br>​                    否则，类查找失败<br>​                提供强大功能的同时，也引入了额外的复杂度，带来了线程死锁和内存泄露的风险（bundle的相互依赖）<br>​            字节码生成技术与动态代理的实现<br>​                字节码生成技术<br>​                    字节码类库<br>​                        Javassist<br>​                        CGLib<br>​                        ASM<br>​                    javac<br>​                    JSP、AOP、动态代理、反射<br>​                动态代理<br>​                    代理类<br>​                        大致过程就是根据Class文件的格式规范去拼接字节码<br>​            Retrotranslator<br>​                跨越JDK版本，具体实现是使用ASM对字节码修改<br>​                JDK每次升级新增功能分类<br>​                    编译器层面做的改进<br>​                        自动拆箱装箱<br>​                    对Java API代码增强<br>​                        JDK1.2的Collections集合类，JDK1.5的concurrent并发包<br>​                    需要在字节码中进行支持的改动<br>​                        譬如，动态语言支持，invokedynamic字节码指令<br>​                    虚拟机内部的改进<br>​                        JDK1.5实现JSR-133规范重新定义Java内存模型（JMM）<br>​                    只能模拟这两类<br>​            实战：远程执行功能<br>​                目标<br>​                    不依赖JDK版本<br>​                    不改变原有服务端程序的部署，不依赖任何第三方类库<br>​                    不侵入原有程序<br>​                    “临时代码”需要直接支持java语言<br>​                    “临时代码”需要具备足够的自由度，不需要依赖特定的类<br>​                    “临时代码”的执行结果可以返回客户端<br>​                问题及解决思路<br>​                    如何编译提交到服务器的Java代码<br>​                        使用tools.jar包<br>​                        javac编译好，上传字节码（.class）文件到服务端<br>​                    如何执行编译之后的Java代码<br>​                        让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法<br>​                    如何收集Java代码的执行结果<br>​                        使用标准输出和标准错误输出获取打印的信息，会影响到原有程序，这里标准输出设备是虚拟机线程全局共享的资源<br>​                        使用自己定义的PrintStream对象，会把其他线程向标准输出中打印的信息也收集了<br>​                        直接在执行的类中把对System.out的符合引用替换为我们准备的PrintStream的符合引用</p><hr><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>虚拟机团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化所带来的好处    </p><h3 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h3><p>编译过程<br>                准备过程：初始化插入式注解处理器<br>1.解析与填充符合表过程<br>                    1.词法分析、语法分析<br>                        词法分析<br>                            将源代码的字符流转变为标记（Token）集合<br>                        语法分析<br>                            是根据Token序列构造抽象语法树的过程<br>                    2.输入到符号表<br>                        符号表<br>                            是由一组符号地址和符合信息构成的表格（K-V）<br>2.插入式注解处理器的注解处理过程<br>                    注解处理器<br>                        可以把它看作是一组编译器的插件，可以读取、修改、添加抽象语法树中的任意元素<br>                        注意：每次处理完注解，如果由修改都会Round<br>3.分析与字节码生成过程<br>                    1.标注检查<br>                        检查的内容包括，变量使用前是否已被声明，变量与赋值之间的数据类型是否能够匹配等<br>                    2.数据流分析<br>                        检查程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理<br>                    3.解语法糖<br>                        泛型<br>                        变长参数<br>                        自动装箱/拆箱<br>                    4.生成字节码<br>                        把前面所生成的信息（语法符合表）转换为字节码写到磁盘中<br>                        少量代码添加和转换工作<br>                            实例构造器和类构造器<br>                            字符串的加操作替换为StringBuffer或builder的append操作<br>                    语义分析</p><h3 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h3><p>​            泛型与类型擦除<br>​                C# 类型膨胀，真实泛型<br>​                Java 伪泛型<br>​            自动拆箱/装箱、变长参数、泛型<br>​            条件编译<br>​                只能实现在语句基本块级别的条件编译，去除分支不成立的代码块</p><h3 id="实战：插入式注解"><a href="#实战：插入式注解" class="headerlink" title="实战：插入式注解"></a>实战：插入式注解</h3><hr><h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>​            为何HotSpot虚拟机要使用解释器与编译器并存的架构？<br>​            为何HotSpot虚拟机要实现两个不同的即时编译器？<br>​            程序合何时使用解释器执行？何时使用编译器执行？<br>​            哪些程序代码会被编译为本地代码？如何编译为本地代码？<br>​            如何从外部观察即时编译器的编译过程和编译结果？<br>​            </p><h3 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h3><p>​    编译器与解释器<br>​        解释器<br>​            Interperter<br>​        编译器<br>​            Client Compiler<br>​            Server Compiler<br>​    编译对象与触发条件（Client即时编译方式）<br>​        热点代码<br>​            被多次掉调用的方法<br>​            被多次执行的循环体（OSR编译，栈上替换）<br>​        热点探测<br>​            基于采样的热点探测<br>​            基于计数器的热点探测（HotSpot）<br>​                方法调用<br>​                回边计数器<br>​        热度衰减<br>​            当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半<br>​    编译过程<br>​        Client Compiler<br>​            第一阶段<br>​                字节码<br>​                方法内联、常量传播、其他优化…<br>​                HIR（SSA形式）<br>​            第二阶段<br>​                空值检查消除、范围检查消除、其他优化…<br>​                优化后的HIR<br>​                HIR到LIR的转换<br>​            第三阶段<br>​                使用线性扫描算法在LIR上分配寄存器<br>​                在LIR上做窥孔优化<br>​                生成机器码<br>​        Server Compiler<br>​            它还会执行所有经典的优化动作<br>​                无用代码消除<br>​                循环展开<br>​                循环表达式外提<br>​                常量传播<br>​                消除公共子表达式<br>​                基本块重排序<br>​                …<br>​            还会实施一些与Java语言特性密切相关的优化技术<br>​                范围检查消除<br>​                空值检查消除<br>​                …<br>​            根据Cllient Compiler提供的性能监控信息，进行一些不稳定的激进优化<br>​                守护内联<br>​                分支频率预测<br>​                …<br>​    查看及分析即时编译结果</p><h3 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h3><p>​    优化技术概览<br>​        编译器策略<br>​            延迟编译<br>​            分层编译<br>​            栈上替换<br>​            延迟优化<br>​            程序依赖图表示<br>​            静态单赋值表示<br>​        基于性能监控的优化技术<br>​            乐观空值断言<br>​            乐观类型断言<br>​            乐观类型增强<br>​            乐观数组长度增强<br>​            裁剪未被选择的分支<br>​            乐观的多态内联<br>​            多支频率预测<br>​            调用频率预测<br>​        基于证据的优化技术<br>​            精确类型判断<br>​            内存值推断<br>​            内存值跟踪<br>​            常量折叠<br>​            重组<br>​            操作符退化<br>​            空值检查消除<br>​            类型检测退化<br>​            类型检测消除<br>​            代数化简<br>​            公共子表达式消除<br>​        数据流敏感重写<br>​            条件常量传播<br>​            基于流承载的类型缩减转换<br>​            无用代码消除<br>​        语言相关的优化技术<br>​            类型继承关系分析<br>​            去虚拟化<br>​            符合常量传播<br>​            自动装箱消除<br>​            逃逸分析<br>​            锁消除<br>​            锁膨胀<br>​            消除反射<br>​        内存及代码位置变换<br>​            表达式提升<br>​            表达式下沉<br>​            冗余存储消除<br>​            相邻存储合并<br>​            交汇点分离<br>​        循环变换<br>​            循环展开<br>​            循环剥离<br>​            安全点消除<br>​            迭代范围分离<br>​            范围检查消除<br>​            循环向量化<br>​        全局代码调整<br>​            内联<br>​            全局代码外提<br>​            基于热度的代码布局<br>​            Switch调整<br>​        控制流图变换<br>​            本地编码编排<br>​            本地代码封包<br>​            延迟槽填充<br>​            着色图寄存器分配<br>​            线性扫描寄存器分配<br>​            复写聚合<br>​            常量分裂<br>​            复写移除<br>​            地址模式匹配<br>​            指令窥孔优化<br>​            基于确定有限状态机的代码生成</p><h3 id="与C-编译器对比"><a href="#与C-编译器对比" class="headerlink" title="与C++编译器对比"></a>与C++编译器对比</h3><p>​    劣势<br>​        1.即时编译器运行占用用户程序的运行时间，它能提供的优化手段受制于编译成本<br>​        2.Java语言是动态的类型安全语言，需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存<br>​        3.Java语言没有virtual关键字，进行优化时的难度大于C/C++<br>​        4.Java语言是动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得对一些全局优化只能使用激进的手段<br>​        5.Java内存都是在堆上分配的，只有方法中的局部变量才能在栈上分配，而C/C++的对象由多种内存分配方式<br>​    </p><p>优势<br>        动态安全、动态扩展、垃圾回收</p><hr><h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><h3 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h3><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>​            主内存<br>​                所有变量都存储在主内存<br>​            工作内存<br>​                每条线程都有一个工作内存，保存了该线程使用到的变量的主内存副本拷贝</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>​            lock<br>​                它把一个变量标识为一条线程独占的状态<br>​            unlock<br>​                它把一个处于锁定状态的变量释放出来<br>​            read<br>​                它把一个变量的值从主内存传输到线程的工作内存中<br>​            write<br>​                它把store操作从工作内存中得到的变量的值放入主内存变量<br>​            load<br>​                它把read操作从内存中得到的变量值放入工作内存的变量副本中<br>​            use<br>​                它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作<br>​            assign<br>​                它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作<br>​            store<br>​                它把工作内存中一个变量的值传送到主内存中，以便write使用<br>​            作用于主内存<br>​            作用于工作内存</p><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>​            不允许read和load、store和write操作之一单独出现<br>​            不允许一个线程丢弃它的最近assign操作<br>​            不允许一个线程无原因地把数据从线程的工作内存同步回主内存<br>​            一个新的变量只能在主内存中“诞生，use和store操作之前，必须先assign和load<br>​            一个变量在同一时刻只允许一条线程对其进行lock操作，但是同一条线程可以多次lock<br>​            如果一个变量执行lock操作，那么清空工作内存中此变量的值，执行引擎使用这个变量前，需要重新load或assign<br>​            一个变量没有被lock,就不允许被unlock，另外不允许unlock其他线程<br>​            一个变量执行unlock操作之前，必须先把此变量同步回主内存中（store、write）</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>​            特征<br>​                1.保证此变量对所有线程的可见性<br>​                2.禁止指令重排<br>​            仍需要加锁的场景<br>​                运算结果并不依赖变量当前值<br>​                变量不需要与其他的状态变量共同参与不变约束</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>​            原子性<br>​                synchronized块保证原子性<br>​            可见性<br>​                volatile可见性，synchronized和final<br>​            有序性<br>​                volatile禁止指令重排，synchronized保证同一个锁两个同步块只能串行</p><h4 id="先行发生原则-happen-before"><a href="#先行发生原则-happen-before" class="headerlink" title="先行发生原则 happen-before"></a>先行发生原则 happen-before</h4><p>​            程序次序规则<br>​            管程锁定规则<br>​            volatile<br>​            线程启动规则<br>​            线程终止规则<br>​            线程中断规则<br>​            对象终结规则<br>​            传递性</p><h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>​            1.使用内核线程实现<br>​            2.使用用户线程实现<br>​            3.使用用户线程加轻量级进程混合实现<br>​            4.java线程的实现</p><h4 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h4><p>​            协同式线程调度<br>​            抢占式线程调度<br>​                线程优先级（不确定性）</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>​            新建(New)<br>​            运行(Runable)<br>​                Running<br>​                Ready<br>​            无限期等待 (Wating)<br>​            限期等待(Timed Wating)<br>​            阻塞(Blocked)<br>​            结束(Terminated)</p><hr><h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="安全程度"><a href="#安全程度" class="headerlink" title="安全程度"></a>安全程度</h4><p>​            1.不可变<br>​                final<br>​                String<br>​                枚举类型<br>​                …<br>​            2.绝对线程安全<br>​                不管运行时环境如何，调用者都不需要任何额外的同步措施<br>​                如Vector就不是绝对线程安全<br>​            3.相对线程安全<br>​                我们通常意义上所讲的线程安全<br>​            4.线程兼容<br>​                不是线程安全的，ArrayList、HashMap<br>​            5.线程对立<br>​                死锁</p><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><h5 id="1-互斥同步（悲观）"><a href="#1-互斥同步（悲观）" class="headerlink" title="1.互斥同步（悲观）"></a>1.互斥同步（悲观）</h5><p>​                保证共享数据在同一个时刻只被一个线程使用<br>​                手段<br>​                    临界区<br>​                    互斥量<br>​                    信号量<br>​                synchronized<br>​                    阻塞唤醒，需要操作系统来帮忙，所以需要从用户态切换到核心态<br>​                    虚拟机优化自旋锁，自旋等待<br>​                ReentrantLock重入锁<br>​                    等待可中断<br>​                        当持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情<br>​                    可实现公平锁<br>​                        多个线程在等待同一个锁的时候，按照申请锁的时间顺序来依次获得锁<br>​                    锁可以绑定多个对象<br>​                        可以同时绑定多个Condition对象</p><h5 id="2-非阻塞同步（乐观）"><a href="#2-非阻塞同步（乐观）" class="headerlink" title="2.非阻塞同步（乐观）"></a>2.非阻塞同步（乐观）</h5><p>​                指令<br>​                    Test-and-Set<br>​                    Fetch-and-Increment<br>​                    Swap<br>​                    Compare-and-Swap（CAS）<br>​                        内存位置<br>​                        旧的预期值<br>​                        新值<br>​                    Load-Linked/Store-Conditional（LL/SC）<br>​                    20世纪已存在大多数</p><h5 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h5><p>​                可重入代码<br>​                    只要输入相同的数据，都能返回相同的结果<br>​                线程本地存储<br>​                    共享数据限制在一个线程内</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>​        自旋锁与自适应锁<br>​        锁消除<br>​        锁粗化<br>​        轻量级锁<br>​            CAS操作<br>​        偏向锁<br>​            当另外一个线程去尝试获取这个锁的时候，偏向模式就宣告结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> note </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL深入浅出</title>
      <link href="/2019/06/04/Overview_MySQL/"/>
      <url>/2019/06/04/Overview_MySQL/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g3ph297snqj30ia0sfjue.jpg" alt="image-20190604220256224"></p><a id="more"></a><h2 id="MySQL版本特征"><a href="#MySQL版本特征" class="headerlink" title="MySQL版本特征"></a>MySQL版本特征</h2><ul><li><p>2001 , 3.23  </p><ul><li>诞生, MyISAM代替ISAM ,引入全文索引和复制</li></ul></li><li><p>2003 , 4.0</p><ul><li>新语法的支持  UNION、多表DELETE语法</li><li>复制优化 , 两个线程来实现复制</li><li>InnoDB成为标准配备   行级锁、外键</li><li>查询缓存</li></ul></li><li><p>2005 , 4.1</p><ul><li>新语法支持  子查询、INSERT ON DUPLICATE KEY UPDATE</li><li>支持UTF-8字符集</li><li>支持新的二级协议和prepared语句</li></ul></li><li><p>2006 , 5.0</p><ul><li>企业级特征 视图、触发器、存储过程、函数</li></ul></li><li><p>2008 , 5.1 </p><ul><li>分区</li><li>基于行复制</li><li>plugin API</li></ul></li><li><p>2010 , 5.5</p><ul><li>InnoDB成为默认引擎</li><li>半同步插件</li><li>线程池</li></ul></li><li><p>2013, 5.7</p><ul><li>JSON支持</li></ul></li><li><p>2016, 8.0</p><p>  <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html</a></p></li></ul><hr><h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li><p>最小的通常更好 占用更少的磁盘、内存和CPU缓存</p></li><li><p>简单就好 简单数据类型的操作通常需要更少的CPU周期</p></li><li><p>尽量避免NULL  </p><p>  NULL columns require additional space in the row to record whether their values are NULL.<br>  For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte</p></li></ul><h3 id="Schema设计中的陷阱"><a href="#Schema设计中的陷阱" class="headerlink" title="Schema设计中的陷阱"></a>Schema设计中的陷阱</h3><ul><li><p>太多的列</p></li><li><p>从行缓冲中将编码过的列转换成行数据结构的操作代价非常的高</p></li><li><p>太多的关联</p></li><li><p>限制 最多只能61张表,经验法则单个查询最好在12个表以内</p></li><li><p>过度枚举</p></li><li><p>NULL</p></li></ul><p>​    </p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ul><li><p>TINYINT（8）</p></li><li><p>SMALLINT（16）</p></li><li><p>MEDIUMINT（32）</p></li><li><p>INT（64）</p></li><li><p>BIGINT（128）</p><p>  属性 UNSIGNED、宽度</p></li></ul><h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><ul><li>FLOAT</li><li>DOUBLE</li><li>DECIMAL</li></ul><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ul><li>VARCHAR<ul><li>需要使用1或2个额外字节记录字符串的长度,会保留末尾空格</li><li>字符串列的最大长度比平均长度大很多,列的更新很少，碎片少            </li></ul></li><li>CHAR<ul><li>适合存储很短的字符串，或者所有值都接近同一个长度,会删除末尾空格</li><li>经常变更的数据</li></ul></li></ul><h4 id="BLOB和TEXT类型"><a href="#BLOB和TEXT类型" class="headerlink" title="BLOB和TEXT类型"></a>BLOB和TEXT类型</h4><ul><li><p>BLOB 二进制</p></li><li><p>TEXT 字符方式存储</p><p>  当值太大时候，InnoDB会使用专门的“外部”存储区域进行存储，行内存储指针</p></li></ul><h4 id="枚举ENUM"><a href="#枚举ENUM" class="headerlink" title="枚举ENUM"></a>枚举ENUM</h4><ul><li><p>优势</p><p>  存储枚举非常紧凑<br>  在列表中保存为整数，在表.frm文件中保存”数字-字符串”映射关系表</p></li><li><p>劣势</p><p>  字符串列表是固定的，修改必须使用ALTER TABLE</p></li></ul><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><ul><li><p>DATETIME</p><p>  存储范围 从1001年到9999年、精度为秒 ,格式 YYYYMMDDHHMMSS、使用8个字节、与时区无关</p></li><li><p>TIMESTAMP</p><p>  存储范围 从1970到2038年、保存了从1970年以来的秒数 和UNIX时间戳相同、只使用4个字节、和时区有关</p></li></ul><pre><code>如果需要保存更小粒度的时间,可以使用BIGINT存储</code></pre><h4 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h4><p>​        BIT、SET( 不常用 )</p><h4 id="选择标识符（主键）"><a href="#选择标识符（主键）" class="headerlink" title="选择标识符（主键）"></a>选择标识符（主键）</h4><h5 id="整数类型-1"><a href="#整数类型-1" class="headerlink" title="整数类型"></a>整数类型</h5><p>​        很快，并且可以使用AUTO_INCREMENT</p><h5 id="字符串类型-1"><a href="#字符串类型-1" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>​    消耗空间、比较计算速度慢</p><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul><li>MD5 SHA1 </li><li>UUID 分布不均，但有一定顺序    </li></ul><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>INSERT变慢<ul><li>磁盘随机访问</li><li>页分裂</li><li>磁盘碎片</li></ul></li><li>SELECT变慢<ul><li>随机I/O</li><li>导致缓存效果差</li></ul></li></ul><h3 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h3><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>​        是什么 :每个数据会出现并且只有一次<br>​        优点<br>​            更新操作比反范式快<br>​            修改更少数据<br>​            更少的DISTINCT或者GROUP BY<br>​        缺点<br>​            需要表关联<br>​            分散了索引</p><h4 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h4><p>​        是什么<br>​            信息是冗余的，可能会存储在多个地方<br>​        优点<br>​            不需要表关联，数据比内存大时，有时候全表扫描会更快，避免了随机I/O<br>​            更有效的索引策略<br>​        缺点<br>​            对应范式的优点</p><h4 id="混用"><a href="#混用" class="headerlink" title="混用"></a>混用</h4><p>​        最常见的反范式化数据的方法<br>​            复制<br>​            缓存<br>​            高效获取，排序的需要</p><p>​    ——&gt;其实这种类型的建议使用redis </p><h4 id="汇总表"><a href="#汇总表" class="headerlink" title="汇总表"></a>汇总表</h4><p>保存使用GROUP BY语句聚合数据的表、逻辑上非冗余</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>​        准实时数据<br>​        局部热点<br>​                最活跃用户<br>​                最常见标签</p><h4 id="缓存表"><a href="#缓存表" class="headerlink" title="缓存表"></a>缓存表</h4><p>来存储可以比较简单从schema表获取的、逻辑上冗余</p><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><p>​            查询语句需要特殊的表和索引结构<br>​            适用不同的存储引擎，适用MyISAM做全文搜索</p><h3 id="加快ALTER-TABLE操作的速度"><a href="#加快ALTER-TABLE操作的速度" class="headerlink" title="加快ALTER TABLE操作的速度"></a>加快ALTER TABLE操作的速度</h3><h4 id="注意修改列的区别"><a href="#注意修改列的区别" class="headerlink" title="注意修改列的区别"></a>注意修改列的区别</h4><p>​        如MODIFY COLUMN ,会引起表重建  ALTER COLUMN,会直接修改.frm文件</p><h4 id="不会重建表的情况"><a href="#不会重建表的情况" class="headerlink" title="不会重建表的情况"></a>不会重建表的情况</h4><p>​        移除一个列的AUTO_INCREMENT属性<br>​        增加、移除，或更改ENUM和SET常量</p><p>​    MYSQL会在没必要的时候也重建表 , 为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表的.frm文件</p><hr><h2 id="高性能索引"><a href="#高性能索引" class="headerlink" title="高性能索引"></a>高性能索引</h2><h3 id="索引基础、类型"><a href="#索引基础、类型" class="headerlink" title="索引基础、类型"></a>索引基础、类型</h3><h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h4><h5 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h5><h6 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h6><p>​    通过物理位置引用被索引的行</p><ul><li><p>优点</p><pre><code>      使用前缀压缩技术，索引更小      存储物理位置（指针），空间占用更少</code></pre></li><li><p>缺点</p><pre><code>      物理位置变化，需要修改二级索引指针地址</code></pre></li></ul><h6 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h6><p>​    根据主键引用被索引的行</p><ul><li><p>优点</p><pre><code>  数据位置变换时，不需要修改二级索引  额外拥有主键，不需要回表</code></pre></li><li><p>缺点</p><pre><code>  占用内存空间多</code></pre></li></ul><h5 id="适用类型"><a href="#适用类型" class="headerlink" title="适用类型"></a>适用类型</h5><ul><li>全值匹配</li><li>匹配最左前缀</li><li>匹配列前缀</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>只访问索引的查询</li></ul><h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><ul><li>不按照最左列开始查找，无法适用索引</li><li>不能跳过索引的列</li><li>如果查询某个列的范围查询，其右边的所有列都无法使用索引优化</li></ul><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>​    <strong>只有Memory引擎显示支持</strong>(如果在InnoDB创建时指定索引类型,会自动转换为b-tree)            </p><p>优点 命中快</p><h5 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h5><ul><li>不能通过索引来避免读取行</li><li>不是顺序存储，无法用于排序</li><li>不支持部分索引列查找</li><li>只能支持等值比较查询</li><li>哈希冲突</li></ul><h5 id="InnoDB-“自适应哈希索引”"><a href="#InnoDB-“自适应哈希索引”" class="headerlink" title="InnoDB “自适应哈希索引”"></a>InnoDB “自适应哈希索引”</h5><p>​    某些索引值被使用非常频繁时，会在内存中基于B-Tree索引上再创建哈希索引，这样让B-Tree也具有哈希索引的一些优点</p><h4 id="空间索引R-Tree"><a href="#空间索引R-Tree" class="headerlink" title="空间索引R-Tree"></a>空间索引R-Tree</h4><p>​    GIS支持并不完善</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>适用于MATCH AGAINST ,可以使用 Elastic Search</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少了服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将随机I/O变为顺序I/O</li></ul><h3 id="如何评价一个索引"><a href="#如何评价一个索引" class="headerlink" title="如何评价一个索引"></a>如何评价一个索引</h3><p>一星 索引将相关的记录放到一起<br>二星 索引中的数据顺序和查找中的排列顺序一致<br>三星 索引中的列包含了查询中需要的全部列</p><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><p>​    索引的作用 ,一般用于快速检索数据,通常还用于排序,限制重复数据</p><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>​    是指所有列不能是表达式的一部分，也不能是函数的参数</p><h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>​    不重复的索引值和数据表的记录总数的比值,<strong>如何计算合适的前缀长度就是关键</strong><br>类型</p><ul><li>BLOB</li><li>TEXT</li><li>VARCHAR</li></ul><p>前缀索引的问题无法使用GROUP BY、ORDER BY</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>一定程度上可以使用表上的多个单列索引来定位指定的行</p><h5 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h5><p>将选择性最高的列放再所有的最前列，在不考虑分组和排序时</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>​    <strong>如果没有定义主键，会选择一个唯一的非空索引代替，如果没有，则会隐式定义一个主键来作为聚簇索引</strong></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>可以把相关数据保存在一起，只需从磁盘读取很少的数据页</li><li>数据访问更快，索引和数据保存在同一个B-Tree</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>最大限度提高I/O密集型应用性能，但是如果数据全部加载在内存中，顺序就没那么重要了</li><li>插入速度依赖插入顺序，按照主键顺序插入最快</li><li>更新索引代价很高，会将更新的行移动到新位置</li><li>页分裂，导致占用更多空间</li><li>可能导致全表扫描变慢，行稀疏，或页分裂导致数据存储不连续</li><li>二级索引包含主键，占用空间可能会很大</li><li>二级索引需要两次查找，自适应哈希</li></ul><h5 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h5><ul><li>主键值</li><li>事务ID</li><li>用于事务和MVCC的回滚指针</li><li>非主键列</li></ul><h5 id="UUID插入的问题"><a href="#UUID插入的问题" class="headerlink" title="UUID插入的问题"></a>UUID插入的问题</h5><p>​    写入的目标页可能已经被刷到磁盘上并从缓存中移除，或者还没有加载到缓存，插入之前不得不先从磁盘读取目标页到内存</p><p>写入乱序，频繁分裂页，导致大量的移动操作和空间占用</p><p>页分裂会导致页变得稀疏并被不规则填充，会有碎片</p><p>必要使用OPTIMIZE TABLE 重建表(删除并不会回收数据存储空间,以及索引位,会锁表)，和优化页的填充</p><h5 id="顺序主键什么时候会造成更坏的结果"><a href="#顺序主键什么时候会造成更坏的结果" class="headerlink" title="顺序主键什么时候会造成更坏的结果"></a>顺序主键什么时候会造成更坏的结果</h5><p>并发插入导致间隙锁竞争、AUTO_INCREMENT锁机制</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmy8c6tkbj30hs0ewgqv.jpg" alt="img"></p><p>​    如果索引不能覆盖查询的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行，通常比顺序地全表扫描慢</p><p>所以,使用覆盖索引有以下好处</p><ul><li><p>索引条目小于数据行大小，减少数据量访问</p></li><li><p>无需回表，顺序I/O</p></li><li><p>对于MyISAM内存中只缓存索引，数据依赖操作系统缓存，访问数据需要系统调用</p></li></ul><p>​    </p><p>优化index condition pushdown(ICP) , 发送查询数据到引擎层</p><h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><h5 id="可以使用使用索引做排序的查询"><a href="#可以使用使用索引做排序的查询" class="headerlink" title="可以使用使用索引做排序的查询"></a>可以使用使用索引做排序的查询</h5><p>​    只有当索引的列顺序和ORDER BY字句的顺序完全一致，并且所有列的排序方向都一样，才能使用索引对结果做排序<br>​    如果关联表，则只有当ORDER BY字句引用的字段全部为第一个表时，才能使用索引做排序</p><h5 id="不能使用索引做排序的查询"><a href="#不能使用索引做排序的查询" class="headerlink" title="不能使用索引做排序的查询"></a>不能使用索引做排序的查询</h5><p>​    使用不同排序方向<br>​    OREDR BY子句引用了一个不在索引的列<br>​    WHERE 和 OREDR BY中的列无法组成索引的最左前缀<br>​    第一个列上是范围条件，无法使用索引其他列</p><h4 id="压缩索引"><a href="#压缩索引" class="headerlink" title="压缩索引"></a>压缩索引</h4><h5 id="MyISAM压缩索引-空间换时间"><a href="#MyISAM压缩索引-空间换时间" class="headerlink" title="MyISAM压缩索引(空间换时间)"></a>MyISAM压缩索引(空间换时间)</h5><p>​    压缩块使用更少的空间 十分之一 存在的问题, 操作更慢 无法使用二分查找</p><h4 id="关于冗余和重复索引"><a href="#关于冗余和重复索引" class="headerlink" title="关于冗余和重复索引"></a>关于冗余和重复索引</h4><h5 id="重复索引（去除）"><a href="#重复索引（去除）" class="headerlink" title="重复索引（去除）"></a>重复索引（去除）</h5><h5 id="冗余索引（适当）"><a href="#冗余索引（适当）" class="headerlink" title="冗余索引（适当）"></a>冗余索引（适当）</h5><p>​    应该尽量扩展已有的索引而不是创建新索引（冗余）<br>​    需要使用新索引的场景<br>​            避免已有索引变大<br>​            排序、分组需要</p><h4 id="未使用索引"><a href="#未使用索引" class="headerlink" title="未使用索引"></a>未使用索引</h4><p>​        有可能是唯一约束，用于避免重复数据</p><h4 id="索引和锁的关系"><a href="#索引和锁的关系" class="headerlink" title="索引和锁的关系"></a>索引和锁的关系</h4><p>​    索引能够减少锁的数量,InnoDB只有在访问行的时候才会对其加锁<br>​    相关细节（InnoDB） 二级索引共享锁、主键索引排他锁</p><h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h3><h4 id="找到损坏的表"><a href="#找到损坏的表" class="headerlink" title="找到损坏的表"></a>找到损坏的表</h4><p>​    CHECK TABLE</p><h4 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h4><p>innoDB 5.5 随机索引访问进行评估并存储在内存中<br>基数(Cardinality)<br>​    SHOW INDEX FROM<br>​    存储引擎估算索引列有多少个不同的取值</p><h4 id="减少索引和数据碎片"><a href="#减少索引和数据碎片" class="headerlink" title="减少索引和数据碎片"></a>减少索引和数据碎片</h4><h5 id="常见的碎片"><a href="#常见的碎片" class="headerlink" title="常见的碎片"></a>常见的碎片</h5><ul><li>碎片, 数据行被存储在多个地方，多个片段中</li><li>行碎片, 逻辑上顺序的页或者行，在磁盘上不是顺序存储</li><li>剩余空间碎片,数据页存在大量剩余空间(删除会导致这种问题)</li></ul><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul><li>OPTIMIZE TABLE(锁表)</li><li>导出再导入</li></ul><h5 id="存储引擎实现"><a href="#存储引擎实现" class="headerlink" title="存储引擎实现"></a>存储引擎实现</h5><ul><li>InnoDB 通过删除、再添加索引功能</li><li>MyISAM 通过排序算法重建索引消除碎片</li></ul><h3 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h3><h4 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h4><ul><li>单行访问效率低</li><li>顺序访问范围数据快</li></ul><p>顺序IO、无需排序操作</p><ul><li>覆盖索引，无需回表，避免单行访问</li></ul><h4 id="如何判断索引合理"><a href="#如何判断索引合理" class="headerlink" title="如何判断索引合理"></a>如何判断索引合理</h4><h5 id="检查设计是否合理"><a href="#检查设计是否合理" class="headerlink" title="检查设计是否合理"></a>检查设计是否合理</h5><ul><li>schema , 数据结构是否合理</li><li>SQL语句是否存在问题</li><li>索引设计是否合理</li></ul><h5 id="判断执行是否符合预期"><a href="#判断执行是否符合预期" class="headerlink" title="判断执行是否符合预期"></a>判断执行是否符合预期</h5><ul><li>是否扫描了太多的行</li><li>是否做了很多额外排序</li><li>使用了临时表</li><li>随机I/O</li><li>太多回表查询</li></ul><hr><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="为什么查询会慢"><a href="#为什么查询会慢" class="headerlink" title="为什么查询会慢"></a>为什么查询会慢</h3><h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><ul><li><p>消除无用子任务</p></li><li><p>减少子任务查询次数</p></li><li><p>加快子任务查询速度</p></li></ul><p>​    </p><h4 id="时间花费"><a href="#时间花费" class="headerlink" title="时间花费"></a>时间花费</h4><ul><li>网络</li><li>CPU计算</li><li>生成统计信息和执行计划</li><li>锁等待</li></ul><h3 id="慢查询的基础：优化数据访问"><a href="#慢查询的基础：优化数据访问" class="headerlink" title="慢查询的基础：优化数据访问"></a>慢查询的基础：优化数据访问</h3><h4 id="是否检索大量超过需要的数据"><a href="#是否检索大量超过需要的数据" class="headerlink" title="是否检索大量超过需要的数据"></a>是否检索大量超过需要的数据</h4><ul><li>查询不需要的记录</li><li>多表关联时返回全部的列</li><li>总是取出全部列</li><li>查询重复的数据</li></ul><h4 id="分析为何检索大量超过需要的行"><a href="#分析为何检索大量超过需要的行" class="headerlink" title="分析为何检索大量超过需要的行"></a>分析为何检索大量超过需要的行</h4><h5 id="相关指标指标"><a href="#相关指标指标" class="headerlink" title="相关指标指标"></a>相关指标指标</h5><h6 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h6><ul><li>服务时间</li><li>排队时间</li></ul><h6 id="扫描行数"><a href="#扫描行数" class="headerlink" title="扫描行数"></a>扫描行数</h6><ul><li>全表扫描</li><li>索引扫描</li><li>范围扫描</li><li>唯一索引扫描</li><li>常数引用</li></ul><h6 id="返回行数"><a href="#返回行数" class="headerlink" title="返回行数"></a>返回行数</h6><p>扫描的行数对返回的行数的比率  通常1：1到1：10之间<br>​            </p><h5 id="WHERE条件"><a href="#WHERE条件" class="headerlink" title="WHERE条件"></a>WHERE条件</h5><ul><li>在索引中使用WHERE条件过滤不匹配记录，存储引擎层</li><li>使用索引覆盖查询，直接从索引中过滤不需要的记录并返回命中结果，服务层，无需回表</li><li>从数据表中返回，然后过滤不满足条件的记录，服务层</li></ul><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ul><li><p>索引覆盖</p></li><li><p>改变库表结果</p></li><li><p>使用汇总表</p></li><li><p>重写查询</p></li></ul><p>​    </p><h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><p>​        一个复杂查询还是多个简单查询,减少锁的占有时间</p><p>​        </p><h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><p>​                让缓存效率更高<br>​                执行单个查询可以减少锁的竞争<br>​                在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展<br>​                可以减少冗余记录的查询<br>​                哈希关联，而不是嵌套循环关联</p><h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><h4 id="一次SQL查询做了什么"><a href="#一次SQL查询做了什么" class="headerlink" title="一次SQL查询做了什么"></a>一次SQL查询做了什么</h4><p>​    简单来说就是, 先查询缓存,在再根据查询优化器解析成执行计划,交给执行引擎,最后将结果返回给客户端 </p><p>更多可以参考<a href="https://zyumin.github.io/2019/03/30/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%9F%A5%E8%AF%A2in%E7%9A%84%E6%80%9D%E8%80%83/#more" target="_blank" rel="noopener">另一篇文章中详细的介绍</a></p><h4 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h4><h5 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h5><p>​    半双工,只能一方发送消息,简单快速,但缺少流量控制,全部推送完成才释放链接</p><h5 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h5><ol><li>客户端用一个单独的数据包将查询传给服务器，max_allowed_packet</li><li>服务器返回多个数据包，必须完整接收</li><li>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里</li></ol><h5 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h5><ul><li>Sleep</li><li>Query</li><li>Locked</li><li>Analyzing and statistics</li><li>Copying to tmp table[on disk]</li><li>Sorting result</li><li>Sending data</li></ul><h4 id="查询缓存（Query-Cache）"><a href="#查询缓存（Query-Cache）" class="headerlink" title="查询缓存（Query Cache）"></a>查询缓存（Query Cache）</h4><p>​    解析一个查询语句之前如果查询缓存是打开的，通过一个对大小写敏感的哈希查找实现的,缓存命中率</p><h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><p>​    将一个SQL转换成执行计划，再按照执行计划和存储引擎进行交互</p><h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h5><p>​    通过关键字将SQL语句进行解析，并生成一颗对应的‘解析树’</p><h6 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h6><p>​    使用语法规则验证和解析查询</p><h6 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h6><p>​    根据一些MySQL规则进一步解析树是否合法,验证权限(例如检查数据表和列是否存在,解析名字和别名)<br>​                    </p><h5 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h5><h6 id="基于成本的优化器"><a href="#基于成本的优化器" class="headerlink" title="基于成本的优化器"></a>基于成本的优化器</h6><p>​    尝试预测一个查询使用了某种执行计划时的成本，并选择其中成本最小的一个</p><h6 id="导致选择错误执行计划的原因"><a href="#导致选择错误执行计划的原因" class="headerlink" title="导致选择错误执行计划的原因"></a>导致选择错误执行计划的原因</h6><ul><li>统计信息不准确</li><li>执行计划汇总的成本估算不等同于实际执行的成本</li><li>最优是基于成本，而有些时候并不是最快</li><li>不考虑其他并发执行的查询</li><li>并不是任何时候都基于成本的优化，有时会基于一些固定的规则</li><li>不会考虑不受其控制的操作成本</li></ul><h6 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h6><p>​    静态优化 编译时优化，直接对解析树进行分析，并完成优化<br>​    动态优化 和查询的上下文有关，每次查询都重新评估</p><h6 id="能够处理的优化类型"><a href="#能够处理的优化类型" class="headerlink" title="能够处理的优化类型"></a>能够处理的优化类型</h6><ul><li>重新定义关联表的顺序</li><li>将外连接转换成内连接</li><li>使用等价变换规则</li><li>优化COUNT() MIN() MAX()</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表IN()的比较</li></ul><h6 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h6><p>​    存储引擎提供给优化器</p><ul><li>每个表或者索引有多少个页面</li><li>每个表的每个索引的基数是多少</li><li>数据行和索引长度</li><li>索引的分布信息</li></ul><h6 id="MySQL如何执行关联查询"><a href="#MySQL如何执行关联查询" class="headerlink" title="MySQL如何执行关联查询"></a>MySQL如何执行关联查询</h6><p>​    策略  对任何关联都执行嵌套循环关联操作<br>​    泳道图</p><h6 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h6><p>​    左侧深度优先的指令树</p><h6 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h6><p>​        通过评估不同顺序时的成本来选择一个代价最小的关联顺序<br>​        当关联表超过optimizer_search_depth的限制选择‘贪婪’搜索模式</p><h6 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h6><p>排序算法</p><ul><li><p>两次传输排序</p><ul><li>读取行指针和需要排序的字段，对其进行排序</li><li>再根据排序结果读取所要的数据行</li></ul></li><li><p>单次传输排序</p><p>  读取所需要的所有列，排序，直接返回排序结果</p></li></ul><p>对于关联排序<br>如果关联操作中ORDER BY子句中所有列都来自关联的第一个表，则处理关联第一个表的时候就进行文件排序</p><p>否则，都会将关联结果存放到一个临时表，然后所有关联结束后，再进行文件排序<br>​</p><h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>​    根据执行计划给出的指令执行，调用存储引擎实现的接口来完成，查询中的每一个表由一个handler的实例表示<br>如果是所有存储引擎共有的特性则由服务器层实现</p><h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><p>不需要结果集，则返回影响到的行数, 如果查询缓存开启，将结果存放到查询缓存中</p><p>是一个增量、逐步的过程,服务器端无需存储太多的结果,客户端第一时间获得返回结果</p><ol><li>每一行都以一个满足MySQL客户端/服务器端通信协议的封包发送</li><li>在通过TCP协议进行传输</li><li>可能会缓存封包，并批量传输</li></ol><h3 id="查询优化器的局限"><a href="#查询优化器的局限" class="headerlink" title="查询优化器的局限"></a>查询优化器的局限</h3><ul><li>关联子查询</li><li>UNION的限制</li><li>索引合并优化</li><li>等值传递</li><li>并行执行</li><li>哈希关联</li><li>松散索引扫描</li><li>最大值和最小值的优化</li><li>在同一个表上查询和更新</li></ul><p>hint, 不建议使用，MySQL版本升级会让新版的优化策略失效</p><h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h4 id="优化COUNT查询"><a href="#优化COUNT查询" class="headerlink" title="优化COUNT查询"></a>优化COUNT查询</h4><p>count(*)&gt;count(1)&gt;count(id)&gt;count(xxx)</p><ul><li>使用相似值 EXPLAIN出来的优化器估算的行数</li><li>覆盖索引</li><li>增加汇总表</li><li>缓存</li></ul><h4 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h4><p>​    只需要在关联顺序中的第二个表的相应列上创建索引,确保任何的GROUP BY 和 ORDER BY中的表达式只涉及到一个表中的列<br>优化子查询<br>优化GROUP BY 和 DISTINCT<br>​优化GROUP BY WITH ROLLUP (转移到应用程序中处理)</p><p>#### </p><p>参考:</p><blockquote><p>高性能MySQL</p></blockquote><h2 id="Mysql-日志"><a href="#Mysql-日志" class="headerlink" title="Mysql 日志"></a>Mysql 日志</h2><p><a href="https://www.cnblogs.com/wy123/p/8365234.html" target="_blank" rel="noopener">https://www.cnblogs.com/wy123/p/8365234.html</a></p><h2 id="mysql锁"><a href="#mysql锁" class="headerlink" title="mysql锁"></a>mysql锁</h2><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p><h2 id="详细架构-存储"><a href="#详细架构-存储" class="headerlink" title="详细架构 存储"></a>详细架构 存储</h2><p><a href="https://juejin.im/post/5d42f48cf265da03ab422e08" target="_blank" rel="noopener">https://juejin.im/post/5d42f48cf265da03ab422e08</a></p><p>存储相关删除相关</p><p>1、drop table table_name 立刻释放磁盘空间 ，不管是 Innodb和MyISAM ;</p><p>2、truncate table table_name 立刻释放磁盘空间 ，不管是 Innodb和MyISAM 。truncate table其实有点类似于drop table 然后creat,只不过这个create table 的过程做了优化，比如表结构文件之前已经有了等等。所以速度上应该是接近drop table的速度;</p><p>3、delete from table_name删除表的全部数据,对于MyISAM 会立刻释放磁盘空间 （应该是做了特别处理，也比较合理）,InnoDB 不会释放磁盘空间;</p><p>4、对于delete from table_name where xxx带条件的删除, 不管是innodb还是MyISAM都不会释放磁盘空间;</p><p>5、delete操作以后使用optimize table table_name 会立刻释放磁盘空间。不管是innodb还是myisam 。所以<strong>要想达到释放磁盘空间的目的，delete以后执行optimize table 操作。</strong></p><p>6、delete from表以后虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以使用这部分空间。 </p><p>存储引擎</p><p><strong>两种存储引擎的对比：</strong>从MyISAM和InnoDB的存储文件可看出，MyISAM注重的是对数据的快速读取，但由于MyISAM不支持事务，同时缺乏灵活性。而InnoDB支持事务和行级锁，因此在5.1之后MySQL的默认存储引擎为InnoDB。</p><h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><p>事务ACID  </p><p><a href="https://blog.csdn.net/tangkund3218/article/details/47361705" target="_blank" rel="noopener">https://blog.csdn.net/tangkund3218/article/details/47361705</a></p><p>logbuffer -&gt;redolog (持久性保证)</p><p>　然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<br>　　1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。<br>　　2，每个事务提交时会将重做日志刷新到重做日志文件。<br>　　3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</p><p>Poolbuffer 脏数据</p><p>binlog</p><p>Redolog bingo 生成之后才能保证事务成功</p><p>undolog(原子性和一致性)</p><p>事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</p><p>　　保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p><p>隔离 其实就是几个级别  read uncommit\ unrepeat\r r\ serial</p><h2 id="mvcc实现原理"><a href="#mvcc实现原理" class="headerlink" title="mvcc实现原理"></a>mvcc实现原理</h2><p><a href="https://www.jianshu.com/p/f692d4f8a53e" target="_blank" rel="noopener">https://www.jianshu.com/p/f692d4f8a53e</a></p><p>1、事务版本号</p><p>2、表的隐藏列。</p><p>3、undo log</p><p>4、 read view</p><p><a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52977862</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper深入浅出</title>
      <link href="/2019/06/03/Overview_Zookeeper/"/>
      <url>/2019/06/03/Overview_Zookeeper/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g3oad10mpuj31hc0u0gp4.jpg" alt="image-20190603212535941"></p><a id="more"></a><h2 id="版本特征"><a href="#版本特征" class="headerlink" title="版本特征"></a>版本特征</h2><ul><li><p>25 March, 2010: release 3.3.0 available  添加Observer、四字命令功能、JMX管理</p></li><li><p>22 Nov, 2011: release 3.4.0 available。3.4 引入Netty 做为NIO框架处理客户端连接 , 废弃两种选举算法</p></li><li><p>6 August, 2014: release 3.5.0-alpha available 。 ZooKeeper Dynamic Reconfiguration ,3.5.3中默认关闭</p></li></ul><pre><code>最新的版本为 20 May, 2019: release 3.5.5 available  </code></pre><p>more  <a href="http://zookeeper.apache.org/releases.html#news" target="_blank" rel="noopener">http://zookeeper.apache.org/releases.html#news</a></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li><p>简单设计模型。</p><ul><li><p>共享、树形结构的名字空间</p><p>  <img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3p70vvka4j30ca071q31.jpg" alt="ZooKeeper&#39;s Hierarchical Namespace"></p></li></ul></li><li><p>可以构建集群</p><ul><li><p>(扩容、缩容 支持不好  需要全部重启 ,或一台台重启rolling update 、3.5版本解决了该问题)</p><p>  <img src="http://ww2.sinaimg.cn/large/006tNc79gy1g3p6yo4dhhj30go055aaj.jpg" alt="ZooKeeper Service"></p></li></ul></li><li><p>顺序访问</p></li><li><p>高性能 </p><ul><li><p>内存,直接服务所有非事务请求,适合读多写少( it performs best where reads are more common than writes, at ratios of around 10:1)</p><p>  <img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3p74rq20ij30dw09qq3b.jpg" alt="ZooKeeper Throughput as the Read-Write Ratio Varies"></p></li></ul></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p>​    传统Master/Slave ( redis/es )</p><p>​    引入 Leader 、Follower 和 Observer( 不参与投票、不写事务日志 )角色 </p><h3 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h3><p>​    TCP长连接 、Watch、SessionTimeout</p><h3 id="数据节点-Znode"><a href="#数据节点-Znode" class="headerlink" title="数据节点(Znode)"></a>数据节点(Znode)</h3><p>​    持久节点和临时节点( 与Session有关)、顺序节点</p><h3 id="版本-保证分布式数据原子性操作、乐观锁"><a href="#版本-保证分布式数据原子性操作、乐观锁" class="headerlink" title="版本(保证分布式数据原子性操作、乐观锁)"></a>版本(保证分布式数据原子性操作、乐观锁)</h3><p>​    Znode会有一个Stat 分别是 version、cversion 、aversion( ACL )</p><h3 id="Watcher-客户端线程、客户端WatchManager和服务器"><a href="#Watcher-客户端线程、客户端WatchManager和服务器" class="headerlink" title="Watcher(客户端线程、客户端WatchManager和服务器)"></a>Watcher(客户端线程、客户端WatchManager和服务器)</h3><p>​    允许用户在指定节点注册一些Watcher,并且在特定事件触发,服务端会进行通知.但具体的内容还需要客户端自己去拉取.</p><ul><li>客户端注册Watcher</li><li>服务端Watcher处理<ul><li>ServerCnxn 是客户端和服务端的连接接口( NIOServerCnxn和NettyServerCnxn )</li></ul></li><li>客户端回调Watcher</li></ul><p>特性</p><ul><li>一次性( 需要重复注册 )</li><li>客户端串行执行</li><li>轻量  </li></ul><p>​        通知状态、事件类型、节点路径</p><h3 id="ACL-Access-Control-Lists-类似UNIX文件系统的权限控制"><a href="#ACL-Access-Control-Lists-类似UNIX文件系统的权限控制" class="headerlink" title="ACL( Access Control Lists 类似UNIX文件系统的权限控制 )"></a>ACL( Access Control Lists 类似UNIX文件系统的权限控制 )</h3><ul><li>权限模式( Scheme )</li><li>授权对象( ID )</li><li>权限( permission )</li></ul><p>​        CREATE、READ、WRITE、DELETE、ADMIN</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>数据发布/订阅  </li><li>分布式协调/通知 </li><li>集群管理</li><li>Master选举</li><li>分布式锁(羊群效应,Watcher只关注比自己低的) </li><li>分布式队列</li></ul><p>一般用于服务注册中心,如下图的Dubbo 中的Registry ,或者配置推送 ( 配置中心 规模不大的 ) </p><p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g3p5jteoz1j30tg0mw3zr.jpg" alt="Architecture"></p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>核心是定义了对于那些会改变ZooKeeper服务器数据状态的事务请求的处理方式:</p><ol><li>所有事务请求由一个全局唯一服务器处理 Leader</li><li>Leader 负责将客户端事务请求转换成一个事务Proposal .分发给集群中的所有Follower</li><li>等待所有服务器反馈,一旦超过半数Follower服务器正确反馈 Leader 会再次向所有Follower服务器分发commit</li></ol><h3 id="两个过程"><a href="#两个过程" class="headerlink" title="两个过程"></a>两个过程</h3><h4 id="奔溃恢复-初始化和选举"><a href="#奔溃恢复-初始化和选举" class="headerlink" title="奔溃恢复(初始化和选举)"></a>奔溃恢复(初始化和选举)</h4><ul><li>基本特征<ul><li>确保那些已经在Leader服务器上提交的事务最终被所有服务器提交</li><li>确保丢弃那些只在Leader服务器上提出的事务</li></ul></li><li>数据同步<ul><li>直接差异化同步</li><li>先回滚再差异化同步</li><li>仅回滚同步</li><li>全量同步  (优先)</li></ul></li></ul><p>​        ZKDatabase会定时向磁盘dump快照数据,再ZooKeeper服务器启动的时候,会通过磁盘上的事务日志(事务操作时间、客户端会话ID、CXID 客户端操作ID、ZXID、操作类型、节点路径、节点数据内容、节点的ACL信息、是否临时节点和父节点的子节点版本号)和快照数据文件恢复成一个完整的内存数据库</p><h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>​            事务全局单调递增唯一ID (事务ID :包含epoch 选举周期) 和myid(机器序号唯一id)  ,为每个Follower分配一个FIFO队列 ,Follower接收后回写入事务日志,本地磁盘(基于FIFO 特性的TCP协议。保证消息广播过程中消息接收与发送的顺序性)</p><h3 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h3><ul><li>选举 <ul><li>根据Vote(zxid,myid). electionEpoch当前选举周期。 state LOOKING</li></ul></li><li>发现<ul><li>Follower将最后epoch发送给准Leader</li><li>收到过半Quorum 生成新epoch 给这些过半Follower</li><li>反馈ACK和历史Proposal集合 ,  Leader 从中选择事务集合</li></ul></li><li>同步<ul><li>Leader 将事务集合 发给所有Quorum</li></ul></li><li>广播<ul><li>开始接收客户端请求,并进行消息广播流程</li></ul></li></ul><p>节点状态</p><ul><li><p>LOOKING </p></li><li><p>FOLLOWING</p></li><li><p>LEADING</p></li></ul><h3 id="ZAB和Paxos区别"><a href="#ZAB和Paxos区别" class="headerlink" title="ZAB和Paxos区别"></a>ZAB和Paxos区别</h3><ul><li>ZAB协议主要用于构建一个高可用的分布式数据主备系统</li><li>Paxos算法用于构建一个分布式的一致性状态机系统</li></ul><h2 id="缺陷和不足"><a href="#缺陷和不足" class="headerlink" title="缺陷和不足"></a>缺陷和不足</h2><p>​    官网的介绍中</p><p><code>ZooKeeper is a distributed, open-source coordination service for distributed applications. It exposes a simple set of primitives that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming.</code> </p><p>​    翻译如下</p><pre><code>        ZooKeeper是一种用于分布式应用程序的分布式开源协调服务。它公开了一组简单的原语，分布式应用程序可以构建这些原语，以实现更高级别的服务，以实现同步，配置维护以及组和命名。</code></pre><ul><li>提供比较底层的API, 具体由使用方实现(这个类似于J.U.C 提供了validate 和 CAS )</li><li>java原生客户端使用繁琐复杂,如Watcher需要反复注册 ,推荐使用Curator</li><li>数据模型为CP, 所以在可用性方面会有所不足,例如选举期间服务不可用(因为可用性问题,所以客户端不应该强依赖zookeeper ,一般的做法是客户端需要本地缓存)</li><li>zookeeper的选举过程速度很慢，zookeeper的选举流程通常耗时30到120秒，期间zookeeper由于没有master，都是不可用的。(官网中提到 To show the behavior of the system over time as failures are injected we ran a ZooKeeper service made up of 7 machines.In our observations, ZooKeeper takes less than 200ms to elect a new leader.)</li><li>Zookeeper树形文件结构、数据存储在内存, 但 snapshot（即数据量）不建议超过 1G,否则容易出现选主失败，导致整个集群不可用</li><li>Zookeeper不能保证跨session的强一致性</li><li>Scalability很弱，3.5.0之前的版本修改任何配置还得要rolling update；3.5.0之后新增支持动态reconfiguration</li><li>其他 监控完善、不提供RESTful API、社区活跃度</li></ul><p>参考:</p><blockquote><p>官方链接: <a href="http://zookeeper.apache.org/doc/r3.5.5/zookeeperOver.html" target="_blank" rel="noopener">http://zookeeper.apache.org/doc/r3.5.5/zookeeperOver.html</a></p><p>Zookeeper缺点 :<a href="https://www.zhihu.com/question/42931473" target="_blank" rel="noopener">https://www.zhihu.com/question/42931473</a></p><p>从Paxos到Zooke分布式一致性原理与实践</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> distributed </tag>
            
            <tag> framework </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式理论基础</title>
      <link href="/2019/06/03/Overview_Distributed/"/>
      <url>/2019/06/03/Overview_Distributed/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3p3wk755qj31400u0gog.jpg" alt="image-20190604142744558"></p><a id="more"></a><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><hr><h4 id="网络通信异常"><a href="#网络通信异常" class="headerlink" title="网络通信异常"></a>网络通信异常</h4><p>​        网络延迟</p><h4 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h4><p>​        脑裂 两个独立集群</p><h4 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h4><ul><li>成功 </li><li>失败 </li><li>超时  <ul><li>发送过程丢失</li><li>结果反馈丢失</li></ul></li></ul><p>​             </p><h3 id="从ACID-到CAP-BASE"><a href="#从ACID-到CAP-BASE" class="headerlink" title="从ACID 到CAP/ BASE"></a>从ACID 到CAP/ BASE</h3><hr><h4 id="传统DBMS-中的ACID"><a href="#传统DBMS-中的ACID" class="headerlink" title="传统DBMS 中的ACID"></a>传统DBMS 中的ACID</h4><ul><li>Atomicity 原子性   </li><li>Isolation 隔离线<ul><li>未授权读取(<em>RU</em>); </li><li>授权读取(<em>RC</em>); </li><li>可重复读取(<em>RR</em>); </li><li>串行化(<em>S</em>)</li></ul></li><li>Consistency 一致性</li><li>Durability 持久性</li></ul><p>​    </p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><ul><li>A 高可用 </li><li>C 一致性 </li><li>P 分区 副本</li></ul><p>在C和A之中寻找平衡</p><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><ul><li>Basically Acaliable <ul><li>响应时间损失</li><li>功能上降级</li></ul></li><li>Soft state</li><li>Eventually consistent</li></ul><p>不止分布式环境,现代数据库主从复制</p><h3 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h3><hr><p>​    一致性问题的解法就是分布式时钟，分布式事务与一致性算法。 </p><p>​    选举、多数派、租约</p><p>​    顺序时钟</p><h4 id="XA-规范"><a href="#XA-规范" class="headerlink" title="XA 规范"></a>XA 规范</h4><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>​     同步阻塞、无限制等待、 存在脑裂问题</p><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><p>​    缩小阻塞范围、加入超时 、存在脑裂问题</p><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><p>​     <a href="https://github.com/Tencent/phxpaxos" target="_blank" rel="noopener">https://github.com/Tencent/phxpaxos</a>  腾讯微信后台的实现</p><h4 id="RAFT算法"><a href="#RAFT算法" class="headerlink" title="RAFT算法:"></a>RAFT算法:</h4><p><a href="https://www.jianshu.com/p/8279d6fd65bb" target="_blank" rel="noopener">https://www.jianshu.com/p/8279d6fd65bb</a></p><p><a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">https://redis.io/topics/cluster-spec</a></p><h4 id="Bully算法"><a href="#Bully算法" class="headerlink" title="Bully算法"></a>Bully算法</h4><p> <a href="http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html" target="_blank" rel="noopener">http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html</a></p><p>​        实现:Es   主从模式 (节点、分片、副本) 容易出现脑裂,所以使用过半来解决</p><p>​        ES的写入优化</p><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>​        实现:redis (gossip协议。p2p)   主从模式 ,主从复制  持久化(AOF、RDB)</p><p>​        <a href="https://www.v2ex.com/t/453036" target="_blank" rel="noopener">https://www.v2ex.com/t/453036</a></p><h4 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h4><p>​        实现 : zk(hadoop、hbase 、kafka)</p>]]></content>
      
      
      
        <tags>
            
            <tag> distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-api-1.0</title>
      <link href="/2019/04/10/spring-api-1-0/"/>
      <url>/2019/04/10/spring-api-1-0/</url>
      
        <content type="html"><![CDATA[<p>更多详情 点击查看<a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/" target="_blank" rel="noopener">spring-api-1.0</a></p><p>为什么要看Spring-api 1.0 ,主要是想了一个优秀框架的发展历史,各个版本新增、删减了哪些内容</p><p>简单分为几个模块</p><ul><li><p>base 基础模块</p></li><li><p>compnent 整合第三方框架</p></li><li><p>Data access 数据访问</p></li><li><p>Web </p></li></ul><a id="more"></a><hr><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/aop/package-frame.html" target="_blank" rel="noopener">org.springframework.aop</a> </p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/beans/package-frame.html" target="_blank" rel="noopener">org.springframework.beans</a> </p><p>​    The classes in this package are discussed in Chapter 11 of <a href="https://www.amazon.com/exec/obidos/tg/detail/-/0764543857/" target="_blank" rel="noopener">Expert One-On-One J2EE Design and Development</a> by Rod Johnson (Wrox, 2002).</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/context/package-frame.html" target="_blank" rel="noopener">org.springframework.context</a> </p><p>​    This package builds on the beans package to add support for message sources and for the Observer design pattern, and the ability for application objects to obtain resources using a consistent API.</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/core/package-frame.html" target="_blank" rel="noopener">org.springframework.core</a> </p><hr><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/metadata/package-frame.html" target="_blank" rel="noopener">org.springframework.metadata</a> </p><p>​    Package defining a facade for accessing source-level metadata attributes at runtime.</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/ejb/access/package-frame.html" target="_blank" rel="noopener">org.springframework.ejb.access</a>  </p><p>​    ejb</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/mail/package-frame.html" target="_blank" rel="noopener">org.springframework.mail</a> </p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/remoting/package-frame.html" target="_blank" rel="noopener">org.springframework.remoting</a>   </p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/scheduling/quartz/package-frame.html" target="_blank" rel="noopener">org.springframework.scheduling.quartz</a>  </p><p>​    scheduling</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/jndi/package-frame.html" target="_blank" rel="noopener">org.springframework.jndi</a> </p><p>​    The classes in this package are discussed in Chapter 11 of Expert One-On-One J2EE Design and Development by Rod Johnson (Wrox, 2002).</p><hr><h3 id="data-access"><a href="#data-access" class="headerlink" title="data access"></a>data access</h3><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/dao/package-summary.html" target="_blank" rel="noopener">org.springframework.dao</a></p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/jdbc/package-frame.html" target="_blank" rel="noopener">org.springframework.jdbc</a> </p><p>​    This package and related packages are discussed in Chapter 9 of Expert One-On-One J2EE Design and Development by Rod Johnson (Wrox, 2002).</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/orm/package-frame.html" target="_blank" rel="noopener">org.springframework.orm</a> </p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/transaction/package-frame.html" target="_blank" rel="noopener">org.springframework.transaction</a>  </p><hr><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/ui/context/package-frame.html" target="_blank" rel="noopener">org.springframework.ui.context</a>  </p><p>​    ui</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/validation/package-frame.html" target="_blank" rel="noopener">org.springframework.validation</a> </p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/web/context/package-frame.html" target="_blank" rel="noopener">org.springframework.web.context</a>  </p><p>​    web</p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/web/filter/package-frame.html" target="_blank" rel="noopener">org.springframework.web.filter</a> </p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/web/multipart/package-frame.html" target="_blank" rel="noopener">org.springframework.web.multipart</a> </p><p><a href="https://docs.spring.io/spring/docs/1.0.0/javadoc-api/org/springframework/web/servlet/package-frame.html" target="_blank" rel="noopener">org.springframework.web.servlet</a>  </p><p>​    servlet</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3月第四周知识点记录</title>
      <link href="/2019/04/01/3%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/04/01/3%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>第四周 25-31 记录</p><p>一周学习的知识点罗列，比较发散，精力有限，会选取相关总结。</p><p>只要你一直走在路上，那么 未来可期也。</p><a id="more"></a><h2 id="周一"><a href="#周一" class="headerlink" title="周一"></a>周一</h2><p>非jvm内的调用</p><p>Distributed object communication</p><p><a href="https://en.wikipedia.org/wiki/Distributed_object_communication" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Distributed_object_communication</a></p><p>rmi  stub 、skeleton</p><p><a href="https://en.wikipedia.org/wiki/Java_remote_method_invocation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_remote_method_invocation</a></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g1euo90mujj30b401odfr.jpg" alt="img"></p><p>rpc 和 rmi</p><p>在里面<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">面向对象的编程</a>范例，RPC调用由<a href="https://en.wikipedia.org/wiki/Remote_method_invocation" target="_blank" rel="noopener">远程方法调用</a>（RMI）表示</p><h2 id="周二"><a href="#周二" class="headerlink" title="周二"></a>周二</h2><p>servelt规范</p><p>304 相关</p><p><a href="https://zhuanlan.zhihu.com/p/59171313" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59171313</a></p><h2 id="周三"><a href="#周三" class="headerlink" title="周三"></a>周三</h2><p>高可用</p><p>​    灰度<br>​    log 监控<br>​    双写双读 防单点<br>​    数据灾备</p><p>tcp/http</p><p><a href="https://cs.chromium.org/chromium/src/net/socket/tcp_socket_win.cc?sq=package:chromium&amp;g=0&amp;l=45" target="_blank" rel="noopener">https://cs.chromium.org/chromium/src/net/socket/tcp_socket_win.cc?sq=package:chromium&amp;g=0&amp;l=45</a></p><p><a href="https://www.jianshu.com/p/cd71efa49d63" target="_blank" rel="noopener">https://www.jianshu.com/p/cd71efa49d63</a></p><p><a href="https://segmentfault.com/a/1190000006923359" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006923359</a></p><p>es http </p><p>es 使用client的性能</p><p>es in too many 错误，默认情况下 in的限制不超过1000</p><p>http 状态</p><p><a href="https://www.cnblogs.com/aspirant/p/5702338.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/5702338.html</a></p><p>线程池</p><h2 id="周四"><a href="#周四" class="headerlink" title="周四"></a>周四</h2><p>反模式</p><p>​    神仙大类： 类职责不单一，复用性低</p><p>​    黄金大锤：不要一味使用map String，雾是String的浓，霾是Map的厚</p><p>枚举</p><p>final 可以写abstract？ 枚举的字节码，final ，extend</p><p>枚举设计：理解枚举引入的意义以及变化， JDK 中常见枚举的设计</p><p>多线程 ，多核？</p><p><a href="https://www.zhihu.com/question/271821176/answer/364029483?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://www.zhihu.com/question/271821176/answer/364029483?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p><h2 id="周五"><a href="#周五" class="headerlink" title="周五"></a>周五</h2><p>​    泛型和类型擦除后的class文件</p><p>泛型参数的获取，被擦除后如何获取</p><p>​    如果泛型参数是在属性，可以通过字节码的方式获取字符描述，然后反推</p><p>​    如果泛型参数在类型上面了，那么可以通过反射获取</p><pre><code class="java">ParameterizedType parameterizedType = (ParameterizedType)             declaredClass.getGenericSuperclass();Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();return (Class&lt;T&gt;) actualTypeArguments[0];</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> week </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次mysql查询in的思考</title>
      <link href="/2019/03/30/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%9F%A5%E8%AF%A2in%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/03/30/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%9F%A5%E8%AF%A2in%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h3 id="从一个日常的in-查询的优化说起"><a href="#从一个日常的in-查询的优化说起" class="headerlink" title="从一个日常的in 查询的优化说起"></a>从一个日常的in 查询的优化说起</h3><p>​    业务场景需要 <code>select * from table where id in( )</code>， 然后就会抛出一个问题，使用in 会不会走索引？</p><p>​    对于这个问题，因为之前在网上看过说不会，说会的，充斥着各种说法，然后自己对这块也是很久之前看过。参考了一些资料。写下自己的思考。</p><p>​    其实关于这个问题，我们需要缩小范围，首先是确定版本，版本意识很重要，这里我们讨论建立在5.5.39-log 这个版本上。（使用 <code>select version()</code>; 命令可以查看当前版本）</p><a id="more"></a><p>​    </p><h3 id="使用EXPLAIN"><a href="#使用EXPLAIN" class="headerlink" title="使用EXPLAIN"></a>使用<a href="https://dev.mysql.com/doc/refman/5.5/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a></h3><p>​    当您在<a href="https://dev.mysql.com/doc/refman/5.5/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 带有关键字的语句 之前时<a href="https://dev.mysql.com/doc/refman/5.5/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>，MySQL会显示优化程序中有关语句执行计划的信息。也就是说，MySQL解释了它将如何处理语句，包括有关如何连接表以及以何种顺序连接的信息。</p><h4 id="MySQL语句的执行过程"><a href="#MySQL语句的执行过程" class="headerlink" title="MySQL语句的执行过程"></a>MySQL语句的执行过程</h4><p>​    首先我们要了解何为执行计划，这又得从一条SQL语句的执行过程说起（这个在高性能mysql的6.4节中有介绍）</p><p>整个查询流程大致如下</p><ul><li>客户端向 MySQL 服务器发送一条查询请求（半双工，即客户端和服务器不能互相通信）</li><li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果，否则进入下一阶段。</li><li>服务器进行 SQL 解析（通过语法规则来验证和解析，生成解析树）、预处理（检查要查询的数据表和数据列是否存在）、再由优化器生成最优的执行计划。</li><li>MySQL 根据执行计划，调用存储引擎的 API 来执行查询。</li><li>将结果返回给客户端，同时缓存查询结果。</li></ul><p>==简单来说，执行计划就是MySQL根据解析、处理、优化后生成的计划。==<img src="https://ww1.sinaimg.cn/large/006tKfTcgy1g1l1l6bkkfj313i0o4gok.jpg" alt="image-20190330192427534"></p><h4 id="使用EXPLAIN-1"><a href="#使用EXPLAIN-1" class="headerlink" title="使用EXPLAIN"></a>使用EXPLAIN</h4><p>​    具体用法如下<code>explain select * from table where id in( )</code>，返回输出结果如下（官方网站的链接如下<a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a>）</p><table><thead><tr><th>Column</th><th>Meaning</th></tr></thead><tbody><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_id" target="_blank" rel="noopener"><code>id</code></a></td><td>The <code>SELECT</code> identifier</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_select_type" target="_blank" rel="noopener"><code>select_type</code></a></td><td>The <code>SELECT</code> type</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_table" target="_blank" rel="noopener"><code>table</code></a></td><td>The table for the output row</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_partitions" target="_blank" rel="noopener"><code>partitions</code></a></td><td>The matching partitions</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_type" target="_blank" rel="noopener"><code>type</code></a></td><td>The join type</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_possible_keys" target="_blank" rel="noopener"><code>possible_keys</code></a></td><td>The possible indexes to choose</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_key" target="_blank" rel="noopener"><code>key</code></a></td><td>The index actually chosen</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_key_len" target="_blank" rel="noopener"><code>key_len</code></a></td><td>The length of the chosen key</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_ref" target="_blank" rel="noopener"><code>ref</code></a></td><td>The columns compared to the index</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_rows" target="_blank" rel="noopener"><code>rows</code></a></td><td>Estimate of rows to be examined</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_filtered" target="_blank" rel="noopener"><code>filtered</code></a></td><td>Percentage of rows filtered by table condition</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html#explain_extra" target="_blank" rel="noopener"><code>Extra</code></a></td><td>Additional information</td></tr></tbody></table><p>这里我们注意点是select_type 、type、possible_keys、key、rows、Extra（更多细节可以查看官方文档）</p><p><code>select_type</code> : 表示了查询的类型，常见的是SIMPLE，这个是在有子查询、联合查询需要注意的。</p><p><code>type</code> ：这个字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等. </p><p>根据性能：</p><p>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</p><p>除了ALL，其他都是走索引</p><p><code>possible_keys</code>：表示可以选择的索引</p><p><code>key</code>：表示执行时候真正使用的索引</p><p><code>ref</code> : 该<code>ref</code>列显示将哪些列或常量与列中指定的索引进行比较(例如联合索引的时候，命中了几个)，以 <code>key</code>从表中选择行。</p><p><code>rows</code>：扫描的行数</p><p><code>Extra</code>：也是比较重要的一个字段，常见的类型如下</p><p> Using filesort，表示MySQL必须执行额外的传递以找出如何按排序顺序检索行。</p><p>Using index，仅需要从索引树中获取，例如通过主键查询（聚合索引类型，所以主键上带有key的所有信息），或者是命中索引，且仅取索引上的相关字段。</p><p>Using where，表示限制哪些行与下一个表匹配或发送到客户端。 除非特意打算从表中获取或检查所有行，否则如果Extra值是Using where并且表连接类型为ALL或index，则可以是查询有问题了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​    有了上述相关知识，我们就可以用<code>explain select * from table where id in( )</code> 来获取相关信息分析，可以发现 type为range ,Extra 为Using where ，是有走索引的。</p><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1g1l35it2ghj325a03saat.jpg" alt="image-20190330201851186"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>​    最后，再简单扩展一些MYSQL相关知识。</p><h4 id="如何创建高性能的索引"><a href="#如何创建高性能的索引" class="headerlink" title="如何创建高性能的索引"></a>如何创建高性能的索引</h4><h5 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h5><p>​    关于索引类型，有b-tree,哈希,r-tree,  需要重点关注Innodb引擎的索引类型b-tree ,</p><p>了解聚簇索引，可以全值匹配、匹配最左前缀（例如，在使用like的时候 “a%” 索引会生效，而在使用“%a”的时候就不会生效）、匹配单列前缀、匹配范围值、只访问索引的查询（覆盖索引，索引自身包含了查询相关信息，不用再通过查询主键获取信息）。</p><h5 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h5><ul><li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机I/O变成顺序I/O</li></ul><p>当然索引并不是万能的 ‘银弹’，需要考虑其选择的依据（ 表的大小 、数据量） ，使用的方式（怎么使用联合索引等）以及带来的问题（频繁写表的同时也会带来索引重建、修改的损耗，索引本身的存储空间占用）</p><h4 id="为什么会慢查询"><a href="#为什么会慢查询" class="headerlink" title="为什么会慢查询"></a>为什么会慢查询</h4><p>正常情况下，主要有以下两类</p><ul><li>是否请求了不需要的数据（常见 select * ，注意这一小细节，可能会带来例如数据返回的时候会损耗时间，使用临时表等问题）</li><li>扫描额外的记录（通常是未走索引，正确使用索引的姿势）</li></ul><p>非正常情况下，即一些非可控因素 ，锁的占用，连接数耗尽等。</p><p>参考：</p><ul><li>高性能MySQL</li><li><a href="https://dev.mysql.com/doc/refman/5.5/en/execution-plan-information.html" target="_blank" rel="noopener">8.8 Understanding the Query Execution Plan</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Broken pipe问题的思考</title>
      <link href="/2019/03/26/%E8%AE%B0%E4%B8%80%E6%AC%A1Broken-pipe%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/03/26/%E8%AE%B0%E4%B8%80%E6%AC%A1Broken-pipe%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>​    今天遇到一个Broken pipe的问题，觉得挺有意思的就记录一下，因为这整个过程还是涉及挺多相关知识的（nginx 、tomcat 、内存查看等），例如是为了找到运行机器ip，通过查询nginx的access.log 获取错误机器ip， 收获挺多。</p><a id="more"></a><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>​    springmvc 发送请求，根据筛选查询MongoDB ，然后将查询结果导出Execl，响应时间比较久，</p><p>然后就返回错误。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code class="java">Caused by: java.net.SocketException: Broken pipe   at java.net.SocketOutputStream.socketWrite0(Native Method) ~[?:1.6.0_25]   at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:92) ~[?:1.6.0_25]   at java.net.SocketOutputStream.write(SocketOutputStream.java:136) ~[?:1.6.0_25]   at org.apache.coyote.http11.InternalOutputBuffer.realWriteBytes(InternalOutputBuffer.java:216) ~[tomcat-coyote.jar:7.0.82]   at org.apache.tomcat.util.buf.ByteChunk.flushBuffer(ByteChunk.java:487) ~[tomcat-coyote.jar:7.0.82]   at org.apache.tomcat.util.buf.ByteChunk.append(ByteChunk.java:373) ~[tomcat-coyote.jar:7.0.82]   at org.apache.coyote.http11.InternalOutputBuffer$OutputStreamOutputBuffer.doWrite(InternalOutputBuffer.java:239) ~[tomcat-coyote.jar:7.0.82]   at org.apache.coyote.http11.filters.IdentityOutputFilter.doWrite(IdentityOutputFilter.java:93) ~[tomcat-coyote.jar:7.0.82]   at org.apache.coyote.http11.AbstractOutputBuffer.doWrite(AbstractOutputBuffer.java:192) ~[tomcat-coyote.jar:7.0.82]   at org.apache.coyote.Response.doWrite(Response.java:506) ~[tomcat-coyote.jar:7.0.82]   at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:405) ~[catalina.jar:7.0.82]   ... 67 more</code></pre><h2 id="猜测思路"><a href="#猜测思路" class="headerlink" title="猜测思路"></a>猜测思路</h2><p>​    因为在选择当天数据的时候导出是没有问题的，而选择7天的时候就报错了。初步的现状认定就是响应时间长，或者文件过大导致。</p><p>猜测一： 查询出来的数据太多，导致内存不足，一直full gc ，导致响应变慢</p><p>​    通过<code>jstat  -gcutil  pid</code>    命令查看，发现并没有吃满内存，只是young gc 频繁了点。</p><p>猜测二： 查询出来的数据太大，tomcat容器有限制</p><p>​    又想是否是导出文件太大，tomcat 会对这个限制，然后去google了一波‘tomcat response body size limit’ 发现并没有相关资料</p><p>有的只是tomcat会对post 请求body做限制，默认是2m</p><pre><code>Having said that*, if this is the issue, you should have got an exception on the lines of `Post data too big` in tomcat</code></pre><p>于是上官网<a href="http://tomcat.apache.org/tomcat-7.0-doc/connectors.html#HTTP" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-7.0-doc/connectors.html#HTTP</a> （从错误信息里获取到的版本是7.0.82） 也没有发现什么说明。（简略翻了一下，或许是没找到）</p><p><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-7.0-doc/config/http.html</a>  ,（这里可以关注下timeout相关配置，另外也可以看下tomcat的异常定义）</p><table><thead><tr><th><strong>Attribute</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>maxPostSize</code></td><td>The maximum size in bytes of the POST which will be handled by the container FORM URL parameter parsing. The limit can be disabled by setting this attribute to a value less than zero. If not specified, this attribute is set to 2097152 (2 megabytes). Note that the <a href="http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Failed_Request_Filter" target="_blank" rel="noopener"><code>FailedRequestFilter</code></a> can be used to reject requests that exceed this limit.</td></tr></tbody></table><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h4 id="Tomcat源码"><a href="#Tomcat源码" class="headerlink" title="Tomcat源码"></a>Tomcat源码</h4><p>于是直接下载源码查看，通过在maven配置</p><ol><li><pre><code> &lt;dependency&gt;     &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;     &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;     &lt;version&gt;7.0.82&lt;/version&gt; &lt;/dependency&gt;</code></pre><p> 然后定位到报错位置org.apache.coyote.http11.InternalOutputBuffer.OutputStreamOutputBuffer#doWrite</p><p> <img src="https://ww1.sinaimg.cn/large/006tKfTcgy1g1g9hxu9n8j31040fo0v2.jpg" alt="image-20190326161033556"></p><p>这里的socketBuffer，定义如下</p></li></ol><pre><code class="javaj">/** * Socket buffer. */private ByteChunk socketBuffer;</code></pre><p>查看ByteChunk的定义，发现它是封装了一层byte[]</p><pre><code>- This class is used to represent a chunk of bytes, and- utilities to manipulate byte[].</code></pre><p>再通过错误信息定位到 org.apache.tomcat.util.buf.ByteChunk#append(byte[], int, int)</p><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1g1g0k4t1gkj315a0fo40s.jpg" alt="image-20190326110116891"></p><p>然后发现有limit !!</p><p>进去看，发现其实只是对limit做了长度限制，并不会导致什么异常，这里limit默认是-1，即没有限制，即使设置了也只是写块的时候限制大小，并不会导致异常。</p><pre><code class="java">/** * Make space for len chars. If len is small, allocate a reserve space too. * Never grow bigger than limit. */public void makeSpace(int count) {    byte[] tmp = null;    int newSize;    int desiredSize=end + count;    // Can&#39;t grow above the limit    if( limit &gt; 0 &amp;&amp;        desiredSize &gt; limit) {        desiredSize=limit;    }    if( buff==null ) {        if( desiredSize &lt; 256 )         {            desiredSize=256; // take a minimum        }        buff=new byte[desiredSize];    }    // limit &lt; buf.length ( the buffer is already big )    // or we already have space XXX    if( desiredSize &lt;= buff.length ) {        return;    }    // grow in larger chunks    if( desiredSize &lt; 2 * buff.length ) {        newSize= buff.length * 2;        if( limit &gt;0 &amp;&amp;            newSize &gt; limit ) {            newSize=limit;        }        tmp=new byte[newSize];    } else {        newSize= buff.length * 2 + count ;        if( limit &gt; 0 &amp;&amp;            newSize &gt; limit ) {            newSize=limit;        }        tmp=new byte[newSize];    }    System.arraycopy(buff, start, tmp, 0, end-start);    buff = tmp;    tmp = null;    end=end-start;    start=0;}</code></pre><p>再根据错误信息 定位到如下</p><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1g1g0strvuej31cm0pk42c.jpg" alt="image-20190326110936819"></p><p>发现是在 从服务向客户端写buffer的时候出错。于是猜测是由于<strong>查询时间过长， 客户端由于超时断开，服务端还在写数据，</strong>这个时候就会报出这个错误。</p><h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><ol><li>查看客户端的超时时间，使用的是chrom（<a href="https://cs.chromium.org/chromium/src/net/socket/client_socket_pool.cc?sq=package:chromium&amp;l=25" target="_blank" rel="noopener">https://cs.chromium.org/chromium/src/net/socket/client_socket_pool.cc?sq=package:chromium&amp;l=25</a>）</li></ol><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1g1g1lpoleaj31g50u07df.jpg" alt="image-20190326113723854"></p><p>​    默认是5分钟，实际请求并没有怎么长，等待个十秒左右就返回错误了</p><ol start="2"><li>于是想到还有个nginx配置，查看发现配置为</li></ol><p>keepalive_timeout  8 8;</p><p>这里通过查询相关资料发现</p><p>​    </p><p>keepalive_timeout timeout [header_timeout];</p><p>​    第一个参数：设置keep-alive客户端连接在服务器端保持开启的超时值（默认75s）；值为0会禁用keep-alive客户端连接；</p><p>​    第二个参数：可选、在响应的header域中设置一个值“Keep-Alive: timeout=time”；通常可以不用设置；</p><p>​    注：keepalive_timeout默认75s</p><p>​    所以这里的超时时间是8s，于是修改keepalive_timeout为60s后，刷新配置，重新测试，发现可以导出了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3月第三周知识点记录</title>
      <link href="/2019/03/24/3%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/03/24/3%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>### </p><p>3月 第三周 18-24 记录</p><p>​    复习Web</p><p>​        Model-View-Controller 延迟</p><p>​        Servlet API (<a href="https://jcp.org/en/jsr/detail?id=340" target="_blank" rel="noopener">JSR 340</a>)  延迟</p><p>​        WebSocket API (<a href="https://www.jcp.org/en/jsr/detail?id=356" target="_blank" rel="noopener">JSR 356</a>)  暂不关心</p><p>​    MQ : JMS (<a href="https://jcp.org/en/jsr/detail?id=914" target="_blank" rel="noopener">JSR 914</a>)</p><p>​    RPC:RMI</p><p>当你发现自己的才华撑不起野心时，就请安静下来学习吧</p><a id="more"></a><h2 id="周一"><a href="#周一" class="headerlink" title="周一"></a>周一</h2><p>JTA </p><p>分而治之的思想  、 多线程、大数据 </p><p>​    负载均衡 解决单机处理问题  垂直扩展（单机机器性能）和水平扩展（增加多台机器分担）</p><p>​    负载均衡策略的优劣及其实现的难易程度有两个关键因素：负载均衡算法；对网络系统状况的检测方式和能力。</p><p>​    轮训 、加权、最少连接数、响应速度、随机、处理能力</p><p>​    硬件（DNS ）和软件</p><p>​    LVS的NAT和DR。责任分离</p><p><a href="https://www.cnblogs.com/kevingrace/p/6137881.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6137881.html</a></p><p>网络模型</p><p><a href="https://juejin.im/post/59a0472f5188251240632f92" target="_blank" rel="noopener">https://juejin.im/post/59a0472f5188251240632f92</a></p><p>反射和字节码（ASM AOP思想）</p><p><a href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/</a></p><h2 id="周二"><a href="#周二" class="headerlink" title="周二"></a>周二</h2><p>jvm <a href="https://blog.csdn.net/zhoufanyang_china/article/details/54601311,对象" target="_blank" rel="noopener">https://blog.csdn.net/zhoufanyang_china/article/details/54601311,对象</a><br>    对象头 信息和指针<br>    实例数据<br>    对齐填充</p><p>限流</p><p>redis+lua在集群里控制方法的调用量了</p><p>单机 令牌（也可以全局发牌） 或者juc信号量 、 guava的 limitrater</p><p>mysql版本、学习</p><p>mysql sending data</p><p>explain</p><p>iostat IOPS</p><p> mysql: show processlist 详解</p><p><a href="https://zhuanlan.zhihu.com/p/30743094" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30743094</a></p><h2 id="周三"><a href="#周三" class="headerlink" title="周三"></a>周三</h2><p>JMM 规范 <a href="https://www.jcp.org/en/jsr/detail?id=133" target="_blank" rel="noopener">https://www.jcp.org/en/jsr/detail?id=133</a></p><p><a href="http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/</a></p><p>Spring 自定义注解</p><p><a href="https://apollochen123.github.io/2018/05/25/%E7%94%B1%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%94%9F%E6%88%90SpringBean%E5%85%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">https://apollochen123.github.io/2018/05/25/%E7%94%B1%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%94%9F%E6%88%90SpringBean%E5%85%A8%E8%BF%87%E7%A8%8B/</a></p><p>jdk介绍<br><a href="https://www.jianshu.com/p/f98c3acd8df8" target="_blank" rel="noopener">https://www.jianshu.com/p/f98c3acd8df8</a></p><p>离职 瓶颈和薪资</p><p>《未来架构：从服务化到云原生》</p><p>springboot  :<a href="http://blog.yuqiyu.com/" target="_blank" rel="noopener">http://blog.yuqiyu.com/</a></p><p>线程？    </p><p><a href="https://mp.weixin.qq.com/s/2ZjgLI3lgJJjpAjPdb9XSw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2ZjgLI3lgJJjpAjPdb9XSw</a></p><h2 id="周四"><a href="#周四" class="headerlink" title="周四"></a>周四</h2><p>全局异常处理—&gt;常用注解</p><p>@ControllerAdvice</p><p>@ResponseStatus </p><p>@ExceptionHandler</p><p>压缩协议</p><p>Protocol Buffers - PB协议概述</p><p>如何验证 java 的双亲委派机制</p><p>虚拟机</p><p>测试</p><p><a href="https://www.cnkirito.moe/java-jmh/" target="_blank" rel="noopener">https://www.cnkirito.moe/java-jmh/</a></p><p><a href="https://www.zhihu.com/question/58735131" target="_blank" rel="noopener">https://www.zhihu.com/question/58735131</a></p><h2 id="周五"><a href="#周五" class="headerlink" title="周五"></a>周五</h2><p>https</p><p><a href="https://www.jianshu.com/p/b0b6b88fe9fe" target="_blank" rel="noopener">https://www.jianshu.com/p/b0b6b88fe9fe</a></p><p>统一版本管理</p><p><a href="https://maven.apache.org/maven-ci-friendly.html" target="_blank" rel="noopener">https://maven.apache.org/maven-ci-friendly.html</a></p><p>spring 初始化</p><p>Springboot 工程</p><p>jpa <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords" target="_blank" rel="noopener">https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords</a></p><p>周六日总结</p><ul><li style="list-style: none"><input type="checkbox"> hibernate反射运用场景？</li><li style="list-style: none"><input type="checkbox"> mybatis和hibernate？</li><li style="list-style: none"><input type="checkbox"> Spring 一个请求一个线程？线程池？</li><li style="list-style: none"><input type="checkbox"> spring观察者模式是怎么实现的？具体回调方式？</li><li style="list-style: none"><input type="checkbox"> 为什么抛异常，而不是返回一个状态码？ 统一处理？性能影响？</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> week </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Expert One-on-One J2EE Development without EJB</title>
      <link href="/2019/03/10/Note_Expert%20One-on-One-J2EE-Development-without-EJB/"/>
      <url>/2019/03/10/Note_Expert%20One-on-One-J2EE-Development-without-EJB/</url>
      
        <content type="html"><![CDATA[<p>阅读的目的？我想要从中获得什么？</p><p>​    架构师的思维，当一个框架不符合主流时候是怎么思考的，spring是为解决什么问题出现的？</p><p>​    spring相关的发展历史</p><ul><li>不符合的原因  </li><li>分析我们真正需要的是什么。</li><li>替代方案，解决方法</li></ul><a id="more"></a><h3 id="Chapeter-1"><a href="#Chapeter-1" class="headerlink" title="Chapeter 1"></a>Chapeter 1</h3><p>Why  without ？</p><h4 id="EJB存在的问题"><a href="#EJB存在的问题" class="headerlink" title="EJB存在的问题"></a>EJB存在的问题</h4><ul><li>EJB规范中的一些部分已经过时,J2SE1.3引入的动态代理(dynamicproxy)</li><li>EJB和RMI之间那种传统的紧密关系也开始显得有些不合时宜(local 和 remote 的调用？)这一方面是因为webservices 的迅速发展，另一方面是因为人们发现:很多时候 EJB 只需要本地接口</li><li>EJB 最善于实现业务对象分布的体系结构，然而这种体系结构究竟有多大程度的普遍性</li><li>SLSB （无状态session bean）和 MDB 使用较多，整个容器成本高昂</li><li>EJB的复杂性，EJB规范的复杂性 -&gt;开发效率</li><li>TDD流行 ，难以测试</li><li>对于 EJB 致力解决的中间件问题，面向方面的程序设计(Aspect Oriented Programming，AOP）</li></ul><p>EJB 试图解决太多的问题，其中很多问题本不应该由它来解决的。</p><h4 id="J2EE还剩下什么"><a href="#J2EE还剩下什么" class="headerlink" title="J2EE还剩下什么"></a>J2EE还剩下什么</h4><p>​    EJB只是J2EE的一种实现框架。因为这些库和框架不仅可以让我们摆脱使用 J2EE 服务的复杂度，而且也不会招致 EJB 所带来的复杂度。</p><p>​    J2EE 都是一个伟大的成功:</p><ul><li>它成功地在从前没有标准的地方建立了标准;</li><li>它大大提升了企业级软件的开放程度;</li><li>并且它得到了整个行业和开发者的广泛认可。</li></ul><h5 id="J2EE-在易用性方面存在着严重的问题"><a href="#J2EE-在易用性方面存在着严重的问题" class="headerlink" title="J2EE 在易用性方面存在着严重的问题"></a>J2EE 在易用性方面存在着严重的问题</h5><p><em>Core J2EE Patterns</em>，书中已经开始提倡使 用普通 Java 对象。</p><h6 id="以规范为驱动的问题"><a href="#以规范为驱动的问题" class="headerlink" title="以规范为驱动的问题"></a>以规范为驱动的问题</h6><p>​    有状态 session bean，状态的复制带来了很多微妙棘手的问题，所以大多数架构师总是尽量避免使用有状态 session bean。 </p><p>​    如果希望开发者遵循 J2EE 规范，那么 J2EE 规范首先必须是一个实用、易用的规范。</p><h5 id="J2EE-项目具备架构重构能力的关键"><a href="#J2EE-项目具备架构重构能力的关键" class="headerlink" title="J2EE 项目具备架构重构能力的关键"></a>J2EE 项目具备架构重构能力的关键</h5><p>​    简单、效率、面向对象（思想）、业务需求至上、可测试性</p><p> 􏰀 遵循良好的 OO 设计法则，并且始终针对接口编程、而非针对类编程。这是经典图书 </p><p>Design Patterns 教给我们的基本常识，可惜人们常常忽视了这一点。 </p><p>​    􏰀 将EJB之类的技术隐藏在普通Java对象背后。 </p><p>利用现有的框架提供这些基础设施服务</p><p>spring</p><p>​    基础框架的设计甚至早于<em>Expert One-on-One J2EE Design and Development</em>的写作，<br>它们来自我过去几个商业项目的经验。</p><h3 id="Chapeter-5-EJB的5年间"><a href="#Chapeter-5-EJB的5年间" class="headerlink" title="Chapeter 5   EJB的5年间"></a>Chapeter 5   EJB的5年间</h3><h4 id="不应该以规范先行-，而应该开源引导"><a href="#不应该以规范先行-，而应该开源引导" class="headerlink" title="不应该以规范先行  ，而应该开源引导"></a>不应该以规范先行  ，而应该开源引导</h4><p>​    EJB出现的背景，制定标准 （好处是 强制接口实现分离 、容器的概念、管理对象，粗粒度）</p><p>rmi到Ws （SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。使用描述语言WSDL）</p><h4 id="需要EJB中的什么（从中获取价值，并用简单的方式实现）"><a href="#需要EJB中的什么（从中获取价值，并用简单的方式实现）" class="headerlink" title="需要EJB中的什么（从中获取价值，并用简单的方式实现）"></a>需要EJB中的什么（从中获取价值，并用简单的方式实现）</h4><ul><li>声明式事务（编程式事务可以解决复杂的事务、 JTA webLogic）</li><li>远程调用（协议。JMS、 ws）</li><li>集群（web层、数据访问层、数据库。真正限制是在数据访问 吞吐、并置的应用更有效）</li><li>线程池（避免jvm垃圾回收、tomcat的线程池）和资源池</li><li>安全（web层、tomcat filter、springmvc filter）</li><li>管理业务对象（JNDI、重量级工厂 、ioc抄袭、spring提供基于配置 而不是代码、picoContainer、EJB提供了一个重量级工厂（实现、部署EJB、使用JNDI 应用代码）、消除了接口与实现之间的耦合。）</li></ul><p>​    </p><p>总结</p><p>​    SLSB、 MDB      entity beans 性能、最好设计成哑数据（贫血模型） 不包含业务逻辑</p><h4 id="不想要什么"><a href="#不想要什么" class="headerlink" title="不想要什么"></a>不想要什么</h4><ul><li>容器的锁定</li></ul><p>​        限制应用服务器的选择</p><p>​        只使用一小部分，却要接受其复杂性（不能按需引入）</p><p>​        业务对象会被EJB API浸入</p><p>​        不能在容器之外复用业务逻辑</p><ul><li>丑陋的结构、泛滥的类</li></ul><p>​        实现一个session bean ，至少需要三个Java源文件home接口 、组件接口 、bean实现类。通常还需要业务接口，来保持bean和组件的同步。</p><ul><li>部署描述文件的地狱</li></ul><p>​        描述文件冗长，依赖代码生成工具，不可手工维护</p><ul><li>==类加载器的地狱==</li></ul><p>​        EJB容器与web容器使用的不是一个类加载器</p><p>​        EJB类加载器是WAR类加载器的父亲。 EJB类加载器不能看到WAR类加载器加载的类？</p><ul><li>测试</li></ul><p>​        依赖容器导致问题</p><h4 id="简单的事情变困难"><a href="#简单的事情变困难" class="headerlink" title="简单的事情变困难"></a>简单的事情变困难</h4><p>​    用EJB实现singleton</p><p>​    在EJB容器启动时做一些处理 （servelt listener 、web的listener 或者是bean的初始化后置操作等 、同时提供了依赖关系和顺序的支持）</p><p>​    在EJB之间以及EJB和EJB容器外的对象之间的共享配置</p><p>​    不能自由访问其他Java API  禁止访问一些Java API</p><p>EJB3.0（JSR 220 2003年6月）</p><p>​    主要动机是容易使用 降低EJB开发者使用时的复杂度，改良EJB的体系架构</p><p>​        使用源码级元数据 -&gt;废除部署描述文件。</p><p>​        提供一个简单、基于元数据标注的依赖注入机制。</p><p>​        采用新的持久化机制。Hibernate采用的持久化方式</p><p>​    时间太长、不大可能引入AOP方案、还是依赖特定EJB容器。（从最近看webflux的做法，决定减少对servelt的依赖可以看出。不强依赖于Servelt，从而达到不依赖于特定服务器）            </p><p>YAGNI     </p><h3 id="Chapter-6-轻量级容器"><a href="#Chapter-6-轻量级容器" class="headerlink" title="Chapter 6 轻量级容器"></a>Chapter 6 轻量级容器</h3><h4 id="容器需提供的服务"><a href="#容器需提供的服务" class="headerlink" title="容器需提供的服务"></a>容器需提供的服务</h4><p>​    生命周期，回调</p><p>​    查看服务 容器的核心是工厂</p><p>​    配置管理 统一方法来配置运行其中的对象</p><p>​    依赖管理</p><h4 id="增值服务"><a href="#增值服务" class="headerlink" title="增值服务"></a>增值服务</h4><p>​    企业级服务 ，事务管理或其他声明式服务</p><p>​    线程管理</p><p>​    对象池</p><p>​    集群服务</p><p>​    管理 jmx或暴露接口</p><p>​    远程服务 http 多协议</p><p>​        暴露</p><p>​        消费</p><p>​    可定制性和扩展性</p><p>EJB容器 管理的是粗粒度的组件（多个对象组合）</p><p>IOC</p><p>利用DI 消除lookup代码，让容器自动决定对象间的依赖关系</p><p>依赖查找 容器管理对象的生命周期，受管对象则负责查找自己的依赖关系 JNDI</p><p>依赖注入 让容器全权去负责依赖查询，受管对象暴露Java Bean 的setter 方法或带参数的构造。（或者通过元数据） </p><p>​    设值方法注入 建立在JavaBean规范之上</p><p>​    构造注入（picoContainer团队发明）</p><p>可以指定init 和 destroy 方法</p><p>注入异常检查</p><p>自动装配 通过类型</p><p>对于可移植性 </p><p>​    减少代码对容器的依赖</p><p>​    企业服务依赖容器，尽量以声明式而非编程式</p><p>代码风格</p><p> 针对接口</p><p>优先使用strategy设计模式</p><p>明确每个对象责任，不要大而全 （大一统，而是应该职责明确，抽成组件化）</p><p>能依靠容器解决的问题，就不要自己编写代码</p><p>为什么spring 能从轻量级框架中脱引而出，提供企业级服务的框架紧密合作，允许开发者通过编程方式或声明方式轻松地访问各种企业级服务。（粘合剂作用，例如整合ssh）</p><h3 id="Chapter-7-Spring框架介绍"><a href="#Chapter-7-Spring框架介绍" class="headerlink" title="Chapter 7 Spring框架介绍"></a>Chapter 7 Spring框架介绍</h3><p>spring不重复造轮子 例如没有logger组件</p><p>工厂bean 主要在spring框架内部使用</p><p>​    例如 </p><p>​        JndiObjectFactoryBean</p><p>​        ProxyFactoryBean</p><p>​        TransactionProxyFactoryBean</p><p>​        RmiProxyFactoryBean</p><p>spring以统一的方式为多种j2ee服务提供了抽象，使得开发者灵活选择各种资源定位策略</p><p>最好不要依赖servlet环境，应该尽量使用spring的抽象，因为这样就不会依赖于任何环境</p><p>ApplicationContext</p><p>​    ApplicationEvent</p><p>​    MessageResource</p><p>​    ResourceLoader. use Resource</p><p>BeanFactoryAware</p><p>ApplicationContextAware</p><p>​     ResoureLoaderAware </p><p>BeanFactory的后处理</p><p>​    允许在底层bean工厂读取bean声明以后进行后处理，可以覆盖某个属性值，或是为某些属性提供占位值。</p><p>​    参考现成的实现</p><p>​        PropertyOverriderConfigurer</p><p>​        PropertyPlaceholderConfigurer</p><p>BeanPostProcessor</p><p>​        可以用于AOP代理</p><p>IoC容器强大在于：它几乎可以用于配置任何对象、框架和应用</p><h3 id="Chapter-8-基于AOP概念的声明性中间件"><a href="#Chapter-8-基于AOP概念的声明性中间件" class="headerlink" title="Chapter 8 基于AOP概念的声明性中间件"></a>Chapter 8 基于AOP概念的声明性中间件</h3><p>​    为何AOP对J2EE的未来至关重要</p><p>​    为何AOP是J2EE without EJB的关键</p><p>OOP 有些时候无法避免代码重复</p><p>概念</p><ul><li>aspect  方面</li><li>adivce 增强，拦截器</li><li>Join point  连接点</li><li>Point cut 切入点</li></ul><p>历史</p><p>一些OOP设计模式已经解决了AOP希望解决的部分问题</p><p>​    Decorator</p><p>​    Observer</p><p>​    Chain of Responsibility</p><p>使用OO设计模式，不可能做到既保持被增强方法的强类型性、又不必自己动手为每个方法编写转发代码</p><p>​    拦截器 如 servlet 、EJB 等 ，存在的问题是 它们将被拦截的代码与特点的API或上下文环境绑在一起，大多损失了强类型性。</p><p>AOP的实现策略</p><ul><li>J2SE动态代理    </li></ul><p>​         java1.3y引入动态代理，调用必要的拦截器链，最后一个拦截器借助反射调用目标对象</p><p>​        好处：标准的语言特征</p><p>​        局限：针对接口</p><p>​        实现：spring</p><ul><li>动态字节码生成</li></ul><p>​        CGLIB包，被应用在Hibernate 2.x版本中，并被证明是一种成熟的技术</p><p>​        存在的问题，通过继承来实现代理的，所以无法为final方法提供代理</p><p>​        实现：spring、Hibernate</p><ul><li>Java代码生成 </li></ul><p>​        OOP设计模式，EJB代码生成策略，预设的方式，由于动态代理和动态字节码生成技术的出现，这种做法逐渐退出</p><ul><li>使用定制的类加载器</li></ul><p>​        对某个类的所有实例进行增强</p><p>​        风险：偏离了Java标准</p><p>​        实现：JBoss4、AspectWerkz</p><ul><li>语言扩展 </li></ul><p>​        实现：AspectJ</p><p>springAOP的缺点</p><p>​    不支持字段拦截，但是封装性考虑是不应该</p><p>​    只有通过SpringIoc容器获取的对象才能进行增强，不能在类装载器层面进行增强</p><p>​    拦截器代码中没有强类型检查</p><p>AOP风险</p><p>​    拦截字段的风险 ，破坏封装性</p><p>​    太多的方面，维护</p><p>​    正交性，不依赖顺序，独立</p><p>​    测试 AOP提升可测试性，单元测试专注于业务逻辑</p><p>​    调试 </p><p>​    性能 粒度</p><p>​        如果你给细粒度的持久化对象加上AOP增强，在每次操作将会有数百个持久化对象被创建出来，那么才会有开销问题。</p><p>​    一次涉及反射的方法调用需要耗费的时间是毫秒级的 </p><p>​    一次数据库只读访问的时间开销通常是数十毫秒</p><p>​    通过浏览器访问web页面的网络延迟则是百毫秒级</p><p>AOP设计建议</p><p>​    渐进式、实用至上的方式来使用AOP</p><p>​    将AOP应用于业务对象，最有价值的用途就是在业务方法的粒度上提供通用的企业级服务</p><p>​    典型问题：</p><p>​        调用堆跟踪和性能监控</p><p>​        审计</p><p>​        消息通知（例如当特定的异常抛出时给管理员发送电子邮件）</p><p>​    不建议在非常细粒度的对象（例如持久化对象）进行增强</p><p>springAOP</p><p>​    一个可移植的服务层，类似于JTA、JDBC和别的底层API（将声明性服务从EJB容器中解耦出来，J2ee）</p><p>​    一种基于AOP的服务获取机制，基于Java</p><h3 id="Chapter-9-事务管理"><a href="#Chapter-9-事务管理" class="headerlink" title="Chapter 9  事务管理"></a>Chapter 9  事务管理</h3><p>​    在一个 web层 、业务对象层 、数据访问层中，事务管理属于业务对象层，通过将数据库切换到手工提交事务的模式。这种模式业务对象层和数据访问层都绑定到了特定的事务处理策略和数据访问策略。</p><p>​    需要分离这些关注点</p><ul><li>业务对象划分抽象事务，而无需关注事务涉及的数据库资源</li><li>数据访问对象获取数据库资源，无需关注数据库资源如何加入事务</li></ul><h4 id="传统J2EE-事务管理"><a href="#传统J2EE-事务管理" class="headerlink" title="传统J2EE 事务管理"></a>传统J2EE 事务管理</h4><p>​    使用全局容器事务：事务由应用服务器来管理，登记所有参与事务的资源。一旦数据访问对象使用了涉及事务的资源，应用服务器容器将根据需要进行提交或回滚。</p><p>​    底层设施是由容器实现的JTA，全局事务管理使用CMT</p><h4 id="J2EE容器作为事务协调器"><a href="#J2EE容器作为事务协调器" class="headerlink" title="J2EE容器作为事务协调器"></a>J2EE容器作为事务协调器</h4><p>​    具备分布式事务的处理能力，应该完整支持遵循X/Open XA规范的两阶段提交协议（2-Phase-Commit）</p><p>​    第一阶段 事务协调器向所有相关资源发布 ‘准备’指令</p><p>​    第二阶段 等所有的资源准备好以后触发实际的提交动作</p><p>​    一、参与事务的资源必须被正确地配置好，例如JDBC，通过javax.sql.XADataSource接口实现类来建立JNDI DataSource</p><p>​    J2EE 1.3 引入参与事务的资源的统一模型 java连接器架构 （Java Connector Architecture）</p><p>​    二、使用特定的服务器特性来获取JTA内置的TransactionManage对象，TransactionManage对象允许数据访问框架注册到实物同步回调接口上</p><p>​    编程式事务管理（使用java代码）  通过JNDI,直接使用JTA UserTransaction （多个受控异常，没有共同父类，事务处理代码污染业务对象）</p><p>​    声明式事务管理（使用xml配置，注解的方式） 组件模型CMT ，建立在JTA基础设施之上的服务(只有EJB才能使用，解决了80%的问题，必须使用全局事务管理，EJB2.0才支持本地接口)</p><h4 id="轻量级事务基础设施"><a href="#轻量级事务基础设施" class="headerlink" title="轻量级事务基础设施"></a>轻量级事务基础设施</h4><p>​    提供的功能：</p><p>​    可编程的事务声明和一致的异常处理机制。错误是不可恢复的，所以应该采用非受控异常，并且所有的异常应该继承自一个公共的基础父类</p><p>​    在OPJO上面实现声明式事务，无需绑定重量级组件模型</p><p>​    可插入的事务策略，以及让资源能够自动加入事务的手段</p><p>​    为采用分布式容器事务而需要的JTA</p><p>​    独立的JDBC数据源</p><p>​    独立的JDO PersistenceManagerFactory</p><p>​    独立的Hibernate SessionFactory</p><p>不应该依赖J2EE容器提供的服务，例如JNDI数据源。切换事务策略和资源定义应该是可配置的。</p><h4 id="Spring-Framework的事务管理"><a href="#Spring-Framework的事务管理" class="headerlink" title="Spring Framework的事务管理"></a>Spring Framework的事务管理</h4><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g18zgtukb9j31kz0u0af4.jpg" alt="image-20190320090427683"></p><h5 id="事务声明"><a href="#事务声明" class="headerlink" title="事务声明"></a>事务声明</h5><p>事务的属性 TransactionDefinition</p><p>​    事务传播类型 required 、supports 、mandatory、  requires new 、not support、 never</p><p>​    隔离级别 default 、ru、 rc、 rr 、serializable</p><p>​    超时</p><p>​    只读</p><p>基础设施接口 PlatfromTransactionManager</p><p>​    抽象了实际的具体事务策略，针对一个给定的TransactionDefinition符合一个TransactionStatus对象，并且对这个状态对象触发提交或回滚操作。</p><p>TransactionStatus对象代表当前运行中的事务。</p><p>​    setRollbackOnly 不会抛出异常</p><blockquote><p>Invoking this method outside a Spring transactionally advised AOP invocation is a programming error and will result in a runtime exception.</p></blockquote><h5 id="编程式事务处理"><a href="#编程式事务处理" class="headerlink" title="编程式事务处理"></a>编程式事务处理</h5><p>直接使用 PlatfromTransactionManager</p><p>事务模板 TransactionTemplate</p><p>​    比直接使用JTA简单</p><h5 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h5><p>​    避免EJB带来的缺陷</p><p>通用的 Aop ProxyFactoryBean 和 TransactionInterceptor</p><p>​    由于TransactionInterceptor是通过ThreadLocal来存取事务状态对象的。</p><p>一站式 TransactionProxyFactoryBean</p><p>​    优点：</p><p>​    把关联的配置组织在一起</p><p>​    不需要了解整个拦截器链</p><p>​    代理接口通过目标类自动确定，并不需要显示的指定    </p><p>​    缺点：</p><p>​    丧失了更强的可配置能力</p><p>源代码级别的元数据（注解）</p><p>1.2开始支持，基于JDK5 </p><h5 id="事务管理策略"><a href="#事务管理策略" class="headerlink" title="事务管理策略"></a>事务管理策略</h5><p>​    DataSourceTransactionManager</p><p>​    JtaTransactionManager</p><p>​    JdoTransactionManager</p><p>​    HibernateTransactionManager</p><h3 id="Chapter10-持久化"><a href="#Chapter10-持久化" class="headerlink" title="Chapter10 持久化"></a>Chapter10 持久化</h3><h4 id="常见持久化策略"><a href="#常见持久化策略" class="headerlink" title="常见持久化策略"></a>常见持久化策略</h4><h5 id="持久化策略概览"><a href="#持久化策略概览" class="headerlink" title="持久化策略概览"></a>持久化策略概览</h5><p>​    推荐Martin Fowler在 Patterns of Enterprise Application Architecture (POEAA) </p><p>​    基于SQL  直接操作关系模型，事务脚本（transaction script ），业务逻辑组织在一个过程中，适用于集合查询和批量更新。</p><p>​    基于O/R 映射（对象-关系映射）  ，查询相对简单，只需要取出很少的几行数据，并对这些数据进行选择新的更新。这些数据实体通常可以映射到持久化的Java对象，组成了领域模型（domain model），业务逻辑表现为对象之间的交互，而不是直接操作数据库里的表和字段。</p><p>​    一种简单的O/R映射就是active record ，一行记录都由对应的gateway类的一个实例来表现，这个持久化类提供insert、update、delete。每张表通常还有一个finder类。 将持久化操作定义在领域类内部。</p><p>​    而数据映射器（data mapper）的用途则是 在对象与数据库之间传递数据，并且保持这两者以及映射器的独立性。考虑持久化的问题。</p><p>​    透明持久化（transparent persistence）这个词通常就是指这种非侵入性的、提供工作单元（unit-of-work） ，例如Hibernate，session对象,维护状态被当前事务中的业务操作修改过的对象列表 。同时还扮演 identity map角色。</p><h5 id="选择持久化映射"><a href="#选择持久化映射" class="headerlink" title="选择持久化映射"></a>选择持久化映射</h5><h6 id="何时使用O-R映射"><a href="#何时使用O-R映射" class="headerlink" title="何时使用O/R映射"></a>何时使用O/R映射</h6><p>​    针对领域对象的 ‘加载/编辑/存储’ 流程</p><p>​    批量查询，更新和删除是单独进行</p><p>​    大量对象需要积极地缓存（通常出现在‘读操作对于写操作’的情况，web应用）</p><p>​    在领域对象与数据库表/字段之间有一个相当自然的对应关系</p><p>​    不需要对SQL进行特别优化。</p><h6 id="使用O-R映射到好处"><a href="#使用O-R映射到好处" class="headerlink" title="使用O/R映射到好处"></a>使用O/R映射到好处</h6><p>​    不必编写重复的JDBC代码来处理领域对象的实例</p><p>​    透明持久化，JDO使用编译器字节码修改的方式，使得StateManager能够知道对象字段的修改情况。Hibernate和TopLink则使用了快照比较的方式。Hibernate采用了运行期字节码生成，TopLink采用反射的架构，需要将对象注册到工作单元上。</p><h4 id="持久化发展史"><a href="#持久化发展史" class="headerlink" title="持久化发展史"></a>持久化发展史</h4><h5 id="关系型映射发展史"><a href="#关系型映射发展史" class="headerlink" title="关系型映射发展史"></a>关系型映射发展史</h5><p>1996年把 JDBC 加入j2SE1.1之中，将其作为RDBMS资源管理和数据访问的标注低级抽象层。</p><p>JDBC 2.0 和JDBC标准扩展（J2SE 1.2）</p><p>​    特性，可滚动结果集（ResultSet对象），新增javax.sql.DataSource接口</p><p>JDBC 3.0（J2SE1.4）</p><p>​    将JDBC标准扩展整合到J2SE的核心中，新特征，savePoint 、PreparedStatement</p><h5 id="O-R映射发展史"><a href="#O-R映射发展史" class="headerlink" title="O/R映射发展史"></a>O/R映射发展史</h5><p>1997-1998 TopLink,CocoBase ODMG</p><p>1999-2001 entity bean , JDO</p><p>​    entity bean ,j2ee ejb 1.1的发布，崛起，但是并没有促进O/R映射的发展，反而是阻碍</p><p>​    JDO java Data Objects</p><p>2002-2003: TopLink, Hibernate,ibatis数据库层</p><p>​    TopLink Oracle收购，提供类似JDO 的API</p><p>​    Hibernate 在JDBC之上提供一层薄薄的封装，在提供完全透明的持久化机制的同时，又提供尽可能多的灵活性。</p><p>​    ibatis 以SQL映射的形式提供了简单的O/R映射</p><p>2004：JDO稳步发展 Hibernate飞黄腾达</p><p>​    Hibernate成为JBoss4.0 CMP引擎的基石</p><p>JPA</p><p>11 May 2006：</p><p>​    The final release date of the JPA 1.0 specification was 11 May 2006 as part of <a href="https://en.wikipedia.org/wiki/Java_Community_Process" target="_blank" rel="noopener">Java Community Process</a> JSR 220. </p><p>10 December 2009</p><p>​    The JPA 2.0 specification was released 10 December 2009 (The Java EE 6 platform requires JPA 2.0<a href="https://en.wikipedia.org/wiki/Java_Persistence_API#cite_note-1" target="_blank" rel="noopener">[1]</a>.) </p><p>22 April 2013</p><p>​    The JPA 2.1 specification was released 22 April 2013 (The Java EE 7 platform requires JPA 2.1<a href="https://en.wikipedia.org/wiki/Java_Persistence_API#cite_note-2" target="_blank" rel="noopener">[2]</a>.)</p><h5 id="entity-bean败笔"><a href="#entity-bean败笔" class="headerlink" title="entity bean败笔"></a>entity bean败笔</h5><p>​    与EJB编程模型紧密耦合，CMP，依赖完整J2EE容器</p><p>​    开发部署工作量大</p><p>​    BMP实现麻烦，性能问题</p><p>​    EJB QL能力有限</p><p>​    </p><p>EJB 2.1开始走向一个可用的O/R映射解决方案。</p><h4 id="实践中的数据访问技术"><a href="#实践中的数据访问技术" class="headerlink" title="实践中的数据访问技术"></a>实践中的数据访问技术</h4><p>​    细粒度的领域模型不应该用重量级的EJB组件来建模，而应该使用简单的Java对象-POJO</p><h5 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h5><p>​    连接工厂：通过它创建连接（DataSource 、SessionFactory）</p><p>​    连接：代表了与特定数据存储介质之间的通信会话（Connection、Session）</p><p>连接工厂会维护一个连接池，避免频繁的创建连接。</p><p>在哪里定义连接工厂？</p><p>​    在容器中定义一个JDBC DataSource对象，在应用程序定义O/R ，也可以使用JCA连接器在J2EE容器中定义</p><p>在哪里初始化连接工厂？</p><p>​    在ServletContextListener中初始化，或者特定J2EE容器产品启动类</p><p>如何获得连接工厂？</p><p>​    使用JNDI查找J2EE容器中定义的连接工厂。本地定义工厂，借助一个自制启动类绑定到JNDI</p><p>如何在同一条线程的多次方法调用之间复用连接？</p><p>​    使用ServletFilter来查找连接工厂，每次请求开始将一个连接绑定到ThreadLocal对象，当请求处理完成后再取消绑定。    </p><p>事务与连接之间的关系是什么：事务驱动连接还是相反？</p><p>​    连接驱动事务，在数据访问或ServletFliter中管理</p><p>​    另一种是以J2EE的JTA驱动事务，并对连接工厂进行配置。</p><p>当异常发生的时候，如何保证连接正确关闭，而又不会破坏原来的异常？</p><p>​    每段代码前后加上 try/catch/finally。</p><p>以上虽然可以解决，但是都与特定环境绑定J2EE容器，Servlet</p><h5 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h5><p>​    SQL层面上操作关系数据库，JDBC是一个公认、强大的API。主要缺点在于，需要编写很多重复的基础设施代码。（iBATIS 映射和SPringJDBC模板支持，简化编码，整合资源管理与实务管理，并且在事务范围内复用连接）</p><h5 id="iBATIS-SQL映射"><a href="#iBATIS-SQL映射" class="headerlink" title="iBATIS SQL映射"></a>iBATIS SQL映射</h5><p>​    将使用JDBC的细节全部抽象隔离起来，SQL语句在XML文件中定义，并预留参数占位符，在执行时，占位符将被指定的参数值所取代。SQL查询时，结果字段将被映射到对象。</p><p>​    还可以缓存查询结果，缓存模型是针对每个查询语句分别指定的，并且可以指定哪些插入/更新/删除语句应该导致刷新特定缓存。</p><p>​    不提供透明持久化，不会对取出的对象进行任何变更。</p><p>与高级透明持久化相比，SQL层面上的映射有以下优点：</p><p>​    保持了SQL的全部能力</p><p>​    可以使用基于数据集的更新和删除高效地处理多行数据</p><p>​    可以毫无限制的使用统计函数（avg、sum、max和count）</p><p>​    可以轻松将领域对象映射到多张表的字段</p><p>缺点：</p><p>​    显示更新被修改对象</p><p>​    将应用层面的值转换成数据库兼容的值</p><p>没有实现工作单元和身份对应表，它不那么复杂。</p><h5 id="JDO"><a href="#JDO" class="headerlink" title="JDO"></a>JDO</h5><p>​    规范</p><p>​    JDOQL java查询API</p><h5 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h5><p>​    目标是在JDBC上提供一层薄薄的封装，同时提供完善的透明持久化；为应用程序增加O/R映射的语意，但又不脱离底层的关系数据库。</p><p>​    查询语言HQL提供了连接、统计函数等重要的关系型概念，与SQL不同是，查询是以领域对象熟悉的形式表现出来的。</p><p>​    核心连接接口是net.sf.hibernate.Session</p><p>​    快照对比 变更侦测 借助CGLIB以动态字节码生成的方式为持久对象创建运行时代理，从而降低了快照对比的性能损耗</p><h6 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h6><p>​    允许将持久对象断开与Session的关联，稍后又可以很容易地重建关联，持久化对象发送到客户端层，对象会暂时从事务中脱离，当用户提交时又回到事务。</p><p>​    好处就是：使得借助版本或时间戳实现跨多个请求、多个Session实例的乐观锁成为可能。</p><p>​    较为放松的状态管理源自 快照比较的变更侦测方式， 刷新数据库的时候将快照与持久对象的当前内容进行比较。从而将需要发出的更新语句减少到最低限度</p><pre><code class="java">@org.hibernate.annotations.Entity(dynamicInsert = true, dynamicUpdate = true)</code></pre><p>### </p><h6 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h6><h4 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h4><p>​    DAO 时最为重要的J2EE模式之一，也是GoF Strategy模式的一种特殊形式。</p><h5 id="DAO和透明化持久化"><a href="#DAO和透明化持久化" class="headerlink" title="DAO和透明化持久化"></a>DAO和透明化持久化</h5><p>​    典型的DAO 接口只针对相对简单、细粒度的持久化机制，当对象状态发送改变时，必须显式调用存储操作。他们没有区分一等对象（领域对象）和二等对象（从属性的领域对象，生命周期由父对象控制）。 JDBC</p><p>​    透明持久化解决方案，只需要对一等对象进行持久化操作，从属对象的操作则通过级联更新或删除隐含进行。（persistence by reachability） ps:复杂 不可控</p><h5 id="DAO设计中的问题"><a href="#DAO设计中的问题" class="headerlink" title="DAO设计中的问题"></a>DAO设计中的问题</h5><p>​    数据访问操作的粒度</p><p>​    透明持久度和对象状态</p><p>​    事务范围和延迟加载</p><h5 id="DAO基础设施的问题"><a href="#DAO基础设施的问题" class="headerlink" title="DAO基础设施的问题"></a>DAO基础设施的问题</h5><p>​    同之前资源处理问题有写关系</p><p>组装</p><p>参与事务</p><p>异常处理</p><p>​    这些问题属于中间层领地，应该由应用框架来提供各种库与组件之间的整合办法。</p><h4 id="使用spring框架进行数据访问"><a href="#使用spring框架进行数据访问" class="headerlink" title="使用spring框架进行数据访问"></a>使用spring框架进行数据访问</h4><p>​    bean工厂和上下文容器可以轻松装配</p><p>​    清晰的事务模型</p><p>​    通用的数据库访问异常体系，很好地定义了事务与连接的关系，尤其是如何在事务之间重复使用连接，</p><p>​    对于各种持久化方式，Spring用形式统一的模板机制解决了关闭连接、处理异常等问题</p><p>下图是访问异常体系</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g1e5z44nkbj31m60t2ade.jpg" alt="image-20190324203729362"></p><h3 id="Chapter11-远程调用"><a href="#Chapter11-远程调用" class="headerlink" title="Chapter11 远程调用"></a>Chapter11 远程调用</h3><h4 id="RMI-EJB-JAX-RPC-（java）"><a href="#RMI-EJB-JAX-RPC-（java）" class="headerlink" title="RMI/EJB/JAX-RPC （java）"></a>RMI/EJB/JAX-RPC （java）</h4><p>​    都是传统RMI模型：服务接口需要继承一个标记接口，并且每个方法都需要声明抛出受控的RemoteException异常。</p><h4 id="Webservice（平台无关调用）"><a href="#Webservice（平台无关调用）" class="headerlink" title="Webservice（平台无关调用）"></a>Webservice（平台无关调用）</h4><h5 id="WSDL-Web-Service-Definition-Language-语言"><a href="#WSDL-Web-Service-Definition-Language-语言" class="headerlink" title="WSDL( Web Service Definition Language )  语言"></a>WSDL( Web Service Definition Language )  语言</h5><p>​    WSDL is an XML format for describing network services as a set of endpoints operating on messages containing either document-oriented or procedure-oriented information.</p><h5 id="SOAP-Simple-Object-Access-Protocol-协议"><a href="#SOAP-Simple-Object-Access-Protocol-协议" class="headerlink" title="SOAP(Simple Object Access Protocol) 协议"></a>SOAP(Simple Object Access Protocol) 协议</h5><p>​    SOAP (abbreviation for <strong>Simple Object Access Protocol</strong>) is a messaging <a href="https://en.wikipedia.org/wiki/Protocol_(computing" target="_blank" rel="noopener">protocol</a>) specification for exchanging structured information in the implementation of <a href="https://en.wikipedia.org/wiki/Web_service" target="_blank" rel="noopener">web services</a> in <a href="https://en.wikipedia.org/wiki/Computer_network" target="_blank" rel="noopener">computer networks</a>. Its purpose is to provide <a href="https://en.wikipedia.org/wiki/Extensibility" target="_blank" rel="noopener">extensibility</a>, <a href="https://en.wikipedia.org/wiki/Neutrality_(philosophy" target="_blank" rel="noopener">neutrality</a>) and independence. It uses <a href="https://en.wikipedia.org/wiki/XML_Information_Set" target="_blank" rel="noopener">XML Information Set</a> for its <a href="https://en.wikipedia.org/wiki/Message_format" target="_blank" rel="noopener">message format</a>, and relies on <a href="https://en.wikipedia.org/wiki/Application_layer" target="_blank" rel="noopener">application layer</a> protocols, most often <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">Hypertext Transfer Protocol</a> (HTTP) or <a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol" target="_blank" rel="noopener">Simple Mail Transfer Protocol</a> (SMTP), for message negotiation and transmission.</p><p>​    对于java远程调用而言，并不是一个令人信服的选择，因为它对方法参数有诸多限制，部署也相当麻烦。</p><pre><code>A WSDL is an XML document that describes a web service. It actually stands for Web Services Description Language.SOAP is an XML-based protocol that lets you exchange info over a particular protocol (can be HTTP or SMTP, for example) between applications. It stands for Simple Object Access Protocol and uses XML for its messaging format to relay the information.REST is an architectural style of networked systems and stands for Representational State Transfer. It&#39;s not a standard itself, but does use standards such as HTTP, URL, XML, etc.</code></pre><p>Ws相关子协议</p><p>​    JAX-RPC</p><p>​    EJB端点JSR-109 J2ee 1.4</p><h4 id="轻量级远程方案（平台无关调用）"><a href="#轻量级远程方案（平台无关调用）" class="headerlink" title="轻量级远程方案（平台无关调用）"></a>轻量级远程方案（平台无关调用）</h4><p>RMI环境配置相当麻烦，并且它使用的网络端口常常被防火墙禁止。</p><p>基于WSDL和SOAP 的web services又很难以一种==可移植==的方式导出，并且它们的协议臃肿冗长，会浪费大量带宽。</p><p>基于HTTP的轻量级远程调用协议（lightweight HTTP-based remotion protocol）解决了上述两个问题：它们可以在任何标准的servlet容器之上运行，并且可以穿越任何防火墙。</p><p>基于HTTP的远程服务有一个特别的好处：它们可以很轻松地利用web服务器提供的权限管理、加密、压缩等能力—可以要求对特定的资源访问进行身份认证，可以使用SSL传输，可以对HTTP应答进行GZIP压缩，等等。</p><p>Hessian/burlap 比ws效率高 </p><p>Hessian ：二进制，简约、效率高</p><p>burlap的优点在于：基于XML，它传输的消息可以被人读懂，也可以被XML解析器解析。</p><p>relationships between http and servlet</p><pre><code>A servlet is a &#39;module&#39; that can be integrated into a server application to respond to client requests. Although a servlet need not use a specific protocol, we will use the HTTP protocol for communication (see figure 21.1). In practice, the term servlet refers to an HTTP servlet.The classic method of constructing dynamic HTML pages on a server is to use CGI (Common Gateway Interface) commands. These take as argument a URL which can contain data coming from an HTML form. The execution then produces a new HTML page which is sent to the client. The following links describe the HTTP and CGI protocols.</code></pre><p>Link : <a href="https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora196.html" target="_blank" rel="noopener">https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora196.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> j2ee </tag>
            
            <tag> ejb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Expert One-on-One J2EE Design and Development</title>
      <link href="/2019/03/10/Note_Expert-One-on-One-J2EE-Design-and-Development/"/>
      <url>/2019/03/10/Note_Expert-One-on-One-J2EE-Design-and-Development/</url>
      
        <content type="html"><![CDATA[<p>​    j2ee的相关历史，spring的诞生背景，理念，重点章节。 4（Design and Standards）、9（data access）、11（Infrastructure）、12-13（web Tier）</p><a id="more"></a><p>有点乱，待整理思路</p><ul><li>4 Design Techniques and Coding<br>  Standards for J2EE Projects</li><li><p>9 Practical Data Access</p></li><li><p>11 Infrastructure and Application Implementation </p></li><li><p>12 Web-Tier MVC Design</p></li><li><p>13 Views in the Web Tier</p></li></ul><h3 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h3><p>J2EE Architectures</p><p>Summary </p><ul><li><p>体系分层</p><p>  ​    EIS层 企业信息系统层 数据访问层？ dao层</p><p>  ​    中间层 业务对象 bizservice</p><p>  ​    用户接口层UI层 web层</p><p>  ​    web 层</p><p>  ​        模型 vo?  Model-&gt; json</p><p>  ​        视图  html   ui框架jsp 渲染引擎？-&gt;前端控制</p><p>  ​        控制器 不应该有业务逻辑  负责转发 struct—&gt;controller</p><p>  ​    控制流程是一种 command的设计模式</p></li></ul><pre><code>可移植性？通过使用一个抽象层（Abstraction layer），可以利用松耦合把该应用的奇遇部分与必须用一种平台特有方式来实现的任何部分隔离开。抽象层指一个其本身就独立于平台的接口。​    spi的思想、 插拔式</code></pre><h3 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h3><p>选择一个应用服务器标准 </p><p>​    得到支持的规范</p><p>​    sun资源 CTS  ECPerf </p><p>​    成本</p><p>​    开发与部署</p><p>​        启动速度 部署速度 内存需求</p><p>​        额外步骤。编写部署描述符？</p><p>​        热部署的能力</p><p>​        服务器所提供的管理工具的完善度</p><p>​        SNMP（Simple Network Management Protocol）和JMX的管理标准集成度</p><p>​        运行时候错误报告的质量    </p><p>​    文档质量</p><p>​    可移植性的含义</p><p>​        应用在应用服务器之间的可以移植性</p><p>​        应用在服务器操作系统之间的可移植性</p><p>​        更改J2EE应用所依赖的重要资源的能力 数据库切换？</p><p>​    发布管理 指：保证一个应用发布从‘开发’ 、‘测试’到‘生产’到发展是可逆和可重复的</p><h3 id="Chapter3"><a href="#Chapter3" class="headerlink" title="Chapter3"></a>Chapter3</h3><p>​    单元测试的重要性</p><h3 id="Chapter4-J2EE项目的实际技术与编程标准"><a href="#Chapter4-J2EE项目的实际技术与编程标准" class="headerlink" title="Chapter4    J2EE项目的实际技术与编程标准"></a>Chapter4    J2EE项目的实际技术与编程标准</h3><p>​    J2EE应用的OO设计推荐标准</p><ul><li><p>利用接口来实现松耦合</p></li><li><p>首选对象合成而非具体继承性</p></li><li><p>Template Method设计模式  将特定步骤留给子类实现</p></li><li><p>Strategy  将特定步骤抽成一个接口。在具体继承性和接口委托之间进行折衷的例子</p></li><li><p>使用回调来实现可扩展 这是Strategy设计模式的一种特殊模式</p></li></ul><p>​            jdbcTemplate</p><p>​                query(String sql,RowCallBackHandler callbackHandler)</p><p>​                public interface RowCallBackHandler{<br>​                        void processRow(ResultSet rs) throws SQLException</p><p>​                }</p><ul><li>Observer设计模式。实现关系分离 </li></ul><p>​                例如处理登陆的对象为什么需要知道管理员的电子邮件地址、或者说如何发送邮件</p><p>​                核心职责被淹没在特性中</p><p>​                publisher-&gt;events-&gt;Observer</p><ul><li><p>考虑合并方法参数 Command</p></li><li><p>异常处理-已检查或未检查异常</p></li></ul><p>​            使用已检查异常会特有引起几个问题：</p><p>​                太多代码</p><p>​                难以读懂的代码</p><p>​                异常的无止休封装</p><p>​            一个异常相当于来自方法的一个可替代返回值的地方</p><p>​            已检查异常要比错误返回码好得多    </p><p>​            如果调用代码能够对该异常做些切合实际的事情可以使用，否则使用未检查异常RuntimeException，选择是否捕捉，依赖应用服务器容器来捕捉.（而不是jvm）    </p><p>​            对异常进行详细描写</p><ul><li><p>使用反射 Factory</p><p>  误解 </p><p>  ​        使用反射的代码是慢的 </p><p>  ​        过分复杂</p><p>  ​    如果使用得当，反射不会降低性能。正确使用反射实际哈桑应该改进代码可维护性。</p><p>  ​    反射的直接使用应该仅局限于基础结构类。</p></li><li><p>使用Java组件来实现灵活性</p></li><li><p>使用应用组册表来实现单例 Singleton Prototype Factory</p><p>  ​    支持接口</p><p>  ​    普通javabean</p><p>  ​    配置源上下文统一管理</p><p>  ​    为什么不适用jndi ? 复杂 单一</p></li></ul><p>编程规范</p><p>​    一个方法只应有一项明确的责任，而且所有操作都应该在同一个抽象级别上</p><p>​    避免代码重复</p><p>​    避免字面常量</p><p>​    可见度和作用范围尽可能小</p><p>​    内部类和接口 避免空间污染 </p><p>​    使用final关键字</p><p>​        开放式封闭原理：对扩展开放，对修改封闭。覆盖具体方法实际上是修改。</p><p>​        和抽象方法联合使用，保护超类的完整性。</p><p>​    使用界定符</p><p>实现一个框架</p><p>​    向现有框架学习</p><p>​    明确目标 、作用范围、 用最小复杂性来实现最大价值 </p><p>​        Pareto Principle（2/8原则） 某个特定功能很难实现，问问自己是不是必不可少的，能不能实现其价值的大部分</p><h3 id="Chapter-5-Chapter-9"><a href="#Chapter-5-Chapter-9" class="headerlink" title="Chapter 5-Chapter 9"></a>Chapter 5-Chapter 9</h3><h4 id="Chpter-6"><a href="#Chpter-6" class="headerlink" title="Chpter 6"></a>Chpter 6</h4><p>高速缓存，减少没必要的调用和消耗</p><p>DATA ACCESS</p><p>DB mysql自身</p><p>DB组件 hibernate缓存</p><p>应用层</p><p>​    分布式缓存 redis  </p><p>​    单机jvm缓存 map  guava cache  </p><p>HTTP 304</p><h4 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h4><p>​    RDBMS 与 ODBMS</p><p>​    范式化数据 消除数据冗余度</p><p>​    O/R 映射 尝试将Java对象的状态映射到RDMBMS上</p><p>​    用于OLTP，不适用于OLAP</p><h4 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h4><p>​    关于Session Beans 和 Entity Beans的讨论</p><p>​    实体组件 分布式、共享的、事务性、持久性对象</p><p>​    Entity Bean 是一种糟糕的设计 ，不应该绑定在EJB容器上，应该交由专用的方案解决</p><p>​    无法继承，不具备java对象</p><h4 id="Chapter-9-实际数据存取"><a href="#Chapter-9-实际数据存取" class="headerlink" title="Chapter 9 实际数据存取"></a>Chapter 9 实际数据存取</h4><p>JDBCTemplete</p><p>​    较高级的抽象 RDBMS建模为Java对象</p><h3 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="==Chapter 11=="></a>==Chapter 11==</h3><h5 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h5><p>​    Without such infrastructure, configuration management is usually haphazard. J2EE applications often hold configuration in a variety of formats, such as properties files, XML documents (an increasingly popular choice), EJB JAR and WAR development descriptors, and database tables. </p><p>​    没有这样的基础设施，配置管理通常是随意的。 J2EE应用程序通常以各种格式进行配置，例如属性文件，XML文档（越来越流行的选择），EJB JAR和WAR开发描述符以及数据库表。</p><p>More seriously, application classes are bloated by configuration management code irrelevant to business responsibilities</p><p>应用程序类因与业务职责无关的配置管理代码而膨胀。</p><p>Equally harmfully, without a central infrastructure for configuration management, application code is to<br>likely to use variety to approaches to locating application objects. The Singleton design pattern is often<br>overused, resulting in problems we’ll discuss below. Alternatively, some application objects may be bound<br>to JNDI or attached to the global ServletContext (in web applications), both of which approaches<br>may complicate testing outside a JNDI server. Each application object is usually reconfigured<br>independently.</p><p>​    通过各种方式去获取配置。每个应用程序对象通常都是独立重新配置的。</p><h5 id="Using-a-Framework-to-Configure-Application-Components"><a href="#Using-a-Framework-to-Configure-Application-Components" class="headerlink" title="Using a Framework to Configure Application Components"></a>Using a Framework to Configure Application Components</h5><p>外部化配置和OO设计</p><p>使用javaBean beanWapper</p><h6 id="Using-JavaBeans"><a href="#Using-JavaBeans" class="headerlink" title="Using JavaBeans"></a>Using JavaBeans</h6><p>​    If we make all application components JavaBeans, we maximize our ability to separate </p><p>configuration data from application code </p><p>​    However, manipulating beans is more complex, and requires the use of<br>reflection to instantiate objects and invoke methods by name. The core JavaBeans API does not provide<br>the ability to perform some useful operations on beans, such as</p><p>why ？</p><p>​    This provides the ability to manipulate beanseasily and adds the enhanced functionality described above, while respecting andavoiding duplicating the standard JavaBeans infrastructure.(andavoiding避免)</p><h6 id="Using-a-“Bean-Factory”"><a href="#Using-a-“Bean-Factory”" class="headerlink" title="Using a “Bean Factory”"></a>Using a “Bean Factory”</h6><p>why?</p><p>​    The com.interface21.beans.factory package defines a way of obtaining beans by<br>name from a central configuration repository using a “bean factory”. ==The goal of a bean==<br>==factory is to remove any need for individual Java objects to read configuration properties==<br>==or instantiate objects. Instead, configuration is read by a central component, the bean==<br>==factory, and the bean properties exposed by each application object are set to reflect==<br>configuration data.== The factory then makes available instances of beans, each with a<br>unique name. Sophisticated object graphs can be created within the bean factory, as<br>managed beans may reference other beans within the same factory.</p><p>对外暴露BeanWapper</p><h6 id="Application-Context-Goals"><a href="#Application-Context-Goals" class="headerlink" title="Application Context Goals"></a>Application Context Goals</h6><p>​    Building on the bean factory, an application context provides a namespace for the JavaBeans that compose an application or subsystem, and the ability to share working objects at run time. The com.interface21.context.ApplicationContext interface extends the ListableBeanFact interface, adding the ability to: </p><p>o Publish events using the Observer design pattern. As we discussed in Chapter 4, the Observer design pattern provides the ability to decouple application components and achieve clean separation of concerns. </p><p>o Participate in a hierarchy of application contexts. Application contexts can have parent contexts, allowing developers to choose the amount of configuration shared between subsystems. </p><p>o Share working objects between application components at run time. </p><p>o Look up messages by string name, allowing support for internationalization. </p><p>o Facilitate testing. With an application context, as well as a bean factory, it’s often possible to provide a test implementation that enables application code to be tested outside an application server. </p><p>o Provide consistent configuration management in different types of applications. Application contexts behave the same way in different kinds of applications, such as Swing GUI applications or web applications, and inside and outside a J2EE application server. </p><p>web层 （不是本周重点）</p><p>性能框架测试（不是本周重点）</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> j2ee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-Core-Container预览</title>
      <link href="/2019/03/03/spring-Core-Container%E9%A2%84%E8%A7%88/"/>
      <url>/2019/03/03/spring-Core-Container%E9%A2%84%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>阅读的目的？我想要从中获得什么？</p><p>​    spring按模块总结 ，ioc和aop是spring的核心</p><a id="more"></a><!-- toc --><h2 id="IoC-container-IoC-容器"><a href="#IoC-container-IoC-容器" class="headerlink" title="IoC container(IoC 容器)"></a>IoC container(IoC 容器)</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>​    思考如下问题</p><ul><li><p>​    首先了解为啥需要这个模块？</p></li><li><p>​    它是啥，这个模块都有啥？</p></li><li><p>​    根据什么来的，实现了哪些规范？</p></li></ul><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><h5 id="从-‘依赖反转’-到-‘依赖注入’"><a href="#从-‘依赖反转’-到-‘依赖注入’" class="headerlink" title="从 ‘依赖反转’ 到 ‘依赖注入’"></a>从 ‘依赖反转’ 到 ‘依赖注入’</h5><pre><code>    In early 2004, Martin Fowler asked the readers of his site: when talking about Inversion of Control: “the question is, what aspect of control are [they] inverting?”</code></pre><p>​    2004年，Martin Fowler 对依赖反转 提出了问题，并获得结论，依赖对象的获得被反转了，基于这个结论提出了个更好的名字，依赖注入。如果对象的引用或依赖关系的管理由具体对象来完成，会导致代码高度耦合和可测试性的降低。</p><h5 id="从-‘对象-对象’-到-‘对象-IOC容器-对象’"><a href="#从-‘对象-对象’-到-‘对象-IOC容器-对象’" class="headerlink" title="从 ‘对象-对象’ 到 ‘对象-IOC容器-对象’"></a>从 ‘对象-对象’ 到 ‘对象-IOC容器-对象’</h5><p>​    依赖反转是一种设计模式，实现有很多种方式，ioc容器式实现这个模式的载体，管理对象，对象之间的关系</p><h5 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h5><p>​    数据对象<br>​    数据处理对象 不常发生变化，是系统中基础的部分，不涉及数据和状态共享的问题，依赖关系比较稳定，单例</p><p>存在于应用系统，但是对象的管理交给了容器（平台）</p><h5 id="与EJB的关系、对比"><a href="#与EJB的关系、对比" class="headerlink" title="与EJB的关系、对比"></a>与EJB的关系、对比</h5><p>​    一方面，spring，ioc提供了一个基本的JavaBean容器，通过Ioc模式管理依赖关系，并通过依赖注入和AOP切面增强了<br>​    为JavaBean这样的POJO对象赋予事务管理、生命周期管理等基本功能；为防止注入异常，嗨提供特定依赖的检查。</p><p>​    EJB组件需要编写远程/本地接口、Home接口以及Bean的实现类，需要依赖EJB容器 JBOSS，查找其他EJB组件也需要通过诸如JNDI这样的方式，从而造成了对EJB容器和技术规范的依赖。</p><p>​    spring把EJB组件还原成了POJO对象或者JavaBean对象，降低了应用开发对传统J2EE技术规范的依赖。<br>但是因为封装、抽象的太好了，反而让J2EE的初学者忽略了相关规范</p><p>​    另一方面，通过可读的文本来完成配置，并且还能通过工具对这些配置信息进行可视化管理和浏览。并且如果耦合关系需要变动，并不需要重新修改和编译Java源代码，符合面向对象设计原则的开闭原则。如果结合OSGI还能提高应用的动态部署能力            </p><h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><h5 id="依赖查找-Dependency-Lookup"><a href="#依赖查找-Dependency-Lookup" class="headerlink" title="依赖查找(Dependency Lookup)"></a>依赖查找(Dependency Lookup)</h5><p>​    ID、别名、名称查找<br>​        BeanFactory#getBean(String) : Object </p><p>​    类型查找<br>​        BeanFactory#getBean(Class) : T </p><p>​    注解查找<br>​        ListableBeanFactory#getBeansWithAnnotation(Class) </p><p>​    FactoryBean 查找<br>​        FactoryBean#getObject() </p><p>​    ObjectFactory 查找<br>​              ObjectFactory#getObject()</p><h5 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入(Dependency Injection)"></a>依赖注入(Dependency Injection)</h5><p>​    方法<br>​        Spring @Autowired </p><p>​        Java @Resource </p><p>​        Java EE @Inject<br>​    注入方式  </p><p>​        接口、setter、构造器</p><p>spring官方更推荐使用构造器的方式</p><pre><code>    The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not null. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</code></pre><p>在Ex中</p><p>Type2 构造子注入的优势:  (注意循环依赖的问题)</p><ol><li><p>“在构造期即创建一个完整、合法的对象”，对于这条Java设计原则，Type2无疑是最好的 </p><p> 响应者。 </p></li><li><p>避免了繁琐的setter方法的编写，所有依赖关系均在构造函数中设定，依赖关系集中呈现， </p><p> 更加易读。 </p></li><li><p>由于没有setter方法，依赖关系在构造时由容器一次性设定，因此组件在被创建之后即处于 </p><p> 相对“不变”的稳定状态，无需担心上层代码在调用过程中执行setter方法对组件依赖关系 </p><p> 产生破坏，特别是对于Singleton模式的组件而言，这可能对整个系统产生重大的影响。 </p></li><li><p>同样，由于关联关系仅在构造函数中表达，只有组件创建者需要关心组件内部的依赖关系。 </p><p> 对调用者而言，组件中的依赖关系处于黑盒之中。对上层屏蔽不必要的信息，也为系统的 </p><p> 层次清晰性提供了保证。 </p></li><li><p>通过构造子注入，意味着我们可以在构造函数中决定依赖关系的注入顺序，对于一个大量 </p><p> 依赖外部服务的组件而言，依赖关系的获得顺序可能非常重要，比如某个依赖关系注入的 先决条件是组件的DataSource及相关资源已经被设定。 </p></li></ol><p>Type3 设值注入的优势 </p><ol><li><p>对于习惯了传统JavaBean开发的程序员而言，通过setter方法设定依赖关系显得更加直 </p><p> 观，更加自然。 </p></li><li><p>如果依赖关系(或继承关系)较为复杂，那么Type2模式的构造函数也会相当庞大(我们需 </p><p> 要在构造函数中设定所有依赖关系)，此时Type3模式往往更为简洁。 </p></li><li><p>对于某些第三方类库而言，可能要求我们的组件必须提供一个默认的构造函数(如Struts </p><p> 中的Action)，此时Type2类型的依赖注入机制就体现出其局限性，难以完成我们期望的功能。</p></li></ol><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>​    官方网站提过：</p><pre><code>    At the heart are the modules of the core container, including a configuration model and a dependency injection mechanism. </code></pre><p>​    从之前的module图可以知道有如下四部分。</p><p>​    <img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4g8j0nhmej30ys0683za.jpg" alt="image-20190628013800037"></p><h4 id="从Beans说起"><a href="#从Beans说起" class="headerlink" title="从Beans说起"></a>从Beans说起</h4><p>​    Spring 就是面向 Bean 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，没有对象的概念就像没有面向对象编程，Spring 中没有 Bean 也就没有 Spring 存在的意义</p><p>​    这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析</p><h5 id="Bean-的创建"><a href="#Bean-的创建" class="headerlink" title="Bean 的创建"></a>Bean 的创建</h5><p>​    Spring Bean 的创建时典型的工厂模式，它的顶级接口是 <code>BeanFactory</code></p><p>​    <code>BeanFactory</code> 有三个子类：</p><p>​        <code>ListableBeanFactory</code> 接口 ：表示这些 Bean 是可列表的</p><p>​        <code>HierarchicalBeanFactory</code>  ：表示的这些 Bean 是有继承关系的，有父bean</p><p>​        <code>AutowireCapableBeanFactory</code> ：接口定义 Bean 的自动装配规则</p><p>​    上述的接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为，它们的默认实现类是 <code>DefaultListableBeanFactory</code></p><p>​    todo ==DefaultListableBeanFactory的子类分析==</p><h5 id="Bean-的定义"><a href="#Bean-的定义" class="headerlink" title="Bean 的定义"></a>Bean 的定义</h5><p>​    Bean 的定义主要有 BeanDefinition 描述，主要来自两方面</p><p>​        XML定义，</p><p>​        注解扫描 @Service @Entity @Bean @Configuration</p><h5 id="Bean-的解析"><a href="#Bean-的解析" class="headerlink" title="Bean 的解析"></a>Bean 的解析</h5><p>​    把xml解析成Resource类            </p><p>​    todo ==Resource的类分析==</p><p>##### </p><h5 id="Spring-Bean-封装机制"><a href="#Spring-Bean-封装机制" class="headerlink" title="Spring Bean 封装机制"></a>Spring Bean 封装机制</h5><p>​    Spring 从核心而言，是一个 DI 容器，其设计哲学是提供一种无侵入式的高扩展性框架。即无需代码中涉及 Spring 专有类（指Bean），即可将其纳入 Spring 容器进行管理。 </p><p>​    作为对比，EJB 则是一种高度侵入性的框架规范，它制定了众多的接口和编码规范，要求实现者必须 遵从。侵入性的后果就是，一旦系统基于侵入性框架设计开发，那么之后任何脱离这个框架的企图都将付 出极大的代价。 </p><p>​    Spring 大量引入了 Java 的 Reflection 机制，通过动态 调用的方式避免硬编码方式的约束，并在此基础上建立了其核心组件 BeanFactory，以此作为其依赖注入 机制的实现基础。 </p><p>org.springframework.beans 包中包括了这些核心组件的实现类，核心中的核心为 BeanWrapper<br>和 BeanFactory 类。</p><h6 id="BeanWrapper"><a href="#BeanWrapper" class="headerlink" title="BeanWrapper"></a>BeanWrapper</h6><p>​    这个BeanWrapper的功能很简单，提供一个设置JavaBean属性的通用方法， 动态设置一个对象属性</p><h5 id="Bean-Factory"><a href="#Bean-Factory" class="headerlink" title="Bean Factory"></a>Bean Factory</h5><p>​    负责创建并维护Bean实例。 </p><p>Bean Factory负责根据配置文件创建Bean实例，可以配置的项目有:</p><ol><li>Bean属性值及依赖关系(对其他Bean的引用)  property</li><li>Bean创建模式(是否Singleton模式，即是否只针对指定类维持全局唯一的实例)  singleton</li><li>Bean初始化和销毁方法  init-method  destroy-method</li><li>Bean的依赖关系。 depends-on（通过depends-on指定其依赖关系可保证在此Bean加载之前，首先对depends-on所指定的资源进行加载）</li></ol><h4 id="容器Context"><a href="#容器Context" class="headerlink" title="容器Context"></a>容器Context</h4><p>​    BeanFactory提供了针对Java Bean的管理功能，而ApplicationContext提供了一个更为框架化的 实现(从上面的示例中可以看出，BeanFactory的使用方式更加类似一个API，而非Framework style)。 </p><p>​    ApplicationContext覆盖了BeanFactory的所有功能，并提供了更多的特性。此外， ApplicationContext为与现有应用框架相整合，提供了更为开放式的实现(如对于Web应用，我们可以在 web.xml中对ApplicationContext进行配置)。 </p><p>​    ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。下面是 Context 的类结构图</p><p><img src="http://ww3.sinaimg.cn/large/006tKfTcgy1g0prh3oklzj31tk0qq781.jpg" alt="image-20190303180157960"></p><p>相对BeanFactory而言，ApplicationContext提供了以下扩展功能: </p><ol><li>国际化支持 我们可以在Beans.xml文件中，对程序中的语言信息(如提示信息)进行定义，将程序中的提示 信息抽取到配置文件中加以定义，为我们进行应用的各语言版本转换提供了极大的灵活性。 </li></ol><pre><code>（native2ascii messages_zh_CN.properties msg.txt）</code></pre><ol start="2"><li>资源访问 支持对文件和URL的访问。 </li><li>事件传播 事件传播特性为系统中状态改变时的检测提供了良好支持。 </li><li>多实例加载 可以在同一个应用中加载多个Context实例。 </li></ol><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><p>​    其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具，从这个角度看来，Core 这个组件叫 Util 更能让你理解。</p><p>下图是 Resource 相关的类结构图：</p><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1g0prtjnknbj31wk0rkgp4.jpg" alt="image-20190303181354519"></p><p>​    从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。</p><p>​    对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。</p><p>​    另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。</p><h4 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a><del>SpEL</del></h4><p><strong>如何创建 BeanFactory 工厂</strong></p><p><strong>如何创建 Bean 实例并构建 Bean 的关系网</strong></p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>实现了哪些规范？</p><h4 id="Java-Beans-JSR—101"><a href="#Java-Beans-JSR—101" class="headerlink" title="Java Beans  JSR—101"></a>Java Beans  JSR—101</h4><p>内省</p><p>​            基础核心特性:反射(Reflection) </p><p>​            附加特性:引用(Reference)<br>​                Reference<br>​                                SoftReference<br>​                                WeakReference<br>​                                PhantomReference<br>​                                FinalReference<br>​                       BeanInfo<br>​                               BeanDescriptor<br>​                      PropertyDescriptor<br>​                            事件: PropertyChangeEvent<br>​                                java.util.EventObject </p><p>​                            监听器: PropertyChangeListener<br>​                                             java.util.EventListener<br>​                              MethodDescriptor</p><h4 id="Dependency-Injection-JSR-330"><a href="#Dependency-Injection-JSR-330" class="headerlink" title="Dependency Injection (JSR 330)"></a>Dependency Injection (<a href="https://www.jcp.org/en/jsr/detail?id=330" target="_blank" rel="noopener">JSR 330</a>)</h4><h4 id="Bean-Validation-JSR-303-JSR-349-JSR-380-1-0-1-1-2-0"><a href="#Bean-Validation-JSR-303-JSR-349-JSR-380-1-0-1-1-2-0" class="headerlink" title="Bean Validation (JSR 303). JSR-349  JSR-380 1.0 1.1 2.0"></a>Bean Validation (<a href="https://jcp.org/en/jsr/detail?id=303" target="_blank" rel="noopener">JSR 303</a>). JSR-349  JSR-380 1.0 1.1 2.0</h4><h4 id="Common-Annotations-JSR-250"><a href="#Common-Annotations-JSR-250" class="headerlink" title="Common Annotations (JSR 250)"></a>Common Annotations (<a href="https://jcp.org/en/jsr/detail?id=250" target="_blank" rel="noopener">JSR 250</a>)</h4><h4 id="JSR-305-meta-annotations"><a href="#JSR-305-meta-annotations" class="headerlink" title="JSR-305 meta-annotations"></a>JSR-305 meta-annotations</h4><h3 id="API-Doc"><a href="#API-Doc" class="headerlink" title="API-Doc"></a>API-Doc</h3><hr><p><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/</a></p><h4 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h4><p>Package org.springframework.beans Description</p><p>This package contains interfaces and classes for manipulating Java beans. It is used by most other Spring packages.</p><p>A BeanWrapper object may be used to set and get bean properties, singly or in bulk.</p><p>The classes in this package are discussed in Chapter 11 of <a href="https://www.amazon.com/exec/obidos/tg/detail/-/0764543857/" target="_blank" rel="noopener">Expert One-On-One J2EE Design and Development</a> by Rod Johnson (Wrox, 2002).</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>Package org.springframework.context Description</p><p>This package builds on the beans package to add support for message sources and for the Observer design pattern, and the ability for application objects to obtain resources using a consistent API.</p><p>There is no necessity for Spring applications to depend on ApplicationContext or even BeanFactory functionality explicitly. One of the strengths of the Spring architecture is that application objects can often be configured without any dependency on Spring-specific APIs.</p><h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p>Package org.springframework.core Description</p><p>Provides basic classes for exception handling and version detection, and other core helpers that are not specific to any part of the framework.</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview-Spring</title>
      <link href="/2019/03/02/Overview_Spring/"/>
      <url>/2019/03/02/Overview_Spring/</url>
      
        <content type="html"><![CDATA[<p>Spring资料</p><p>​    <a href="https://en.wikipedia.org/wiki/Spring_Framework" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Spring_Framework</a></p><p>​    <a href="https://docs.spring.io/spring/docs/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/</a></p><p>Spring 系列文章</p><ul><li><a href="https://zyumin.github.io/2019/12/05/spring-BeanFactory/" target="_blank" rel="noopener">Spring-BeanFactory</a></li><li><a href="https://zyumin.github.io/2020/01/16/Spring-ApplicationContext/" target="_blank" rel="noopener">Spring-ApplicationContext</a></li><li><a href="https://zyumin.github.io/2019/02/03/spring-mvc/" target="_blank" rel="noopener">Spring-MVC</a></li><li><a href="https://zyumin.github.io/2020/01/23/spring-aop/" target="_blank" rel="noopener">Spring-AOP</a></li></ul><h2 id="Spring理念"><a href="#Spring理念" class="headerlink" title="Spring理念"></a>Spring理念</h2><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy</a> </p><p><strong>Design Philosophy</strong></p><p>When you learn about a framework, it’s important to know not only what it does but what principles it follows. Here are the guiding principles of the Spring Framework:</p><ul><li>Provide choice at every level. Spring lets you defer design decisions as late as possible. For example, you can switch persistence providers through configuration without changing your code. The same is true for many other infrastructure concerns and integration with third-party APIs.</li><li>Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about how things should be done. It supports a wide range of application needs with different perspectives.</li><li>Maintain strong backward compatibility. Spring’s evolution has been carefully managed to force few breaking changes between versions. Spring supports a carefully chosen range of JDK versions and third-party libraries to facilitate maintenance of applications and libraries that depend on Spring.</li><li>Care about API design. The Spring team puts a lot of thought and time into making APIs that are intuitive and that hold up across many versions and many years.</li><li>Set high standards for code quality. The Spring Framework puts a strong emphasis on meaningful, current, and accurate javadoc. It is one of very few projects that can claim clean code structure with no circular dependencies between packages.</li></ul><h2 id="Spring-Framework-Module"><a href="#Spring-Framework-Module" class="headerlink" title="Spring Framework Module"></a>Spring Framework Module</h2><p>Show a picture (从spring 4.3.x中扒的，因为spring5的找不到这个module图了)</p><p><a href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/overview.html#overview-modules" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/overview.html#overview-modules</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb7itsonujj31320rk0y2.jpg" alt="image-20200124120638018"></p><h2 id="Spring-发展史"><a href="#Spring-发展史" class="headerlink" title="Spring 发展史"></a>Spring 发展史</h2><p> 下面讲spring分成几个阶段</p><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><h4 id="开端-J2EE"><a href="#开端-J2EE" class="headerlink" title="开端 J2EE"></a>开端 J2EE</h4><p><strong>j2ee存在的问题</strong></p><p>​        applications are often slow, unduly complex, and take too long to develop.Rod Johnson believes that the problem lies not in J2EE itself, but in that it is often used badly(使用问题)</p><p>​    2002-10 Rod Johnson 写了 Expert One-on-One J2EE Design and Development </p><p>​    在这 本书中 讲解了何时使用EJB（需要分布式事务和消息的时候使用） 以及J2EE走向何方，写了interface21包 来简化J2EE的开发，提出了using a Framework to Configure Application Components ，</p><p>用 javaBeans、 BeanFactory、applictionContext (简化、参考ejb)来简化J2EE开发， </p><p>以及如何简化EJB的使用 ，通过抽象EJB的 Bean，将使用EJB的代码与依赖JNDI和EJB API的代码分离。</p><p>​    同年， 开源了interface21， 并改名为 spring</p><p>​    2003 年6月  发布 spring0.9</p><p>​    2004-3 发布 spring 1.0 XML Bean Definitions</p><p>​               Spring MVC</p><p>​               spring 1.2    支持注解，要求jdk1.5</p><p>​                粘合剂     把Struts,Hibernate等黏合到一起，史称SSH。 </p><h4 id="繁琐的EJB"><a href="#繁琐的EJB" class="headerlink" title="繁琐的EJB"></a>繁琐的EJB</h4><p>​        In early 2004, Martin Fowler asked the readers of his site: when talking about Inversion of Control: “the question is, what aspect of control are [they] inverting?”</p><p>​    Inversion of Control / Dependency Injection </p><p>​    2004-6 Rod Johnson等写了 J2EE Development without EJB（讨论了我们真正需要EJB的什么，如何同样实现这些功能, 我们曾经在无数的书籍和文章中看到，EJB是J2EE的核心技术之一，EJB太繁琐，约束太多，依赖EJB容器，轻量级j2ee）</p><p>​    2005-7  Professional Java Development with the Spring Framework</p><p>​    </p><h4 id="注解时代"><a href="#注解时代" class="headerlink" title="注解时代"></a>注解时代</h4><p>​        基于注解的依赖注入和组件扫描 @Autowise @Configurable</p><p>​    2006年发布 Spring 2.0 </p><p>​        Ruby on Rails的框架突然崛起，约定重于配置，Don’t repeat yourself的思想随着RoR深入人心。</p><p>​    2007年发布 Spring 2.5 。</p><p>​    2009年Spring 3.0 注解的进一步完善, RESTful的支持</p><p>​    </p><h4 id="配置简化"><a href="#配置简化" class="headerlink" title="配置简化"></a>配置简化</h4><p>​        xml配置繁琐，自动装配springboot， 微服务等兴起 </p><p>​    2013年12月 Spring4.0 支持jdk8</p><p>​    2014  Spring Boot 约定大于配置</p><p>​    2015 Spring Cloud</p><h4 id="反应式编程"><a href="#反应式编程" class="headerlink" title="反应式编程"></a>反应式编程</h4><p>​    解决了什么问题？为什么需要？</p><p>​        高并发，IO密集型应用，同步阻塞的模型，受连接池等约束，反应式编程 reactive stream</p><p>​    2017年9月     Spring 5.0  WebFlux</p><h3 id="版本特征"><a href="#版本特征" class="headerlink" title="版本特征"></a>版本特征</h3><table><thead><tr><th>Version</th><th>Date</th><th>Notes</th></tr></thead><tbody><tr><td>0.9</td><td>2002</td><td></td></tr><tr><td>1.0</td><td>2003</td><td></td></tr><tr><td>2.0</td><td>2006</td><td></td></tr><tr><td>3.0</td><td>2009</td><td></td></tr><tr><td>4.0</td><td>2013</td><td></td></tr><tr><td>5.0</td><td>2017</td></tr></tbody></table><blockquote><p>​    The first version was written by <a href="https://en.wikipedia.org/wiki/Rod_Johnson_(programmer" target="_blank" rel="noopener">Rod Johnson</a>), who released the framework with the publication of his book <em>Expert One-on-One J2EE Design and Development</em> in October 2002. </p><p>The framework was first released under the <a href="https://en.wikipedia.org/wiki/Apache_License" target="_blank" rel="noopener">Apache 2.0 license</a> in June 2003. </p><p>The first milestone release, 1.0, was released in March 2004 with further milestone releases in September 2004 and March 2005. </p><p>The Spring 1.2.6 framework won a <a href="https://en.wikipedia.org/wiki/Jolt_Awards" target="_blank" rel="noopener">Jolt productivity award</a> and a <a href="https://en.wikipedia.org/w/index.php?title=JAX_Innovation_Award&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">JAX (Java API for XML) Innovation Award</a> in 2006.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-2" target="_blank" rel="noopener">[2]</a><a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-3" target="_blank" rel="noopener">[3]</a> </p><p>Spring 2.0 was released in October 2006, </p><p>Spring 2.5 in November 2007, </p><p>Spring 3.0 in December 2009, </p><p>Spring 3.1 in December 2011, and Spring 3.2.5 in November 2013.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-4" target="_blank" rel="noopener">[4]</a> </p><p>Spring Framework 4.0 was released in December 2013.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-5" target="_blank" rel="noopener">[5]</a> </p><p>Notable improvements in Spring 4.0 included support for Java SE (Standard Edition) 8, <a href="https://en.wikipedia.org/wiki/Groovy_(programming_language" target="_blank" rel="noopener">Groovy</a>) 2, some aspects of Java EE 7, and <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>.</p><p>Spring Framework 4.2.0 was released on 31 July 2015 and was immediately upgraded to version 4.2.1, which was released on 01 Sept 2015.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-6" target="_blank" rel="noopener">[6]</a> It is <em>“compatible with Java 6, 7 and 8, with a focus on core refinements and modern web capabilities”</em>.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-7" target="_blank" rel="noopener">[7]</a></p><p>Spring Framework 4.3 has been released on 10 June 2016 and will be supported until 2020.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-8" target="_blank" rel="noopener">[8]</a> It <em>“will be the final generation within the general Spring 4 system requirements (Java 6+, Servlet 2.5+), […]”</em>.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-9" target="_blank" rel="noopener">[9]</a></p><p>Spring 5 is announced to be built upon <a href="https://en.wikipedia.org/wiki/Reactive_Streams" target="_blank" rel="noopener">Reactive Streams</a> compatible Reactor Core.<a href="https://en.wikipedia.org/wiki/Spring_Framework#cite_note-10" target="_blank" rel="noopener">[10]</a></p></blockquote><h2 id="Bean发展史"><a href="#Bean发展史" class="headerlink" title="Bean发展史"></a>Bean发展史</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>​    java, 一开始的目标是客户端应用</p><p>javaBeans</p><p>《javaBeans规范》</p><ol><li>这个类需要是public 的， 然后需要有个无参数的构造函数</li><li>这个类的属性应该是private 的， 通过setXXX()和getXXX()来访问</li><li>这个类需要能支持“事件”， 例如addXXXXListener(XXXEvent e),  事件可以是Click事件，Keyboard事件等等， 当然咱们也支持自定义的事件。 </li><li>我们得提供一个所谓的自省/反射机制， 这样能在运行时查看java bean 的各种信息“</li><li>这个类应该是可以序列化的， 即可以把bean的状态保存的硬盘上， 以便以后来恢复。 </li></ol><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>​    MVC(Model-View-Controller)中的model</p><p>​    -&gt;struct     </p><p>​    -&gt;spring</p><h3 id="Enterprise-Java-bean"><a href="#Enterprise-Java-bean" class="headerlink" title="Enterprise Java bean"></a>Enterprise Java bean</h3><h4 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h4><p>​    1998年发表 JDK1.2 并分为标准版(Standard Edition，<a href="https://baike.baidu.com/item/J2SE" target="_blank" rel="noopener">J2SE</a>), 企业版(Enterprise Edition，J2EE)，微型版(MicroEdition，<a href="https://baike.baidu.com/item/J2ME" target="_blank" rel="noopener">J2ME</a>)。J2EE便由此诞生。</p><p>​    四层模型</p><p>​        客户层组件 ：运行在客户端机器上的客户层组件</p><p>​        session bean</p><p>​        web层组件 ：运行在J2EE<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">服务器</a>上,java Servlet和JavaServer Pages(JSP）是web层组件</p><p>​        entity Bean</p><p>​        业务层组件:  运行在J2EE服务器上,Enterprise JavaBeans(EJB）是业务层组件.</p><p>​        message-driven beans.</p><p>​        信息系统层 : EIS服务器上的<a href="https://baike.baidu.com/item/%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">企业信息系统</a>（Enterprise information system）层软件</p><p>​                </p><h4 id="J2EE-粘合剂：EJB"><a href="#J2EE-粘合剂：EJB" class="headerlink" title="J2EE 粘合剂：EJB"></a>J2EE 粘合剂：EJB</h4><p>​    EJB(Enterprise JavaBean) 是J2EE的一种规范。设计目标与核心应用是部署分布式应用程序。</p><p>​    EJB 1.0 (1998-03-24)</p><p>​    EJB 2.0, final release (2001-08-22)</p><p>​    EJB 3.0, final release (2006-05-11)</p><p>​        JDBC</p><p>​        JNDI</p><p>​        RMI</p><p>​        JMS</p><p>​        JTA</p><p>​        Java mail</p><p>​        部署、集群</p><h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>​    POJO（Plain Ordinary Java Object）即POJO是一个简单的普通的Java对象，它不包含<a href="https://baike.baidu.com/item/业务逻辑" target="_blank" rel="noopener">业务逻辑</a>或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。(是MartinFowler等发明的一个术语)</p><p>Spring的文档中有这样一句话</p><pre><code> Spring enables you to build applications from &quot;plain old Java objects&quot; (POJOs) and to apply enterprise services non-invasively to POJOs. This capability applies to the Java SE programming model and to full and partial Java EE.</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet_spring-mvc</title>
      <link href="/2019/02/03/spring-mvc/"/>
      <url>/2019/02/03/spring-mvc/</url>
      
        <content type="html"><![CDATA[<p>​    本文分析基于    <code>基于spring-webmvc 4.0.3.RELEASE</code></p><a id="more"></a><h2 id="springMVC-核心servlet-—DispatcherServlet"><a href="#springMVC-核心servlet-—DispatcherServlet" class="headerlink" title="springMVC 核心servlet —DispatcherServlet"></a>springMVC 核心servlet —DispatcherServlet</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fyc0ein61sj31m20u0adx.jpg" alt="image-20181219135235499"></p><blockquote><p>Aware：如果某个类想使用Spring的一些东西，就可以实现Aware接口</p><p>Capable:具有spring某个类的能力</p></blockquote><h3 id="时序图预览"><a href="#时序图预览" class="headerlink" title="时序图预览"></a>时序图预览</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8v5w3d34j31p90u0any.jpg" alt="image-20200125155900180"></p><h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><h4 id="HttpServletBean的创建"><a href="#HttpServletBean的创建" class="headerlink" title="HttpServletBean的创建"></a>HttpServletBean的创建</h4><p>​        实现了<code>EnvironmentCapable</code>、<code>EnvironmentAware</code> ，主要作用是将Servlet中配置的参数设置到相应的容器</p><h4 id="FramewordkServlet的创建"><a href="#FramewordkServlet的创建" class="headerlink" title="FramewordkServlet的创建"></a>FramewordkServlet的创建</h4><p>​        实现了<code>ApplicationContextAware</code>，其主要作用是调用<code>initWebApplicationContext()</code>初始化<code>WebApplicationContext</code></p><ul><li>获取spring的根工期rootContext</li><li>设置webApplicationContext并根据情况调用onRefresh方法</li><li>将WebApplicationContext设置到ServletContext中            </li></ul><h4 id="DispatcherServlet的创建"><a href="#DispatcherServlet的创建" class="headerlink" title="DispatcherServlet的创建"></a>DispatcherServlet的创建</h4><p>​    onRefresh方法是DispatcherServlet的入口方法，onRefresh中调用了initStrategies()方法来初始化一些策略组件</p><pre><code class="java">protected void onRefresh(ApplicationContext context) {    this.initStrategies(context);}/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) {    initMultipartResolver(context);    initLocaleResolver(context);    initThemeResolver(context);    initHandlerMappings(context);    initHandlerAdapters(context);    initHandlerExceptionResolvers(context);    initRequestToViewNameTranslator(context);    initViewResolvers(context);    initFlashMapManager(context);}</code></pre><p>如果没有配置相关，会使用默认的配置，在DispatcherServlet.properties文件中</p><pre><code class="properties"># Default implementation classes for DispatcherServlet&#39;s strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\   org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\   org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\   org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\   org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</code></pre><blockquote><p>Tips：If no bean is defined with the given name in the BeanFactory for this namespace, no multipart handling is provided.</p></blockquote><h3 id="组件概览"><a href="#组件概览" class="headerlink" title="组件概览"></a>组件概览</h3><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>​    它的作用是根据request找到对应的处理器handler和Interceptors ,首先看下接口信息</p><pre><code class="java">package org.springframework.web.servlet;import javax.servlet.http.HttpServletRequest;/** * Interface to be implemented by objects that define a mapping between * requests and handler objects. * @see org.springframework.core.Ordered * @see org.springframework.web.servlet.handler.AbstractHandlerMapping * @see org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping * @see org.springframework.web.servlet.handler.SimpleUrlHandlerMapping */public interface HandlerMapping {   String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;;   String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;;   String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;;   String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;;   String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.matrixVariables&quot;;   String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;;   /**    * Return a handler and any interceptors for this request. The choice may be made    * on request URL, session state, or any factor the implementing class chooses.    * &lt;p&gt;The returned HandlerExecutionChain contains a handler Object, rather than    * even a tag interface, so that handlers are not constrained in any way.    * For example, a HandlerAdapter could be written to allow another framework&#39;s    * handler objects to be used.    * &lt;p&gt;Returns {@code null} if no match was found. This is not an error.    * The DispatcherServlet will query all registered HandlerMapping beans to find    * a match, and only decide there is an error if none can find a handler.    * @param request current HTTP request    * @return a HandlerExecutionChain instance containing handler object and    * any interceptors, or {@code null} if no mapping found    * @throws Exception if there is an internal error    */   HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;}</code></pre><p>以常用接口实现为例，RequestMappingHandlerMapping</p><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fyc839v8vdj31l20u043g.jpg" alt="image-20181219181838287"></p><blockquote><p>这里提供了Ordered接口，可以确定匹配的顺序，同时通过继承WebApplicationObjectSupport抽象类，可以获取相关Bean（handler）,更多细节可查看 类AbstractHandlerMapping。</p></blockquote><h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>​    之所以要使用HandlerAdapter，是因为SpringMVC中并没有对处理器做任何的限制，可以是个类，方法（HandlerMethod）这点从hanlder是Object就可以看出，首先是接口实现</p><pre><code class="java">package org.springframework.web.servlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * MVC framework SPI interface, allowing parameterization of core MVC workflow. * * &lt;p&gt;Interface that must be implemented for each handler type to handle a request. * This interface is used to allow the {@link DispatcherServlet} to be indefinitely * extensible. The DispatcherServlet accesses all installed handlers through this * interface, meaning that it does not contain code specific to any handler type. * * &lt;p&gt;Note that a handler can be of type {@code Object}. This is to enable * handlers from other frameworks to be integrated with this framework without * custom coding, as well as to allow for annotation handler objects that do * not obey any specific Java interface. * * &lt;p&gt;This interface is not intended for application developers. It is available * to handlers who want to develop their own web workflow. * * &lt;p&gt;Note: HandlerAdaptger implementators may implement the * {@link org.springframework.core.Ordered} interface to be able to specify a * sorting order (and thus a priority) for getting applied by DispatcherServlet. * Non-Ordered instances get treated as lowest priority. * * @author Rod Johnson * @author Juergen Hoeller * @see org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter * @see org.springframework.web.servlet.handler.SimpleServletHandlerAdapter */public interface HandlerAdapter {   /**    * Given a handler instance, return whether or not this HandlerAdapter can    * support it. Typical HandlerAdapters will base the decision on the handler    * type. HandlerAdapters will usually only support one handler type each.    * &lt;p&gt;A typical implementation:    * &lt;p&gt;{@code    * return (handler instanceof MyHandler);    * }    * @param handler handler object to check    * @return whether or not this object can use the given handler    */   boolean supports(Object handler);   /**    * Use the given handler to handle this request.    * The workflow that is required may vary widely.    * @param request current HTTP request    * @param response current HTTP response    * @param handler handler to use. This object must have previously been passed    * to the {@code supports} method of this interface, which must have    * returned {@code true}.    * @throws Exception in case of errors    * @return ModelAndView object with the name of the view and the required    * model data, or {@code null} if the request has been handled directly    */   ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;   /**    * Same contract as for HttpServlet&#39;s {@code getLastModified} method.    * Can simply return -1 if there&#39;s no support in the handler class.    * @param request current HTTP request    * @param handler handler to use    * @return the lastModified value for the given handler    * @see javax.servlet.http.HttpServlet#getLastModified    * @see org.springframework.web.servlet.mvc.LastModified#getLastModified    */   long getLastModified(HttpServletRequest request, Object handler);}</code></pre><p>其中一个实现类<code>SimpleControllerHandlerAdapter</code></p><pre><code class="java">package org.springframework.web.servlet.mvc;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerAdapter;import org.springframework.web.servlet.ModelAndView;/** * Adapter to use the plain {@link Controller} workflow interface with * the generic {@link org.springframework.web.servlet.DispatcherServlet}. * Supports handlers that implement the {@link LastModified} interface. * &lt;p&gt;This is an SPI class, not used directly by application code. * * @author Rod Johnson * @author Juergen Hoeller * @see org.springframework.web.servlet.DispatcherServlet * @see Controller * @see LastModified * @see HttpRequestHandlerAdapter */public class SimpleControllerHandlerAdapter implements HandlerAdapter {   @Override   public boolean supports(Object handler) {      return (handler instanceof Controller);   }   @Override   public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {      return ((Controller) handler).handleRequest(request, response);   }   @Override   public long getLastModified(HttpServletRequest request, Object handler) {      if (handler instanceof LastModified) {         return ((LastModified) handler).getLastModified(request);      }      return -1L;   }}</code></pre><p>一般默认使用的是 RequestMappingHandlerAdapter ,在其父类中有这样一句设置Order</p><p><code>private int order = Ordered.LOWEST_PRECEDENCE;</code></p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fyc7lnlrzmj318o0u042e.jpg" alt="image-20181219180136155"></p><blockquote><p>HandlerAdapter implementators may implement the Order，使用时候是遍历 handlerAdapters ，调用supports判断直接返回（除了设置的，默认的实现有3个）。注意Order是越低优先级越高的。更多细节可以查看#afterPropertiesSet()方法</p></blockquote><p>总结一下，主要做了三件事，解析参数、执行请求，处理返回结果</p><ul><li>解析参数的过程中用到的参数来源有多个，大体可分为两类<ul><li>一类是从Model来的（通过FlashMapManager和ModelFactory）</li><li>另一类是从Request来的, 具体使用HandlerMethodArgumentResolver进行解析（有的是@InitBinder WebDataBinder）</li></ul></li><li>执行请求的是用HandlerMethod的子类ServletInvocableHandlerMethod</li><li>返回值用HandlerMethodReturnValueHandler进行解析。</li></ul><p>另外，整个处理过程中ModelAndViewContainer起着参数传递的作用。</p><p>​    这里还有一个需要注意的，就是<code>RequestMappingHandlerAdapter</code> 是怎么注入的，通过debug发现，默认的实现HandlerAdapter 有 3个 ,除了前者还有<code>HttpRequestHandlerAdapte</code>、<code>SimpleControllerHandlerAdapte</code>的</p><p><a href="https://docs.spring.io/spring/docs/3.2.10.RELEASE/spring-framework-reference/html/mvc.html#mvc-config-enable" target="_blank" rel="noopener">通过查询官方文档发现</a>，有两种方式, 会自动生成相关@RequestMapping的类。</p><ul><li>@EnableWebMvc</li><li>配置文件配置了<code>mvc:annotation-driven</code> </li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb8vloeh4nj31wo0u0qdk.jpg" alt="image-20200125161405442"></p><blockquote><p>官方文档截图</p></blockquote><h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h4><p>​    根据异常设置ModelAndView，之后交给render方法去渲染，这里要注意它是在render之前工作，所以只作用于解析对请求做处理过程中的产生的异常。</p><pre><code class="java">package org.springframework.web.servlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Interface to be implemented by objects than can resolve exceptions thrown * during handler mapping or execution, in the typical case to error views. * Implementors are typically registered as beans in the application context. * * &lt;p&gt;Error views are analogous to the error page JSPs, but can be used with * any kind of exception including any checked exception, with potentially * fine-granular mappings for specific handlers. * * @author Juergen Hoeller * @since 22.11.2003 */public interface HandlerExceptionResolver {   /**    * Try to resolve the given exception that got thrown during on handler execution,    * returning a ModelAndView that represents a specific error page if appropriate.    * &lt;p&gt;The returned ModelAndView may be {@linkplain ModelAndView#isEmpty() empty}    * to indicate that the exception has been resolved successfully but that no view    * should be rendered, for instance by setting a status code.    * @param request current HTTP request    * @param response current HTTP response    * @param handler the executed handler, or {@code null} if none chosen at the    * time of the exception (for example, if multipart resolution failed)    * @param ex the exception that got thrown during handler execution    * @return a corresponding ModelAndView to forward to,    * or {@code null} for default processing    */   ModelAndView resolveException(         HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);}</code></pre><p>其实现SimpleMappingExceptionResolver 可以通过扩展配置，设置自定义类型</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyc6u9xp9nj30zn0u0ag3.jpg" alt="image-20181219173520333"></p><blockquote><p>可以配合定制自定义Exception，前端统一展示等</p></blockquote><h4 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h4><p>​    通过viewName来找到 对应的View，View是用来渲染页面的，主要解决用什么模版和用什么规则填入参数</p><pre><code class="java">package org.springframework.web.servlet;import java.util.Locale;/** * Interface to be implemented by objects that can resolve views by name. * * &lt;p&gt;View state doesn&#39;t change during the running of the application, * so implementations are free to cache views. * * &lt;p&gt;Implementations are encouraged to support internationalization, * i.e. localized view resolution. * * @author Rod Johnson * @author Juergen Hoeller * @see org.springframework.web.servlet.view.InternalResourceViewResolver * @see org.springframework.web.servlet.view.ResourceBundleViewResolver * @see org.springframework.web.servlet.view.XmlViewResolver */public interface ViewResolver {   /**    * Resolve the given view by name.    * &lt;p&gt;Note: To allow for ViewResolver chaining, a ViewResolver should    * return {@code null} if a view with the given name is not defined in it.    * However, this is not required: Some ViewResolvers will always attempt    * to build View objects with the given name, unable to return {@code null}    * (rather throwing an exception when View creation failed).    * @param viewName name of the view to resolve    * @param locale Locale in which to resolve the view.    * ViewResolvers that support internationalization should respect this.    * @return the View object, or {@code null} if not found    * (optional, to allow for ViewResolver chaining)    * @throws Exception if the view cannot be resolved    * (typically in case of problems creating an actual View object)    */   View resolveViewName(String viewName, Locale locale) throws Exception;}</code></pre><p>常用的jsp解析</p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fycat4mrudj310q0u043a.jpg" alt="image-20181219195241323"></p><p>按照类图可以把继承<code>AbstractCachingViewResolver</code>(里面两个Map的方式值得学习)分成两类</p><ul><li><code>ResourceBundleViewResolver</code>  可以同时支持多种类型的视图，需要将每一个视图名和对应的视图类型配置到相应的properties文件中,该类的注释中，解释了其用法,</li></ul><pre><code class="java"> /* &lt;p&gt;This {@code ViewResolver} supports localized view definitions, * using the default support of {@link java.util.PropertyResourceBundle}. * For example, the basename &quot;views&quot; will be resolved as class path resources * &quot;views_de_AT.properties&quot;, &quot;views_de.properties&quot;, &quot;views.properties&quot; - * for a given Locale &quot;de_AT&quot;./</code></pre><ul><li><code>UrlBasedViewResolver</code>系列的解析器都是对单一视图进行解析的，只需找到模版就行，例如</li></ul><p><code>InternalResourceViewResolver</code> 是专门用来解析jsp，<code>FreeMarkerViewResolver</code>只针对FreeMarker</p><blockquote><p>相关扩展ExecelViewResolver、SimpleMapViewResolver</p><p>默认实现是 InternalResourceViewResolver</p></blockquote><h4 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h4><p>比较简单，当handler处理完后，没有View和ViewName的会调用该方法。</p><pre><code class="java">/** * Do we need view name translation? */private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception {   if (mv != null &amp;&amp; !mv.hasView()) {      mv.setViewName(getDefaultViewName(request));   }}/** * Translate the supplied request into a default view name. * @param request current HTTP servlet request * @return the view name (or {@code null} if no default found) * @throws Exception if view name translation failed */protected String getDefaultViewName(HttpServletRequest request) throws Exception {    return this.viewNameTranslator.getViewName(request);}</code></pre><blockquote><p>​    默认实现是RequestToViewNameTranslator</p></blockquote><h4 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h4><p>​    用于从request中解析出Locale,默认实现是</p><pre><code class="java">package org.springframework.web.servlet.i18n;import java.util.Locale;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.LocaleResolver;/** * {@link LocaleResolver} implementation that simply uses the primary locale * specified in the &quot;accept-language&quot; header of the HTTP request (that is, * the locale sent by the client browser, normally that of the client&#39;s OS). * * &lt;p&gt;Note: Does not support {@code setLocale}, since the accept header * can only be changed through changing the client&#39;s locale settings. * * @author Juergen Hoeller * @since 27.02.2003 * @see javax.servlet.http.HttpServletRequest#getLocale() */public class AcceptHeaderLocaleResolver implements LocaleResolver {   public Locale resolveLocale(HttpServletRequest request) {      return request.getLocale();   }   public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {      throw new UnsupportedOperationException(            &quot;Cannot change HTTP accept header - use a different locale resolution strategy&quot;);   }}</code></pre><p>​    在DispatcherServlet#doSerive()方法中， <code>request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</code> 放进request中，这里除了视图解析的时候需要用到，在使用国际化主题的时候也会用到</p><blockquote><p>切换相关，可查看 LocaleChangeInterceptor</p></blockquote><h4 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h4><p>​    SpringMVC中和主题相关的类有如下</p><ul><li>ThemeResolver 作用是从request中解析出主题名,默认实现FixedThemeResolver</li><li>ThemeSource 根据主题名找到对应的主题 ，默认使用WebApplicationContext</li><li>Theme 就是主题，包含了具体资源</li></ul><pre><code class="java">package org.springframework.web.servlet.theme;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * {@link org.springframework.web.servlet.ThemeResolver} implementation * that simply uses a fixed theme. The fixed name can be defined via * the &quot;defaultThemeName&quot; property; out of the box, it is &quot;theme&quot;. * * &lt;p&gt;Note: Does not support {@code setThemeName}, as the fixed theme * cannot be changed. * * @author Jean-Pierre Pawlak * @author Juergen Hoeller * @since 17.06.2003 * @see #setDefaultThemeName */public class FixedThemeResolver extends AbstractThemeResolver {   @Override   public String resolveThemeName(HttpServletRequest request) {      return getDefaultThemeName();   }   @Override   public void setThemeName(HttpServletRequest request, HttpServletResponse response, String themeName) {      throw new UnsupportedOperationException(&quot;Cannot change theme - use a different theme resolution strategy&quot;);   }}</code></pre><blockquote><p>切换相关，可查看 ThemeChangeInterceptor</p></blockquote><h4 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h4><p>​    用于处理文件上传，注意这个组件在DispatcherServlet.properties 中 没有默认实现,首先是接口</p><pre><code class="java">package org.springframework.web.multipart;import javax.servlet.http.HttpServletRequest;/** * A strategy interface for multipart file upload resolution in accordance * with &lt;a href=&quot;http://www.ietf.org/rfc/rfc1867.txt&quot;&gt;RFC 1867&lt;/a&gt;. * Implementations are typically usable both within an application context * and standalone. * * &lt;p&gt;There are two concrete implementations included in Spring, as of Spring 3.1: * &lt;ul&gt; * &lt;li&gt;{@link org.springframework.web.multipart.commons.CommonsMultipartResolver} for Jakarta Commons FileUpload * &lt;li&gt;{@link org.springframework.web.multipart.support.StandardServletMultipartResolver} for Servlet 3.0 Part API * &lt;/ul&gt; * * @author Juergen Hoeller * @author Trevor D. Cook * @since 29.09.2003 * @see MultipartHttpServletRequest * @see MultipartFile * @see org.springframework.web.multipart.commons.CommonsMultipartResolver * @see org.springframework.web.multipart.support.ByteArrayMultipartFileEditor * @see org.springframework.web.multipart.support.StringMultipartFileEditor * @see org.springframework.web.servlet.DispatcherServlet */public interface MultipartResolver {   /**    * Determine if the given request contains multipart content.    * &lt;p&gt;Will typically check for content type &quot;multipart/form-data&quot;, but the actually    * accepted requests might depend on the capabilities of the resolver implementation.    * @param request the servlet request to be evaluated    * @return whether the request contains multipart content    */   boolean isMultipart(HttpServletRequest request);   /**    * Parse the given HTTP request into multipart files and parameters,    * and wrap the request inside a    * {@link org.springframework.web.multipart.MultipartHttpServletRequest} object    * that provides access to file descriptors and makes contained    * parameters accessible via the standard ServletRequest methods.    * @param request the servlet request to wrap (must be of a multipart content type)    * @return the wrapped servlet request    * @throws MultipartException if the servlet request is not multipart, or if    * implementation-specific problems are encountered (such as exceeding file size limits)    * @see MultipartHttpServletRequest#getFile    * @see MultipartHttpServletRequest#getFileNames    * @see MultipartHttpServletRequest#getFileMap    * @see javax.servlet.http.HttpServletRequest#getParameter    * @see javax.servlet.http.HttpServletRequest#getParameterNames    * @see javax.servlet.http.HttpServletRequest#getParameterMap    */   MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException;   /**    * Cleanup any resources used for the multipart handling,    * like a storage for the uploaded files.    * @param request the request to cleanup resources for    */   void cleanupMultipart(MultipartHttpServletRequest request);}</code></pre><p>常用实现CommonsMultipartResolver</p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fycdyq4kmxj31ta0u0ahy.jpg" alt="image-20181219214146380"></p><p>对于上传类型判断是 multipart/form-data, 两种实现</p><ul><li>一种是Servlet的标准实现StandardServletMultipartResolver</li><li>一种是Apache的commons-fileupload方式</li></ul><h4 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h4><p>​    FlashMap主要用于redirect中传递参数，FlashMapManage是用来管理FlashMap的</p><pre><code class="java">package org.springframework.web.servlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * A strategy interface for retrieving and saving FlashMap instances. * See {@link FlashMap} for a general overview of flash attributes. * * @author Rossen Stoyanchev * @since 3.1 * @see FlashMap */public interface FlashMapManager {   /**    * Find a FlashMap saved by a previous request that matches to the current    * request, remove it from underlying storage, and also remove other    * expired FlashMap instances.    * &lt;p&gt;This method is invoked in the beginning of every request in contrast    * to {@link #saveOutputFlashMap}, which is invoked only when there are    * flash attributes to be saved - i.e. before a redirect.    * @param request the current request    * @param response the current response    * @return a FlashMap matching the current request or {@code null}    */   FlashMap retrieveAndUpdate(HttpServletRequest request, HttpServletResponse response);   /**    * Save the given FlashMap, in some underlying storage and set the start    * of its expiration period.    * &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Invoke this method prior to a redirect in order    * to allow saving the FlashMap in the HTTP session or in a response    * cookie before the response is committed.    * @param flashMap the FlashMap to save    * @param request the current request    * @param response the current response    */   void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response);}</code></pre><p>​    两个方法，分别是retrieveAndUpdate 用于恢复参数，saveOutputFlashMap用于保存参数</p><p>类图也比较简单</p><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fyce346qynj30zc0u0q9t.jpg" alt="image-20181219214559988"></p><blockquote><p>默认实现是SessionFlashMapManager</p></blockquote><p>整个redirects 的参数通过FlashMap传递的过程分三步</p><ol><li>首先，RequestMappingHandlerAapter会将其设置到<code>outputFlashMap</code>中，如果是redirect类型的返回类型值（将需要传递的参数设置到<code>outputFlashMap</code>中，也可以是RedirectAttributes类型的参数中）</li><li>在RedirectView中会调用<code>#saveOutputFlashMap()</code>方法，将<code>outputFlashMap</code>中的参数设置到Session</li><li>请求redirect后，DispatcherServlet会调有你<code>#retrieveAndUpdate()</code>方法从Session中获取<code>inputFlashMap</code>并设置到Request的属性中备用，同时从Session中删除</li></ol><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><h4 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h4><p>​    Servlet的处理过程，首先是从Servlet接口的service，然后在HttpServlet的service方法中根据请求的类型不同将请求路由到了doGet、doHead等方法。</p><p>​    FrameworkServlet中重写了doGet等方法。将请求集中到processRequest方法进行统一处理</p><pre><code class="java">/** * Override the parent class implementation in order to intercept PATCH * requests. */@Overrideprotected void service(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException {    String method = request.getMethod();    if (method.equalsIgnoreCase(RequestMethod.PATCH.name())) {        processRequest(request, response);    }    else {        super.service(request, response);    }}/** * Delegate GET requests to processRequest/doService. * &lt;p&gt;Will also be invoked by HttpServlet&#39;s default implementation of {@code doHead}, * with a {@code NoBodyResponse} that just captures the content length. * @see #doService * @see #doHead */@Overrideprotected final void doGet(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException {    processRequest(request, response);}</code></pre><p>​    processRequest这个方法主要做了两件事情(当然还有doService，和对异步请求对处理)</p><ul><li>对LocaleContext（获取locale）和RequestAttributes(管理request和session属性)的设置及恢复</li><li>处理完后发布ServletRequestHandledEvent消息</li></ul><p>LocaleContextHolder 、RequestContextHolder </p><pre><code class="java">public abstract class LocaleContextHolder {    private static final ThreadLocal localeContextHolder = new NamedThreadLocal(&quot;Locale context&quot;);    private static final ThreadLocal inheritableLocaleContextHolder = new NamedInheritableThreadLocal(&quot;Locale context&quot;);    ....}</code></pre><p> 这里比较有意思的地方是这是个抽象类，里面的方法实现都是静态方法，只能调用不能实例化。RequestContextHolder的实现类似，封装的是ServletRequestAttributes</p><blockquote><p>这里之所以需要对LocaleContext和RequestAttributes恢复，是因为在Servlet外面可能还有别等操作，例如Filter（Spring-MVC的HandlerInterceptor）,为了不影响那些操作。</p></blockquote><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>​    DispatcherServlet是FrameworkServlet的子类，实现了doService方法</p><h5 id="doService"><a href="#doService" class="headerlink" title="doService"></a>doService</h5><pre><code class="java">/** * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch} * for the actual dispatching. */@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response)     throws Exception {    // Keep a snapshot of the request attributes in case of an include,    // to be able to restore the original attributes after the include.    Map&lt;String, Object&gt; attributesSnapshot = null;    if (WebUtils.isIncludeRequest(request)) {        attributesSnapshot = new HashMap&lt;String, Object&gt;();        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();        while (attrNames.hasMoreElements()) {            String attrName = (String) attrNames.nextElement();            if (this.cleanupAfterInclude || attrName.startsWith(&quot;org.springframework.web.servlet&quot;)) {                attributesSnapshot.put(attrName, request.getAttribute(attrName));            }        }    }    // Make framework objects available to handlers and view objects.    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());    //Pass paramter use to Redirect    FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);    if (inputFlashMap != null) {        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));    }    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);    try {        doDispatch(request, response);    }    finally {        if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {            return;        }        // Restore the original attribute snapshot, in case of an include.        if (attributesSnapshot != null) {            restoreAttributesAfterInclude(request, attributesSnapshot);        }    }}</code></pre><p>在doDispatch之前做了</p><ul><li>判断是否include请求，是的话保存快照（attributesSnapshot）</li><li>为request设置默认的属性，在后面的handlers和view中需要使用</li></ul><h5 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a>doDispatch</h5><p>下面是doDispatch的方法的实现，主要的功能是 Process the actual dispatching to the handler.</p><pre><code class="java">/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet&#39;s HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet&#39;s installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It&#39;s up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response)     throws Exception {    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    boolean multipartRequestParsed = false;    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);    try {        ModelAndView mv = null;        Exception dispatchException = null;        try {            processedRequest = checkMultipart(request);            multipartRequestParsed = processedRequest != request;            // Determine handler for the current request.            mappedHandler = getHandler(processedRequest);            if (mappedHandler == null || mappedHandler.getHandler() == null) {                noHandlerFound(processedRequest, response);                return;            }            // Determine handler adapter for the current request.            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());            // Process last-modified header, if supported by the handler.            String method = request.getMethod();            boolean isGet = &quot;GET&quot;.equals(method);            if (isGet || &quot;HEAD&quot;.equals(method)) {                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                if (logger.isDebugEnabled()) {                    logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);                }                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {                    return;                }            }            if (!mappedHandler.applyPreHandle(processedRequest, response)) {                return;            }            try {                // Actually invoke the handler.                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());            }            finally {                if (asyncManager.isConcurrentHandlingStarted()) {                    return;                }            }            applyDefaultViewName(request, mv);            mappedHandler.applyPostHandle(processedRequest, response, mv);        }catch (Exception ex) {            dispatchException = ex;        }        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);    }catch (Exception ex) {        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);    }catch (Error err) {        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);    }finally {        if (asyncManager.isConcurrentHandlingStarted()) {            // Instead of postHandle and afterCompletion            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);            return;        }        // Clean up any resources used by a multipart request.        if (multipartRequestParsed) {            cleanupMultipart(processedRequest);        }    }}</code></pre><p>整个处理过程最核心的代码只有4句</p><ul><li>根据request请求在HandlerMapping找到对应的Handler </li><li>根据Handler找到对应的HandlerAdapter</li><li>用HandlerAdapter处理Handler,返回一个ModelAndView(Controller就是在这个地方执行)</li><li>根据ModelAndView的信息（或异常处理），通过ViewResolver找到View,并根据Model中的数据渲染输出后给用户</li></ul><p>整个<code>#doDispatcher()</code>处理流程如下</p><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fybvzj6p72j30u00ynju2.jpg" alt="image-20181219111943655"></p><blockquote><p>​    从请求开始的话，当请求到达服务器，服务器(Tomcat connector)分配一个socket线程来连接，创建request和response ，然后交给对应的servlet处理（中间经过Pipeline,Filter），这样请求就从容器(Tomcat)到Servlet（springMVC）</p></blockquote><p>​    </p><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>​    http协议是单向的，只能客户端自己拉，不能服务端主动推。</p><p>异步请求一般有两种方式，定时轮询或长链接。Servlet对异步的支持是通过长链接的方式。</p><h3 id="servlet异步支持"><a href="#servlet异步支持" class="headerlink" title="servlet异步支持"></a>servlet异步支持</h3><h4 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h4><p>​    首先是在 3.0后的 ServletRequest 中可以找到<code>#startAsync()</code> 返回一个异步容器</p><pre><code class="java">package javax.servlet;import java.io.*;import java.util.*;/** * Defines an object to provide client request information to a servlet.  The * servlet container creates a &lt;code&gt;ServletRequest&lt;/code&gt; object and passes * it as an argument to the servlet&#39;s &lt;code&gt;service&lt;/code&gt; method. * * &lt;p&gt;A &lt;code&gt;ServletRequest&lt;/code&gt; object provides data including * parameter name and values, attributes, and an input stream. * Interfaces that extend &lt;code&gt;ServletRequest&lt;/code&gt; can provide * additional protocol-specific data (for example, HTTP data is * provided by {@link javax.servlet.http.HttpServletRequest}. *  * @author     Various * * @see     javax.servlet.http.HttpServletRequest * */public interface ServletRequest {    /**     * Puts this request into asynchronous mode, and initializes its     * {@link AsyncContext} with the original (unwrapped) ServletRequest     * and ServletResponse objects.     *     * &lt;p&gt;Calling this method will cause committal of the associated     * response to be delayed until {@link AsyncContext#complete} is     * called on the returned {@link AsyncContext}, or the asynchronous     * operation has timed out.     *     * &lt;p&gt;Calling {@link AsyncContext#hasOriginalRequestAndResponse()} on     * the returned AsyncContext will return &lt;code&gt;true&lt;/code&gt;. Any filters     * invoked in the &lt;i&gt;outbound&lt;/i&gt; direction after this request was put     * into asynchronous mode may use this as an indication that any request     * and/or response wrappers that they added during their &lt;i&gt;inbound&lt;/i&gt;     * invocation need not stay around for the duration of the asynchronous     * operation, and therefore any of their associated resources may be     * released.     *     * &lt;p&gt;This method clears the list of {@link AsyncListener} instances     * (if any) that were registered with the AsyncContext returned by the     * previous call to one of the startAsync methods, after calling each     * AsyncListener at its {@link AsyncListener#onStartAsync onStartAsync}     * method.     *     * &lt;p&gt;Subsequent invocations of this method, or its overloaded      * variant, will return the same AsyncContext instance, reinitialized     * as appropriate.     *     * @return the (re)initialized AsyncContext     *      * @throws IllegalStateException if this request is within the scope of     * a filter or servlet that does not support asynchronous operations     * (that is, {@link #isAsyncSupported} returns false),     * or if this method is called again without any asynchronous dispatch     * (resulting from one of the {@link AsyncContext#dispatch} methods),     * is called outside the scope of any such dispatch, or is called again     * within the scope of the same dispatch, or if the response has     * already been closed     *     * @since Servlet 3.0     */    public AsyncContext startAsync() throws IllegalStateException;    //...}</code></pre><h4 id="异步容器AsyncContext"><a href="#异步容器AsyncContext" class="headerlink" title="异步容器AsyncContext"></a>异步容器AsyncContext</h4><pre><code class="java">package javax.servlet;/** * Class representing the execution context for an asynchronous operation * that was initiated on a ServletRequest. * * &lt;p&gt;An AsyncContext is created and initialized by a call to * {@link ServletRequest#startAsync()} or * {@link ServletRequest#startAsync(ServletRequest, ServletResponse)}. * Repeated invocations of these methods will return the same AsyncContext * instance, reinitialized as appropriate. * * &lt;p&gt;In the event that an asynchronous operation has timed out, the * container must run through these steps: * &lt;ol&gt; * &lt;li&gt;Invoke, at their {@link AsyncListener#onTimeout onTimeout} method, all * {@link AsyncListener} instances registered with the ServletRequest * on which the asynchronous operation was initiated.&lt;/li&gt; * &lt;li&gt;If none of the listeners called {@link #complete} or any of the * {@link #dispatch} methods, perform an error dispatch with a status code * equal to &lt;tt&gt;HttpServletResponse.SC_INTERNAL_SERVER_ERROR&lt;/tt&gt;.&lt;/li&gt; * &lt;li&gt;If no matching error page was found, or the error page did not call * {@link #complete} or any of the {@link #dispatch} methods, call * {@link #complete}.&lt;/li&gt; * &lt;/ol&gt; * * @since Servlet 3.0 */public interface AsyncContext {    /**     * The name of the request attribute under which the original     * request URI is made available to the target of a     * {@link #dispatch(String)} or {@link #dispatch(ServletContext,String)}      */    static final String ASYNC_REQUEST_URI = &quot;javax.servlet.async.request_uri&quot;;    /**     * The name of the request attribute under which the original     * context path is made available to the target of a     * {@link #dispatch(String)} or {@link #dispatch(ServletContext,String)}      */    static final String ASYNC_CONTEXT_PATH = &quot;javax.servlet.async.context_path&quot;;    /**     * The name of the request attribute under which the original     * path info is made available to the target of a     * {@link #dispatch(String)} or {@link #dispatch(ServletContext,String)}      */    static final String ASYNC_PATH_INFO = &quot;javax.servlet.async.path_info&quot;;    /**     * The name of the request attribute under which the original     * servlet path is made available to the target of a     * {@link #dispatch(String)} or {@link #dispatch(ServletContext,String)}       */    static final String ASYNC_SERVLET_PATH = &quot;javax.servlet.async.servlet_path&quot;;    /**     * The name of the request attribute under which the original     * query string is made available to the target of a     * {@link #dispatch(String)} or {@link #dispatch(ServletContext,String)}      */    static final String ASYNC_QUERY_STRING = &quot;javax.servlet.async.query_string&quot;;    /**     * Gets the request that was used to initialize this AsyncContext     * by calling {@link ServletRequest#startAsync()} or     * {@link ServletRequest#startAsync(ServletRequest, ServletResponse)}.     *     * @return the request that was used to initialize this AsyncContext     */    public ServletRequest getRequest();    /**     * Gets the response that was used to initialize this AsyncContext     * by calling {@link ServletRequest#startAsync()} or     * {@link ServletRequest#startAsync(ServletRequest, ServletResponse)}.     *     * @return the response that was used to initialize this AsyncContext     */    public ServletResponse getResponse();    /**     * Checks if this AsyncContext was initialized with the original or     * application-wrapped request and response objects.     *      * &lt;p&gt;This information may be used by filters invoked in the     * &lt;i&gt;outbound&lt;/i&gt; direction, after a request was put into     * asynchronous mode, to determine whether any request and/or response     * wrappers that they added during their &lt;i&gt;inbound&lt;/i&gt; invocation need     * to be preserved for the duration of the asynchronous operation, or may     * be released.     *     * @return true if this AsyncContext was initialized with the original     * request and response objects by calling     * {@link ServletRequest#startAsync()}, or if it was initialized by     * calling     * {@link ServletRequest#startAsync(ServletRequest, ServletResponse)},     * and neither the ServletRequest nor ServletResponse arguments      * carried any application-provided wrappers; false otherwise     */    public boolean hasOriginalRequestAndResponse();    /**     * Dispatches the request and response objects of this AsyncContext     * to the servlet container.     *      * &lt;p&gt;If the asynchronous cycle was started with     * {@link ServletRequest#startAsync(ServletRequest, ServletResponse)},     * and the request passed is an instance of HttpServletRequest,     * then the dispatch is to the URI returned by     * {@link javax.servlet.http.HttpServletRequest#getRequestURI}.     * Otherwise, the dispatch is to the URI of the request when it was     * last dispatched by the container.     *     * &lt;p&gt;The following sequence illustrates how this will work:     * &lt;code&gt;&lt;pre&gt;     * // REQUEST dispatch to /url/A     * AsyncContext ac = request.startAsync();     * ...     * ac.dispatch(); // ASYNC dispatch to /url/A     *      * // FORWARD dispatch to /url/B     * getRequestDispatcher(&quot;/url/B&quot;).forward(request,response);     * // Start async operation from within the target of the FORWARD     * // dispatch     * ac = request.startAsync();     * ...     * ac.dispatch(); // ASYNC dispatch to /url/A     *      * // FORWARD dispatch to /url/B     * getRequestDispatcher(&quot;/url/B&quot;).forward(request,response);     * // Start async operation from within the target of the FORWARD     * // dispatch     * ac = request.startAsync(request,response);     * ...     * ac.dispatch(); // ASYNC dispatch to /url/B     * &lt;/pre&gt;&lt;/code&gt;     *     * &lt;p&gt;This method returns immediately after passing the request     * and response objects to a container managed thread, on which the     * dispatch operation will be performed.     * If this method is called before the container-initiated dispatch     * that called &lt;tt&gt;startAsync&lt;/tt&gt; has returned to the container, the     * dispatch operation will be delayed until after the container-initiated     * dispatch has returned to the container.     *     * &lt;p&gt;The dispatcher type of the request is set to     * &lt;tt&gt;DispatcherType.ASYNC&lt;/tt&gt;. Unlike     * {@link RequestDispatcher#forward(ServletRequest, ServletResponse)     * forward dispatches}, the response buffer and     * headers will not be reset, and it is legal to dispatch even if the     * response has already been committed.     *     * &lt;p&gt;Control over the request and response is delegated     * to the dispatch target, and the response will be closed when the     * dispatch target has completed execution, unless     * {@link ServletRequest#startAsync()} or     * {@link ServletRequest#startAsync(ServletRequest, ServletResponse)}     * are called.     *      * &lt;p&gt;Any errors or exceptions that may occur during the execution     * of this method must be caught and handled by the container, as     * follows:     * &lt;ol&gt;     * &lt;li&gt;Invoke, at their {@link AsyncListener#onError onError} method, all     * {@link AsyncListener} instances registered with the ServletRequest     * for which this AsyncContext was created, and make the caught      * &lt;tt&gt;Throwable&lt;/tt&gt; available via {@link AsyncEvent#getThrowable}.&lt;/li&gt;     * &lt;li&gt;If none of the listeners called {@link #complete} or any of the     * {@link #dispatch} methods, perform an error dispatch with a status code     * equal to &lt;tt&gt;HttpServletResponse.SC_INTERNAL_SERVER_ERROR&lt;/tt&gt;, and     * make the above &lt;tt&gt;Throwable&lt;/tt&gt; available as the value of the     * &lt;tt&gt;RequestDispatcher.ERROR_EXCEPTION&lt;/tt&gt; request attribute.&lt;/li&gt;     * &lt;li&gt;If no matching error page was found, or the error page did not call     * {@link #complete} or any of the {@link #dispatch} methods, call     * {@link #complete}.&lt;/li&gt;     * &lt;/ol&gt;     *     * &lt;p&gt;There can be at most one asynchronous dispatch operation per     * asynchronous cycle, which is started by a call to one of the     * {@link ServletRequest#startAsync} methods. Any attempt to perform an     * additional asynchronous dispatch operation within the same     * asynchronous cycle will result in an IllegalStateException.     * If startAsync is subsequently called on the dispatched request,     * then any of the dispatch or {@link #complete} methods may be called.     *     * @throws IllegalStateException if one of the dispatch methods     * has been called and the startAsync method has not been     * called during the resulting dispatch, or if {@link #complete}     * was called     *     * @see ServletRequest#getDispatcherType     */    public void dispatch();    /**     * Dispatches the request and response objects of this AsyncContext     * to the given &lt;tt&gt;path&lt;/tt&gt;.     *     * &lt;p&gt;The &lt;tt&gt;path&lt;/tt&gt; parameter is interpreted in the same way      * as in {@link ServletRequest#getRequestDispatcher(String)}, within     * the scope of the {@link ServletContext} from which this     * AsyncContext was initialized.     *     * &lt;p&gt;All path related query methods of the request must reflect the     * dispatch target, while the original request URI, context path,     * path info, servlet path, and query string may be recovered from     * the {@link #ASYNC_REQUEST_URI}, {@link #ASYNC_CONTEXT_PATH},     * {@link #ASYNC_PATH_INFO}, {@link #ASYNC_SERVLET_PATH}, and     * {@link #ASYNC_QUERY_STRING} attributes of the request. These     * attributes will always reflect the original path elements, even under     * repeated dispatches.     *     * &lt;p&gt;There can be at most one asynchronous dispatch operation per     * asynchronous cycle, which is started by a call to one of the     * {@link ServletRequest#startAsync} methods. Any attempt to perform an     * additional asynchronous dispatch operation within the same     * asynchronous cycle will result in an IllegalStateException.     * If startAsync is subsequently called on the dispatched request,     * then any of the dispatch or {@link #complete} methods may be called.     *     * &lt;p&gt;See {@link #dispatch()} for additional details, including error     * handling.     *     * @param path the path of the dispatch target, scoped to the     * ServletContext from which this AsyncContext was initialized     *     * @throws IllegalStateException if one of the dispatch methods     * has been called and the startAsync method has not been     * called during the resulting dispatch, or if {@link #complete}     * was called     *     * @see ServletRequest#getDispatcherType     */    public void dispatch(String path);    /**     * Dispatches the request and response objects of this AsyncContext     * to the given &lt;tt&gt;path&lt;/tt&gt; scoped to the given &lt;tt&gt;context&lt;/tt&gt;.     *     * &lt;p&gt;The &lt;tt&gt;path&lt;/tt&gt; parameter is interpreted in the same way      * as in {@link ServletRequest#getRequestDispatcher(String)}, except that     * it is scoped to the given &lt;tt&gt;context&lt;/tt&gt;.     *     * &lt;p&gt;All path related query methods of the request must reflect the     * dispatch target, while the original request URI, context path,     * path info, servlet path, and query string may be recovered from     * the {@link #ASYNC_REQUEST_URI}, {@link #ASYNC_CONTEXT_PATH},     * {@link #ASYNC_PATH_INFO}, {@link #ASYNC_SERVLET_PATH}, and     * {@link #ASYNC_QUERY_STRING} attributes of the request. These     * attributes will always reflect the original path elements, even under     * repeated dispatches.     *     * &lt;p&gt;There can be at most one asynchronous dispatch operation per     * asynchronous cycle, which is started by a call to one of the     * {@link ServletRequest#startAsync} methods. Any attempt to perform an     * additional asynchronous dispatch operation within the same     * asynchronous cycle will result in an IllegalStateException.     * If startAsync is subsequently called on the dispatched request,     * then any of the dispatch or {@link #complete} methods may be called.     *     * &lt;p&gt;See {@link #dispatch()} for additional details, including error     * handling.     *     * @param context the ServletContext of the dispatch target     * @param path the path of the dispatch target, scoped to the given     * ServletContext     *     * @throws IllegalStateException if one of the dispatch methods     * has been called and the startAsync method has not been     * called during the resulting dispatch, or if {@link #complete}     * was called     *     * @see ServletRequest#getDispatcherType     */    public void dispatch(ServletContext context, String path);    /**     * Completes the asynchronous operation that was started on the request     * that was used to initialze this AsyncContext, closing the response     * that was used to initialize this AsyncContext.     *     * &lt;p&gt;Any listeners of type {@link AsyncListener} that were registered     * with the ServletRequest for which this AsyncContext was created will     * be invoked at their {@link AsyncListener#onComplete(AsyncEvent)     * onComplete} method.     *     * &lt;p&gt;It is legal to call this method any time after a call to     * {@link ServletRequest#startAsync()} or     * {@link ServletRequest#startAsync(ServletRequest, ServletResponse)},     * and before a call to one of the &lt;tt&gt;dispatch&lt;/tt&gt; methods     * of this class.      * If this method is called before the container-initiated dispatch     * that called &lt;tt&gt;startAsync&lt;/tt&gt; has returned to the container, then     * the call will not take effect (and any invocations of     * {@link AsyncListener#onComplete(AsyncEvent)} will be delayed) until     * after the container-initiated dispatch has returned to the container.     */    public void complete();    /**     * Causes the container to dispatch a thread, possibly from a managed     * thread pool, to run the specified &lt;tt&gt;Runnable&lt;/tt&gt;. The container may     * propagate appropriate contextual information to the &lt;tt&gt;Runnable&lt;/tt&gt;.      *     * @param run the asynchronous handler     */    public void start(Runnable run);    /**     * Registers the given {@link AsyncListener} with the most recent     * asynchronous cycle that was started by a call to one of the     * {@link ServletRequest#startAsync} methods.     *     * &lt;p&gt;The given AsyncListener will receive an {@link AsyncEvent} when     * the asynchronous cycle completes successfully, times out, or results     * in an error.     *     * &lt;p&gt;AsyncListener instances will be notified in the order in which     * they were added.     *     * @param listener the AsyncListener to be registered     *      * @throws IllegalStateException if this method is called after     * the container-initiated dispatch, during which one of the     * {@link ServletRequest#startAsync} methods was called, has     * returned to the container     */    public void addListener(AsyncListener listener);    /**     * Registers the given {@link AsyncListener} with the most recent     * asynchronous cycle that was started by a call to one of the     * {@link ServletRequest#startAsync} methods.     *     * &lt;p&gt;The given AsyncListener will receive an {@link AsyncEvent} when     * the asynchronous cycle completes successfully, times out, or results     * in an error.     *     * &lt;p&gt;AsyncListener instances will be notified in the order in which     * they were added.     *     * &lt;p&gt;The given ServletRequest and ServletResponse objects will     * be made available to the given AsyncListener via the     * {@link AsyncEvent#getSuppliedRequest getSuppliedRequest} and     * {@link AsyncEvent#getSuppliedResponse getSuppliedResponse} methods,     * respectively, of the {@link AsyncEvent} delivered to it. These objects     * should not be read from or written to, respectively, at the time the     * AsyncEvent is delivered, because additional wrapping may have     * occurred since the given AsyncListener was registered, but may be used     * in order to release any resources associated with them.     *     * @param listener the AsyncListener to be registered     * @param servletRequest the ServletRequest that will be included     * in the AsyncEvent     * @param servletResponse the ServletResponse that will be included     * in the AsyncEvent     *     * @throws IllegalStateException if this method is called after     * the container-initiated dispatch, during which one of the     * {@link ServletRequest#startAsync} methods was called, has     * returned to the container     */    public void addListener(AsyncListener listener,                            ServletRequest servletRequest,                            ServletResponse servletResponse);    /**     * Instantiates the given {@link AsyncListener} class.     *     * &lt;p&gt;The returned AsyncListener instance may be further customized     * before it is registered with this AsyncContext via a call to one of      * the &lt;code&gt;addListener&lt;/code&gt; methods.     *     * &lt;p&gt;The given AsyncListener class must define a zero argument     * constructor, which is used to instantiate it.     *     * &lt;p&gt;This method supports resource injection if the given     * &lt;tt&gt;clazz&lt;/tt&gt; represents a Managed Bean.     * See the Java EE platform and JSR 299 specifications for additional     * details about Managed Beans and resource injection.     * &lt;p&gt;This method supports any annotations applicable to AsyncListener.     *     * @param clazz the AsyncListener class to instantiate     *     * @return the new AsyncListener instance     *     * @throws ServletException if the given &lt;tt&gt;clazz&lt;/tt&gt; fails to be     * instantiated     */    public &lt;T extends AsyncListener&gt; T createListener(Class&lt;T&gt; clazz)        throws ServletException;     /**     * Sets the timeout (in milliseconds) for this AsyncContext.     *     * &lt;p&gt;The timeout applies to this AsyncContext once the     * container-initiated dispatch during which one of the     * {@link ServletRequest#startAsync} methods was called has     * returned to the container.      *     * &lt;p&gt;The timeout will expire if neither the {@link #complete} method     * nor any of the dispatch methods are called. A timeout value of     * zero or less indicates no timeout.      *      * &lt;p&gt;If {@link #setTimeout} is not called, then the container&#39;s     * default timeout, which is available via a call to     * {@link #getTimeout}, will apply.     *     * @param timeout the timeout in milliseconds     *     * @throws IllegalStateException if this method is called after     * the container-initiated dispatch, during which one of the     * {@link ServletRequest#startAsync} methods was called, has     * returned to the container     */    public void setTimeout(long timeout);    /**     * Gets the timeout (in milliseconds) for this AsyncContext.     *     * &lt;p&gt;This method returns the container&#39;s default timeout for     * asynchronous operations, or the timeout value passed to the most     * recent invocation of {@link #setTimeout}.     *     * &lt;p&gt;A timeout value of zero or less indicates no timeout.     *     * @return the timeout in milliseconds     */    public long getTimeout();}</code></pre><pre><code> 比较简单，通过看代码中的注释就能知其大意了，异步就是不等待结果立即返回，这里start一般用新线程的方式，线程运行完后(#complete)，需要通知（#addListener）,以及超时检测处理（#setTimeout,由容器Tomcat来设置）</code></pre><h4 id="AsyncListener监听器"><a href="#AsyncListener监听器" class="headerlink" title="AsyncListener监听器"></a>AsyncListener监听器</h4><pre><code class="java">package javax.servlet;import java.io.IOException;import java.util.EventListener;/** * Listener that will be notified in the event that an asynchronous * operation initiated on a ServletRequest to which the listener had been  * added has completed, timed out, or resulted in an error. * * @since Servlet 3.0 */public interface AsyncListener extends EventListener {    /**     * Notifies this AsyncListener that an asynchronous operation     * has been completed.     *      * &lt;p&gt;The {@link AsyncContext} corresponding to the asynchronous     * operation that has been completed may be obtained by calling     * {@link AsyncEvent#getAsyncContext getAsyncContext} on the given     * &lt;tt&gt;event&lt;/tt&gt;.     *     * &lt;p&gt;In addition, if this AsyncListener had been registered via a call     * to {@link AsyncContext#addListener(AsyncListener,     * ServletRequest, ServletResponse)}, the supplied ServletRequest and     * ServletResponse objects may be retrieved by calling     * {@link AsyncEvent#getSuppliedRequest getSuppliedRequest} and     * {@link AsyncEvent#getSuppliedResponse getSuppliedResponse},     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.     *     * @param event the AsyncEvent indicating that an asynchronous     * operation has been completed     *     * @throws IOException if an I/O related error has occurred during the     * processing of the given AsyncEvent     */    public void onComplete(AsyncEvent event) throws IOException;    /**     * Notifies this AsyncListener that an asynchronous operation     * has timed out.     *      * &lt;p&gt;The {@link AsyncContext} corresponding to the asynchronous     * operation that has timed out may be obtained by calling     * {@link AsyncEvent#getAsyncContext getAsyncContext} on the given     * &lt;tt&gt;event&lt;/tt&gt;.     *     * &lt;p&gt;In addition, if this AsyncListener had been registered via a call     * to {@link AsyncContext#addListener(AsyncListener,     * ServletRequest, ServletResponse)}, the supplied ServletRequest and     * ServletResponse objects may be retrieved by calling     * {@link AsyncEvent#getSuppliedRequest getSuppliedRequest} and     * {@link AsyncEvent#getSuppliedResponse getSuppliedResponse},     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.     *     * @param event the AsyncEvent indicating that an asynchronous     * operation has timed out     *     * @throws IOException if an I/O related error has occurred during the     * processing of the given AsyncEvent     */    public void onTimeout(AsyncEvent event) throws IOException;    /**     * Notifies this AsyncListener that an asynchronous operation      * has failed to complete.     *      * &lt;p&gt;The {@link AsyncContext} corresponding to the asynchronous     * operation that failed to complete may be obtained by calling     * {@link AsyncEvent#getAsyncContext getAsyncContext} on the given     * &lt;tt&gt;event&lt;/tt&gt;.     *      * &lt;p&gt;In addition, if this AsyncListener had been registered via a call     * to {@link AsyncContext#addListener(AsyncListener,     * ServletRequest, ServletResponse)}, the supplied ServletRequest and     * ServletResponse objects may be retrieved by calling     * {@link AsyncEvent#getSuppliedRequest getSuppliedRequest} and     * {@link AsyncEvent#getSuppliedResponse getSuppliedResponse},     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.     *     * @param event the AsyncEvent indicating that an asynchronous     * operation has failed to complete     *     * @throws IOException if an I/O related error has occurred during the     * processing of the given AsyncEvent     */    public void onError(AsyncEvent event) throws IOException;    /**     * Notifies this AsyncListener that a new asynchronous cycle is being     * initiated via a call to one of the {@link ServletRequest#startAsync}     * methods.     *     * &lt;p&gt;The {@link AsyncContext} corresponding to the asynchronous     * operation that is being reinitialized may be obtained by calling     * {@link AsyncEvent#getAsyncContext getAsyncContext} on the given     * &lt;tt&gt;event&lt;/tt&gt;.     *      * &lt;p&gt;In addition, if this AsyncListener had been registered via a call     * to {@link AsyncContext#addListener(AsyncListener,     * ServletRequest, ServletResponse)}, the supplied ServletRequest and     * ServletResponse objects may be retrieved by calling     * {@link AsyncEvent#getSuppliedRequest getSuppliedRequest} and     * {@link AsyncEvent#getSuppliedResponse getSuppliedResponse},     * respectively, on the given &lt;tt&gt;event&lt;/tt&gt;.     *     * &lt;p&gt;This AsyncListener will not receive any events related to the     * new asynchronous cycle unless it registers itself (via a call     * to {@link AsyncContext#addListener}) with the AsyncContext that     * is delivered as part of the given AsyncEvent.     *     * @param event the AsyncEvent indicating that a new asynchronous     * cycle is being initiated     *     * @throws IOException if an I/O related error has occurred during the     * processing of the given AsyncEvent     */    public void onStartAsync(AsyncEvent event) throws IOException;     }</code></pre><p>​    监听器主要有4个事件，开始、完成、超时、错误。</p><h3 id="SpringMVC中的相关组件"><a href="#SpringMVC中的相关组件" class="headerlink" title="SpringMVC中的相关组件"></a>SpringMVC中的相关组件</h3><p>​    SpringMVC中异步请求相关组件 AsyncWebRequest、WebAsyncManager、WebAsyncUtils    </p><h4 id="AsyncWebRequest"><a href="#AsyncWebRequest" class="headerlink" title="AsyncWebRequest"></a>AsyncWebRequest</h4><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fydgk0syd0j30u019f7aj.jpg" alt="image-20181220195645682"></p><p>其实现有两个，其中<code>NoSupportAsyncWebRequest</code>不支持异步，所以我们只需要关注<code>StandarServletAsyncWebRequest</code>即可。（可以看到其实主要是对Servelt中支持异步的类的一些特性进行整合）</p><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fydgqk142nj31bm0pawie.jpg" alt="image-20181220200306736"></p><blockquote><p>具体细节看StandarServletAsyncWebRequest的实现</p></blockquote><h4 id="WebAsyncManager"><a href="#WebAsyncManager" class="headerlink" title="WebAsyncManager"></a>WebAsyncManager</h4><pre><code class="java">package org.springframework.web.context.request.async;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.concurrent.Callable;import javax.servlet.http.HttpServletRequest;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.core.task.AsyncTaskExecutor;import org.springframework.core.task.SimpleAsyncTaskExecutor;import org.springframework.util.Assert;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.async.DeferredResult.DeferredResultHandler;import org.springframework.web.util.UrlPathHelper;/** * The central class for managing asynchronous request processing, mainly intended * as an SPI and not typically used directly by application classes. * * &lt;p&gt;An async scenario starts with request processing as usual in a thread (T1). * Concurrent request handling can be initiated by calling * {@link #startCallableProcessing(Callable, Object...) startCallableProcessing} or * {@link #startDeferredResultProcessing(DeferredResult, Object...) startDeferredResultProcessing}, * both of which produce a result in a separate thread (T2). The result is saved * and the request dispatched to the container, to resume processing with the saved * result in a third thread (T3). Within the dispatched thread (T3), the saved * result can be accessed via {@link #getConcurrentResult()} or its presence * detected via {@link #hasConcurrentResult()}. * * @author Rossen Stoyanchev * @since 3.2 * * @see org.springframework.web.context.request.AsyncWebRequestInterceptor * @see org.springframework.web.servlet.AsyncHandlerInterceptor * @see org.springframework.web.filter.OncePerRequestFilter#shouldNotFilterAsyncDispatch * @see org.springframework.web.filter.OncePerRequestFilter#isAsyncDispatch */public final class WebAsyncManager {   private static final Object RESULT_NONE = new Object();   private static final Log logger = LogFactory.getLog(WebAsyncManager.class);   private static final UrlPathHelper urlPathHelper = new UrlPathHelper();   private static final CallableProcessingInterceptor timeoutCallableInterceptor =         new TimeoutCallableProcessingInterceptor();   private static final DeferredResultProcessingInterceptor timeoutDeferredResultInterceptor =         new TimeoutDeferredResultProcessingInterceptor();   private AsyncWebRequest asyncWebRequest;   private AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(this.getClass().getSimpleName());   private Object concurrentResult = RESULT_NONE;   private Object[] concurrentResultContext;   private final Map&lt;Object, CallableProcessingInterceptor&gt; callableInterceptors =         new LinkedHashMap&lt;Object, CallableProcessingInterceptor&gt;();   private final Map&lt;Object, DeferredResultProcessingInterceptor&gt; deferredResultInterceptors =         new LinkedHashMap&lt;Object, DeferredResultProcessingInterceptor&gt;();   /**    * Package private constructor.    * @see WebAsyncUtils#getAsyncManager(javax.servlet.ServletRequest)    * @see WebAsyncUtils#getAsyncManager(org.springframework.web.context.request.WebRequest)    */   WebAsyncManager() {   }   /**    * Configure the {@link AsyncWebRequest} to use. This property may be set    * more than once during a single request to accurately reflect the current    * state of the request (e.g. following a forward, request/response    * wrapping, etc). However, it should not be set while concurrent handling    * is in progress, i.e. while {@link #isConcurrentHandlingStarted()} is    * {@code true}.    *    * @param asyncWebRequest the web request to use    */   public void setAsyncWebRequest(final AsyncWebRequest asyncWebRequest) {      Assert.notNull(asyncWebRequest, &quot;AsyncWebRequest must not be null&quot;);      Assert.state(!isConcurrentHandlingStarted(), &quot;Can&#39;t set AsyncWebRequest with concurrent handling in progress&quot;);      this.asyncWebRequest = asyncWebRequest;      this.asyncWebRequest.addCompletionHandler(new Runnable() {         @Override         public void run() {            asyncWebRequest.removeAttribute(WebAsyncUtils.WEB_ASYNC_MANAGER_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);         }      });   }   /**    * Configure an AsyncTaskExecutor for use with concurrent processing via    * {@link #startCallableProcessing(Callable, Object...)}.    * &lt;p&gt;By default a {@link SimpleAsyncTaskExecutor} instance is used.    */   public void setTaskExecutor(AsyncTaskExecutor taskExecutor) {      this.taskExecutor = taskExecutor;   }   /**    * Whether the selected handler for the current request chose to handle the    * request asynchronously. A return value of &quot;true&quot; indicates concurrent    * handling is under way and the response will remain open. A return value    * of &quot;false&quot; means concurrent handling was either not started or possibly    * that it has completed and the request was dispatched for further    * processing of the concurrent result.    */   public boolean isConcurrentHandlingStarted() {      return ((this.asyncWebRequest != null) &amp;&amp; this.asyncWebRequest.isAsyncStarted());   }   /**    * Whether a result value exists as a result of concurrent handling.    */   public boolean hasConcurrentResult() {      return (this.concurrentResult != RESULT_NONE);   }   /**    * Provides access to the result from concurrent handling.    *    * @return an Object, possibly an {@code Exception} or {@code Throwable} if    * concurrent handling raised one.    * @see #clearConcurrentResult()    */   public Object getConcurrentResult() {      return this.concurrentResult;   }   /**    * Provides access to additional processing context saved at the start of    * concurrent handling.    *    * @see #clearConcurrentResult()    */   public Object[] getConcurrentResultContext() {      return this.concurrentResultContext;   }   /**    * Get the {@link CallableProcessingInterceptor} registered under the given key.    * @param key the key    * @return the interceptor registered under that key or {@code null}    */   public CallableProcessingInterceptor getCallableInterceptor(Object key) {      return this.callableInterceptors.get(key);   }   /**    * Get the {@link DeferredResultProcessingInterceptor} registered under the given key.    * @param key the key    * @return the interceptor registered under that key or {@code null}    */   public DeferredResultProcessingInterceptor getDeferredResultInterceptor(Object key) {      return this.deferredResultInterceptors.get(key);   }   /**    * Register a {@link CallableProcessingInterceptor} under the given key.    * @param key the key    * @param interceptor the interceptor to register    */   public void registerCallableInterceptor(Object key, CallableProcessingInterceptor interceptor) {      Assert.notNull(key, &quot;Key is required&quot;);      Assert.notNull(interceptor, &quot;CallableProcessingInterceptor  is required&quot;);      this.callableInterceptors.put(key, interceptor);   }   /**    * Register a {@link CallableProcessingInterceptor} without a key.    * The key is derived from the class name and hashcode.    * @param interceptors one or more interceptors to register    */   public void registerCallableInterceptors(CallableProcessingInterceptor... interceptors) {      Assert.notNull(interceptors, &quot;A CallableProcessingInterceptor is required&quot;);      for (CallableProcessingInterceptor interceptor : interceptors) {         String key = interceptor.getClass().getName() + &quot;:&quot; + interceptor.hashCode();         this.callableInterceptors.put(key, interceptor);      }   }   /**    * Register a {@link DeferredResultProcessingInterceptor} under the given key.    * @param key the key    * @param interceptor the interceptor to register    */   public void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor) {      Assert.notNull(key, &quot;Key is required&quot;);      Assert.notNull(interceptor, &quot;DeferredResultProcessingInterceptor is required&quot;);      this.deferredResultInterceptors.put(key, interceptor);   }   /**    * Register a {@link DeferredResultProcessingInterceptor} without a key.    * The key is derived from the class name and hashcode.    * @param interceptors one or more interceptors to register    */   public void registerDeferredResultInterceptors(DeferredResultProcessingInterceptor... interceptors) {      Assert.notNull(interceptors, &quot;A DeferredResultProcessingInterceptor is required&quot;);      for (DeferredResultProcessingInterceptor interceptor : interceptors) {         String key = interceptors.getClass().getName() + &quot;:&quot; + interceptors.hashCode();         this.deferredResultInterceptors.put(key, interceptor);      }   }   /**    * Clear {@linkplain #getConcurrentResult() concurrentResult} and    * {@linkplain #getConcurrentResultContext() concurrentResultContext}.    */   public void clearConcurrentResult() {      this.concurrentResult = RESULT_NONE;      this.concurrentResultContext = null;   }   /**    * Start concurrent request processing and execute the given task with an    * {@link #setTaskExecutor(AsyncTaskExecutor) AsyncTaskExecutor}. The result    * from the task execution is saved and the request dispatched in order to    * resume processing of that result. If the task raises an Exception then    * the saved result will be the raised Exception.    *    * @param callable a unit of work to be executed asynchronously    * @param processingContext additional context to save that can be accessed    * via {@link #getConcurrentResultContext()}    * @throws Exception If concurrent processing failed to start    *    * @see #getConcurrentResult()    * @see #getConcurrentResultContext()    */   @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot; })   public void startCallableProcessing(final Callable&lt;?&gt; callable, Object... processingContext) throws Exception {      Assert.notNull(callable, &quot;Callable must not be null&quot;);      startCallableProcessing(new WebAsyncTask(callable), processingContext);   }   /**    * Use the given {@link WebAsyncTask} to configure the task executor as well as    * the timeout value of the {@code AsyncWebRequest} before delegating to    * {@link #startCallableProcessing(Callable, Object...)}.    *    * @param webAsyncTask a WebAsyncTask containing the target {@code Callable}    * @param processingContext additional context to save that can be accessed    * via {@link #getConcurrentResultContext()}    * @throws Exception If concurrent processing failed to start    */   public void startCallableProcessing(final WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext) throws Exception {      Assert.notNull(webAsyncTask, &quot;WebAsyncTask must not be null&quot;);      Assert.state(this.asyncWebRequest != null, &quot;AsyncWebRequest must not be null&quot;);      Long timeout = webAsyncTask.getTimeout();      if (timeout != null) {         this.asyncWebRequest.setTimeout(timeout);      }      AsyncTaskExecutor executor = webAsyncTask.getExecutor();      if (executor != null) {         this.taskExecutor = executor;      }      List&lt;CallableProcessingInterceptor&gt; interceptors = new ArrayList&lt;CallableProcessingInterceptor&gt;();      interceptors.add(webAsyncTask.getInterceptor());      interceptors.addAll(this.callableInterceptors.values());      interceptors.add(timeoutCallableInterceptor);      final Callable&lt;?&gt; callable = webAsyncTask.getCallable();      final CallableInterceptorChain interceptorChain = new CallableInterceptorChain(interceptors);      this.asyncWebRequest.addTimeoutHandler(new Runnable() {         @Override         public void run() {            logger.debug(&quot;Processing timeout&quot;);            Object result = interceptorChain.triggerAfterTimeout(asyncWebRequest, callable);            if (result != CallableProcessingInterceptor.RESULT_NONE) {               setConcurrentResultAndDispatch(result);            }         }      });      this.asyncWebRequest.addCompletionHandler(new Runnable() {         @Override         public void run() {            interceptorChain.triggerAfterCompletion(asyncWebRequest, callable);         }      });      interceptorChain.applyBeforeConcurrentHandling(asyncWebRequest, callable);      startAsyncProcessing(processingContext);      this.taskExecutor.submit(new Runnable() {         @Override         public void run() {            Object result = null;            try {               interceptorChain.applyPreProcess(asyncWebRequest, callable);               result = callable.call();            }            catch (Throwable t) {               result = t;            }            finally {               result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result);            }            setConcurrentResultAndDispatch(result);         }      });   }   private void setConcurrentResultAndDispatch(Object result) {      synchronized (WebAsyncManager.this) {         if (hasConcurrentResult()) {            return;         }         concurrentResult = result;      }      if (asyncWebRequest.isAsyncComplete()) {         logger.error(&quot;Could not complete async processing due to timeout or network error&quot;);         return;      }      logger.debug(&quot;Concurrent result value [&quot; + concurrentResult + &quot;]&quot;);      logger.debug(&quot;Dispatching request to resume processing&quot;);      asyncWebRequest.dispatch();   }   /**    * Start concurrent request processing and initialize the given    * {@link DeferredResult} with a {@link DeferredResultHandler} that saves    * the result and dispatches the request to resume processing of that    * result. The {@code AsyncWebRequest} is also updated with a completion    * handler that expires the {@code DeferredResult} and a timeout handler    * assuming the {@code DeferredResult} has a default timeout result.    *    * @param deferredResult the DeferredResult instance to initialize    * @param processingContext additional context to save that can be accessed    * via {@link #getConcurrentResultContext()}    * @throws Exception If concurrent processing failed to start    *    * @see #getConcurrentResult()    * @see #getConcurrentResultContext()    */   public void startDeferredResultProcessing(         final DeferredResult&lt;?&gt; deferredResult, Object... processingContext) throws Exception {      Assert.notNull(deferredResult, &quot;DeferredResult must not be null&quot;);      Assert.state(this.asyncWebRequest != null, &quot;AsyncWebRequest must not be null&quot;);      Long timeout = deferredResult.getTimeoutValue();      if (timeout != null) {         this.asyncWebRequest.setTimeout(timeout);      }      List&lt;DeferredResultProcessingInterceptor&gt; interceptors = new ArrayList&lt;DeferredResultProcessingInterceptor&gt;();      interceptors.add(deferredResult.getInterceptor());      interceptors.addAll(this.deferredResultInterceptors.values());      interceptors.add(timeoutDeferredResultInterceptor);      final DeferredResultInterceptorChain interceptorChain = new DeferredResultInterceptorChain(interceptors);      this.asyncWebRequest.addTimeoutHandler(new Runnable() {         @Override         public void run() {            try {               interceptorChain.triggerAfterTimeout(asyncWebRequest, deferredResult);            }            catch (Throwable t) {               setConcurrentResultAndDispatch(t);            }         }      });      this.asyncWebRequest.addCompletionHandler(new Runnable() {         @Override         public void run() {            interceptorChain.triggerAfterCompletion(asyncWebRequest, deferredResult);         }      });      interceptorChain.applyBeforeConcurrentHandling(asyncWebRequest, deferredResult);      startAsyncProcessing(processingContext);      try {         interceptorChain.applyPreProcess(this.asyncWebRequest, deferredResult);         deferredResult.setResultHandler(new DeferredResultHandler() {            @Override            public void handleResult(Object result) {               result = interceptorChain.applyPostProcess(asyncWebRequest, deferredResult, result);               setConcurrentResultAndDispatch(result);            }         });      }      catch (Throwable t) {         setConcurrentResultAndDispatch(t);      }   }   private void startAsyncProcessing(Object[] processingContext) {      clearConcurrentResult();      this.concurrentResultContext = processingContext;      this.asyncWebRequest.startAsync();      if (logger.isDebugEnabled()) {         HttpServletRequest request = this.asyncWebRequest.getNativeRequest(HttpServletRequest.class);         String requestUri = urlPathHelper.getRequestUri(request);         logger.debug(&quot;Concurrent handling starting for &quot; + request.getMethod() + &quot; [&quot; + requestUri + &quot;]&quot;);      }   }}</code></pre><p>​    类中有两个重要的方法#startCallableProcessing（用于处理Callable和WebAsyncTask类型），#startDeferredResultProcessing（用于处理DeferredResult和ListenableFuture类型）,是启动异步处理的入口方法，它们一共做了三件事</p><ul><li>启动异步处理</li><li>给Request设置相应属性（timeout、timeoutHandler和completionHandler）</li><li>在相应的位置调用相应的拦截器（CallableProcessingInterceptor和DeferredResultProcessingInterceptor都封装在相应的Chain中）</li></ul><blockquote><p>更多细节 可查看startCallableProcessing的执行过程</p></blockquote><h4 id="WebAsyncUtils"><a href="#WebAsyncUtils" class="headerlink" title="WebAsyncUtils"></a>WebAsyncUtils</h4><pre><code class="java">package org.springframework.web.context.request.async;import java.lang.reflect.Constructor;import javax.servlet.ServletRequest;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.BeanUtils;import org.springframework.util.ClassUtils;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.WebRequest;/** * Utility methods related to processing asynchronous web requests. * * @author Rossen Stoyanchev * @since 3.2 */public abstract class WebAsyncUtils {   public static final String WEB_ASYNC_MANAGER_ATTRIBUTE = WebAsyncManager.class.getName() + &quot;.WEB_ASYNC_MANAGER&quot;;   private static Constructor&lt;?&gt; standardAsyncRequestConstructor;   /**    * Obtain the {@link WebAsyncManager} for the current request, or if not    * found, create and associate it with the request.    */   public static WebAsyncManager getAsyncManager(ServletRequest servletRequest) {      WebAsyncManager asyncManager = (WebAsyncManager) servletRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE);      if (asyncManager == null) {         asyncManager = new WebAsyncManager();         servletRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager);      }      return asyncManager;   }   /**    * Obtain the {@link WebAsyncManager} for the current request, or if not    * found, create and associate it with the request.    */   public static WebAsyncManager getAsyncManager(WebRequest webRequest) {      int scope = RequestAttributes.SCOPE_REQUEST;      WebAsyncManager asyncManager = (WebAsyncManager) webRequest.getAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, scope);      if (asyncManager == null) {         asyncManager = new WebAsyncManager();         webRequest.setAttribute(WEB_ASYNC_MANAGER_ATTRIBUTE, asyncManager, scope);      }      return asyncManager;   }   /**    * Create an AsyncWebRequest instance. By default an instance of    * {@link StandardServletAsyncWebRequest} is created if running in Servlet    * 3.0 (or higher) environment or as a fallback, an instance of    * {@link NoSupportAsyncWebRequest} is returned.    *    * @param request the current request    * @param response the current response    * @return an AsyncWebRequest instance, never {@code null}    */   public static AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) {      return ClassUtils.hasMethod(ServletRequest.class, &quot;startAsync&quot;) ?            createStandardServletAsyncWebRequest(request, response) : new NoSupportAsyncWebRequest(request, response);   }   private static AsyncWebRequest createStandardServletAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) {      try {         if (standardAsyncRequestConstructor == null) {            String className = &quot;org.springframework.web.context.request.async.StandardServletAsyncWebRequest&quot;;            Class&lt;?&gt; clazz = ClassUtils.forName(className, WebAsyncUtils.class.getClassLoader());            standardAsyncRequestConstructor = clazz.getConstructor(HttpServletRequest.class, HttpServletResponse.class);         }         return (AsyncWebRequest) BeanUtils.instantiateClass(standardAsyncRequestConstructor, request, response);      }      catch (Throwable t) {         throw new IllegalStateException(&quot;Failed to instantiate StandardServletAsyncWebRequest&quot;, t);      }   }}</code></pre><p>​    可以看到这个类主要是提供WebAsyncManage、AsyncWebRequest 相关的操作</p><h3 id="SpringMVC中请求的支持"><a href="#SpringMVC中请求的支持" class="headerlink" title="SpringMVC中请求的支持"></a>SpringMVC中请求的支持</h3><ol><li><p><code>FrameworkServlet</code>中添加了<code>RequestBindingInterceptor</code></p></li><li><p><code>RequestMappingHandlerAdapter</code>的<code>#invokeHandlerMethod</code> 提供了对异步请求的核心支持</p><p> ​    2.1 创建<code>AsyncWebRequest</code>并设置超时时间</p><p> ​    2.2 对当前请求<code>WebAsyncManager</code>设置了属性<code>（taskExecutor、asyncWebRequest、callabltinterceptors和deferredResultInterceptors）</code></p><p> ​    2.3 并判断是否有结果，如果有对结果进行处理。<code>requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</code></p><p> ​    2.4 然后执行方法 <code>requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</code></p></li><li><p>返回值处理器，<code>AsyncTaskMethodReturnValueHandler</code> <code>CallableMethodReturnValueHandler</code> <code>DeferredResultMethodReturnValueHandler</code> <code>ListenableFutureReturnValueHandler</code></p></li><li><p><code>DispatcherServlet</code>的<code>#doDispatcher</code>，如果是异步直接返回。</p></li></ol><pre><code class="java">/** * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView} * if view resolution is required. */private ModelAndView invokeHandleMethod(HttpServletRequest request,      HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {   ServletWebRequest webRequest = new ServletWebRequest(request, response);   WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);   ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);   ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);   ModelAndViewContainer mavContainer = new ModelAndViewContainer();   mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));   modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);   mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);   AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);   asyncWebRequest.setTimeout(this.asyncRequestTimeout);   final WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);   asyncManager.setTaskExecutor(this.taskExecutor);   asyncManager.setAsyncWebRequest(asyncWebRequest);   asyncManager.registerCallableInterceptors(this.callableInterceptors);   asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);   if (asyncManager.hasConcurrentResult()) {      Object result = asyncManager.getConcurrentResult();      mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];      asyncManager.clearConcurrentResult();      if (logger.isDebugEnabled()) {         logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);      }      requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);   }   requestMappingMethod.invokeAndHandle(webRequest, mavContainer);   if (asyncManager.isConcurrentHandlingStarted()) {      return null;   }   return getModelAndView(mavContainer, modelFactory, webRequest);}</code></pre><p>##### </p><h3 id="spring-webFlux"><a href="#spring-webFlux" class="headerlink" title="spring webFlux"></a>spring webFlux</h3><p>等待填坑</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> servlet </tag>
            
            <tag> spring-mvc </tag>
            
            <tag> spring-webflux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet_tomcat</title>
      <link href="/2019/02/03/Overview_Tomcat/"/>
      <url>/2019/02/03/Overview_Tomcat/</url>
      
        <content type="html"><![CDATA[<p>阅读的目的？我想要从中获得什么？</p><p>​    对tomcat容器的分析 总结 ,实现servlet规范 web容器</p><h2 id="版本情况"><a href="#版本情况" class="headerlink" title="版本情况"></a>版本情况</h2><p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fztadjl1lbj31680mmtd6.jpg" alt="image-20190203155202660"></p><h2 id="Tomcat的顶层结构"><a href="#Tomcat的顶层结构" class="headerlink" title="Tomcat的顶层结构"></a>Tomcat的顶层结构</h2><ul><li><p>Catalina 管理整个Tomcat的管理类</p></li><li><p>Server 最顶层容器，代表整个服务器</p></li><li>Service 提供具体服务 （多个）</li><li>Connector 负责网络连接、request/response的创建（可以有多个连接，从servet.xml的配置也可以看出，同时提供http和https，也可以提供相同协议不同端口的连接）</li><li>Container 具体处理Servlet</li></ul><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g3j4xp3inmj30iw0bwmz4.jpg" alt="img"></p><p>贴个图(源自这里<a href="https://my.oschina.net/masterworker/blog/844225" target="_blank" rel="noopener">https://my.oschina.net/masterworker/blog/844225</a>)</p><h2 id="Tomcat的启动过程"><a href="#Tomcat的启动过程" class="headerlink" title="Tomcat的启动过程"></a>Tomcat的启动过程</h2><p><code>org.apache.catalina.startup.Bootstrap</code> 是Tomcat的入口，作用类似一个<code>CatalinaAdptor</code>，具体处理还是Catalina来完成，这样做的好处是可以把启动的入口和具体的管理类分开，从而可以很方便地创建出多种启动方式。 </p><blockquote><p>BootStrap不在Tomcat依赖包下 ，而是在bin目录 通过反射 完全松耦合</p></blockquote><pre><code class="java">package org.apache.catalina.startup;import ...;public final class Bootstrap {    private static final Log log = LogFactory.getLog(Bootstrap.class);    /**     * Daemon object used by main.     */    private static Bootstrap daemon = null;    /**     * Daemon reference.     */    private Object catalinaDaemon = null;    ClassLoader commonLoader = null;    ClassLoader catalinaLoader = null;    ClassLoader sharedLoader = null;    private void initClassLoaders() {        try {            commonLoader = createClassLoader(&quot;common&quot;, null);            if( commonLoader == null ) {                // no config file, default to this loader - we might be in a &#39;single&#39; env.                commonLoader=this.getClass().getClassLoader();            }            catalinaLoader = createClassLoader(&quot;server&quot;, commonLoader);            sharedLoader = createClassLoader(&quot;shared&quot;, commonLoader);        } catch (Throwable t) {            handleThrowable(t);            log.error(&quot;Class loader creation threw exception&quot;, t);            System.exit(1);        }    }    private ClassLoader createClassLoader(String name, ClassLoader parent)        throws Exception {        String value = CatalinaProperties.getProperty(name + &quot;.loader&quot;);        if ((value == null) || (value.equals(&quot;&quot;)))            return parent;        value = replace(value);        List&lt;Repository&gt; repositories = new ArrayList&lt;&gt;();        String[] repositoryPaths = getPaths(value);        for (String repository : repositoryPaths) {            // Check for a JAR URL repository            try {                @SuppressWarnings(&quot;unused&quot;)                URL url = new URL(repository);                repositories.add(new Repository(repository, RepositoryType.URL));                continue;            } catch (MalformedURLException e) {                // Ignore            }            // Local repository            if (repository.endsWith(&quot;*.jar&quot;)) {                repository = repository.substring                    (0, repository.length() - &quot;*.jar&quot;.length());                repositories.add(                        new Repository(repository, RepositoryType.GLOB));            } else if (repository.endsWith(&quot;.jar&quot;)) {                repositories.add(                        new Repository(repository, RepositoryType.JAR));            } else {                repositories.add(                        new Repository(repository, RepositoryType.DIR));            }        }        return ClassLoaderFactory.createClassLoader(repositories, parent);    }    /**     * Initialize daemon.     * @throws Exception Fatal initialization error     */    public void init() throws Exception {        initClassLoaders();        Thread.currentThread().setContextClassLoader(catalinaLoader);        SecurityClassLoad.securityClassLoad(catalinaLoader);        // Load our startup class and call its process() method        if (log.isDebugEnabled())            log.debug(&quot;Loading startup class&quot;);        Class&lt;?&gt; startupClass =            catalinaLoader.loadClass            (&quot;org.apache.catalina.startup.Catalina&quot;);        Object startupInstance = startupClass.newInstance();        // Set the shared extensions class loader        if (log.isDebugEnabled())            log.debug(&quot;Setting startup class properties&quot;);        String methodName = &quot;setParentClassLoader&quot;;        Class&lt;?&gt; paramTypes[] = new Class[1];        paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);        Object paramValues[] = new Object[1];        paramValues[0] = sharedLoader;        Method method =            startupInstance.getClass().getMethod(methodName, paramTypes);        method.invoke(startupInstance, paramValues);        catalinaDaemon = startupInstance;    }    /**     * Load daemon.     */    private void load(String[] arguments)        throws Exception {        // Call the load() method        String methodName = &quot;load&quot;;        Object param[];        Class&lt;?&gt; paramTypes[];        if (arguments==null || arguments.length==0) {            paramTypes = null;            param = null;        } else {            paramTypes = new Class[1];            paramTypes[0] = arguments.getClass();            param = new Object[1];            param[0] = arguments;        }        Method method =            catalinaDaemon.getClass().getMethod(methodName, paramTypes);        if (log.isDebugEnabled())            log.debug(&quot;Calling startup class &quot; + method);        method.invoke(catalinaDaemon, param);    }    // ----------------------------------------------------------- Main Program    /**     * Load the Catalina daemon.     * @param arguments Initialization arguments     * @throws Exception Fatal initialization error     */    public void init(String[] arguments)        throws Exception {        init();        load(arguments);    }    /**     * Start the Catalina daemon.     * @throws Exception Fatal start error     */    public void start()        throws Exception {        if( catalinaDaemon==null ) init();        Method method = catalinaDaemon.getClass().getMethod(&quot;start&quot;, (Class [] )null);        method.invoke(catalinaDaemon, (Object [])null);    }    /**     * Stop the Catalina Daemon.     * @throws Exception Fatal stop error     */    public void stop()        throws Exception {        //实现略,主要通过反射调用了catalina的stop    }    /**     * Stop the standalone server.     * @throws Exception Fatal stop error     */    public void stopServer()        throws Exception {        //实现略,主要通过反射调用了catalina的stopServer    }    /**     * Set flag.     * @param await &lt;code&gt;true&lt;/code&gt; if the daemon should block     * @throws Exception Reflection error     */    public void setAwait(boolean await)        throws Exception {        //实现略 ,主要通过反射调用了catalina的setAwait    }    public boolean getAwait()        throws Exception{        //实现略 ,主要通过反射调用了catalina的getAwait    }    /**     * Destroy the Catalina Daemon.     */    public void destroy() {        // FIXME    }    /**     * Main method and entry point when starting Tomcat via the provided     * scripts.     *     * @param args Command line arguments to be processed     */    public static void main(String args[]) {        if (daemon == null) {            // Don&#39;t set daemon until init() has completed            Bootstrap bootstrap = new Bootstrap();            try {                bootstrap.init();            } catch (Throwable t) {                handleThrowable(t);                t.printStackTrace();                return;            }            daemon = bootstrap;        } else {            // When running as a service the call to stop will be on a new            // thread so make sure the correct class loader is used to prevent            // a range of class not found exceptions.            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);        }        try {            String command = &quot;start&quot;;            if (args.length &gt; 0) {                command = args[args.length - 1];            }            if (command.equals(&quot;startd&quot;)) {                args[args.length - 1] = &quot;start&quot;;                daemon.load(args);                daemon.start();            } else if (command.equals(&quot;stopd&quot;)) {                args[args.length - 1] = &quot;stop&quot;;                daemon.stop();            } else if (command.equals(&quot;start&quot;)) {                daemon.setAwait(true);                daemon.load(args);                daemon.start();            } else if (command.equals(&quot;stop&quot;)) {                daemon.stopServer(args);            } else if (command.equals(&quot;configtest&quot;)) {                daemon.load(args);                if (null==daemon.getServer()) {                    System.exit(1);                }                System.exit(0);            } else {                log.warn(&quot;Bootstrap: command \&quot;&quot; + command + &quot;\&quot; does not exist.&quot;);            }        } catch (Throwable t) {            // Unwrap the Exception for clearer error reporting            if (t instanceof InvocationTargetException &amp;&amp;                    t.getCause() != null) {                t = t.getCause();            }            handleThrowable(t);            t.printStackTrace();            System.exit(1);        }    }}</code></pre><pre><code>Tomcat 启动脚本 startup.bat 是从main方法中开始的。其中主要做了:</code></pre><ul><li><p>准备容器环境，<code>init()</code>初始化类加载器, </p></li><li><p>初始化容器，调用<code>load()</code> 实际是调用catalina里的<code>init()</code></p></li><li><p>启动容器，通过引用<code>catalinaDaemon</code> 反射射调用<code>start()</code>方法（实际还是通过catalina操作容器）</p><pre><code> 关于类加载，我们都知道 J2EE 默认的类加载机制是双亲委派原则（详细查看如下🔎https://www.cnblogs.com/miduos/p/9250565.html）</code></pre><p>  通过debug可以发现  commonLoader、catalinaLoader 、sharedLoader 其实三个是同一个（底层都是URLClassLoader），原因是因为<code>catalina.properties</code> 的配置中默认是空的。</p><p>  另外在<code>init()</code> 中 <code>Thread.currentThread().setContextClassLoader(catalinaLoader);</code> </p></li></ul><h3 id="Catalina的启动过程"><a href="#Catalina的启动过程" class="headerlink" title="Catalina的启动过程"></a>Catalina的启动过程</h3><p>Catalina的启动主要是调用<code>setAwait()</code>、<code>load()</code>和<code>start()</code>方法来完成。</p><ul><li><code>setAwait()</code> 方法用于设置Server启动完成后是否进入等待状态的标记</li><li><code>load()</code>方法主要是用来加载配置文件<code>conf/server.xml</code>创建Server对象 （解析是通过Digester），然后调用Server的<code>init()</code></li><li><code>start()</code> 主要是调用Server的 <code>start()</code></li></ul><h3 id="Server的启动过程"><a href="#Server的启动过程" class="headerlink" title="Server的启动过程"></a>Server的启动过程</h3><p>Server的默认实现<code>org.apache.catalina.core.StandardServer</code> ,在其父类中<code>org.apache.catalina.util.LifecycleBase</code> 中的<code>init()</code> 实现如下</p><pre><code class="java">@Overridepublic final synchronized void init() throws LifecycleException {    if (!state.equals(LifecycleState.NEW)) {        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);    }    try {        setStateInternal(LifecycleState.INITIALIZING, null, false);        initInternal();        setStateInternal(LifecycleState.INITIALIZED, null, false);    } catch (Throwable t) {        ExceptionUtils.handleThrowable(t);        setStateInternal(LifecycleState.FAILED, null, false);        throw new LifecycleException(                sm.getString(&quot;lifecycleBase.initFail&quot;,toString()), t);    }}</code></pre><p> <code>start()</code> 实现如下</p><pre><code class="java">/** * {@inheritDoc} */@Overridepublic final synchronized void start() throws LifecycleException {    if (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||LifecycleState.STARTED.equals(state)) {        if (log.isDebugEnabled()) {            Exception e = new LifecycleException();            log.debug(sm.getString(&quot;lifecycleBase.alreadyStarted&quot;, toString()), e);        } else if (log.isInfoEnabled()) {            log.info(sm.getString(&quot;lifecycleBase.alreadyStarted&quot;, toString()));        }        return;    }    if (state.equals(LifecycleState.NEW)) {        init();    } else if (state.equals(LifecycleState.FAILED)) {        stop();    } else if (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;            !state.equals(LifecycleState.STOPPED)) {        invalidTransition(Lifecycle.BEFORE_START_EVENT);    }    try {        setStateInternal(LifecycleState.STARTING_PREP, null, false);        startInternal();        if (state.equals(LifecycleState.FAILED)) {            // This is a &#39;controlled&#39; failure. The component put itself into the            // FAILED state so call stop() to complete the clean-up.            stop();        } else if (!state.equals(LifecycleState.STARTING)) {            // Shouldn&#39;t be necessary but acts as a check that sub-classes are            // doing what they are supposed to.            invalidTransition(Lifecycle.AFTER_START_EVENT);        } else {            setStateInternal(LifecycleState.STARTED, null, false);        }    } catch (Throwable t) {        // This is an &#39;uncontrolled&#39; failure so put the component into the        // FAILED state and throw an exception.        ExceptionUtils.handleThrowable(t);        setStateInternal(LifecycleState.FAILED, null, false);        throw new LifecycleException(sm.getString(&quot;lifecycleBase.startFail&quot;, toString()), t);    }}</code></pre><p>其中 <code>startInternal() 和 initInternal()</code> 为模版方法 ，查看其实现类 可以发现是循环调用了每个<code>service</code>的<code>start()</code>和<code>init()</code></p><h3 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h3><p>类似于Server , <code>StandardService</code>的<code>initInternal()</code>和 <code>startInternal()</code>的方法主要调用<code>container</code>、<code>executors</code>、<code>mapperListener</code>、<code>connectors</code>的<code>init()</code>和<code>start()</code>方法。</p><blockquote><p>mapperListener是Mapper的监听器，可以监听container容器的变化</p><p>executors是用在connectors中管理线程的线程池，在server.xml配置文件中tomcatThreadPool</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下图为整个启动流程</p><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fyasgs52ycj30wk0k6jxv.jpg" alt="image-20181218123224591"></p><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>​        Connector用于接收请求并将请求封装成<code>Request</code>和<code>Response</code>来处理，最底层是使用Socket来进行连接的，封装完后交给Container进行处理（通过pipeline-Value管道来处理），Container处理完之后返回给Connector，最后Connector使用Socket将处理结果返回给客户端，整个请求就处理完了。</p><h3 id="Connector的结构"><a href="#Connector的结构" class="headerlink" title="Connector的结构"></a>Connector的结构</h3><p>​    <code>Connector</code>中具体是用<code>ProtocolHandler</code>来处理请求的，有多种不同的连接类型（Ajp、HTTP和Spdy）。</p><p>其中有3个非常重要的组件。（<code>Connector</code>的创建过程主要是初始化<code>ProtocolHandler</code>,serverx.xml中可配置）</p><ul><li>Endpoint  用于处理底层的Socket的网络连接，用来实现TCP/IP协议</li><li>Processor  用于将Endpoint接收到的Socket封装成Request，用来实现HTTP协议(BIO、NIO、APR)</li><li>Adapter 用于将封装好的Request交给Container进行具体处理，将适配到Servlet容器（转换<code>org.apache.coyote.Request</code>为<code>org.apache.catalina.connector.Request</code> ）</li></ul><blockquote><p>Ajp ：连接器监听8009端口，负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。</p><p>Apr : 是从操作系统级别解决异步IO问题，大幅度提高服务器的并发处理性能 <a href="http://tomcat.apache.org/tomcat-8.5-doc/apr.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-8.5-doc/apr.html</a></p><p>协议升级：在servlet 3.1之后新增 WebSocket协议，如果Processor处理之后Socket的状态是UPGRADING,则EndPoint中的handler回接着创建并调用upgrade包中的processor进行处理</p><p>request转换：Adapter转换后的request，其实就是封装了一层，  <code>public class Request implements org.apache.catalina.servlet4preview.http.HttpServletRequest</code></p></blockquote><h3 id="Pipeline-Value管道"><a href="#Pipeline-Value管道" class="headerlink" title="Pipeline-Value管道"></a>Pipeline-Value管道</h3><p>​    Piepeline的管道模型和普通的责任链模式稍微有点不同，区别主要如下</p><ul><li>每个pipeline都有特定的value，而且是在管道的最后一个执行，这个Value叫做BaseValue</li><li>上层的BaseValue（类似配货车到中转站的感觉）会调用下层容器的管道</li></ul><blockquote><p>每个BaseValue都有一个StandarValue的实现，例如WrapperValue的标准实现是StanderWrpperValue</p></blockquote><p>​    经过所有管道（EnginePipeline、HostPipeline、ContextPipeline、WrapperPieline）后，在最后的WrapperPieline的BaseValue中会创建<code>FilterChain</code>并调用其doFilter来处理请求，FilterChain包含着我们配置的与请求相匹配的<code>Filter</code>和<code>Servlet</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overview_java</title>
      <link href="/2019/02/02/Overview_java/"/>
      <url>/2019/02/02/Overview_java/</url>
      
        <content type="html"><![CDATA[<p>​    对java知识体系的整理，把知识从点到线 面的 ,学习地图</p><a id="more"></a><p>知识体系总结</p><!-- toc --><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>​    了解一手资料，官方文档，github资料 </p><p>​    书籍📚《程序员英语》 </p><h3 id="linux-计算机基础、原理"><a href="#linux-计算机基础、原理" class="headerlink" title="linux / 计算机基础、原理"></a>linux / 计算机基础、原理</h3><p>​    linux常用命令，问题定位需要知道 </p><p>​    计算机原理这里，基于冯诺伊曼模型建造的计算机分为4个子系统：存储器、算术逻辑单元、控制单元、和输入/输出单元</p><p>​    书籍📚《linux鸟哥私房菜》、《计算机原理》、《深入理解计算机原理》、《程序是怎么跑起来的》《Linux内核》</p><h3 id="网络编程-tcp-ip协议-http"><a href="#网络编程-tcp-ip协议-http" class="headerlink" title="网络编程 tcp/ip协议  http"></a>网络编程 tcp/ip协议  http</h3><p>​    TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据，IP想像成一种高速公路，TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，HTTP协议即超文本传送协议(Hypertext Transfer Protocol )</p><p>​    书籍📚《http权威指南》、《tcp/ip详解》、《图解http》、《网络是怎么链接的》</p><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><p>​    数据结构和算法，常见的排序类型，知道时间复杂度，空间复杂度等概念，==实现方面可以看jdk的集合类==</p><p>​    书籍📚 《算法》</p><h3 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h3><p>​    关系型数据库，事务隔离级别、对应解决的问题，懂的索引（b+ tree 以及相关优化）、锁（MVCC实现相关、 间隙锁），调优，定位问题</p><p>​    书籍📚 《高性能MySQL》</p><pre><code>mysql分析。—-》https://mp.weixin.qq.com/s/213sPk-0RtWwwX6YotN6eQ原因1.硬件问题。如网络速度慢，内存不足，I/O吞吐量小，磁盘空间满了等。2.没有索引或者索引失效。（一般在互联网公司，DBA会在半夜把表锁了，重新建立一遍索引，因为当你删除某个数据的时候，索引的树结构就不完整了。所以互联网公司的数据做的是假删除.一是为了做数据分析,二是为了不破坏索引 ）3.数据过多（分库分表）4.服务器调优及各个参数设置（调整my.cnf切入点1.先观察，开启慢查询日志，设置相应的阈值（比如超过3秒就是慢SQL），在生产环境跑上个一天过后，看看哪些SQL比较慢。2.Explain和慢SQL分析。比如SQL语句写的烂，索引没有或失效，关联查询太多（有时候是设计缺陷或者不得以的需求）等等。3.Show Profile是比Explain更近一步的执行细节，可以查询到执行每一个SQL都干了什么事，这些事分别花了多少秒。4.找DBA或者运维对MySQL进行服务器的参数调优。</code></pre><h2 id="Java-SE（Java-Standard-Edition）"><a href="#Java-SE（Java-Standard-Edition）" class="headerlink" title="Java SE（Java Standard Edition）"></a>Java SE（Java Standard Edition）</h2><h3 id="Java语言-语法基础"><a href="#Java语言-语法基础" class="headerlink" title="Java语言/语法基础"></a>Java语言/语法基础</h3><p>​    对象：封装性、派生性、多态性</p><p>​    切面： Java动态代理 字节码提升</p><p>​    元编程 ：泛型、 反射、 注解</p><p>​    函数编程：函数式编程、Stream API设计</p><p>​    书籍📚 《Thinking in java》 《core Java》 《SCJP考试指南》《java8函数式编程》</p><p>​    文档 官方指导文档：<a href="https://docs.oracle.com/javase/tutorial/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/index.html</a></p><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>​    Java Collections Framework Java Collections主要包括以下三部分：接口（Interface）、实现（Implemention）和算法（Algorithm）</p><h3 id="Java-IO-网络"><a href="#Java-IO-网络" class="headerlink" title="Java IO/网络"></a>Java IO/网络</h3><p>​     文件流、 java网络编程  、阻塞IO、非阻塞IO</p><p>​    书籍📚《NIO与Socket》、《Netty权威指南》、《Netty实战》</p><p>​    可以沿着这个路线深入学习，socket -&gt; Netty  -&gt; dubbo </p><p>​    Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。Socket 只是个接口不是协议</p><p>​    netty资料：==待整理==</p><p><a href="https://mp.weixin.qq.com/s/nVqjSbocs4kFFz2pJqovhQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nVqjSbocs4kFFz2pJqovhQ</a><br><a href="https://mp.weixin.qq.com/s/WBV4Tm-I5VNWXqjxMgw0yw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WBV4Tm-I5VNWXqjxMgw0yw</a><br><a href="https://www.jianshu.com/p/cde27461c226" target="_blank" rel="noopener">https://www.jianshu.com/p/cde27461c226</a><br><a href="https://mp.weixin.qq.com/s/zf_LY0MSD4S4p0wXKOyhZg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zf_LY0MSD4S4p0wXKOyhZg</a></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>​    ==J.U.C== ，多线程的整个体系基于volatile 、cas -&gt;aqs，通常需要了解的 JMM内存模型、锁、线程池、工具类 </p><p>​    书籍📚《Java并发编程艺术》 、《并发编程实践》 翻译不太好，建议看英文版、《Concurrent_Programming_in_Java》并发框架的作者DougLea写的</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​    调优，问题定位，常用的工具，jstack 等，字节码、编译过程、垃圾收集器、即时编译等、虚拟机规范</p><p>​    书籍📚《深入理解 Java 虚拟机》</p><h4 id="版本特征-待整理"><a href="#版本特征-待整理" class="headerlink" title="版本特征 ==待整理=="></a>版本特征 ==待整理==</h4><p>​    JDK发展史：从几个角度看 jvm特性、并发工具、语言特性 ，例如</p><pre><code class="html">JDK1.0版本：JAVA 虚拟机、AWTJDK1.1版本:JAR文件格式、JDBC、JavaBeans、RMI、Java语法：内部类（Inner Class）和反射（Reflection）JDK1.2版本:Java技术体系拆分为3个方向（面向桌面应用开发J2SE/面向企业级开发的J2EE/面向手机等移动端开发的J2ME）      代表性技术：EJB、Java plugin-in、JavaIDL、Swing      虚拟机中内置了JIT(JUST IN TIME)编译器、3个虚拟机并存（Classic VM /HotSpot VM/Exact VM）      语言和API级别上：添加了strictfp关键字与Collections集合类JDK1.3版本:一些类库（数学运算和新的Timer API）/JNDI服务作为平台级服务提供、使用CORBA IIOP来实现RMI通信/添加了JavaSound类库JDK1.4版本：正则表达式、异常链、NIO、日志类、XML解析器、XSLT转换器JDK1.5版本：语法：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）jmx 元数据(注解); 引入Instrumentation(Agent，jvm级别的AOP)      虚拟机和API:改进了Java的内存模型、提供了Java.util.concurrent并发包JDK1.6版本：终结了J2ME/J2SE/J2EE的命名方式，启用Java SE6/Java EE6/Java ME6的命名方式      提供动态语言支持（通过内置的Mozilla javaScript Rhion引擎实现）      提供编译API和微型HTTP服务器API，增强Instrumentation，虚拟机启动后的      虚拟机改进：锁与同步、垃圾收集、类加载JDK1.7版本：nio2 try resource autocloseable JVM新增了一套叫做invokedynamic的指令为为支持动态类型化程序语言的实现；并发API新增了轻量级的分支/合并（Fork/Join）框架      Java开源      提供新的G1收集器（G1在发布时依然处于Experimental状态）      加强对非Java语言的调用支持（JSR-292到目前没有完全实现定型）、升级类加载架构JDK1.8版本：Lambda表达式、CoinJDK1.9版本：flow reative 模块化JDK10版本：var 垃圾收集改进JDK11版本：httpclient 垃圾收集改进 Epsilon 垃圾收集器被称为“no-op”收集器，将处理内存分配而不实施任何实际的内存回收机制</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="classLoder"><a href="#classLoder" class="headerlink" title="classLoder"></a>classLoder</h5><p>​    双亲委派，以及怎么破坏双亲委派，在spring和tomcat中的体现</p><p>​    文档：<a href="https://zhuanlan.zhihu.com/p/51374915?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51374915?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p><h5 id="java官方订阅"><a href="#java官方订阅" class="headerlink" title="java官方订阅"></a>java官方订阅</h5><p>​    获取了解最新变化情况</p><p>​    文档：mail.openjdk.java.net Mailing Lists</p><h2 id="Java-EE（Enterprise-Edition）"><a href="#Java-EE（Enterprise-Edition）" class="headerlink" title="Java EE（Enterprise Edition）"></a>Java EE（Enterprise Edition）</h2><p>​    常用的技术栈spring + springmvc + mybatis(或者其他的orm框架) ，这里建议学习j2ee的常用规范</p><h3 id="Spring-Spring-boot"><a href="#Spring-Spring-boot" class="headerlink" title="Spring /Spring boot"></a>Spring /Spring boot</h3><p>​    ==注意关注版本特征==</p><p>​    spring 实现了大部分的j2ee规范，本身主要是DI（管理对象之间的关系）和AOP（切面编程） ，深度学习源码和理解它的优秀思想（简单，开放），springmvc</p><p>​    SpringBoot的简化配置，部署，自动装配。</p><p>​    书籍📚《spring实战》、《spring技术内幕》、《spring源码剖析》、《Expert One-on-One J2EE Design and Development》《Expert One-on-One J2EE Development without EJB》 spring作者写的书</p><p>​    文档：spring 动态代理 <a href="https://mp.weixin.qq.com/s/vCZP8sPrtnXWvg6IlcHQOg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vCZP8sPrtnXWvg6IlcHQOg</a></p><p>​            特性 <a href="https://mp.weixin.qq.com/s/09lMCJKvACOU_umkzu2StQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/09lMCJKvACOU_umkzu2StQ</a></p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="web-Framework框架性能"><a href="#web-Framework框架性能" class="headerlink" title="web Framework框架性能"></a>web Framework框架性能</h4><p>​    关注常用框架性能</p><p>​    文档 <a href="https://www.techempower.com/benchmarks/#section=data-r17" target="_blank" rel="noopener">https://www.techempower.com/benchmarks/#section=data-r17</a>    </p><h2 id="重视规范"><a href="#重视规范" class="headerlink" title="重视规范"></a>重视规范</h2><h3 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h3><p>​    Java语言规范、Java虚拟机规范、Java内存模型规范</p><p>​    书籍📚/文档：官方文档 ==待补充==</p><h3 id="JSR规范"><a href="#JSR规范" class="headerlink" title="JSR规范"></a>JSR规范</h3><p>​    Servlet、REST、JDBC、JNDI、JPA、JTA、Bean Validation、JMS等</p><p>​    书籍📚/文档：JSR <a href="https://jcp.org/en/jsr/platform" target="_blank" rel="noopener">https://jcp.org/en/jsr/platform</a></p><p>​    Servlet :  servlet规范 -&gt; springMVC -&gt; servelt容器 tomcat jetty</p><p>​    JNDI: Java Naming and Directory Interface，JNDI避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署。 SPI  <a href="https://www.zhihu.com/question/49667892/answer/404097870" target="_blank" rel="noopener">https://www.zhihu.com/question/49667892/answer/404097870</a>    /   <a href="https://blog.hhui.top/hexblog/2017/05/26/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/#%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9A-Z-blog" target="_blank" rel="noopener">https://blog.hhui.top/hexblog/2017/05/26/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/#%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9A-Z-blog</a></p><p>​    restful风格 —–》〉 <a href="https://mp.weixin.qq.com/s/_CeSX_lSoyg9zPxs52twRA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_CeSX_lSoyg9zPxs52twRA</a></p><h3 id="IETF规范"><a href="#IETF规范" class="headerlink" title="IETF规范"></a>IETF规范</h3><p>​    URL/URI、HTTP、REST、WebSockets等</p><p>​    书籍📚/文档：RFC 2616 新标准</p><h3 id="消息规范"><a href="#消息规范" class="headerlink" title="消息规范"></a>消息规范</h3><p>​    AMQP、MQTT</p><p>​    书籍📚/文档：官方文档 ==待补充==</p><h3 id="关系型数据库规范"><a href="#关系型数据库规范" class="headerlink" title="关系型数据库规范"></a>关系型数据库规范</h3><p>​    SQL99、SQL03等</p><p>​    书籍📚/文档：官方文档 ==待补充==</p><h3 id="Reactive-规范"><a href="#Reactive-规范" class="headerlink" title="Reactive 规范"></a>Reactive 规范</h3><p>​    Reactive Manifesto、Reactive Streams    </p><p>​    书籍📚/文档：官方文档 ==待补充==</p><h2 id="高效-优雅"><a href="#高效-优雅" class="headerlink" title="高效/优雅"></a>高效/优雅</h2><p>​    多看，多写模仿，例如spring中的设计模式，tomcat中的设计模式</p><p>​    常用工具Git、Maven 、Nginx</p><p>​    书籍📚/文档 ：《Maven实战》、《Effective Java》、《重构》、《Head First设计模式》、《测试驱动开发 by Example》、《程序员修炼之道》翻译不太好</p><h2 id="框架-中间件"><a href="#框架-中间件" class="headerlink" title="框架/中间件"></a>框架/中间件</h2><p>​    关注常用框架，以及生命周期Attic—–&gt; <a href="https://attic.apache.org/，注意主流框架的版本特征" target="_blank" rel="noopener">https://attic.apache.org/，注意主流框架的版本特征</a> / 使用了什么设计模式</p><h3 id="Web栈"><a href="#Web栈" class="headerlink" title="Web栈"></a>Web栈</h3><p>​    Struts、 Spring </p><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>​     MyBatis、Hiberante、JPA</p><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>​      Redis 、Mongo、 ELasticSearch、Hbase</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>​    CXF(WebServices)、Spring Cloud Feign(REST)、Dubbo (多协议)</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>​    Java Timer/ScheduleExecutorService、 Spring @Scheduled</p><h3 id="消息服务"><a href="#消息服务" class="headerlink" title="消息服务"></a>消息服务</h3><p>​    ActiveMQ（JMS）、RabbitMQ（AMQP）、Kafka</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>​    HttpClient(HTTP) 、Spring RestTemplate ( REST )</p><h3 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h3><p>​    Tomcat、Jetty​    </p><p>书籍📚/资料</p><p>​    《大型网络架构与中间件》、《Tomcat架构解析》</p><p>​         tomcat设计模式 <a href="https://www.cnblogs.com/coldridgeValley/p/6606271.html" target="_blank" rel="noopener">https://www.cnblogs.com/coldridgeValley/p/6606271.html</a></p><p>​    </p><h2 id="微服务演变"><a href="#微服务演变" class="headerlink" title="微服务演变"></a>微服务演变</h2><p>​    SOA向微服务的演变，衍生了许多技术，CAP 、BASE理论</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>​    如何高并发、高可用</p><h3 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h3><p>​    Nacos、Spring Cloud Feign</p><h3 id="服务注册-发现"><a href="#服务注册-发现" class="headerlink" title="服务注册/发现"></a>服务注册/发现</h3><p>​    zk、Eureka Consul。对比，使用场景。 cp、ap</p><p>​    书籍📚：《proxys到zookeeper一致性协议》</p><h3 id="路由-负载均衡"><a href="#路由-负载均衡" class="headerlink" title="路由/负载均衡"></a>路由/负载均衡</h3><p>​    Netflix Ribbon</p><h3 id="熔断-限流"><a href="#熔断-限流" class="headerlink" title="熔断/限流"></a>熔断/限流</h3><p>​    Spring Cloud Hystrix</p><p>相关技术：</p><p>​    限流 -》RateLimiter是Guava的concurrent包下的一个用于限制访问频率的类.</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>​    Spring Cloud Zuul     </p><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><p>​    分布式锁    </p><p>​    分布式事务 <a href="https://mp.weixin.qq.com/s/oKOzvN49zOhl8cwliy3SEg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oKOzvN49zOhl8cwliy3SEg</a></p><p>​        XA两阶段提交的不足  XA三阶段</p><p>​    解决一致性问题，raft、Gossip （redis）、Paxos(zk)</p><h3 id="Spring-Cloud-（侵入式）"><a href="#Spring-Cloud-（侵入式）" class="headerlink" title="Spring Cloud （侵入式）"></a>Spring Cloud （侵入式）</h3><p>​    可以看看springCloud都做了些什么实现</p><p>​    Compare with k8s  <a href="https://en.wikipedia.org/wiki/Kubernetes#Comparison_to_Spring_Cloud" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Kubernetes#Comparison_to_Spring_Cloud</a></p><p>​    相关文档/书籍📚：《领域驱动》、《SpringCloud微服务实践》</p><h3 id="Service-Mesh-（非侵入式）"><a href="#Service-Mesh-（非侵入式）" class="headerlink" title="Service Mesh （非侵入式）"></a>Service Mesh （非侵入式）</h3><p>​    kubernetes 为基础，docker为容器（<a href="https://zhuanlan.zhihu.com/p/54512286?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54512286?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336）</a></p><p>​    相关技术：CI/CD 持续集成</p><p>相关文档/书籍📚：《Docker进阶与实战》</p><h2 id="大数据生态"><a href="#大数据生态" class="headerlink" title="大数据生态"></a>大数据生态</h2><p>​    Kafka zookeeper flume</p><p>​    实时 sparker</p><p>​    离线 hive</p><h2 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h2><h3 id="开阔视野"><a href="#开阔视野" class="headerlink" title="开阔视野"></a>开阔视野</h3><p>​    正所谓站的高看得远，多关注业界发展。 </p><p>​    相关资料：<a href="https://www.zhihu.com/question/305924723/answer/556971474?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336" target="_blank" rel="noopener">https://www.zhihu.com/question/305924723/answer/556971474?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=557574927448846336</a></p><p>​    <a href="https://mp.weixin.qq.com/s/CPUaB60pue0Zf3fUL9xqvw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CPUaB60pue0Zf3fUL9xqvw</a></p><p>​    <a href="http://www.iocoder.cn/chinese-comment-repository/?xing" target="_blank" rel="noopener">http://www.iocoder.cn/chinese-comment-repository/?xing</a></p><h3 id="性能-压力测试-调优"><a href="#性能-压力测试-调优" class="headerlink" title="性能/压力测试/调优"></a>性能/压力测试/调优</h3><p>​    懂常用性能指标，以及如何预估性能</p><p>​    相关资料：</p><p>​    <a href="https://mp.weixin.qq.com/s/w0TxuFQZAIED879JRax8vg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/w0TxuFQZAIED879JRax8vg</a></p><p>​    <a href="https://mp.weixin.qq.com/s/Lz4cEt0LY_Fvqz2zAgOafw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Lz4cEt0LY_Fvqz2zAgOafw</a></p><h3 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h3><p>​    除了html、css、javascript 相关、 一些前端框架也需要了解Vue、React</p><p>​    前后端分离/单页面应用—》〉<a href="https://blog.csdn.net/Nicorui/article/details/74945839" target="_blank" rel="noopener">https://blog.csdn.net/Nicorui/article/details/74945839</a></p><p>​    书籍📚《Javascript DOM编程艺术》</p><h3 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h3><p>​    保持自我驱动和热情/不满足于完成预期</p><h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><ul><li><p>是什么 :官方、wiki、同类技术对比、组成部分、版本特性</p></li><li><p>为什么 : 解决了什么问题、没有出现之前怎么做、 自己实现的话会怎么做</p></li><li><p>怎么做  :官方示例/文档 、相关学习视频、写Demo、带着问题看源码、实践</p></li><li><p>输出 :写blog、分享</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>j2ee_servlet</title>
      <link href="/2019/02/02/Spec_Servlet/"/>
      <url>/2019/02/02/Spec_Servlet/</url>
      
        <content type="html"><![CDATA[<p>阅读的目的？我想要从中获得什么？</p><p>​    servlet规范相关 , 理解tomcat 和dispatchServlet实现</p><a id="more"></a><h2 id="servlet-3-1规范概览"><a href="#servlet-3-1规范概览" class="headerlink" title="servlet 3.1规范概览"></a>servlet 3.1规范概览</h2><h3 id="What-is-servlet"><a href="#What-is-servlet" class="headerlink" title="What is servlet"></a>What is servlet</h3><pre><code>A servlet is a JavaTM technology-based Web component, managed by a container, that generates dynamic content. </code></pre><blockquote><p>From servlet 3.1</p></blockquote><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fy9oye7wq4j31pm0hyarl.jpg" alt=""></p><blockquote><p>From wiki</p></blockquote><h3 id="Servlet-Life-Cycle"><a href="#Servlet-Life-Cycle" class="headerlink" title="Servlet Life Cycle"></a>Servlet Life Cycle</h3><ul><li><p>Loading and Instantiation</p><p>  When the servlet engine is started, needed servlet classes must be located by the<br>  servlet container(WEB-INF/lib)</p></li><li><p>Initialization</p><pre><code>  The container initializes the servlet instance by calling the init method of the Servlet interface with a unique (per servlet declaration) object implementing the ServletConfig interface</code></pre></li></ul><p>（ServletConfig used by Servlet）</p><ul><li><p>Request Handling</p><p>  After a servlet is properly initialized, the servlet container may use it to handle client<br>  requests. </p></li><li><p>End of Service</p></li></ul><h3 id="Servlet-继承结构"><a href="#Servlet-继承结构" class="headerlink" title="Servlet 继承结构"></a>Servlet 继承结构</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fycf0mk9d5j30u00u6dqo.jpg" alt="image-20181219221816845"></p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><blockquote><p>​    The ServletContext interface defines a servlet’s view of the Web application within which the servlet is running.  (web.xml) The Container Provider is responsible for providing an implementation of the ServletContext interface in the servlet container.</p></blockquote><pre><code class="markdown">InitParameterconfig     -Filter    -Listenr    -ServletAttributeResource...</code></pre><blockquote><p>see : ApplicationContext、ApplicationContextFacade (tomcat)</p></blockquote><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>HttpServletRequest</p><ul><li><p>HTTP Protocol Parameters</p><blockquote><p>■ getParameter</p><p>■ getParameterNames </p><p>■ getParameterValues </p><p>■ getParameterMap</p></blockquote></li><li><p>File upload </p><p>  content-type : multipart/form-data </p></li><li><p>Attributes </p></li><li><p>Headers</p></li><li><p>Request Path Elements</p><blockquote><p>requestURI = contextPath + servletPath + pathInfo</p></blockquote></li><li><p>Path Translation Methods</p><blockquote><p>■ ServletContext.getRealPath  </p><p>■ HttpServletRequest.getPathTranslated</p></blockquote></li><li><p>Non Blocking IO</p><p>  Non-blocking IO only works with async request processing in Servlets and Filters</p></li><li><p>Cookies</p></li><li><p>SSL</p></li><li><p>Internationalization</p><p>  Accept-Language : zh-cn</p></li><li><blockquote><p>■ getLocale<br>■ getLocales</p></blockquote></li><li><p>Request data encoding </p><p>  The default encoding of a request the container uses to create the request reader and parse POST data must be “ISO-8859-1” if none has been specified by the client request. </p></li><li><p>Lifetime of the Request Object </p><p>  Each request object is valid only within the scope of a servlet’s service method, or within the scope of a filter’s doFilter method, unless the asynchronous processing is enabled for the component and the startAsync method is invoked on the request object. </p></li></ul><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fyceza35scj30lc0luwf3.jpg" alt="image-20181219221656097"></p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p> what is Filter? </p><blockquote><p>A filter is a reusable piece of code that can transform the content of HTTP requests,responses, and header information.</p></blockquote><p>org.springframework.web.servlet.HandlerInterceptor</p><pre><code class="java">/* &lt;p&gt;HandlerInterceptor is basically similar to a Servlet 2.3 Filter, but in* contrast to the latter it just allows custom pre-processing with the option* of prohibiting the execution of the handler itself, and custom post-processing.* Filters are more powerful, for example they allow for exchanging the request* and response objects that are handed down the chain. Note that a filter* gets configured in web.xml, a HandlerInterceptor in the application context.*/</code></pre><h3 id="Lifecycle-Events"><a href="#Lifecycle-Events" class="headerlink" title="Lifecycle Events"></a>Lifecycle Events</h3><pre><code class="json">Event    -Servlet    -Session    -RequestEventListener    -Servlet    -Session    -Request</code></pre><p>Example : <code>ServletContextListener</code></p><pre><code class="java">public class ContextLoaderListener implements ServletContextListener {    private ContextLoader contextLoader;    public ContextLoaderListener() {    }    public void contextInitialized(ServletContextEvent event) {        this.contextLoader = this.createContextLoader();        this.contextLoader.initWebApplicationContext(event.getServletContext());    }    protected ContextLoader createContextLoader() {        return new ContextLoader();    }    public ContextLoader getContextLoader() {        return this.contextLoader;    }    public void contextDestroyed(ServletContextEvent event) {        if(this.contextLoader != null) {            this.contextLoader.closeWebApplicationContext(event.getServletContext());        }    }}</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h2 id="Servlet源码分析"><a href="#Servlet源码分析" class="headerlink" title="Servlet源码分析"></a>Servlet源码分析</h2><p>Server + Applet 的缩写，表示一个服务器应用 , 以下内容为<code>javax.servlet</code></p><h3 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h3><pre><code class="java">package javax.servlet;import java.io.IOException;public interface Servlet {    public void init(ServletConfig config) throws ServletException;    public ServletConfig getServletConfig();    public void service(ServletRequest req, ServletResponse res)   throws ServletException, IOException;    public String getServletInfo();    public void destroy();}</code></pre><blockquote><p>Load-on-startup 为负的话不会在容器启动调用</p></blockquote><h3 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h3><pre><code class="java">package javax.servlet;import java.util.Enumeration;/** * A servlet configuration object used by a servlet container * to pass information to a servlet during initialization.  */ public interface ServletConfig {    public String getServletName();    public ServletContext getServletContext();    public String getInitParameter(String name);    public Enumeration&lt;String&gt; getInitParameterNames();}</code></pre><p>如下配置</p><pre><code class="xml">&lt;!--web.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app ...&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;application-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;&lt;servlet&gt;    &lt;servlet-name&gt;demoDispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.Dispatcher&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;demo-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;/web-app&gt;</code></pre><p>在Servlet中 可以分别通过它们的getInitParameter方法获取，比如：</p><pre><code class="java">String contextLocation = getServletConfig().getServletContext().getInitParameter(    &quot;contextConfigLocation&quot;);String servletLocation = getServletConfig().getInitParameter(&quot;contextConfigLocation&quot;);</code></pre><h3 id="GenerieServlet"><a href="#GenerieServlet" class="headerlink" title="GenerieServlet"></a>GenerieServlet</h3><pre><code>`Servlet`的默认实现，同时实现了`ServletConfig`接口、`Serializable`接口，所以可以直接调用`ServletConfig`里面的方法。详细可参考如下类注释。</code></pre><pre><code class="java">package javax.servlet;import java.io.IOException;import java.util.Enumeration;/** * * Defines a generic, protocol-independent * servlet. To write an HTTP servlet for use on the * Web, extend {@link javax.servlet.http.HttpServlet} instead. * * &lt;p&gt;&lt;code&gt;GenericServlet&lt;/code&gt; implements the &lt;code&gt;Servlet&lt;/code&gt; * and &lt;code&gt;ServletConfig&lt;/code&gt; interfaces. &lt;code&gt;GenericServlet&lt;/code&gt; * may be directly extended by a servlet, although it&#39;s more common to extend * a protocol-specific subclass such as &lt;code&gt;HttpServlet&lt;/code&gt;. * * &lt;p&gt;&lt;code&gt;GenericServlet&lt;/code&gt; makes writing servlets * easier. It provides simple versions of the lifecycle methods  * &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; and of the methods  * in the &lt;code&gt;ServletConfig&lt;/code&gt; interface. &lt;code&gt;GenericServlet&lt;/code&gt; * also implements the &lt;code&gt;log&lt;/code&gt; method, declared in the * &lt;code&gt;ServletContext&lt;/code&gt; interface.  * * &lt;p&gt;To write a generic servlet, you need only * override the abstract &lt;code&gt;service&lt;/code&gt; method.  * */public abstract class GenericServlet     implements Servlet, ServletConfig, java.io.Serializable{    private transient ServletConfig config;    public GenericServlet() {}    public void destroy() {}    public String getInitParameter(String name) {        return getServletConfig().getInitParameter(name);    }    public Enumeration getInitParameterNames() {        return getServletConfig().getInitParameterNames();    }       public ServletConfig getServletConfig() {        return config;    }    public ServletContext getServletContext() {        return getServletConfig().getServletContext();    }    public String getServletInfo() {        return &quot;&quot;;    }    public void init(ServletConfig config) throws ServletException {        this.config = config;        this.init();    }    public void init() throws ServletException {    }    public void log(String msg) {        getServletContext().log(getServletName() + &quot;: &quot;+ msg);    }    public void log(String message, Throwable t) {        getServletContext().log(getServletName() + &quot;: &quot; + message, t);    }    public abstract void service(ServletRequest req, ServletResponse res)    throws ServletException, IOException;    public String getServletName() {        return config.getServletName();    }}</code></pre><p>附：为什么需要实现 <code>java.io.Serializable</code> 接口？</p><p>答：在 Servlet 2.4 规范的 7.7.2 Distributed Environments 章节中，有一句这样的描述：</p><pre><code class="markdown">The distributed servlet container must support the mechanism necessary formigrating objects that implement Serializable.</code></pre><blockquote><p>按照规范的设计，Servlet 有一个钝化的特性，类似于 Servlet 持久化到文件，然后当容器 Crash 回复后，可以重新恢复保存前的状态。</p></blockquote><h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><pre><code class="java">package javax.servlet.http;import ....;/** * Provides an abstract class to be subclassed to create * an HTTP servlet suitable for a Web site. A subclass of * &lt;code&gt;HttpServlet&lt;/code&gt; must override at least  * one method, usually one of these: * * &lt;ul&gt; * &lt;li&gt; &lt;code&gt;doGet&lt;/code&gt;, if the servlet supports HTTP GET requests * &lt;li&gt; &lt;code&gt;doPost&lt;/code&gt;, for HTTP POST requests * &lt;li&gt; &lt;code&gt;doPut&lt;/code&gt;, for HTTP PUT requests * &lt;li&gt; &lt;code&gt;doDelete&lt;/code&gt;, for HTTP DELETE requests * &lt;li&gt; &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt;,  * to manage resources that are held for the life of the servlet * &lt;li&gt; &lt;code&gt;getServletInfo&lt;/code&gt;, which the servlet uses to * provide information about itself  * &lt;/ul&gt; * * &lt;p&gt;There&#39;s almost no reason to override the &lt;code&gt;service&lt;/code&gt; * method. &lt;code&gt;service&lt;/code&gt; handles standard HTTP * requests by dispatching them to the handler methods * for each HTTP request type (the &lt;code&gt;do&lt;/code&gt;&lt;i&gt;XXX&lt;/i&gt; * methods listed above). * * &lt;p&gt;Likewise, there&#39;s almost no reason to override the  * &lt;code&gt;doOptions&lt;/code&gt; and &lt;code&gt;doTrace&lt;/code&gt; methods. * */public abstract class HttpServlet extends GenericServlet    implements java.io.Serializable{    private static final String METHOD_DELETE = &quot;DELETE&quot;;    private static final String METHOD_HEAD = &quot;HEAD&quot;;    private static final String METHOD_GET = &quot;GET&quot;;    private static final String METHOD_OPTIONS = &quot;OPTIONS&quot;;    private static final String METHOD_POST = &quot;POST&quot;;    private static final String METHOD_PUT = &quot;PUT&quot;;    private static final String METHOD_TRACE = &quot;TRACE&quot;;    private static final String HEADER_IFMODSINCE = &quot;If-Modified-Since&quot;;    private static final String HEADER_LASTMOD = &quot;Last-Modified&quot;;    /**    * Resource bundles contain locale-specific objects.    */    private static final String LSTRING_FILE =    &quot;javax.servlet.http.LocalStrings&quot;;    private static ResourceBundle lStrings =    ResourceBundle.getBundle(LSTRING_FILE);    public HttpServlet() { }    protected void doGet(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{        String protocol = req.getProtocol();        String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;);        if (protocol.endsWith(&quot;1.1&quot;)) {            resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);        } else {            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);        }    }    protected long getLastModified(HttpServletRequest req) {        return -1;    }    protected void doHead(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{        NoBodyResponse response = new NoBodyResponse(resp);        doGet(req, response);        response.setContentLength();    }    protected void doPost(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{        String protocol = req.getProtocol();        String msg = lStrings.getString(&quot;http.method_post_not_supported&quot;);        if (protocol.endsWith(&quot;1.1&quot;)) {            resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);        } else {            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);        }    }    protected void doPut(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{       //略,类似doPost    }    protected void doDelete(HttpServletRequest req,                HttpServletResponse resp)    throws ServletException, IOException{       //略,类似doPost    }    protected void doOptions(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{      //略,主要用于调试,输出允许类型    }    protected void service(HttpServletRequest req, HttpServletResponse resp)    throws ServletException, IOException{        String method = req.getMethod();        if (method.equals(METHOD_GET)) {            long lastModified = getLastModified(req);            if (lastModified == -1) {            // servlet doesn&#39;t support if-modified-since, no reason            // to go through further expensive logic            doGet(req, resp);            } else {            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);            if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) {                // If the servlet mod time is later, call doGet()                        // Round down to the nearest second for a proper compare                        // A ifModifiedSince of -1 will always be less                maybeSetLastModified(resp, lastModified);                doGet(req, resp);            } else {                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);            }            }        } else if (method.equals(METHOD_HEAD)) {            long lastModified = getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        } else if (method.equals(METHOD_POST)) {            doPost(req, resp);        } else if (method.equals(METHOD_PUT)) {            doPut(req, resp);            } else if (method.equals(METHOD_DELETE)) {            doDelete(req, resp);        } else if (method.equals(METHOD_OPTIONS)) {            doOptions(req,resp);        } else if (method.equals(METHOD_TRACE)) {            doTrace(req,resp);        } else {            //            // Note that this means NO servlet supports whatever            // method was requested, anywhere on this server.            //            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);            Object[] errArgs = new Object[1];            errArgs[0] = method;            errMsg = MessageFormat.format(errMsg, errArgs);            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        }    }    public void service(ServletRequest req, ServletResponse res)    throws ServletException, IOException{        HttpServletRequest    request;        HttpServletResponse    response;        try {            request = (HttpServletRequest) req;            response = (HttpServletResponse) res;        } catch (ClassCastException e) {            throw new ServletException(&quot;non-HTTP request or response&quot;);        }        service(request, response);    }}/* * A response that includes no body, for use in (dumb) &quot;HEAD&quot; support. * This just swallows that body, counting the bytes in order to set * the content length appropriately.  All other methods delegate directly * to the HTTP Servlet Response object used to construct this one. */// file privateclass NoBodyResponse extends HttpServletResponseWrapper {    private NoBodyOutputStream        noBody;    private PrintWriter            writer;    private boolean            didSetContentLength;    // file private    NoBodyResponse(HttpServletResponse r) {        super(r);    noBody = new NoBodyOutputStream();    }    // ....}/* * Servlet output stream that gobbles up all its data. */// file privateclass NoBodyOutputStream extends ServletOutputStream {    //...}</code></pre><p>doXXX 都是模板方法，如果子类没有实现将抛出异常</p><p>doGet 方法前还会对是否过期做检查，如果没有过期，则直接返回304状态码做缓存。</p><p>doHead调用了doGet的请求，然后返回空body的response</p><p>doOptions和doTrace 主要是用来做一些调试工作 </p>]]></content>
      
      
      
        <tags>
            
            <tag> j2ee </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
