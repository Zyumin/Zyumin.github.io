<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>浅谈软件设计 | Zyumin</title>
  <meta name="keywords" content=" design , patten , ddd ">
  <meta name="description" content="浅谈软件设计 | Zyumin">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://zyumin.github.io/about/index.html">
<meta property="og:site_name" content="Zyumin">
<meta property="og:description" content="为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事的结果，那仅仅是第二位。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-30T10:46:00.000Z">
<meta property="article:modified_time" content="2022-06-30T10:46:00.813Z">
<meta property="article:author" content="zhengyumin">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/github-gist.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.png"/>
</a>
<div class="author">
    <span>zhengyumin</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/Zyumin"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=60037019"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(56)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="design">
                        
                        design
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="java">
                        
                        java
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="jdk">
                        
                        jdk
                        <small>(13)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="mysql">
                        
                        mysql
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="redis">
                        
                        redis
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="spring">
                        
                        spring
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="56">
<input type="hidden" id="yelog_site_word_count" value="215.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>aop</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>applicationContext</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>beanFactory</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>classLoader</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>collections</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ddd</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>design</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>distributed</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>doc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ejb</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>elasticsearch</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>event</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>file</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>framework</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>gc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hbase</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hide</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hotspot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>io</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ioc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>j2ee</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jdk</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>job</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>juc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>kafka</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>lang</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>map</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mysql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>netty</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>note</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>packages</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>patten</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>serialization</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>servlet</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spark</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spec</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring-mvc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring-webflux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>summary</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>thread</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>tomcat</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>utils</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>week</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>zookeeper</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a id="top" class="全部文章 java "
           href="/2019/02/02/Overview_java/"
           data-tag="summary"
           data-author="" >
            <span class="post-title" title="Overview_java">Overview_java</span>
            <span class="post-date" title="2019-02-02 20:43:14">2019/02/02</span>
        </a>
        
        
        <a id="top" class="全部文章 spring "
           href="/2019/03/02/Overview_Spring/"
           data-tag="spring,framework"
           data-author="" >
            <span class="post-title" title="Overview-Spring">Overview-Spring</span>
            <span class="post-date" title="2019-03-02 12:29:06">2019/03/02</span>
        </a>
        
        
        <a id="top" class="全部文章 jdk "
           href="/2019/06/13/Overview_JDK/"
           data-tag="jdk,hotspot"
           data-author="" >
            <span class="post-title" title="Overview_JDK">Overview_JDK</span>
            <span class="post-date" title="2019-06-13 19:36:54">2019/06/13</span>
        </a>
        
        
        <a id="top" class="全部文章 java "
           href="/2020/05/10/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"
           data-tag="job"
           data-author="" >
            <span class="post-title" title="面试常见知识点梳理">面试常见知识点梳理</span>
            <span class="post-date" title="2020-05-10 23:46:06">2020/05/10</span>
        </a>
        
        
        <a  class="全部文章 design "
           href="/2022/07/31/%E6%B5%85%E8%B0%88%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"
           data-tag="design,patten,ddd"
           data-author="" >
            <span class="post-title" title="浅谈软件设计">浅谈软件设计</span>
            <span class="post-date" title="2022-07-31 00:45:09">2022/07/31</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2021/01/13/GC%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/"
           data-tag="jvm,gc,summary"
           data-author="" >
            <span class="post-title" title="GC调优总结">GC调优总结</span>
            <span class="post-date" title="2021-01-13 21:36:01">2021/01/13</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2020/03/18/Overview-Hbase/"
           data-tag="distributed,hbase,framework"
           data-author="" >
            <span class="post-title" title="Overview_Hbase">Overview_Hbase</span>
            <span class="post-date" title="2020-03-18 22:00:51">2020/03/18</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2020/03/18/Overview-Spark/"
           data-tag="distributed,framework,spark"
           data-author="" >
            <span class="post-title" title="Overview_Spark">Overview_Spark</span>
            <span class="post-date" title="2020-03-18 22:00:43">2020/03/18</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2020/02/28/Redis%E9%9B%86%E7%BE%A4%E7%AF%87/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="Redis集群篇">Redis集群篇</span>
            <span class="post-date" title="2020-02-28 18:52:52">2020/02/28</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2020/02/28/Redis%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="Redis实战篇">Redis实战篇</span>
            <span class="post-date" title="2020-02-28 18:52:43">2020/02/28</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2020/02/28/Redis%E5%8E%9F%E7%90%86%E7%AF%87/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="Redis原理篇">Redis原理篇</span>
            <span class="post-date" title="2020-02-28 18:52:35">2020/02/28</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2020/01/23/spring-aop/"
           data-tag="spring,aop"
           data-author="" >
            <span class="post-title" title="spring-aop">spring-aop</span>
            <span class="post-date" title="2020-01-23 23:54:29">2020/01/23</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2020/01/16/Spring-ApplicationContext/"
           data-tag="spring,applicationContext"
           data-author="" >
            <span class="post-title" title="Spring-ApplicationContext">Spring-ApplicationContext</span>
            <span class="post-date" title="2020-01-16 21:04:45">2020/01/16</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/12/05/spring-BeanFactory/"
           data-tag="spring,beanFactory"
           data-author="" >
            <span class="post-title" title="spring-BeanFactory">spring-BeanFactory</span>
            <span class="post-date" title="2019-12-05 21:28:57">2019/12/05</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/12/02/spring-Q-A/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="spring Q&amp;A">spring Q&amp;A</span>
            <span class="post-date" title="2019-12-02 18:20:38">2019/12/02</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/10/29/Documentation-Spring-Core-IOC/"
           data-tag="spring,doc"
           data-author="" >
            <span class="post-title" title="Documentation-Spring_Core_IOC">Documentation-Spring_Core_IOC</span>
            <span class="post-date" title="2019-10-29 21:51:07">2019/10/29</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/09/26/JDK-Packages-java-nio/"
           data-tag="jdk,packages,nio"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_nio">JDK_Packages_java_nio</span>
            <span class="post-date" title="2019-09-26 10:39:22">2019/09/26</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/09/23/JDK-Packages-java-io/"
           data-tag="jdk,packages,io,serialization,file"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_io">JDK_Packages_java_io</span>
            <span class="post-date" title="2019-09-23 16:07:43">2019/09/23</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/31/JDK-Class/"
           data-tag="jdk"
           data-author="" >
            <span class="post-title" title="JDK_Class">JDK_Class</span>
            <span class="post-date" title="2019-08-31 19:38:34">2019/08/31</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/31/JDK-Thread/"
           data-tag="jvm,jdk,hotspot"
           data-author="" >
            <span class="post-title" title="JDK_Thread">JDK_Thread</span>
            <span class="post-date" title="2019-08-31 18:16:08">2019/08/31</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/08/29/JVM-main%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/"
           data-tag="jvm,java"
           data-author="" >
            <span class="post-title" title="JVM_main方法分析">JVM_main方法分析</span>
            <span class="post-date" title="2019-08-29 23:38:13">2019/08/29</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/24/JDK-ReentrantLock/"
           data-tag="juc,jdk"
           data-author="" >
            <span class="post-title" title="JDK_ReentrantLock">JDK_ReentrantLock</span>
            <span class="post-date" title="2019-08-24 18:48:54">2019/08/24</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/08/17/JVM-Synchronized/"
           data-tag="jvm"
           data-author="" >
            <span class="post-title" title="JVM_Synchronized">JVM_Synchronized</span>
            <span class="post-date" title="2019-08-17 17:01:54">2019/08/17</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/08/11/Overview-Java-Virtual-Machine/"
           data-tag="jvm"
           data-author="" >
            <span class="post-title" title="Overview_Java Virtual Machine">Overview_Java Virtual Machine</span>
            <span class="post-date" title="2019-08-11 19:05:38">2019/08/11</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/11/JDK-Packages-java-lang/"
           data-tag="jdk,packages,lang"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_lang">JDK_Packages_java_lang</span>
            <span class="post-date" title="2019-08-11 19:04:56">2019/08/11</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/11/JDK-Packages-java-utils/"
           data-tag="jdk,packages,utils"
           data-author="" >
            <span class="post-title" title="JDK_Packages_java_utils">JDK_Packages_java_utils</span>
            <span class="post-date" title="2019-08-11 19:04:25">2019/08/11</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/08/10/JDK-The-Concurrent-Framework/"
           data-tag="juc,jdk"
           data-author="" >
            <span class="post-title" title="JDK_The Concurrent Framework">JDK_The Concurrent Framework</span>
            <span class="post-date" title="2019-08-10 19:45:39">2019/08/10</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/07/29/JDK-The-Collections-Framework/"
           data-tag="jdk,collections"
           data-author="" >
            <span class="post-title" title="JDK_The Collections Framework">JDK_The Collections Framework</span>
            <span class="post-date" title="2019-07-29 15:26:01">2019/07/29</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/07/10/Note-%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB/"
           data-tag="java,note"
           data-author="" >
            <span class="post-title" title="Note_码农翻身">Note_码农翻身</span>
            <span class="post-date" title="2019-07-10 22:18:56">2019/07/10</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/07/06/JDK-ClassLoader/"
           data-tag="jdk,classLoader"
           data-author="" >
            <span class="post-title" title="JDK_ClassLoader">JDK_ClassLoader</span>
            <span class="post-date" title="2019-07-06 23:12:51">2019/07/06</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/07/03/spring-ApplicationContext%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"
           data-tag="spring,classLoader,servlet,tomcat,event"
           data-author="" >
            <span class="post-title" title="spring-ApplicationContext启动流程和事件机制">spring-ApplicationContext启动流程和事件机制</span>
            <span class="post-date" title="2019-07-03 09:37:08">2019/07/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/26/Overview_Elasticsearch/"
           data-tag="framework,elasticsearch"
           data-author="" >
            <span class="post-title" title="Overview_Elasticsearch">Overview_Elasticsearch</span>
            <span class="post-date" title="2019-06-26 18:06:48">2019/06/26</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/06/24/J-U-C-ConcurrentHashMap/"
           data-tag="juc,map"
           data-author="" >
            <span class="post-title" title="J.U.C_ConcurrentHashMap">J.U.C_ConcurrentHashMap</span>
            <span class="post-date" title="2019-06-24 19:03:29">2019/06/24</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/06/19/JVM-Garbage-Collection/"
           data-tag="jvm,gc"
           data-author="" >
            <span class="post-title" title="JVM_Garbage Collection">JVM_Garbage Collection</span>
            <span class="post-date" title="2019-06-19 00:28:10">2019/06/19</span>
        </a>
        
        
        <a  class="全部文章 jdk "
           href="/2019/06/16/J-U-C-InterruptedException/"
           data-tag="juc"
           data-author="" >
            <span class="post-title" title="J.U.C_InterruptedException">J.U.C_InterruptedException</span>
            <span class="post-date" title="2019-06-16 16:09:43">2019/06/16</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/06/14/Spec-JSR133/"
           data-tag="jvm,Spec,thread"
           data-author="" >
            <span class="post-title" title="Spec_JSR133">Spec_JSR133</span>
            <span class="post-date" title="2019-06-14 19:26:57">2019/06/14</span>
        </a>
        
        
        <a  class="全部文章 java "
           href="/2019/06/13/Spec-Java-Virtual-Machine/"
           data-tag="jvm,Spec"
           data-author="" >
            <span class="post-title" title="Spec_Java Virtual Machine">Spec_Java Virtual Machine</span>
            <span class="post-date" title="2019-06-13 17:25:17">2019/06/13</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/12/Overview_Kafka/"
           data-tag="framework,kafka"
           data-author="" >
            <span class="post-title" title="kafka深入浅出">kafka深入浅出</span>
            <span class="post-date" title="2019-06-12 20:05:37">2019/06/12</span>
        </a>
        
        
        <a  class="全部文章 redis "
           href="/2019/06/10/Overview_Redis/"
           data-tag="framework,redis"
           data-author="" >
            <span class="post-title" title="redis深入浅出">redis深入浅出</span>
            <span class="post-date" title="2019-06-10 18:33:40">2019/06/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/06/Note_java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"
           data-tag="juc,java,note"
           data-author="" >
            <span class="post-title" title="Note_java并发编程的艺术">Note_java并发编程的艺术</span>
            <span class="post-date" title="2019-06-06 19:05:01">2019/06/06</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/05/Overview_Netty/"
           data-tag="nio,framework,netty"
           data-author="" >
            <span class="post-title" title="Netty深入浅出">Netty深入浅出</span>
            <span class="post-date" title="2019-06-05 22:01:31">2019/06/05</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/05/Note_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag="jvm,java,note"
           data-author="" >
            <span class="post-title" title="Note_深入理解java虚拟机">Note_深入理解java虚拟机</span>
            <span class="post-date" title="2019-06-05 21:12:25">2019/06/05</span>
        </a>
        
        
        <a  class="全部文章 mysql "
           href="/2019/06/04/Overview_MySQL/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="MySQL深入浅出">MySQL深入浅出</span>
            <span class="post-date" title="2019-06-04 22:02:31">2019/06/04</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/03/Overview_Zookeeper/"
           data-tag="distributed,framework,zookeeper"
           data-author="" >
            <span class="post-title" title="Zookeeper深入浅出">Zookeeper深入浅出</span>
            <span class="post-date" title="2019-06-03 21:15:05">2019/06/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/06/03/Overview_Distributed/"
           data-tag="distributed"
           data-author="" >
            <span class="post-title" title="分布式理论基础">分布式理论基础</span>
            <span class="post-date" title="2019-06-03 20:34:37">2019/06/03</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/04/10/spring-api-1-0/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="spring-api-1.0">spring-api-1.0</span>
            <span class="post-date" title="2019-04-10 09:45:25">2019/04/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/04/01/3%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"
           data-tag="week,hide"
           data-author="" >
            <span class="post-title" title="3月第四周知识点记录">3月第四周知识点记录</span>
            <span class="post-date" title="2019-04-01 09:51:07">2019/04/01</span>
        </a>
        
        
        <a  class="全部文章 mysql "
           href="/2019/03/30/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%9F%A5%E8%AF%A2in%E7%9A%84%E6%80%9D%E8%80%83/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="记一次mysql查询in的思考">记一次mysql查询in的思考</span>
            <span class="post-date" title="2019-03-30 20:39:49">2019/03/30</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/26/%E8%AE%B0%E4%B8%80%E6%AC%A1Broken-pipe%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"
           data-tag="tomcat"
           data-author="" >
            <span class="post-title" title="记一次Broken pipe问题的思考">记一次Broken pipe问题的思考</span>
            <span class="post-date" title="2019-03-26 10:53:37">2019/03/26</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/24/3%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"
           data-tag="week,hide"
           data-author="" >
            <span class="post-title" title="3月第三周知识点记录">3月第三周知识点记录</span>
            <span class="post-date" title="2019-03-24 20:55:31">2019/03/24</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/10/Note_Expert%20One-on-One-J2EE-Development-without-EJB/"
           data-tag="spring,j2ee,ejb"
           data-author="" >
            <span class="post-title" title="Expert One-on-One J2EE Development without EJB">Expert One-on-One J2EE Development without EJB</span>
            <span class="post-date" title="2019-03-10 19:45:57">2019/03/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/03/10/Note_Expert-One-on-One-J2EE-Design-and-Development/"
           data-tag="spring,j2ee"
           data-author="" >
            <span class="post-title" title="Expert One-on-One J2EE Design and Development">Expert One-on-One J2EE Design and Development</span>
            <span class="post-date" title="2019-03-10 19:45:18">2019/03/10</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/03/03/spring-Core-Container%E9%A2%84%E8%A7%88/"
           data-tag="spring,ioc"
           data-author="" >
            <span class="post-title" title="spring-Core-Container预览">spring-Core-Container预览</span>
            <span class="post-date" title="2019-03-03 14:51:56">2019/03/03</span>
        </a>
        
        
        <a  class="全部文章 spring "
           href="/2019/02/03/spring-mvc/"
           data-tag="spring,servlet,spring-mvc,spring-webflux"
           data-author="" >
            <span class="post-title" title="servlet_spring-mvc">servlet_spring-mvc</span>
            <span class="post-date" title="2019-02-03 15:50:16">2019/02/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/02/03/Overview_Tomcat/"
           data-tag="servlet,tomcat"
           data-author="" >
            <span class="post-title" title="servlet_tomcat">servlet_tomcat</span>
            <span class="post-date" title="2019-02-03 15:49:08">2019/02/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2019/02/02/Spec_Servlet/"
           data-tag="j2ee,servlet"
           data-author="" >
            <span class="post-title" title="j2ee_servlet">j2ee_servlet</span>
            <span class="post-date" title="2019-02-02 18:05:54">2019/02/02</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-浅谈软件设计" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">浅谈软件设计</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="design">design</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">design</a>
            
            <a class="color2">patten</a>
            
            <a class="color4">ddd</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-07-31 22:15:23'>2022-07-31 00:45</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:26.1k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-text">一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-text">模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">建立模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-text">编程语言的发展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1"><span class="toc-text">数据建模</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1"><span class="toc-text">对象建模</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1"><span class="toc-text">业务建模</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7"><span class="toc-text">建模工具</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-text">原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F"><span class="toc-text">模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83"><span class="toc-text">规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%88%B0%E5%BA%95%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88"><span class="toc-text">架构到底是指什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-text">架构图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E8%A7%86%E5%9B%BE"><span class="toc-text">4+1视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c4"><span class="toc-text">c4</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Level-1-System-Context-diagram"><span class="toc-text">Level 1: System Context diagram</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Level-2-Container-diagram"><span class="toc-text">Level 2: Container diagram</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Level-3-Component-diagram"><span class="toc-text">Level 3: Component diagram</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Level-4-Code"><span class="toc-text">Level 4: Code</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4R"><span class="toc-text">4R</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-text">架构设计目的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-text">复杂度的来源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-text">高性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">高可用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%89%A9%E5%B1%95"><span class="toc-text">高扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8E%E6%88%90%E6%9C%AC%E3%80%81%E5%AE%89%E5%85%A8%E3%80%81%E8%A7%84%E6%A8%A1"><span class="toc-text">低成本、安全、规模</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99-1"><span class="toc-text">原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E9%80%82%E5%8E%9F%E5%88%99"><span class="toc-text">合适原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8E%9F%E5%88%99"><span class="toc-text">简单原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-text">结构的复杂性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-text">逻辑的复杂性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E5%8C%96%E5%8E%9F%E5%88%99"><span class="toc-text">演化原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96"><span class="toc-text">架构演化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3%EF%BC%9AUnix%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-text">原始分布式时代：Unix设计哲学</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%9C%80%E5%B9%BF%E6%B3%9B%E7%9A%84%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-text">单体架构：最广泛的架构风格</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%90%BD%E5%90%8E%E6%9E%B6%E6%9E%84"><span class="toc-text">落后架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%8B%86%E5%88%86"><span class="toc-text">不可拆分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SOA%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%88%90%E5%8A%9F%E7%90%86%E8%AE%BA%E5%A4%B1%E8%B4%A5%E5%AE%9E%E8%B7%B5"><span class="toc-text">SOA架构：成功理论失败实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%83%9F%E5%9B%B1%E5%BC%8F%E6%9E%B6%E6%9E%84%EF%BC%88Information-Silo-Architecture%EF%BC%89"><span class="toc-text">烟囱式架构（Information Silo Architecture）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%EF%BC%88Microkernel-Architecture%EF%BC%89"><span class="toc-text">微内核架构（Microkernel Architecture）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%EF%BC%88Event-Driven-Architecture%EF%BC%89"><span class="toc-text">事件驱动架构（Event-Driven Architecture）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9ASOA%E9%9D%A9%E5%91%BD%E8%80%85"><span class="toc-text">微服务架构：SOA革命者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9F"><span class="toc-text">后微服务时代：云原生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%EF%BC%9A%E2%80%9C%E4%B8%8D%E5%88%86%E5%B8%83%E5%BC%8F%E2%80%9D%E4%BA%91%E7%AB%AF%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-text">无服务时代：“不分布式”云端系统的起点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%A3%8E%E6%A0%BC%EF%BC%89"><span class="toc-text">架构模式（风格）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-text">面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B-1"><span class="toc-text">模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%86%85%E8%81%9A%E5%8E%9F%E5%88%99"><span class="toc-text">组件内聚原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E8%80%A6%E5%90%88%E5%8E%9F%E5%88%99"><span class="toc-text">组件耦合原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-text">面向对象概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="toc-text">理解封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E6%9A%B4%E9%9C%B2%E6%8E%A5%E5%8F%A3"><span class="toc-text">减少暴露接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">组合优于继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E5%8F%98%E5%8C%96"><span class="toc-text">隔离变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%BE%B9%E7%95%8C"><span class="toc-text">定义边界</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-text">面向接口编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">设计的目的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%9F%E7%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">糟糕的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%83%B5%E5%8C%96%E6%80%A7"><span class="toc-text">僵化性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%86%E5%BC%B1%E6%80%A7"><span class="toc-text">脆弱性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A2%E5%9B%BA%E6%80%A7"><span class="toc-text">牢固性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B2%98%E6%BB%9E%E6%80%A7"><span class="toc-text">粘滞性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%A6%E6%B6%A9%E6%80%A7"><span class="toc-text">晦涩性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88SRP%EF%BC%89"><span class="toc-text">单一职责原则（SRP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-OCP"><span class="toc-text">开闭原则(OCP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-LSP"><span class="toc-text">里氏替换原则(LSP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-ISP"><span class="toc-text">接口隔离原则(ISP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99-DIP"><span class="toc-text">依赖倒转原则(DIP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8E%9F%E5%88%99"><span class="toc-text">其他原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">设计原则之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-text">基本要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GOF23"><span class="toc-text">GOF23</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-text">关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">框架中的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mybatis"><span class="toc-text">Mybatis</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%8D%E8%B6%B3"><span class="toc-text">设计不足</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E5%88%86%E8%AE%BE%E8%AE%A1"><span class="toc-text">过分设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%9C%BA%E6%99%AF%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-text">具体场景的权衡</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">领域驱动设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">DDD是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8DDD%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">使用DDD的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80"><span class="toc-text">统一语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80"><span class="toc-text">怎么建立统一语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B-2"><span class="toc-text">模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%B6%88%E5%8C%96%EF%BC%88%E5%8E%9F%E5%88%99%EF%BC%89"><span class="toc-text">知识消化（原则）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E4%B8%A4%E5%85%B3%E8%81%94%E2%80%9D"><span class="toc-text">“两关联”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E4%B8%80%E5%BE%AA%E7%8E%AF%E2%80%9D"><span class="toc-text">“一循环”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-text">建立模型（模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1"><span class="toc-text">战略设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%EF%BC%88domain%EF%BC%89"><span class="toc-text">领域（domain）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Bounded-Context%EF%BC%89"><span class="toc-text">限界上下文（Bounded Context）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84%E5%9B%BE%EF%BC%88Context-Map%EF%BC%89"><span class="toc-text">上下文映射图（Context Map）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">战术设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%EF%BC%9A%E5%AE%9E%E4%BD%93%E3%80%81%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="toc-text">角色：实体、值对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%EF%BC%9A%E8%81%9A%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E6%A0%B9"><span class="toc-text">关系：聚合和聚合根</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E5%8A%A8%EF%BC%9A%E5%B7%A5%E5%8E%82%E3%80%81%E4%BB%93%E5%BA%93%E3%80%81%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1%E3%80%81%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-text">互动：工厂、仓库、领域服务、应用服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDD%E6%9E%B6%E6%9E%84"><span class="toc-text">DDD架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-text">分层架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-text">1.用户接口层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">2.应用层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%A2%86%E5%9F%9F%E5%B1%82"><span class="toc-text">3.领域层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9F%BA%E7%A1%80%E5%B1%82"><span class="toc-text">4.基础层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99"><span class="toc-text">分层架构的依赖原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%B1%82%E5%92%8C%E9%A2%86%E5%9F%9F%E5%B1%82%E8%B0%81%E6%9B%B4%E7%A8%B3%E5%AE%9A%EF%BC%9F"><span class="toc-text">基础设施层和领域层谁更稳定？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84"><span class="toc-text">其他架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	初次了解“设计”，是在大学的图书馆无意翻到的《设计模式：可复用面向对象软件的基础》，那时候只是初略的翻翻，并没有觉得有何特别。再到后来工作几年，参与过一些系统设计，扒过一些优秀的框架，写过一些代码，读过一些书籍和文章之后，对设计有了一些了解。在此分享下自己的记录和理解，也欢迎一起交流。</p>
<p>​	目录如下	</p>
<ul>
<li>一些概念：设计、模型、原则、模式、规范</li>
<li>架构设计：从宏观的角度设计</li>
<li>面向对象设计：从微观的角度设计</li>
<li>领域驱动设计：从业务的角度补充</li>
<li>总结</li>
</ul>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>​	作为一名程序员，我们都知道“设计”是软件开发中的一个步骤（设计先行）。但软件设计到底是什么，可能会存在不同的理解：</p>
<ul>
<li>设计就是讨论要用什么技术实现功能；</li>
<li>设计就是要考虑选择哪些框架和中间件；</li>
<li>设计就是设计模式；</li>
<li>设计就是 Controller、Service 加 Model；</li>
</ul>
<p>​	那软件设计到底是什么？从<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_design">wiki</a>上的一段定义来看</p>
<blockquote>
<p><strong>Software design</strong> is the process by which an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Agency_(philosophy)">agent</a> creates a specification of a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Artifact_(software_development)">software artifact</a> intended to accomplish <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Goal">goals</a>, using a set of primitive components and subject to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Constraint_(mathematics)">constraints</a>.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_design#cite_note-1">1]</a> Software design may refer to either “all the activity involved in conceptualizing, framing, implementing, commissioning, and ultimately modifying complex systems” or “the activity following <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_requirements">requirements</a> specification and before <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_programming">programming</a>, as … [in] a stylized software engineering process.”[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_design#cite_note-2">2]</a></p>
<p>Software design usually involves problem-solving and planning a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software">software</a> solution. This includes both a low-level component and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Algorithm_design">algorithm design</a> and a high-level, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_architecture">architecture</a> design.</p>
</blockquote>
<p>​	软件设计是一个过程，通过该过程，代理使用一组原始组件并受约束来创建用于实现目标的软件工件的规范。软件设计可以是指“涉及概念化、框架化、实施、调试和最终修改复杂系统的所有活动”或“遵循需求规范并在编程之前的活动”</p>
<p>​	软件设计通常涉及解决问题和规划软件解决方案。这包括低级组件和算法设计以及高级架构设计。简单来说， 软件设计是要在问题和解决方案架设一座桥梁，好的设计要更接近问题</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731190901.jpg" alt="img" style="zoom:33%;" />

<p>​		区别于解决简单的问题，软件的开发往往是一项长期的工作，会有许多人参与其中。在这种情况下，就需要建立起一个统一的结构，以便于所有人都能有一个共同的理解。这就如同建筑中的图纸，懂建筑的人看了之后，就会产生一个统一的认识。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>​	在软件的开发过程中，这种统一的结构就是模型（也可以理解为抽象），而软件设计就是要根据问题分析、抽象出一套模型，再根据模型设计、抽象、开发实现对应的软件系统。</p>
<p><img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731190911.png" alt="image-20220720193203555"></p>
<p>​	模型可以是业务的各种实体，各种服务类，也可以是各种组件、框架。 模型的粒度可大可小。如果把模型理解为一个一个的类，这就是小的模型。也可以把整个系统当作一个整体来理解，这就是大的模型。例如常见的计算机模型，冯诺伊曼模型，计算机网络模型，OSI model，IO模型，JMM内存模型，模型一直都在，只是你没有发现它。	<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731221518.png" alt="image-20220731221438383" style="zoom:50%;" /></p>
<p>​		</p>
<p>那么怎么建立模型、评判模型的好坏就成了一个问题。</p>
<h4 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h4><h5 id="编程语言的发展"><a href="#编程语言的发展" class="headerlink" title="编程语言的发展"></a>编程语言的发展</h5><p>编程语言的发展可以分为几个阶段，面向机器、面向过程（ 数据 ）、面向对象</p>
<p>​	远在1949 年，随着第一台可存储程序的计算机的发明而出现，程序员终于可以写代码了，这个阶段计算机指令的二进制编码，早期的程序员发现记忆计算机指令的二进制编码非常浪费时间，于是他们发明了汇编语言，这阶段其实本质都是面向机器编程。</p>
<p>​	随着计算机技术的不断发展和计算机的普及，为了更高效地进行编程，应该采用一种对程序员更加友好的编程方式，一种更接近人类语言的编程语言，于是各种各样的高级编程语言出现了。Fortran、C ( Unix 操作系统就使用c语言写的 )，由于这些语言关注逻辑处理过程，所以也被称作面向过程的编程语言（结构化编程，模块）。</p>
<p>​	面向过程的复杂性随着软件规模的膨胀以更快的速度膨胀，许多软件开发失控，形成了软件危机。软件危机使人们开始重新审视软件编程这件事情的本质，除了一部分科学计算或者其他特定目的的软件，大部分的软件是为了解决现实世界的问题，企业的库存管理、银行的账务处理等等。所以软件编程这件事情应该关注的重点是客观世界的事物本身，向对象的编程语言应运而生（ java 、C++ ）。</p>
<p>​	随着计算机性能的不断增强，例如大数据，人工智能以及移动互联网的发展，面向数据的编程需求越来越多，能够更好迎合这一需求的编程模型开始得到青睐，比如函数式编程。</p>
<p>​	另外，互联网应用对计算资源需求的不断增加，如何更好地利用 CPU 的多核以及分布式集群的多服务器特性，软件编程越来越多需要考虑机器本身，反应式编程也得到越来越多的关注。</p>
<p>​	从编程语言的发展中我们可以得到建模的一些启示。</p>
<h5 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h5><p>​	按照面向机器和数据的思想，计算机就是处理数据计算（ 涉及的数据结构 ）、存储（ 数据存储在硬盘，数据库 ）、输入、输出。在软件行业发展的早期，计算方面处理主要是围绕数据，数据结构像堆、栈、链表、树、图等构建与领域无关的模型。存储方面则是数据根据需要对数据库表进行增删改查，这种思路实际上是一种<strong>结构化编程</strong>的思路。</p>
<h5 id="对象建模"><a href="#对象建模" class="headerlink" title="对象建模"></a>对象建模</h5><p>​	为了应对软件复杂度膨胀，引入了对象的概念，对象和数据结构两者的区别之一就在于对数据的操作是主动还是被动——对象是主动操作数据，而数据结构的数据是被动操作。那么是否使用面向对象的编程语言进行编程，就是面向对象的思想了。</p>
<p>​	可能未必，例如，目前企业级应用开发中，业务逻辑的组织方式主要是事务脚本模式。事务脚本模式典型的就是 Controller→Service→Dao 这样的程序设计模式。Controller 封装用户请求，根据请求参数构造一些数据对象调用 Service，Service 里面包含大量的业务逻辑代码，完成对数据的处理，期间可能需要通过 Dao 从数据库中获取数据，或者将数据写入数据库中。</p>
<p>​	由于事务脚本模式中，Service、Dao 这些对象只有方法，没有数值成员变量，而方法调用时传递的数值对象没有方法（ 或者只有一些 getter、setter 方法 ），因此事务脚本又被称作贫血模型。</p>
<p>​	这两种做法本质上没什么太大的区别，都是以数据为中心，以数据库ER设计作驱动。分层架构在这种开发模式下，可以理解为是对数据移动、处理和实现的过程。在业务需求不复杂的年代，围绕数据做文章的做法还能满足开发的要求，但随着软件日益深入到人们日常工作和生活中，软件变得越来越复杂，这种做法就越发显得笨拙了。这个时候就该ddd出场了。</p>
<h5 id="业务建模"><a href="#业务建模" class="headerlink" title="业务建模"></a>业务建模</h5><p>​	领域模型是合并了行为和数据的领域的对象模型。通过领域模型对象的交互完成业务逻辑的实现，也就是说，设计好了领域模型对象，也就设计好了业务逻辑实现。和事务脚本被称作贫血模型相对应的，领域模型也被称为充血模型。领域驱动设计，使用战略设计划分界限上下文，识别核心领域，统一语言。使用战术设计指导聚合根设计，识别实体，值对象。DDD早在随着微服务的浪潮，ddd也大放异彩。</p>
<p>​									<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191121.png" alt="image-20220727010708582" style="zoom:50%;" /></p>
<h5 id="建模工具"><a href="#建模工具" class="headerlink" title="建模工具"></a>建模工具</h5><p>​	在实践中，通常用来进行软件建模画图的工具是 UML，统一建模语言。UML 包含的软件模型有 10 种，其中常用的有 7 种：类图、序列图、组件图、部署图、用例图、状态图和活动图。</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>​	一个模型的好坏我们怎么去评价，或者有什么要求。我们平时常说的<strong>高内聚、低耦合</strong>（ 是软件工程中的概念，是判断设计好坏的标准，主要是面向对象的设计，主要是看类的内聚性是否高，耦合度是否低 ）其实是对模型的要求。同时好的模型应该是<strong>分层</strong>的，例如OSI model的分层，操作系统的分层。符合这些要求的模型，能够有效地隐藏细节，让人理解起来也更容易，甚至还可以在上面继续扩展。  </p>
<p>​	在unix编程艺术中的模块化原则中，给出的建议是从封装、正交性和紧凑性、分层这些方面去设计。当然除了模块化原则，在unix编程艺术中，还列举了很多的原则</p>
<blockquote>
<ol>
<li>模块原则：使用简洁的接口拼合简单的部件</li>
<li>清晰原则：清晰生于机巧</li>
<li>组合原则：设计时考虑拼接组合</li>
<li>分离原则：策略同机制分离，接口同引擎分离</li>
<li>简洁原则：设计要简洁，复杂度能低则低</li>
<li>吝啬原则：除非却无他法，不要编写庞大的程序</li>
<li>透明性原则：设计要可见，以便审查和调试</li>
<li>健壮原则：健壮源于透明与简洁</li>
<li>表示原则：把知识叠入数据以求逻辑质朴而健壮</li>
<li>通俗原则：接口设计避免标新立异</li>
<li>缄默原则：如果一个程序没什么好说的，就沉默</li>
<li>补救原则：出现异常时，马上退出并给出足够多的错误信息</li>
<li>经济原则：宁花机器一分，不花程序员一秒</li>
<li>生成原则：避免手工hack，尽量编写程序去生成程序</li>
<li>优化原则：雕琢前要先有圆形，跑之前先学会走</li>
<li>多样性原则：绝不相信所谓”不二法门“的断言</li>
<li>扩展原则：设计着眼未来，未来总比预想来的快</li>
</ol>
</blockquote>
<p>这些原则思想，在架构设计、代码设计都有体现。更多原则相关可以阅读<a target="_blank" rel="noopener" href="http://www.catb.org/~esr/writings/taoup/html/ch01s06.html">这篇文章</a></p>
<p>​	所有的这些都在强调kiss ( KEEP IT SIMPLE , STUPID  ) 原则，”简单原则”，尽量用简单的方法解决问题，是”Unix哲学”的根本原则。除了kiss原则，还有YAGNI ( You aren‘t gonna nedd it ) 以及DRY ( Dont repeat yourself ) 原则也是比较常见的。面向对象中也有许多经典原则SOLID （ 这个我们在下面再讲 ）</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>​	当我们在解决一个问题的时候，一般不会发明一种和已有解决方案完全不同的方案来处理这个问题。通常会想起已解决过的相似问题，并重用其解法精华来解决新问题。建筑领域给出的“模式”的定义是，每个模式是一条由三部分组成的规则，它表示一个特定环境、一个问题和一个解决方案之间的关系。这种同时考虑问题、求解方案的，在很多领域都是共同的，建筑学、金融、软件工程中领域也是如此。</p>
<p>​	所谓“模式”，就是一套反复被人使用或验证过的方法论。从抽象或者更宏观的角度上看，架构设计有其模式，常见的MVC分层、主从、事件驱动、分布式、微服务等。从代码实践角度看，面向对象的有其对应的设计模式，GOF23。（有人专门写了面向模式的软件架构，<a target="_blank" rel="noopener" href="https://book.douban.com/subject/25741382/">Pattern-oriented software architecture</a>）</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>​	如果说，软件设计要构建出一套模型，这还是比较直观好理解的。因为模型通常可以直接体现在代码中。但软件设计的另一部分——规范，就常常会被忽略。规范，就是限定了什么样的需求应该以怎样的方式去完成，限定了模型的边界和范围。</p>
<p>​	例如我们可以看到很多框架、软件的实现，都是实现了相关的规范。像我们比较熟悉的java</p>
<ul>
<li>java语言有<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html">java语言规范</a></li>
<li>java虚拟机实现了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Spec-Java-Virtual-Machine</a>规范</li>
<li>虚拟机中的内存模型实现了<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf?spm=a2c4e.10696291.0.0.3c5419a4WH2pe1&file=jsr133.pdf">Spec-JSR133</a>规范</li>
<li>数据库驱动有JDBC驱动</li>
<li>服务请求也有servlet规范</li>
</ul>
<p>​	这些规范其实都来自jsr，即<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/platform">Java Specification Requests</a>.可以分为两类，一种是java se，se是标准 。一种是java ee，ee是面向企业的，比较熟悉的EJB(Enterprise JavaBean) 是J2EE的一种规范，其中包括了JDBC、JNDI、RMI、JMS、JTA，设计目标与核心应用是部署分布式应用程序，也就是后来的spring框架。</p>
<p>​	当然除了java，其他像数据库（SQL99、SQL03）、网络（IETF规范）等都有其对应的规范。模型与规范，二者相辅相成。一个项目最初建立起的模型，往往是要符合一定规范的，而规范的制定也有赖于模型。	</p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>​	接下来我们从宏观的架构设计，来好好聊聊“设计”</p>
<h3 id="架构到底是指什么"><a href="#架构到底是指什么" class="headerlink" title="架构到底是指什么"></a>架构到底是指什么</h3><p>​	对于技术人员来说，“架构”是一个再常见不过的词了，新员工培训的系统架构，参与架构设计评审，学习业界开源系统的架构。虽然“架构”这个词很常见，但如果深究一下，“架构”到底是指什么，可能大部分人就搞不清楚了。给不出一个具体的定义。</p>
<p>​	wiki中给出的定义是<strong>软件架构</strong>是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。软件架构会包括<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E7%B5%84%E4%BB%B6">软件组件</a>、组件之间的关系，组件特性以及组件间关系的特性。</p>
<p>​	这里比较容易混淆的其实有几个概念</p>
<ul>
<li><p>系统与子系统  ，一个系统的架构，只包括顶层这一个层级的架构，而不包括下属子系统层级的架构</p>
</li>
<li><p>模块与组件 ，模块（业务，职责分离）和组件（物理部署，单元复用）都是系统的组成部分，只是从不同的角度拆分系统而已</p>
</li>
<li><p>架构与框架，架是一整套开发规范，架构是某一套开发规范下的具体落地方案，包括各个模块之间的组合关系以及它们协同起来完成功能的运作规则</p>
</li>
</ul>
<p>​	可能到这里还是感觉挺抽象，那么回想下，我们都是怎么了解、介绍一个系统的。首先浮现在脑海的是一张张的架构图。</p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><h4 id="4-1视图"><a href="#4-1视图" class="headerlink" title="4+1视图"></a>4+1视图</h4><p>​	说起架构图，就不能不提UML(类图、序列图、组件图、部署图、用例图、状态图和活动图)和4+1视图（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">统一建模语言</a>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/4%2B1_architectural_view_model">软件架构的 4+1 模型</a>）</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191129.png" alt="image-20220721125104811" style="zoom:50%;" />

<p>​	我们还是从它的由来说起。1995 年，Philippe Kruchten 在论文中指出了过去用单一视图描述软件系统架构的问题，并提出了 4+1 视图作为解决方案。</p>
<blockquote>
<p>​	有时，软件架构的问题来源于系统设计者过早地划分软件或者过分地强调软件开发的某一个方面，比如数据工程、运行时效率、开发策略或团队组织。此外，软件架构往往不能解决它的所有“用户”的问题。……作为补救措施，我们建议使用几个并发视图来组织对软件架构的描述，其中每个视图分别解决一组特定的问题。</p>
</blockquote>
<p>​	不同视图之间的关系如下图所示：</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191140.png" alt="img" style="zoom:40%;" />

<p>4+1 视图的核心理念是从不同的角度去剖析系统，看看系统的结构是什么样的，具体每个视图的含义是：</p>
<p>逻辑视图：从终端用户角度看系统提供给用户的功能，对应 UML 的 class 和 state diagrams。</p>
<p>处理视图：从动态的角度看系统的处理过程，对应 UML 的 sequence 和 activity diagrams。</p>
<p>开发视图：从程序员角度看系统的逻辑组成，对应 UML 的 package diagrams。</p>
<p>物理视图：从系统工程师角度看系统的物理组成，对应 UML 的 deployment diagrams。</p>
<p>场景视图：从用户角度看系统需要实现的需求，对应 UML 的 use case diagrams。</p>
<h4 id="c4"><a href="#c4" class="headerlink" title="c4"></a>c4</h4><p>传统架构图存在以下问题</p>
<ul>
<li>方框或其他形状表示什么意思？</li>
<li>虚线 实线 箭头 颜色，比较复杂</li>
<li>缺少层级</li>
</ul>
<p>传统UML的问题在于过于复杂，上手难度大，理解成本高，表现力不够，一张好的架构图不需要多余的文字解释，这里介绍一种简单的方法。</p>
<p><img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191146.png" alt="image-20220721125525848"></p>
<p>​	C4 模型是一种易于学习、对开发人员友好的软件架构图表方法。良好的软件架构图有助于软件开发&#x2F;产品团队内部&#x2F;外部的沟通、新员工的有效入职、架构审查&#x2F;评估、风险识别、威胁建模等。（上下文，容器，组件，代码）</p>
<p>类似地图的缩进功能，从一个全局的视角，逐步放大到某一个细节。</p>
<h5 id="Level-1-System-Context-diagram"><a href="#Level-1-System-Context-diagram" class="headerlink" title="Level 1: System Context diagram"></a>Level 1: System Context diagram</h5><p>​	这是一个虚构的网上银行系统的示例系统上下文图。它显示了使用它的人，以及与网上银行系统有关系的其他软件系统。银行的个人客户使用网上银行系统查看有关其银行帐户的信息并进行付款。网上银行系统本身使用银行现有的大型机银行系统来执行此操作，并使用银行现有的电子邮件系统向客户发送电子邮件。</p>
<p><img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191152.png" alt="系统上下文图"></p>
<h5 id="Level-2-Container-diagram"><a href="#Level-2-Container-diagram" class="headerlink" title="Level 2: Container diagram"></a>Level 2: Container diagram</h5><p>​	这是一个虚构的网上银行系统的示例容器图。它显示网上银行系统（虚线框）由五个容器组成：服务器端 Web 应用程序、单页应用程序、移动应用程序、服务器端 API 应用程序和数据库。Web 应用程序是一个 Java&#x2F;Spring MVC Web 应用程序，它只提供静态内容（HTML、CSS 和 JavaScript），包括构成单页应用程序的内容。单页应用程序是在客户的网络浏览器中运行的 Angular 应用程序，提供所有网上银行功能。或者，客户可以使用跨平台 Xamarin 移动应用程序来访问网上银行功能的子集。</p>
<p>单页应用程序和移动应用程序都使用 JSON&#x2F;HTTPS API，该 API 由运行在服务器上的另一个 Java&#x2F;Spring MVC 应用程序提供。API 应用程序从数据库（关系数据库模式）中获取用户信息。API 应用程序还使用专有的 XML&#x2F;HTTPS 接口与现有的大型机银行系统进行通信，以获取有关银行帐户的信息或进行交易。如果 API 应用程序需要向客户发送电子邮件，它也会使用现有的电子邮件系统。</p>
<p><img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191158.png" alt="容器图"></p>
<h5 id="Level-3-Component-diagram"><a href="#Level-3-Component-diagram" class="headerlink" title="Level 3: Component diagram"></a>Level 3: Component diagram</h5><p>​	这是一个虚构的网上银行系统的示例组件图，显示了 API 应用程序中的一些（而不是全部）组件。在这里，有三个 Spring MVC Rest Controller 为 JSON&#x2F;HTTPS API 提供访问点，每个控制器随后使用其他组件来访问来自数据库和大型机银行系统的数据，或发送电子邮件。</p>
<p><img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191202.png" alt="组件图"></p>
<h5 id="Level-4-Code"><a href="#Level-4-Code" class="headerlink" title="Level 4: Code"></a>Level 4: Code</h5><p>这是一个虚构 Internet 银行系统的示例（和部分）UML 类图，显示了构成 MainframeBankingSystemFacade 组件的代码元素（接口和类）。它表明该组件由许多类组成，实现细节直接反映了代码。</p>
<p><img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191207.png" alt="UML 类图"></p>
<p>​		虽然C4简单，但是C4表达能力不足，在《从 0 开始学架构》中提到的4R，或许能解决这个问题。</p>
<h4 id="4R"><a href="#4R" class="headerlink" title="4R"></a>4R</h4><p>​	4R指的是，软件架构指软件系统的顶层（Rank）结构，它定义了系统由哪些角色（Role）组成，角色之间的关系（Relation）和运作规则（Rule）。</p>
<p>​														<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191212.png" alt="image-20220721130251164" style="zoom:50%;" /></p>
<p>​	在实际工作中，为了方便理解，Rank、Role 和 Relation 是通过系统架构图来展示的，而 Rule 是通过系统序列图（System Sequence Diagram）来展示的。</p>
<p>​																		<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191218.png" alt="image-20220721130457460" style="zoom:50%;" /></p>
<p>​	介绍 4+1 视图的时候，我提到过，从不同的角度去剖析系统，就会得到不同的视图。其实按照 4R 架构定义来画架构图也是这样，用不同的方式去划分系统，就会得到不同类型的架构，分别对应不同类型的架构图。常见的类型整理如下：</p>
<p>​												<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191223.png" alt="image-20220721130612794" style="zoom:50%;" /></p>
<p>​	总之，不管哪种架构图，我们都得先想清楚，受众是谁。到这里，我们对架构应该有所了解，在谈设计之前先来看看架构的演变。</p>
<h3 id="架构设计目的"><a href="#架构设计目的" class="headerlink" title="架构设计目的"></a>架构设计目的</h3><p>​	架构设计的主要目的是为了解决软件系统复杂度带来的问题。通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</p>
<h4 id="复杂度的来源"><a href="#复杂度的来源" class="headerlink" title="复杂度的来源"></a>复杂度的来源</h4><p>而复杂度的来源主要有以下几个</p>
<h5 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h5><p>​	一是单台计算机内部为了高性能带来的复杂度；二是多台计算机集群为了高性能带来的复杂度。</p>
<h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><p>​	计算（业务的逻辑处理）高可用，存储高可用。高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。</p>
<h5 id="高扩展"><a href="#高扩展" class="headerlink" title="高扩展"></a>高扩展</h5><p>​	提炼出“变化层”和“稳定层”（通过变化层来隔离变化），提炼出“抽象层”和“实现层”（通过实现层来封装变化）。</p>
<h5 id="低成本、安全、规模"><a href="#低成本、安全、规模" class="headerlink" title="低成本、安全、规模"></a>低成本、安全、规模</h5><ul>
<li>低成本，低成本本质上是与高性能和高可用冲突的，所以低成本很多时候不会是架构设计的首要目标，而是架构设计的附加约束。</li>
<li>安全，一类是功能上的安全，一类是架构上的安全。</li>
<li>规模，规模带来复杂度的主要原因就是“量变引起质变”。<ul>
<li>功能规模大增长，导致系统复杂度，指数级增长。</li>
<li>数据越来越多，系统复杂度发生质变，例如数据库的拆分，分库分表的技术。（数据的规模也推动了大数据的发展，Google 发表的三篇大数据相关论文）</li>
</ul>
</li>
</ul>
<h3 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h3><p>​	那么有什么原则来指导我们进行设计呢？在极客的《<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/7071">从 0 开始学架构</a>》 中作者提到的几个原则觉得挺适用：</p>
<ul>
<li>合适原则</li>
<li>简单原则</li>
<li>演化原则</li>
</ul>
<h4 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h4><p>合适原则宣言：“合适优于业界领先”。</p>
<p>业界领先架构不适用的失败原因有以下几个</p>
<ul>
<li>没那么多人，却想干那么多活，是失败的第一个主要原因。</li>
<li>没有那么多积累，却想一步登天，是失败的第二个主要原因。</li>
<li>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。</li>
</ul>
<p>真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地</p>
<h4 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h4><p>简单原则宣言：“简单优于复杂”。</p>
<p>软件领域的复杂性体现在两个方面：</p>
<h5 id="结构的复杂性"><a href="#结构的复杂性" class="headerlink" title="结构的复杂性"></a>结构的复杂性</h5><ul>
<li>组件越多，就越有可能其中某个组件出现故障</li>
<li>某个组件改动，会影响关联的所有组件</li>
<li>定位一个复杂系统中的问题总是比简单系统更加困难</li>
</ul>
<h5 id="逻辑的复杂性"><a href="#逻辑的复杂性" class="headerlink" title="逻辑的复杂性"></a>逻辑的复杂性</h5><p>逻辑复杂的组件，一个典型特征就是单个组件承担了太多的功能，另外一个典型特征就是采用了复杂的算法。复杂算法导致的问题主要是难以理解，进而导致难以实现、难以修改，并且出了问题难以快速解决。</p>
<h4 id="演化原则"><a href="#演化原则" class="headerlink" title="演化原则"></a>演化原则</h4><p>​	演化原则宣言：“演化优于一步到位”。</p>
<ul>
<li>首先，设计出来的架构要满足当时的业务需要。</li>
<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</li>
<li>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。</li>
</ul>
<p>​	因为很难完美预测所有的业务发展和变化路径，所以应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>
<p>​	另外关于原则还有类似的可以查看<a target="_blank" rel="noopener" href="https://towardsdatascience.com/5-key-principles-of-software-architecture-e5379cb10fd5">这里</a>，以及<a target="_blank" rel="noopener" href="https://baozh.github.io/2015-12/tencent-massive-service-discipline/">解密腾讯海量服务之道</a>也值得参考。</p>
<h3 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a>架构演化</h3><p>​	我们在之前讨论了编程语言的发展，这里也同样来看下架构的演化，看看我们能从中收获什么。</p>
<h4 id="原始分布式时代：Unix设计哲学"><a href="#原始分布式时代：Unix设计哲学" class="headerlink" title="原始分布式时代：Unix设计哲学"></a>原始分布式时代：Unix设计哲学</h4><p>​	在20 世纪 70 年代末到 80 年代初，计算机科学刚经历了从以大型机为主，到向以微型机为主的蜕变，这个时候的微型计算机系统，通常具有 16 位寻址能力、不足 5MHz（兆赫）时钟频率的处理器和 128KB 左右的内存地址空间，为了突破硬件算力的限制，各个高校、研究机构、软硬件厂商，都开始分头探索，想看看到底能不能使用多台计算机共同协作，来支撑同一套软件系统的运行。这个阶段其实是对分布式架构最原始的探索与研究。而亲身经历过那个年代的计算机科学家、IBM 院士凯尔 · 布朗（Kyle Brown），在事后曾经评价道，“这次尝试最大的收获就是对 RPC、DFS 等概念的开创，以及得到了一个价值千金的教训：某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果”。<br>​	在当时计算机科学面前，有两条通往更大规模软件系统的道路，一条路是尽快提升单机的处理能力，以避免分布式的种种问题；另一条路是找到更完美的解决方案，来应对如何构筑分布式系统的问题。（服务的发现、跟踪、通讯、容错、隔离、配置、传输、数据一致性和编码复杂度等方面的问题）<br>​	在 20 世纪 80 年代，正是摩尔定律开始稳定发挥作用的黄金时期，微型计算机的性能以每两年就增长一倍的惊人速度在提升，硬件算力束缚软件规模的链条，很快就松动了，我们用单台或者几台计算机，就可以作为服务器来支撑大型信息系统的运作了，信息系统进入了单体时代，而且在未来很长的一段时间内，单体系统都将是软件架构的主流。<br>不过尽管如此，对于另外一条路径，也就是对分布式计算、远程服务调用的探索，开发者们也从没有中断过。才有了后面的SOA、微服务。</p>
<h4 id="单体架构：最广泛的架构风格"><a href="#单体架构：最广泛的架构风格" class="headerlink" title="单体架构：最广泛的架构风格"></a>单体架构：最广泛的架构风格</h4><p>​	单体架构是绝大部分软件开发者都学习和实践过的一种软件架构，很多介绍微服务的图书和技术资料中，也常常会把这种架构形式的应用称作“巨石系统”（Monolithic Application）。在整个软件架构演进的历史进程里，单体架构是出现时间最早、应用范围最广、使用人数最多、统治历史最长的一种架构风格。</p>
<h5 id="落后架构"><a href="#落后架构" class="headerlink" title="落后架构"></a>落后架构</h5><p>​	那在剖析单体架构之前呢，我们有必要先搞清楚对单体架构的两个思维误区，一个是认为，单体架构是落后的系统架构风格，最终会被微服务所取代。</p>
<p>​	对于小型系统，也就是用单台机器就足以支撑其良好运行的系统来说，这样的单体不仅易于开发、易于测试、易于部署，而且因为各个功能、模块、方法的调用过程，都是在进程内调用的，不会发生进程间通讯，所以程序的运行效率也要比分布式系统更高。所以，当我们在讨论单体系统的缺陷的时候，必须基于软件的性能需求超过了单机，软件的开发人员规模明显超过了“2 Pizza Teams”范畴的前提下，这样才有讨论的价值。</p>
<h5 id="不可拆分"><a href="#不可拆分" class="headerlink" title="不可拆分"></a>不可拆分</h5><p>​	另一个误区是“不可拆分”，难以扩展，所以它才不能支撑起越来越大的软件规模。但它的不可拆分，可能我们的理解也需要弄清楚。<br>​	从两个角度来看拆分，纵向角度可拆分，分层架构（Layered Architecture）已经是现在几乎所有的信息系统建设中，都普遍认可、普遍采用的软件设计方法了。无论是单体还是微服务，或者是其他架构风格，都会对代码进行纵向拆分，收到的外部请求会在各层之间，以不同形式的数据结构进行流转传递，在触及到最末端的数据库后依次返回响应。</p>
<p>​	而在横向角度的“可拆分”上，单体架构也可以支持按照技术、功能、职责等角度，把软件拆分为各种模块，以便重用和团队管理。即使是从横向扩展（Scale Horizontally）的角度来衡量，如果我们要在负载均衡器之后，同时部署若干个单体系统的副本，以达到分摊流量压力的效果，那么基于单体架构，也是轻而易举就可以实现的。单体系统也会做集群部署，也会有服务冗余，也会进行主从热备。</p>
<p>​	单体系统的真正缺陷实际上并不在于要如何拆分，而在于拆分之后，它会存在隔离与自治能力上的欠缺。</p>
<p>​	单体作为迄今为止使用人数最多的一种软件架构风格，自身必定是有可取之处的，比如说，易于分层、易于开发、易于部署测试、进程内的高效交互，等等，这些都是单体架构的优点。可是，今天以微服务为代表的分布式架构的呼声如此之高，也同样说明，单体至少在当今的某些领域中存在一些关键性的问题。</p>
<h4 id="SOA架构：成功理论失败实践"><a href="#SOA架构：成功理论失败实践" class="headerlink" title="SOA架构：成功理论失败实践"></a>SOA架构：成功理论失败实践</h4><p>​	在介绍 SOA 架构模式之前，我们先来看三种比较有代表性的服务拆分的架构模式。这些架构是 SOA 演化过程的中间产物，你也可以理解为，它们是 SOA 架构出现的必要前提。</p>
<h5 id="烟囱式架构（Information-Silo-Architecture）"><a href="#烟囱式架构（Information-Silo-Architecture）" class="headerlink" title="烟囱式架构（Information Silo Architecture）"></a>烟囱式架构（Information Silo Architecture）</h5><p>​	信息烟囱也被叫做信息孤岛（Information Island），使用这种架构的系统呢，也被称为孤岛式信息系统或者烟囱式信息系统。这种信息系统，完全不会跟其他相关的信息系统之间进行互操作，或者是进行协调工作。</p>
<p>​	所以，两个不发生交互的信息系统，让它们使用独立的数据库、服务器，就可以完成拆分了。而唯一的问题，也是这个架构模式的致命问题，那就是：企业中真的存在完全不发生交互的部门吗？</p>
<h5 id="微内核架构（Microkernel-Architecture）"><a href="#微内核架构（Microkernel-Architecture）" class="headerlink" title="微内核架构（Microkernel Architecture）"></a>微内核架构（Microkernel Architecture）</h5><p>​	既然在烟囱式架构中，我们说两个没有业务往来关系的系统，也可能需要共享人员、组织、权限等一些公共的主数据，那就不妨把这些主数据，连同其他可能被各个子系统使用到的公共服务、数据、资源，都集中到一块，成为一个被所有业务系统共同依赖的核心系统（Kernel，也称为 Core System）。这样的话，具体的业务系统就能以插件模块（Plug-in Modules）的形式存在了，就可以为整个系统提供可扩展的、灵活的、天然隔离的功能特性。</p>
<p>​	不过，微内核架构也有它的局限和使用前提，它会假设系统中各个插件模块之间是互不认识的（不可预知系统会安装哪些模块），这些插件会访问内核中一些公共的资源，但不会发生直接交互。</p>
<p>​	可是，无论是在企业信息系统还是在互联网，在许多场景中这一假设都不成立。比如说，你要建设一个购物网站，支付子系统和用户子系统是独立的，但当交易发生时，支付子系统可能需要从用户子系统中得到是否是 VIP、银行账号等信息，而用户子系统也可能要从支付子系统中获取交易金额等数据，来维护用户积分。所以，我们必须找到一个办法，它既能拆分出独立的系统，也能让拆分后的子系统之间可以顺畅地互相调用通讯</p>
<h5 id="事件驱动架构（Event-Driven-Architecture）"><a href="#事件驱动架构（Event-Driven-Architecture）" class="headerlink" title="事件驱动架构（Event-Driven Architecture）"></a>事件驱动架构（Event-Driven Architecture）</h5><p>那么，为了能让子系统之间互相通讯，事件驱动架构就应运而生了。这种架构模式的运作方案是，在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送到管道中，各个子系统可以从管道里获取自己感兴趣、可以处理的事件消息，也可以为事件新增或者是修改其中的附加信息，甚至还可以自己发布一些新的事件到管道队列中去。这样一来，每一个消息的处理者都是独立的、高度解耦的，但它又能与其他处理者（如果存在该消息处理者的话）通过事件管道来进行互动。</p>
<p>当系统演化至事件驱动架构的时候，且第二条通往大规模软件的路径，也就是仍然在并行发展的远程服务调用，就迎来了 SOAP 协议的诞生。此时“面向服务的架构”（Service Oriented Architecture，SOA），就已经有了登上软件架构舞台所需要的全部前置条件了。</p>
<p>SOA 看可以称之为一套软件架构的基础平台。</p>
<p>那，我们怎么理解“基础平台”这个概念呢？主要是下面几个方面：</p>
<ul>
<li>SOA 拥有领导制定技术标准的组织 Open CSA；</li>
<li>SOA 具有清晰的软件设计的指导原则，比如服务的封装性、自治、松耦合、可重用、可组合、无状态，等  等；SOA 架构明确了采用 SOAP 作为远程调用的协议，依靠 SOAP 协议族（WSDL、UDDI 和一大票 WS-* 协议）来完成服务的发布、发现和治理；</li>
<li>SOA 架构会利用一个被称为是企业服务总线（Enterprise Service Bus，ESB）的消息管道，来实现各个子系统之间的通讯交互，这就让各个服务间在 ESB 的调度下，不需要相互依赖就可以实现相互通讯，既带来了服务松耦合的好处，也为以后可以进一步实现业务流程编排（Business Process Management，BPM）提供了基础；</li>
<li>SOA 架构使用了服务数据对象（Service Data Object，SDO）来访问和表示数据，使用服务组件架构（Service Component Architecture，SCA）来定义服务封装的形式和服务运行的容器；</li>
</ul>
<p>​	在这一整套成体系、可以互相精密协作的技术组件的支持下，我们从技术可行性的角度来评判的话，SOA 实际上就可以算是成功地解决了分布式环境下，出现的诸如服务注册、发现、隔离、治理等主要技术问题了。</p>
<p>​	但SOA 架构过于严谨精密的流程与理论，导致了软件开发的全过程，都需要有懂得复杂概念的专业人员才能够驾驭，最本质的原因就是过于严格的规范定义，给架构带来了过度的复杂性，这其实跟当年的EJB（Enterprise JavaBean，企业级 JavaBean）的失败如出一辙。</p>
<h4 id="微服务架构：SOA革命者"><a href="#微服务架构：SOA革命者" class="headerlink" title="微服务架构：SOA革命者"></a>微服务架构：SOA革命者</h4><p>​	“微服务”这个词，并不是直接凭空创造出来的概念。最开始的微服务，可以说是在 SOA 发展的同时被催生出来的产物，就像是 EJB 在推广的过程中，催生出了 Spring 和 Hibernate 框架那样。这一阶段的微服务，是作为 SOA 的一种轻量化的补救方案而被提出来的。</p>
<p>​	微服务真正崛起是在 2014 年，也就是从 Martin Fowler 和 James Lewis 合写的文章“<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html#">Microservices: a definition of this new architectural term</a>”里面，第一次了解到微服务的。<br>​	这篇文章定义了现代微服务的概念：微服务是一种通过多个小型服务的组合，来构建单个应用的架构风格，这些服务会围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的数据存储技术、运行在不同的进程之中。服务会采取轻量级的通讯机制和自动化的部署机制，来实现通讯与运维。</p>
<p>在这篇论文中，作者还列举出了微服务的九个核心的业务与技术特征</p>
<ul>
<li><p>第一，围绕业务能力构建（Organized around Business Capabilities）</p>
</li>
<li><p>第二，分散治理（Decentralized Governance）</p>
</li>
<li><p>第三，通过服务来实现独立自治的组件（Componentization via Services）</p>
</li>
<li><p>第四，产品化思维（Products not Projects）</p>
</li>
<li><p>第五，数据去中心化（Decentralized Data Management）</p>
</li>
<li><p>第六，轻量级通讯机制（Smart Endpoints and Dumb Pipes）</p>
</li>
<li><p>第七，容错性设计（Design for Failure）</p>
</li>
<li><p>第八，演进式设计（Evolutionary Design）</p>
</li>
<li><p>第九，基础设施自动化（Infrastructure Automation）</p>
</li>
</ul>
<p>微服务追求的是更加自由的架构风格，它摒弃了 SOA 中几乎所有可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”。</p>
<p>​	可是，如果没有了统一的规范和约束，以前 SOA 解决的那些分布式服务的问题，不又都重新出现了吗？没错，的确如此。服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等问题，在微服务中，都不再会有统一的解决方案。例如，即使我们只讨论 Java 范围内会使用到的微服务，那么光一个服务间通讯的问题，可以列入候选清单的解决方案就有很多很多。比如，RMI（Sun&#x2F;Oracle）、Thrift（Facebook）、Dubbo（阿里巴巴）、gRPC（Google）、Motan2（新浪）、Finagle（Twitter）、brpc（百度）、Arvo（Hadoop）、JSON-RPC、REST，等等。再来举个例子，光一个服务发现问题，我们可以选择的解决方案就有：Eureka（Netflix）、Consul（HashiCorp）、Nacos（阿里巴巴）、ZooKeeper（Apache）、etcd（CoreOS）、CoreDNS（CNCF），等等。</p>
<p>​	在微服务时代中，软件研发本身的复杂度应该说是有所降低，一个简单服务，并不见得就会同时面临分布式中所有的问题，也就没有必要背上 SOA 那百宝袋般沉重的技术包袱。微服务架构下，我们需要解决什么问题，就引入什么工具；团队熟悉什么技术，就使用什么框架。此外，像 Spring Cloud 这样的胶水式的全家桶工具集，通过一致的接口、声明和配置，进一步屏蔽了源自于具体工具、框架的复杂性，降低了在不同工具、框架之间切换的成本</p>
<h4 id="后微服务时代：云原生"><a href="#后微服务时代：云原生" class="headerlink" title="后微服务时代：云原生"></a>后微服务时代：云原生</h4><p>​		微服务时代，我们之所以不得不在应用服务层面，而不是基础设施层面去解决这些分布式问题，完全是因为由硬件构成的基础设施，跟不上由软件构成的应用服务的灵活性。这其实是一种无奈之举。	</p>
<p>​	但是随着2017 年 Kubernetes 赢得容器战争的胜利，标志着后微服务时代的到来，开始普遍采用的通过虚拟化（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtualization">虚拟化</a>技术和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OS-level_virtualization">容器化</a>技术）的基础设施，去解决分布式架构问题的方案。</p>
<p>​	针对同一个分布式服务的问题，对比下 Spring Cloud 中提供的应用层面的解决方案，以及 Kubernetes 中提供的基础设施层面的解决方案。</p>
<p>​                              	<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191238.jpg" alt="img" style="zoom:30%;" /></p>
<p>​	但 Kubernetes 其实并没有完美地解决全部的分布式问题。这里所说的“不完美”的意思是，仅从功能灵活强大这点来看，Kubernetes 反而还不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，我们很难能完全在基础设施的层面中，去精细化地解决掉它们。</p>
<p>​	为了解决这一类问题，微服务基础设施很快就进行了第二次进化，引入在今天被我们叫做是“服务网格”（Service Mesh）的“边车代理模式”（Sidecar Proxy）。</p>
<p>​                                     	<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191243.jpg" alt="img" style="zoom:80%;" /></p>
<p>​	服务网格将会成为微服务之间通讯交互的主流模式，它会把“选择什么通讯协议”“如何做认证授权”之类的技术问题隔离于应用软件之外，取代今天的 Spring Cloud 全家桶中的大部分组件的功能。这是最理想的Smart Endpoints解决方案，微服务只需要考虑业务本身的逻辑就行了，业务与技术完全分离，远程与本地完全透明，这也许这就是分布式架构最好的时代吧。</p>
<h4 id="无服务时代：“不分布式”云端系统的起点"><a href="#无服务时代：“不分布式”云端系统的起点" class="headerlink" title="无服务时代：“不分布式”云端系统的起点"></a>无服务时代：“不分布式”云端系统的起点</h4><p>​	我们都知道，分布式架构出现的最初目的，是要解决单台机器的性能成为整个软件系统的瓶颈的问题。后来随着技术的演进，容错能力、技术异构、职责划分等其他因素，也都成了分布式架构要考虑的问题。但不可否认的是，获得更好的性能，仍然在架构设计中占有非常大的比重。</p>
<p>​	但分布式架构也会引入一些新问题（比如服务的安全、容错，分布式事务的一致性），因此对软件开发这件事儿来说，不去做分布式无疑是最简单的。如果单台服务器的性能可以是无限的，那架构演进的结果，肯定会跟今天不一样。不管是分布式和容器化，还是微服务，恐怕都未必会出现了，最起码不会是今天的模样。</p>
<p>​	当然了，绝对意义上的无限性能肯定是不存在的，但相对意义上的无限性能其实已经实现了，云计算的成功落地就可以说明这一点。对基于云计算的软件系统来说，无论用户有多少、逻辑如何复杂，AWS、阿里云等云服务提供商都能在算力上满足系统对性能的需求，只要你能为这种无限的性能支付得起对应的代价。</p>
<p>​	“无服务”（Serverless）涉及了后端设施（Backend）和函数（Function）两块内容。</p>
<ul>
<li><p>后端设施是指数据库、消息队列、日志、存储等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件。这些后端设施都运行在云中，也就是无服务中的“后端即服务”（Backend as a Service，BaaS）。</p>
</li>
<li><p>函数指的就是业务逻辑代码。这里函数的概念与粒度，都已经和程序编码角度的函数非常接近了，区别就在于，无服务中的函数运行在云端，不必考虑算力问题和容量规划（从技术角度可以不考虑，但从计费的角度来看，你还是要掂量一下自己的钱包够不够用），也就是无服务中的“函数即服务”（Function as a Service，FaaS）。</p>
</li>
</ul>
<p>无服务的愿景是让开发者只需要纯粹地关注业务：</p>
<ul>
<li>一是，不用考虑技术组件，因为后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼；</li>
<li>二是，不需要考虑如何部署，因为部署过程完全是托管到云端的，由云端自动完成；</li>
<li>三是，不需要考虑算力，因为有整个数据中心的支撑，算力可以认为是无限的；</li>
<li>四是，也不需要操心运维，维护系统持续地平稳运行是云服务商的责任，而不再是开发者的责任。</li>
</ul>
<p>​	这是不是就像从汇编语言发展到高级语言后，开发者不用再去关注寄存器、信号、中断等与机器底层相关的细节？没错儿，UC Berkeley 的论文“Cloud Programming Simplified: A Berkeley View on Serverless Computing”中，就是这样描述无服务给生产力带来的极大解放的。</p>
<p>​	与单体架构、微服务架构不同，无服务架构天生的一些特点，比如冷启动、 无状态、运行时间有限制等等，决定了它不是一种具有普适性的架构模式。软件开发的未来，不会只存在某一种“最先进的”架构风格，而是会有多种具有针对性的架构风格并存。更多详情可以查看这里，凤凰架构-周志明。</p>
<h3 id="架构模式（风格）"><a href="#架构模式（风格）" class="headerlink" title="架构模式（风格）"></a>架构模式（风格）</h3><p>​	<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a>也像<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">设计模式</a>一样，都是通用性，可复用的解决方案。不同的是，架构模式是针对在特定情境下软件架构上的常见问题。</p>
<p>在架构演进中我们就提到以下模式：</p>
<ul>
<li>单体架构（ <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monolithic_application">Monolithic application</a>）</li>
<li>分层架构 （<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Layered_architecture">Layered</a> ）</li>
<li>烟囱式架构（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Information_silo">Information Silo Architecture</a>）</li>
<li>微内核架构（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microkernel">Microkernel Architecture</a>）</li>
<li>事件驱动架构  (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event-driven_architecture">Event-driven</a>)</li>
<li>SOA架构（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service-oriented_architecture">Service-oriented</a>）</li>
<li>微服务架构<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microservices">Microservices architecture</a></li>
<li>服务网格（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service_mesh">Service Mesh</a>）</li>
<li>无服务架构（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serverless_computing">Serverless computing</a>）</li>
</ul>
<p>​	在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_architecture">wiki</a>中还有以下常见的模式：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blackboard_(computing)">Blackboard</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">Client-server</a> (2-tier, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Three-tier_(computing)">3-tier</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/N-tier"><em>n</em>-tier</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cloud_computing">cloud computing</a> exhibit this style)</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_componentry">Component-based</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database-centric_architecture">Data-centric</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Peer-to-peer">Peer-to-peer</a> (P2P)</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pipes_and_filters">Pipes and filters</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Plug-in_(computing)">Plug-ins</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/w/index.php?title=Reactive_architecture&action=edit&redlink=1">Reactive architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Representational_state_transfer">Representational state transfer</a> (REST)</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rule-based_system">Rule-based</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_nothing_architecture">Shared nothing architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Space-based_architecture">Space-based architecture</a></li>
</ul>
<p>更多模式设计相关可以参考下面资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.oreilly.com/content/software-architecture-patterns/">software-architecture-patterns</a> ，oreilly中对上述几种常见的模式进行深入分析。</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/">Cloud Design Patterns</a> ，微软云平台 Azure 上的设计模式，罗列了分布式设计的各种设计模式，对于每一个模式都有详细的说明，并有对其优缺点的讨论，以及适用场景和不适用场景的说明。</li>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/45406.pdf">Design patterns for container-based distributed systems</a>，Google在容器化下的分布式架构的设计模式。</li>
<li><a target="_blank" rel="noopener" href="https://martinfowler.com/articles/patterns-of-distributed-systems/">Patterns for distributed systems</a>， Martin Fowler 关于分布式系统的设计模式。</li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1230559/">Patterns of Enterprise Application Architecture</a>，Martin Fowler专门针对企业应用架构的书写的，企业应用架构设计模式。</li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/">Designing Data-Intensive Applications</a>，中文译名数据密集型应用系统设计，但其实讲了很多分布式相关的设计和理论。</li>
</ul>
<h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><p>​	架构设计终究是要落地的，而落地的实践，最终离不开代码，模块（组件）的组织。下面我们就来讨论下面“向对象的设计”</p>
<h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><p>​	面向对象设计目标是高内聚、低耦合，那么今天我们从这两个维度，看组件的设计原则。</p>
<h4 id="组件内聚原则"><a href="#组件内聚原则" class="headerlink" title="组件内聚原则"></a>组件内聚原则</h4><p>​	组件内聚原则主要讨论哪些类应该聚合在同一个组件中，以便组件既能提供相对完整的功能，又不至于太过庞大。在具体设计中，可以遵循以下三个原则。</p>
<ul>
<li>复用发布等同原则，软件复用的最小粒度应该等同于其发布的最小粒度</li>
<li>共同封闭原则，我们应该将那些会同时修改，并且为了相同目的而修改的类放到同一个组件中。</li>
<li>共同复用原则，不要强迫一个组件的用户依赖他们不需要的东西。</li>
</ul>
<h4 id="组件耦合原则"><a href="#组件耦合原则" class="headerlink" title="组件耦合原则"></a>组件耦合原则</h4><ul>
<li>无循环依赖原则，组件依赖关系中不应该出现环</li>
<li>稳定依赖原则，组件依赖关系必须指向更稳定的方向</li>
<li>稳定抽象原则，一个组件的抽象化程度应该与其稳定性程度一致（JDBC,slf4j）</li>
</ul>
<p>​	当然，上面讨论的是关于组件的，并没有考虑业务场景（模块的划分，更多的是业务场景的考虑），构建模型的难点，首先在于分离关注点，其次在于找到共性。下面我们从面向对象的概念来具体看看这两个难点。</p>
<h3 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h3><p>​	使用面向对象语言（java）写出来的代码风格就是面向对象的吗？可能未必，如果对面向对象的理解有偏差，可能会写出C语言风格的代码，例如代码里却没有体现出面向对象程序的特点，没有封装，更不用说继承和多态。所以在讨论设计之前有必要先聊聊面向对象的几个特征。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><h5 id="理解封装"><a href="#理解封装" class="headerlink" title="理解封装"></a>理解封装</h5><p>​	封装，是面向对象的根基。它把紧密相关的信息放在一起，形成一个单元。“面向对象”这个词是由 Alan Kay 创造的，他是 2003 年图灵奖的获得者。在他最初的构想中：</p>
<blockquote>
<p>对象就是一个细胞。当细胞一点一点组织起来，就可以组成身体的各个器官，再一点一点组织起来，就构成了人体。而当你去观察人的时候，就不用再去考虑每个细胞是怎样的</p>
</blockquote>
<p>​	封装的重点在于对象提供了哪些行为，而不是有哪些数据。理解了这一点，我们来看一个日常编程习惯，编写一个类的方法是，把这个类有哪些字段写出来，然后，生成一大堆 getter 和 setter，将这些字段的访问暴露出去。这种做法的错误就在于把数据当成了设计的核心，这一堆的 getter 和 setter，就等于把实现细节暴露了出去。</p>
<p>​	一个正确的做法应该是，我们设计一个类，先要考虑其对象应该提供哪些行为。然后，我们根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。</p>
<h5 id="减少暴露接口"><a href="#减少暴露接口" class="headerlink" title="减少暴露接口"></a>减少暴露接口</h5><p>​	封装，除了要减少内部实现细节的暴露，还要减少对外接口的暴露。一个原则是最小化接口暴露。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​	如果我们把继承理解成一种代码复用方式，更多地是站在子类的角度向上看。在客户端代码使用的时候，面对的是子类，这种继承叫实现继承:</p>
<pre><code class="java">    Child object = new Child();
</code></pre>
<p>另一种看待继承的角度，就是从父类的角度往下看，客户端使用的时候，面对的是父类，这种继承叫接口继承:</p>
<pre><code class="java">    Parent object = new Child();
</code></pre>
<p>​	其实把<strong>实现继承</strong>当作一种代码复用的方式，并不是好的方式。主要有以下两点：</p>
<ul>
<li>java是单继承语言，每个类只能有一个父类，一旦继承的位置被实现继承占据了，再想做接口继承就很难了。</li>
<li>实现继承通常也是一种受程序设计语言局限的思维方式，有很多程序设计语言，即使不使用继承，也有自己的代码复用方式。</li>
</ul>
<h5 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h5><p>​	有一个通用的原则叫做：组合优于继承。也就是说，如果一个方案既能用组合实现，也能用继承实现，那就选择用组合实现。</p>
<p>​	通过一个例子，我们来看下组合和继承设计上的差异。我们有个字体类（Font），现在的需求是，字体能够加粗（Bold）、能够有下划线（Underline）、还要支持斜体（Italic），而且这些能力之间是任意组合的。</p>
<p>​	如果采用继承的方式，那就要有 8 个类：</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191251.jpg" alt="img" style="zoom:30%;" />

<p>​	而采用组合的方式，我们的字体类（Font）只要有三个独立的维度，也就是是否加粗（Bold）、是否有下划线（Underline）、是否是斜体（Italic）。这还不是终局，如果再来一种其他的要求，由 3 种要求变成 4 种，采用继承的方式，类的数量就会膨胀到 16 个类，而组合的方式只需要再增加一个维度就好。我们把一个 M*N 的问题，通过设计转变成了 M+N 的问题，复杂度的差别一望便知。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​	多态（Polymorphism），顾名思义，一个接口，多种形态。上面讲了继承有两种，实现继承和接口继承。其中，实现继承尽可能用组合的方式替代继承。而接口继承，主要是给多态用的。运用多态需要构建出一个抽象，即找出不同事物的共同点。而寻找共同点这件事，最主要还是在分离关注点上。</p>
<p>​	在构建抽象上，接口扮演着重要的角色。</p>
<h5 id="隔离变化"><a href="#隔离变化" class="headerlink" title="隔离变化"></a>隔离变化</h5><p>​	首先，接口将变的部分和不变的部分隔离开来，不变的部分就是接口的约定，而变的部分就是子类各自的实现。在软件开发中，对系统影响最大的就是变化。识别出变与不变，是一种很重要的能力。</p>
<h5 id="定义边界"><a href="#定义边界" class="headerlink" title="定义边界"></a>定义边界</h5><p>​	其次，接口是一个边界。无论是什么样的系统，清晰界定不同模块的职责是很关键的，而模块之间彼此通信最重要的就是通信协议。这种通信协议对应到代码层面上，就是接口。实际开发中，我们在接口中添加方法总是很随意，并没有区分实现者和使用者角色的差异，这也就导致边界的模糊，模块划分不清，彼此之间互相影响。</p>
<h5 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h5><p>​	面向对象的基本原则，面向接口编程。面向接口编程的价值就根植于多态，也正是因为有了多态，一些设计原则，比如，开闭原则、接口隔离原则才得以成立，相应地，设计模式才有了立足之本。</p>
<h3 id="设计的目的"><a href="#设计的目的" class="headerlink" title="设计的目的"></a>设计的目的</h3><p>​	 在讨论设计的目的之前，先来看看没有设计，或者糟糕的设计会带来什么样的影响。</p>
<h4 id="糟糕的设计"><a href="#糟糕的设计" class="headerlink" title="糟糕的设计"></a>糟糕的设计</h4><p>​	糟糕的设计和代码有如下一些特点，这些特点共同铸造了糟糕的软件。</p>
<h5 id="僵化性"><a href="#僵化性" class="headerlink" title="僵化性"></a>僵化性</h5><p>​	代码之间耦合严重，难以改动，任何微小的改动都会引起更大范围的改动。一个看似微小的需求变更，却发现需要在很多地方修改代码。修改的成本随着时间的增长而增加。</p>
<h5 id="脆弱性"><a href="#脆弱性" class="headerlink" title="脆弱性"></a>脆弱性</h5><p>​	比僵化性更糟糕的是脆弱性，僵化导致任何一个微小的改动都能引起更大范围的改动，而脆弱则是微小的改动容易引起莫名其妙的崩溃或者 bug，出现 bug 的地方看似与改动的地方毫无关联，或者软件进行了一个看似简单的改动，重新启动，然后就莫名其妙地崩溃了。</p>
<h5 id="牢固性"><a href="#牢固性" class="headerlink" title="牢固性"></a>牢固性</h5><p>​	牢固性是指软件无法进行快速、有效地拆分。想要复用软件的一部分功能，却无法容易地将这部分功能从其他部分中分离出来。</p>
<h5 id="粘滞性"><a href="#粘滞性" class="headerlink" title="粘滞性"></a>粘滞性</h5><p>​	需求变更导致软件变更的时候，如果糟糕的代码变更方案比优秀的方案更容易实施，那么软件就会向糟糕的方向发展。很多软件在设计之初有着良好的设计，但是随着一次一次的需求变更，最后变得千疮百孔，趋向腐坏。</p>
<h5 id="晦涩性"><a href="#晦涩性" class="headerlink" title="晦涩性"></a>晦涩性</h5><p>​	代码首先是给人看的，其次是给计算机执行的。如果代码晦涩难懂，必然会导致代码的维护者以设计者不期望的方式对代码进行修改，导致系统腐坏变质。把代码写简单可不容易。</p>
<p>​	软件不是一次性的，在其漫长的生命周期中会被不断修改、迭代、演化、发展。如果毫无设计，或者糟糕的设计会导致其不断腐化，而解决之道就是遵循设计原则，灵活运用各种设计模式。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>​		在软件设计中，有众多的原则，这里我们就来讲讲SOLID这个面向对象的设计原则。</p>
<ul>
<li><p>单一职责原则（Single Responsibility Principle, SRP）</p>
</li>
<li><p>开闭原则（Open Closed Principle，OCP）</p>
</li>
<li><p>里氏替换原则（Liskov Substitution Principle，LSP）</p>
</li>
<li><p>接口隔离原则（Interface Segregation Principle，ISP）</p>
</li>
<li><p>依赖倒转原则（Dependency Inversion Principle，DIP）</p>
</li>
</ul>
<p>​	下面简单讲讲这几个原则。</p>
<h4 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h4><p>​	设计类的时候，我们应该把强相关的元素放在一个类里，而弱相关性的元素放在类的外边。保持类的高内聚性。具体设计时应该遵循这样一个设计原则：一个类，应该只有一个引起它变化的原因。</p>
<p>​	如果一个类承担的职责太多，就等于把这些职责都耦合在一起。这种耦合会导致类很脆弱：当变化发生的时候，会引起类不必要的修改，进而导致 bug 出现。职责太多，还会导致类的代码太多。</p>
<p>​	一个类太大，它就很难保证满足<strong>开闭原则</strong>，如果不得不打开类文件进行修改，大堆大堆的代码呈现在屏幕上，一不小心就会引出不必要的错误。</p>
<p>​	如何判断一个类是否违法了单一职责原则很简单，就是看这个类是否只有一个引起它变化的原因。或者日常代码解决提交冲突最多的那个类，就该引起你的注意了。</p>
<p>​	而关于拆分方法，可以从功能职责维度去做拆分（配合DDD里聚合的设计食用更佳）、也可以从处理步骤的维度去做拆分。</p>
<h4 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则(OCP)"></a>开闭原则(OCP)</h4><p>​	软件实体（模块、类、函数等等）应该对扩展是开放的，对修改是关闭的。这听起来有点矛盾，不修改，怎么实现功能需求的变更。我们先来看看哪些是违法开闭原则的。</p>
<p>​	简单粗暴来看，当我们在代码中看到 else 或者 switch&#x2F;case 关键字的时候，这里就要小心是否违反开闭原则了。这是因为当我们想要进行任何需求变更的时候，都必须要修改代码。同时我们需要注意，大段的 switch&#x2F;case 语句是非常脆弱的，当需要增加新的类型的时候，需要非常谨慎地在这段代码中找到合适的位置，稍不小心就可能出现 bug。</p>
<p>​	设计模式中很多模式其实都是用来解决软件的扩展性问题的，也是符合开闭原则的。实践中，我们可以使用，使用策略模式（用一个Factory返回策略类，把if的条件当做参数传给Factory，就不需要if了。 或者用一个map记录&lt;if条件变量，策略对象&gt;，从map中获得策略，也不需要if了），适配器模式，观察者模式，模板方法模式来实现开闭原则，实现开闭原则的关键是抽象。</p>
<p>​	<strong>开闭原则可以说是软件设计原则的原则，是软件设计的核心原则，其他的设计原则更偏向技术性，具有技术性的指导意义，而开闭原则是方向性的。</strong></p>
<h4 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h4><p>​	关于如何设计类的继承关系，怎样使<strong>继承</strong>不违反<strong>开闭原则</strong>，实际上有一个关于继承的设计原则，叫里氏替换原则。简单来说就是程序中，所有使用基类的地方，都应该可以用子类代替。</p>
<p>​	怎么判断违反里氏替换原则，就不得不提起经典案例， 正方形可以继承长方形吗？小马驹可以继承马吗？</p>
<p>一个继承设计是否违反里氏替换原则，需要在具体场景中考察。而一个重要的契约是子类不能比父类更严格。</p>
<p>​	正方形继承了长方形，但是正方形有比长方形更严格的契约，即正方形要求长和宽是一样的。因为正方形有比长方形更严格的契约，那么在使用长方形的地方，正方形因为更严格的契约而无法替换长方形。我们开头小马继承马的例子也是如此，小马比马有更严格的要求，即不能骑，那么小马继承马就是不合适的。</p>
<p>​	再来看看JDK中违反的例子</p>
<p>​                                                  	<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191257.png" 		alt="img" style="zoom:80%;" />     </p>
<p>​	Properties 要求处理的数据类型是 String，而它的父类 Hashtable 要求处理的数据类型是 Object，子类比父类的契约更严格；Stack 是一个栈数据结构，数据只能后进先出，而它的父类 Vector 是一个线性表，子类比父类的契约更严格。</p>
<h4 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h4><p>​	当一个类比较大的时候，如果该类的不同调用者被迫依赖类的所有方法，就可能产生不必要的耦合。对这个类的改动也可能会影响到它的不同调用者，引起误用，导致对象被破坏，引发 bug。</p>
<p>​	使用接口隔离原则，就是定义多个接口，不同调用者依赖不同的接口，只看到自己需要的方法。而实现类则实现这些接口，通过多个接口将类内部不同的方法隔离开来。</p>
<p>​	一方面，从API开发和调用的角度来看，使用接口隔离可以以避免不必要的依赖和方法的误用。</p>
<p>​	一方面是划分职责，接口隔离原则在迭代器设计模式中的应用，在 Java5 以前，每种容器的遍历方法都不相同，在 Java5 以后，可以统一使用这种简化的遍历语法实现对容器的遍历。而实现这一特性，主要就在于 Java5 通过 Iterable 接口，将容器的遍历访问从容器的其他操作中隔离出来，使 Java 可以针对这个接口进行优化，提供更加便利、简洁、统一的语法。</p>
<h4 id="依赖倒转原则-DIP"><a href="#依赖倒转原则-DIP" class="headerlink" title="依赖倒转原则(DIP)"></a>依赖倒转原则(DIP)</h4><p>​	在软件开发过程中，我们经常会使用各种编程框架。这些框架的一个特点是，当开发者使用框架开发一个应用程序时，无需在程序中调用框架的代码，就可以使用框架的功能特性。比如程序不需要调用 Spring 的代码，就可以使用 Spring 的依赖注入，MVC 这些特性，开发出低耦合、高内聚的应用代码。我们的程序更不需要调用 Tomcat 的代码，就可以监听 HTTP 协议端口，处理 HTTP 请求。</p>
<p>​	这些框架设计的核心关键点，也就是面向对象的基本设计原则之一：依赖倒置原则（好莱坞原则）。</p>
<p>​	依赖倒置原则通俗说就是，高层模块不依赖低层模块，而是都依赖抽象接口，这个抽象接口通常是由高层模块定义，低层模块实现。</p>
<p>​	通常的编程习惯中，低层模块拥有自己的接口，高层模块依赖低层模块提供的接口，比如方法层有自己的接口，策略层依赖方法层的接口；DAO 层定义自己的接口，Service 层依赖 DAO 层定义的接口。</p>
<p>​	但是按照依赖倒置原则，接口的所有权是被倒置的，也就是说，接口被高层模块定义，高层模块拥有接口，低层模块实现接口。不是高层模块依赖底层模块的接口，而是低层模块依赖高层模块的接口，从而实现依赖关系的倒置。</p>
<h4 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h4><ul>
<li><p>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</p>
</li>
<li><p>最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）</p>
</li>
</ul>
<h4 id="设计原则之间的关系"><a href="#设计原则之间的关系" class="headerlink" title="设计原则之间的关系"></a>设计原则之间的关系</h4><p>从整体来看，设计原则之间的关系：单一职责是所有设计原则的基础，开闭原则是设计的终极目标。里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。依赖倒置原则是过程式编程与OO编程的分水岭，同时它也被用来指导接口隔离原则。</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191303.png" alt="img" style="zoom:50%;" />

<p>​																				<a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/what-is-solid-principle/">图片来源</a></p>
<p>thoughtworks关于原则不错的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/understand-solid-principles/">https://insights.thoughtworks.cn/understand-solid-principles/</a></li>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/what-is-solid-principle/">https://insights.thoughtworks.cn/what-is-solid-principle/</a></li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>​	所谓模式，其实就是针对的就是一些普遍存在的问题给出的解决方案。</p>
<p>​	模式这个说法起源于建筑领域，建筑师克里斯托佛·亚历山大曾把建筑中的一些模式汇集成册。结果却是墙里开花墙外香，模式这个说法却在软件行业流行了起来。</p>
<p>​	最早是 Kent Beck 和 Ward Cunningham 探索将模式这个想法应用于软件开发领域，之后，Erich Gamma 把这一思想写入了其博士论文。而真正让建筑上的模式思想成了设计模式，在软件行业得到了广泛地接受，则是在《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/34262305/">设计模式</a>》这本书出版之后了。这本书扩展了 Erich Gamma 的论文。四位作者 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 也因此名声大噪，得到了 GoF（Gang of Four，GoF） 的称呼。我们今天大部分人知道的 23 种设计模式就是从这本书来的，而困惑也是从这里开始的。</p>
<h4 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h4><p>​	面向对象编程的本质是多态，而设计模式的精髓是对多态的使用。设计原则大部分都是和多态有关的，不过这些设计原则更多时候是具有指导性，编程的时候还需要依赖更具体的编程设计方法，这些方法就是设计模式。</p>
<p>​	模式是可重复的解决方案，人们在编程实践中发现，有些问题是重复出现的，虽然场景各有不同，但是问题的本质是一样的，而解决这些问题的方法也是可以重复使用的。人们把这些可以重复使用的编程方法称为设计模式。</p>
<p>设计模式有四个基本要素：</p>
<ol>
<li>模式名称(pattern name)：一个助记名，它用一两个词来描述模式的问题、解决方案和效果。</li>
<li>问题(problem)：描述了应该在何时使用模式。</li>
<li>解决方案(solution)：描述了设计的组成成分，它们之间的相关关系以及各自的职责和协作方案。</li>
<li>效果(consequences)：描述了模式应用的效果以及使用模式应该权衡的问题。</li>
</ol>
<p>​	开发者很多时候会重点关注第1和第3点要素(过度关注设计模式和设计模式的实现)，忽略第2和第4点要素(忽视使用设计模式的场景和目标)，导致设计出来的编码逻辑可能过于复杂或者达不到预期的效果。</p>
<h4 id="GOF23"><a href="#GOF23" class="headerlink" title="GOF23"></a>GOF23</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>​	设计模式在粒度和抽象层次各不相同，下面是23种设计按照两个准则（目的和范围）进行分类</p>
<p>​	<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191308.png" alt="image-20220726154106715" style="zoom:67%;" /></p>
<p>​																	图片来源《设计模式》	</p>
<p>第一个目的准则，可分为创建型、结构型、行为型：</p>
<ul>
<li>创建型，创建型模式与对象的创建有关；</li>
<li>结构型，结构型模式处理类或对象的组合；</li>
<li>行为型，行为型模式对类或对象怎样交互和怎么样分配职责进行描述。</li>
</ul>
<p>第二个范围准则，指定模式主要是用于类还是对象：</p>
<ul>
<li>类，类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的。<ul>
<li>创建型类模式，将对象的部分创建工作延迟到子类</li>
<li>结构型类模式，使用继承机制来组合类</li>
<li>行为型类模式，使用继承描述算法和控制流</li>
</ul>
</li>
<li>对象，对象模式处理对象间的读过哪些，这些关系在运行时刻是可以变化的，具有动态性。<ul>
<li>创建型对象模式，将对象的部分创建工作延迟到另一个对象中</li>
<li>结构型对象模式，描述对象的组装方式</li>
<li>行为型对象模式，描述一组对象怎么协作完成单个对象无法完成的任务</li>
</ul>
</li>
</ul>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p>​	下图是描述模式之间怎么相互引用来组织设计模式的：</p>
<p>​	          					<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191312.png" alt="image-20220726125344083" style="zoom:50%;" /></p>
<p>​																		图片来源《设计模式》	</p>
<p>​	学习设计模式或者是在工程中实践设计模式，必须深入到某一个特定的业务场景中去，再结合对业务场景的理解和领域模型的建立，才能体会到设计模式思想的精髓。	</p>
<p>​	事实上，设计模式不仅仅包括《设计模式》这本书里讲到的 23 种设计模式，只要可重复用于解决某个问题场景的设计方案都可以被称为设计模式。</p>
<h4 id="框架中的设计模式"><a href="#框架中的设计模式" class="headerlink" title="框架中的设计模式"></a>框架中的设计模式</h4><p>​	关于框架，我们前面已经解释过了，框架是对某一类架构方案可复用的设计与实现。那么下面我们来说说如何设计、开发一个编程框架？框架应该满足哪些原则？</p>
<p>​	框架应该满足开闭原则，即面对不同应用场景，框架本身是不需要修改的，需要对修改关闭。但是各种应用功能却是可以扩展的，即对扩展开放，应用程序可以在框架的基础上扩展出各种业务功能。</p>
<p>​	同时还应该满足依赖倒置原则，即框架不应该依赖应用程序，因为开发框架的时候，应用程序还没有呢。应用程序也不应该依赖框架，这样应用程序可以灵活更换框架。框架和应用程序应该都依赖抽象</p>
<p>编程框架与应用程序、设计模式、设计原则之间的关系如下图所示。</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191316.png" alt="image-20220726170242239" style="zoom:50%;" />

<p>下面我们从设计模式的角度来看框架，都运用了哪些设计模式，学习它们的最佳实践。</p>
<h5 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h5><p>​	spring框架有大量设计模式的运用，这里简单列举几个</p>
<ul>
<li>工厂模式：通过BeanFactory和ApplicationContext来创建对象</li>
<li>单例模式：Spring Bean默认位单例模式</li>
<li>策略模式：例如ReSource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术</li>
<li>模板方法：以Template结尾的，例如RestTemplate、JmsTemplate、JpaTemplate</li>
<li>适配器模式：SpringAOP的增强或通知（Adive）使用到了适配器模式</li>
<li>观察者模式：Spring事件驱动模式</li>
</ul>
<h5 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h5><p><img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191320.jpg" alt="img"></p>
<p>​																											<a target="_blank" rel="noopener" href="https://bugstack.cn/md/spring/develop-mybatis/2022-07-15-%E7%AC%AC22%E7%AB%A0%EF%BC%9AMybatis%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">图片来源</a></p>
<p>​	其他更多框架的设计模式，例如tomcat 也可以参考 <a href="">深入分析Java Web技术内幕（修订版）</a>中也有讨论。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>​	什么时候使用？为什么会有过分设计和设计不足？ 这里的区分在于使用场景，我们在前面基本要素的也提到过这一点。</p>
<h5 id="设计不足"><a href="#设计不足" class="headerlink" title="设计不足"></a>设计不足</h5><p>​		如果已经发生了需求变更，但是你却没有用灵活的设计方法去应对，而是通过硬编码的方式在既有代码上打补丁，那么这就是设计不足。	设计模式的使用难点，在于判断模式要解决的是否是同一个问题，这也是为什么我们提倡通过重构获得模式：当问题明显出现的时候（以坏味道的形式），那么最难的一步其实你已经解决了</p>
<h5 id="过分设计"><a href="#过分设计" class="headerlink" title="过分设计"></a>过分设计</h5><p>​	如果你为需求变更而进行了设计，但是预期中的需求变更却从来没有发生过，那么你的设计就属于设计过度；</p>
<p>​	<a target="_blank" rel="noopener" href="https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8">Avoid Over Engineering</a> ，有时候，我们会过度设计我们的系统，过度设计会把我们带到另外一个复杂度上，所以，我们需要一些工程上的平衡。这篇文章是一篇非常不错地告诉你什么是过度设计的文章。</p>
<h5 id="具体场景的权衡"><a href="#具体场景的权衡" class="headerlink" title="具体场景的权衡"></a>具体场景的权衡</h5><p>​	前面我们都提到了违反原则会导致的问题，那是不是设计就一定不能违反原则，违反原则都是错误的？我们来看个具体的例子，在Servlet中，HttpServlet 通过继承 GenericServlet 实现了 Servlet 接口，并在自己的 service 方法中，针对不同的 HTTP 请求类型调用相应的方法，HttpServlet 的 service 方法就是一个模板方法。</p>
<pre><code class="java">    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
    &#123;
        String method = req.getMethod();
        if (method.equals(METHOD_GET)) &#123;
                doGet(req, resp);
        &#125; else if (method.equals(METHOD_HEAD)) &#123;
            long lastModified = getLastModified(req);
            maybeSetLastModified(resp, lastModified);
            doHead(req, resp);
        &#125; else if ...
</code></pre>
<p>​	service里方法不停的if&#x2F;else 是不是违反的我们的开闭原则？</p>
<p>​	显然是违反开闭原则的。但是这里如果用策略模式消除这些if else，可能会导致开发者需要继承不同的类处理不同的HTTP请求，提高开发者的学习和使用成本。 是否要遵循原则，要看具体场景进行权衡。HTTP协议中的请求方法诞生以来都没有被修改过，所以写死也是一个办法。</p>
<p>相关资料</p>
<ul>
<li>美团的实践，<a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/03/19/design-pattern-practice-in-marketing.html">设计模式在外卖营销业务中的实践</a></li>
<li>关于设计模式，挺有意思的<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/catalog">网站</a></li>
</ul>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><h3 id="DDD是什么"><a href="#DDD是什么" class="headerlink" title="DDD是什么"></a>DDD是什么</h3><p>​	领域驱动设计（Domain Driven Design，DDD）是 Eric Evans 在《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1629512/">领域驱动设计</a>》中提出的从系统分析到软件建模的一套方法论。它要解决什么问题呢？就是将业务概念和业务规则转换成软件系统中概念和规则，从而降低或隐藏业务复杂性，使系统具有更好的扩展性，以应对复杂多变的现实业务问题。我们前面讨论的设计，更多的是从系统和代码模块 结构的层面考虑，而领域驱动设计是设计中关于业务方面的补充。</p>
<p>​	关于设计模式和领域模型驱动设计的关系，站在业务建模的立场上，DDD的模式解决的是如何进行领域建模。而站在代码实践的立场上，设计模式主要关注于代码的设计与实现，本质上都是“模式”。</p>
<h3 id="使用DDD的目的"><a href="#使用DDD的目的" class="headerlink" title="使用DDD的目的"></a>使用DDD的目的</h3><p>​	在对抗软件架构腐烂的时候，我们可能会想到敏捷实践中的重构(重构中使用设计模式)、测试驱动设计及持续集成可以对付各种混乱问题</p>
<ul>
<li>重构，保持行为不变的代码改善清除了不协调的局部设计</li>
<li>测试驱动设计，确保对系统的更改不会导致系统丢失或破坏现有功能</li>
<li>持续集成，则为团队提供了同一代码库</li>
</ul>
<p>​	为什么我们有了这些方式，还需要使用DDD呢？</p>
<p>​	上述问题在于我们解决了设计到代码之间的重构，但提炼出来的设计模型，并不具有实际的业务含义，这就导致在开发新需求时，并不能很自然地将业务问题映射到该设计模型。设计似乎变成了重构者的自娱自乐，代码继续腐败，重新重构……无休止的循环。</p>
<p>​	用DDD进行业务建模，则可以很好地解决领域模型到设计模型的同步、演化，最后再将反映了领域的设计模型转为实际的代码。</p>
<p>​	而业务建模的难点有两个：清晰地定义业务问题，并让所有干系人都接受你对业务问题的定义；在特定架构的约束下，将模型实现出来。</p>
<h3 id="统一语言"><a href="#统一语言" class="headerlink" title="统一语言"></a>统一语言</h3><p>​	通用语言，就是在业务人员和开发人员之间建立起的一套共有的语言。统一语言可以包含以下内容：</p>
<ul>
<li>源自领域模型的概念与逻辑；</li>
<li>界限上下文（Bounded Context）；</li>
<li>系统隐喻；</li>
<li>职责的分层；</li>
<li>模式（patterns）与惯用法。</li>
</ul>
<p>​	虽然在理想中，我们希望直接使用模型作为统一语言。但从实际出发，直接使用模型的效果并不好。主要是两点：模型将业务维度隐藏了，对业务方显得不够直观；对于未提取的知识，超出了模型的表达能力。因而统一语言是非常必要的。</p>
<h4 id="怎么建立统一语言"><a href="#怎么建立统一语言" class="headerlink" title="怎么建立统一语言"></a>怎么建立统一语言</h4><p>​	至于如何建立统一语言，一般会使用事件风暴（Event Storming），主要分为三步：</p>
<ul>
<li>第一步就是把领域事件识别出来，这个系统有哪些是人们关心的结果。有了领域事件，下面一个问题是，这些事件是如何产生的，它必然会是某个动作的结果。</li>
<li>第二步就是找出这些动作，也就是引发领域事件的命令。比如：产品已上架是由产品上架这个动作引发的，而订单已下就是由下单这个命令引发的。</li>
<li>第三步就是找出与事件和命令相关的实体或聚合，比如，产品上架就需要有个产品（Product），下单就需要有订单（Order）。</li>
</ul>
<h3 id="模型-2"><a href="#模型-2" class="headerlink" title="模型"></a>模型</h3><p>​	模型在领域驱动设计中，其实主要有三个用途：</p>
<ul>
<li>通过模型反映软件实现（Implementation）的结构；</li>
<li>以模型为基础形成团队的统一语言（Ubiquitous Language）；</li>
<li>把模型作为精粹的知识，以用于传递。</li>
</ul>
<p>​	在业务系统中，构造一种专用的模型（领域模型），将相关的业务流程与功能转化成模型的行为，能避免开发人员与业务方的认知差异，这一理念的转变开始于面向对象技术的出现，而最终的完成，则是以行业对 DDD 的采纳作为标志的。</p>
<h3 id="知识消化（原则）"><a href="#知识消化（原则）" class="headerlink" title="知识消化（原则）"></a>知识消化（原则）</h3><p>​	在 DDD 中，Eric Evans 提倡了一种叫做知识消化（Knowledge Crunching）的方法帮助我们去提炼领域模型。</p>
<p>​	知识消化法具体来说有五个步骤，分别是：</p>
<ol>
<li>关联模型与软件实现；</li>
<li>基于模型提取统一语言；</li>
<li>开发富含知识的模型；</li>
<li>精炼模型；</li>
<li>头脑风暴与试验。</li>
</ol>
<p>​	我们可以简单总结为 “两关联一循环”，其中“两关联”对应的是前两步，”一循环“对应的是后面三步</p>
<p>​										<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191343.png" alt="image-20220725014019771" style="zoom:50%;" /></p>
<h4 id="“两关联”"><a href="#“两关联”" class="headerlink" title="“两关联”"></a>“两关联”</h4><ul>
<li>模型与软件实现关联；关联模型与软件实现（富含知识的模型、通过聚合关系表达业务概念、修改模型就是修改代码），是知识消化可以顺利进行的前提与基础</li>
<li>统一语言与模型关联；则会将业务方变成模型的使用者。</li>
</ul>
<h4 id="“一循环”"><a href="#“一循环”" class="headerlink" title="“一循环”"></a>“一循环”</h4><p>​	提炼知识的循环。通过统一语言讨论需求；发现模型中的缺失或者不恰当的概念，精炼模型以反映业务的实践情况；对模型的修改引发了统一语言的改变，再以试验和头脑风暴的态度，使用新的语言以验证模型的准确。</p>
<p>​	如此循环往复，不断完善模型与统一语言。因其整体流程与重构（Refactoring）类似，也有人称之为重构循环。知识消化是一种<strong>迭代改进试错法</strong>，它并不追求模型的好坏，而是通过迭代反馈的方式逐渐提高模型的有效性。</p>
<h3 id="建立模型（模式）"><a href="#建立模型（模式）" class="headerlink" title="建立模型（模式）"></a>建立模型（模式）</h3><p>​	 我们有了通用语言，知道了模型应该怎么迭代循环，但面对这么多的业务模型，该如何组织呢？怎样补全欠缺的模型，使之成为一个可以落地的方案呢？也正是因为在通常情况下，业务模型数量众多，所以在 DDD 的过程中，我们将设计分成了两个阶段：战略设计（Strategic Design）和战术设计（Tactical Design）</p>
<h4 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h4><p>​	战略设计是<strong>高层设计，是指将系统拆分成不同的领域</strong>。而领域驱动设计，核心的概念就是领域，也就是说，它给了我们一个拆分系统的新视角：按业务领域拆分。</p>
<h5 id="领域（domain）"><a href="#领域（domain）" class="headerlink" title="领域（domain）"></a>领域（domain）</h5><p>​		领域就是用来确定范围的，范围即边界，这也是 DDD 在设计中不断强调边界的原因。领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。</p>
<p>​	比如，我把一个电商系统拆分成产品域、订单域、支付域、物流域等。拆分成领域之后，我们识别出来的各种业务对象就会归结到各个领域之中。拆分成多个领域后，但并非每个子域都一样重要。所以，我们还要把划分出来的子域再做一下区分，分成核心域（Core Domain）、支撑域（Supporting Subdomain）和通用域（Generic Subdomain）。</p>
<ul>
<li>核心域，整个系统最重要的部分，如何识别（为什么这个系统值得写，为什么不直接买一个，为什么不外包），例如在电商中的黄金流程。</li>
<li>支撑域，非核心竞争力的子域，但是不得不做。例如排行榜功能。</li>
<li>通用域，则是你需要用到的通用系统，第三方服务。例如认证、权限、发送短信等等</li>
</ul>
<p>​	我们之所以要区分不同的子域，关键的原因就在于，我们可以决定不同的投资策略。核心域要全力投入，支撑域次之，通用域甚至可以花钱买服务。</p>
<p>​	切分出来的子域，怎样去落实到代码上呢？首先要解决的就是这些子域如何组织的问题，这就引出了领域驱动设计中的一个重要的概念，限界上下文。</p>
<h5 id="限界上下文（Bounded-Context）"><a href="#限界上下文（Bounded-Context）" class="headerlink" title="限界上下文（Bounded Context）"></a>限界上下文（Bounded Context）</h5><p>​	限界上下文，顾名思义，它形成了一个边界，一个限定了通用语言自由使用的边界，一旦出界，含义便无法保证。比如，同样是说“订单”，如果不加限制，你很难区分它是用在哪种场景之下。而一旦定义了限界上下文，那交易上下文的“订单”和物流上下文的“订单”肯定是不同的。原因就在于，订单这个说法，在不同的边界内，含义是不一样的。</p>
<p>​	注意，子域和限界上下文不一定是一一对应的，可能在一个限界上下文中包含了多个子域，也可能在一个子域横跨了多个限界上下文。</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191348.jpg" alt="img" style="zoom:33%;" />

<p>​	同时微服务的一个难点如何划分服务边界，而限界上下文的出现刚好与微服务的理念契合，每个限界上下文都可以成为一个独立的服务。	</p>
<p>​	有了对限界上下文的理解，我们就可以把整个业务分解到不同的限界上下文中，那么上下之间是怎么交互的，就是上下文映射图需要解决的事情了。</p>
<h5 id="上下文映射图（Context-Map）"><a href="#上下文映射图（Context-Map）" class="headerlink" title="上下文映射图（Context Map）"></a>上下文映射图（Context Map）</h5><p>​	<a target="_blank" rel="noopener" href="https://www.oreilly.com/library/view/what-is-domain-driven/9781492057802/ch04.html">上下文映射图</a>，一种描述方式，将不同限界上下文之间交互的方式描述出来。DDD 给我们提供如下方式：</p>
<ul>
<li>合作关系（Partnership）</li>
<li>共享内核（Shared Kernel）</li>
<li>客户 - 供应商（Customer-Supplier）</li>
<li>跟随者（Conformist）</li>
<li><strong>防腐层（Anticorruption Layer）</strong>，最具防御性的一种关系，在外部模型和内部模型之间建立起一个翻译层，将外部模型转化为内部模型。</li>
<li>开放主机服务（Open Host Service）</li>
<li>发布语言（Published Language）</li>
<li>各行其道（Separate Ways）</li>
<li>大泥球（Big Ball of Mud）</li>
</ul>
<p>​	当我们知道了不同的限界上下文之间采用哪种交互方式之后，不同的交互方式就可以落地为不同的协议。现在最常用的几种协议有 REST API、RPC 或是消息队列，我们可以根据实际情况进行选择。</p>
<p>​	在我们定义好不同的限界上下文，将它们之间的交互呈现出来之后，我们就得到了一张上下文映射图。上下文映射图是可以帮助我们理解系统的各个部分之间，是怎样进行交互的，帮我们建立一个全局性的认知。</p>
<p>​				<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191353.jpg" alt="img" style="zoom:33%;" /></p>
<h4 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h4><p>​	战术设计是<strong>低层设计，也就是如何具体地组织不同的业务模型</strong>。在这个层次上，DDD 给我们提供了一些标准的做法供我们参考。主要有以下步骤</p>
<ul>
<li>梳理有模型哪些角色，比如，哪种模型应该设计成实体，哪些应该设计成值对象。我们还要考虑模型之间是什么样的关系，</li>
<li>梳理模型角色关系，比如，哪些模型要一起使用，可以成为一个聚合。</li>
<li>梳理模型互动（动作），接下来，我们还需要考虑这些模型从哪来、怎样演变，DDD 同样为我们提供了一些标准的设计概念，比如仓库、服务等等。</li>
</ul>
<h5 id="角色：实体、值对象"><a href="#角色：实体、值对象" class="headerlink" title="角色：实体、值对象"></a>角色：实体、值对象</h5><p>​	我们在战术设计中，首先要识别的模型角色就是实体和值对象。</p>
<p>​	什么是实体呢？实体（Entity）指的是能够通过唯一标识符标识出来的对象。再业务处理中，有一类对象会有一定的生命周期，在它的生命周期内一些属性可能会有变化。例如电商平台上的订单，它的状态（已下单、已付款、已发货）根据流程的进行会发生流转，但这个订单始终是这个订单，我们根据唯一标志符去修改它的属性。</p>
<p>​	还有一类对象称为值对象，它就表示一个值。比如，订单地址，它是由省、市、区和具体住址组成。它同实体的差别在于，它没有标识符，它是不可变的。我们为什么要将对象分为实体和值对象？其实主要是为了分出值对象，也就是把变的对象和不变的对象区分开。</p>
<p>​	在传统的做法中，找出实体是你一定会做的一件事，而在不同的模型中，区分出值对象是我们通常欠缺的考虑。比如，很多人会用一个字符串表示电话号码，会用一个 double 类型表示价格，而这些东西其实都应该是一个值对象。因为手机号是有固话、区号、前缀的概念的，而价格其实要有精度的限制，计算时要有自己的计算规则。如果不用一个类将它封装起来，这种行为就将散落在代码的各处，变得难以维护。</p>
<p>​	但是要注意一点是实体和值对象是可以相互转换的，例如有些场景中，地址会被某一实体引用，它只承担描述实体的作用，并且它的值只能整体替换，这时候你就可以将地址设计为值对象，比如收货地址。而在某些业务场景中，地址会被经常修改，地址是作为一个独立对象存在的，这时候它应该设计为实体，比如行政区划中的地址信息维护。</p>
<p>简单来说，它们的特点如下：</p>
<p>​	实体的特点：有 ID 标识，通过 ID 判断相等性，ID 在聚合内唯一即可。状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。</p>
<p>​	值对象的特点：无 ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。值对象尽量只引用值对象。</p>
<h5 id="关系：聚合和聚合根"><a href="#关系：聚合和聚合根" class="headerlink" title="关系：聚合和聚合根"></a>关系：聚合和聚合根</h5><p>​	选定了角色之后，接下来，我们就该考虑它们的关系了。战术设计就给了我们这样一个思考的维度：聚合</p>
<p>​	<strong>聚合</strong>（Aggregate）就是多个实体或值对象的组合，这些对象是什么关系呢？你可以理解为它们要同生共死。比如，一个订单里有很多个订单项，如果这个订单作废了，这些订单项也就没用了。所以，我们基本上可以把订单和订单项看成一个单元，订单和订单项就是一个聚合。既然它们是一个整体，这些对象要一起操作，那么聚合要保证事务（Transaction）一致也就不难理解了。</p>
<p>​	怎么设计聚合，《实现领域驱动设计》一书中对聚合设计原则的描述：</p>
<ul>
<li><strong>在一致性边界内建模真正的不变条件</strong>，聚合用来封装真正的不变性，而不是简单地将对象组合在一起</li>
<li><strong>设计小聚合</strong>，如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂</li>
<li><strong>通过唯一标识引用其它聚合</strong>，聚合之间是通过关联外部聚合根 ID 的方式引用，而不是直接对象引用的方式</li>
<li><strong>在边界之外使用最终一致性</strong>，聚合内数据强一致性，而聚合之间数据最终一致性。在一次事务中，最多只能更改一个聚合的状态</li>
<li><strong>通过应用层实现跨聚合的服务调用</strong>，应避免跨聚合的领域服务调用和跨聚合的数据库表关联</li>
</ul>
<p>​	一个聚合里可以包含很多个对象，每个对象里还可以继续包含其它的对象，就像一棵大树一层层展开。但重点是，这是一棵树，所以，它只能有一个树根，这个根就是聚合根。</p>
<p>​	<strong>聚合根</strong>（Aggregate Root），就是从外部访问这个聚合的起点。我还以上面的订单和订单项为例，在订单和订单项组成的这个聚合里，订单就是聚合根。因为你想访问它们，就要从订单入手，你要通过订单号找到订单，然后，把相关的订单项也一并拿出来。</p>
<p>​					<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191357.jpg" alt="img" style="zoom:33%;" /></p>
<p>简单来说，它们的特点如下</p>
<p>聚合的特点：高内聚、低耦合，它是领域模型中最底层的边界。</p>
<p>聚合根的特点：聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同。</p>
<h5 id="互动：工厂、仓库、领域服务、应用服务"><a href="#互动：工厂、仓库、领域服务、应用服务" class="headerlink" title="互动：工厂、仓库、领域服务、应用服务"></a>互动：工厂、仓库、领域服务、应用服务</h5><p>​	角色和关系有了，现在就来看看这些角色都有什么动作。事件风暴里会识别出事件和动作，动作的结果会产生出各种事件，也就是领域事件，领域事件相当于记录了业务过程中最重要的事情。 我们前面提到了实体或值对象上会有行为动作，那除了这两个还有其他的动作吗？</p>
<p>​	在战术设计中，<strong>领域服务</strong>（Domain Service）就是一种动作，它操作的目标是领域对象（聚合根）。通常，我们的动作应该放在实体或值对象，但总会有一些动作不适合放在这些对象上面，比如，要在两个账户之间转账，这个操作牵扯到两个账户，肯定不能放到一个实体类中。这样的动作就可以放到领域服务中。</p>
<p>​	还有一类动作也比较特殊，就是创建对象的动作，这一类的动作也要放在领域服务上，这种动作对应的就是<strong>工厂</strong>（Factory）。</p>
<p>​	对于这些领域对象，无论是创建，还是修改，我们都需要有一个地方把变更的结果保存下来，而承担这个职责的就是<strong>仓库</strong>（Repository）。</p>
<p>​	当我们把领域服务构建起来之后，核心的业务逻辑基本就成型了，这时还需要<strong>应用服务</strong>（Application Service）。应用服务可以扮演协调者的角色，协调不同的领域对象、领域服务等完成客户端所要求的各种业务动作。一般来说，一些与业务逻辑无关的内容都会放到应用服务中完成，比如，监控、身份认证等等。</p>
<p>​	应用服务和领域服务之间最大的区别就在于，领域服务包含业务逻辑，而应用服务不包含。	</p>
<h3 id="DDD架构"><a href="#DDD架构" class="headerlink" title="DDD架构"></a>DDD架构</h3><h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>​	从下图我们可以很直观的看到，DDD的架构和传统三层架构主要区别在于将原来的业务逻辑层，拆分为应用层和领域层。</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191402.jpg" alt="img" style="zoom:40%;" />

<p>那 DDD 各层的主要职责是什么呢？</p>
<h5 id="1-用户接口层"><a href="#1-用户接口层" class="headerlink" title="1.用户接口层"></a>1.用户接口层</h5><p>​	用户接口层负责向用户显示信息和解释用户指令。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。</p>
<h5 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2.应用层"></a>2.应用层</h5><p>​	我们前面提到的应用服务（Application Service）。它是一个协调者的角色，不应该有业务规则或逻辑，它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。不要将本该放在领域层的业务逻辑放到应用层中实现。因为庞大的应用层会使领域模型失焦，时间一长你的微服务就会演化为传统的三层架构，业务逻辑会变得混乱。</p>
<h5 id="3-领域层"><a href="#3-领域层" class="headerlink" title="3.领域层"></a>3.领域层</h5><p>​	领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则。</p>
<p>​	领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。	</p>
<h5 id="4-基础层"><a href="#4-基础层" class="headerlink" title="4.基础层"></a>4.基础层</h5><p>​	基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。</p>
<h4 id="分层架构的依赖原则"><a href="#分层架构的依赖原则" class="headerlink" title="分层架构的依赖原则"></a>分层架构的依赖原则</h4><p>​	领域驱动设计使用分层架构，主要是因为各层的需求变化速率（Pace of Changing）不同。分层架构对变化传播的控制，是通过层与层之间的依赖关系实现的，因为下层的修改会波及到上层。我们希望通过层来控制变化的传播，只要所有层都单向依赖比自己更稳定的层，更易变依赖不易改变的，那么变化就不会扩散了。</p>
<p>​	那我们来看下领域驱动的分层是否符合这个原则</p>
<p>​												<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191407.png" alt="image-20220727013937408" style="zoom:50%;" /></p>
<p>​	这张图通过依赖关系表示了每一层的变化速率：展示层最易变，其次是应用层，然后是领域层，最后是基础设施层。那实际情况是这样吗？	</p>
<ul>
<li><strong>展现层的逻辑，的确是最容易改变的</strong> ，新的交互模式，不同的视觉模版，都会带来展现层逻辑的改变。</li>
<li><strong>应用层的逻辑，会随着业务流程以及功能点的变化而改变</strong>，比如流程的重组与优化、新功能点的引入，都会改变应用层的逻辑。</li>
<li><strong>领域层是核心领域概念的提取，已经存在的领域概念和核心逻辑不会改变</strong>，在软件系统有限的生命周期内，我们可以认为领域层应该是不变的。</li>
<li><strong>基础设施层的逻辑由所选择的技术栈决定</strong>，更改技术组件、替换所使用的框架，都会改变基础设施层的逻辑，例如基础设施层还可能存在不可预知的突变。如果我们历数过往的诸多思潮，NoSQL（Not Only SQL）、大数据（Big Data）、云计算（Cloud Computing）等等，都为基础设施层带来过未曾预期的突变。</li>
</ul>
<h5 id="基础设施层和领域层谁更稳定？"><a href="#基础设施层和领域层谁更稳定？" class="headerlink" title="基础设施层和领域层谁更稳定？"></a>基础设施层和领域层谁更稳定？</h5><p>​	显然，跟领域层相比，基础设施层就不够稳定。这就违背了分层架构的依赖原则。那么解决这个依赖问题的方法是什么呢，其实DDD 的分层架构是在在不断发展，从最早是传统的四层架构，到后来通过依赖倒置实现了各层对基础层的解耦；</p>
<p>​											<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731191410.png" alt="image-20220727014702335" style="zoom:50%;" /></p>
<p>​	我们可以将基础设施，看作对不同的层的扩展，在每一层中留有能力接口，基础设施则作为这些能力接口的供应商（Capability Provider），参与层内、层间的交互。那么这样的架构，无论从变化的频率还是使用实现关系上就形成了统一。除此之外，我们还解决了分层架构里的另一个难题：层与层之间是单向依赖关系，那么如果需要上一层参与下一层的交互与逻辑，层与层之间就会形成双向依赖关系。</p>
<h4 id="其他架构"><a href="#其他架构" class="headerlink" title="其他架构"></a>其他架构</h4><p>​	DDD的其他架构，常见的架构有整洁架构（洋葱架构）、六边形架构（端口适配器架构）、命令查询职责分离架构(CQRS，Command Query Responsibility Segregation)。</p>
<p>​	其实这些架构的是为了分离关注点，其中清洁架构和六边形架构是将业务与技术相分离，而CQRS则是将业务领域分离为查询和命令两种方式。</p>
<p>​	另外还有一种事件溯源架构（Event sourcing），Martin Fowler在2005年的博客中提及了“Event Sourcing”这个词语，他将事件描述为一个应用的一系列状态改变，这一系列事件能够捕获用来重建当前状态的一切事实真相。他认为事件是不可变的，事件日志是一种只会不断追加（append-only）的存储。不存储当前状态，而是通过事件来计算。</p>
<p>DDD的学习资料</p>
<ul>
<li>Vaughn Vernon的《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/25844633/">实现领域驱动设计</a>》和《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/30333944/">领域驱动设计精粹</a>》</li>
<li>极客时间的《<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100082101">如何落地业务建模</a>》、《<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/158248?cid=100037301">DDD实战课</a>》</li>
<li>国内 JDON的《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35216922/">复杂软件设计之道</a>》也可以作为补充</li>
<li>美团的<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">领域驱动设计在互联网业务开发中的实践</a> 也挺不错的</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	最后，让我们一起来回顾下，首先一开始我们给出的是设计相关的概念，设计出现的原因，阐述模型与设计的关系，以及怎么建立模型，有什么指导原则，对一些重复的问题都提取了什么样的解决方案，有什么模式。</p>
<p>​	接着我们先从架构设计入手，从宏观的角度看待设计，介绍了怎么通过架构图去表达我们的系统，架构设计的目的，怎么去解决复杂度，复杂度是怎么产生的，以及架构设计应该遵循原则，同时也通过架构发展的历史，架构模式、风格应该是会有多种具有针对性的架构风格并存。</p>
<p>​	如果说架构设计是宏观的设计，那么微观设计就是，具体到代码的实现，怎么组织代码的结构，具体的落地实践。这里我们提到了面向对象的设计应该高耦合、低内聚，而怎么实现，关键在于应该遵循SOLID 的原则，这些原则的核心观念也就是分离关注点，引入中间人，同时也对设计模式分类，使用场景做了相关讨论。</p>
<p>​	而面向对象的设计在实际的使用中，会存在贫血模型的情况，针对这种的缺陷，我们使用领域驱动设计进行补充，加入了业务方面的考量。</p>
<img src="https://yuminzheng-pic.oss-cn-hangzhou.aliyuncs.com/images/20220731204146.png" alt="image-20220731203829227" style="zoom:50%;" />

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 951488791@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>浅谈软件设计</p>
    <p><span class="copy-title">字数:</span><span class="post-count">26.1k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="zhengyumin">zhengyumin</a></p>
    <p><span class="copy-title">发布时间:</span>2022-07-31, 00:45:09</p>
    <p><span class="copy-title">最后更新:</span>2022-07-31, 22:15:23</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2022/07/31/%E6%B5%85%E8%B0%88%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" title="浅谈软件设计">http://zyumin.github.io/2022/07/31/%E6%B5%85%E8%B0%88%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#34;署名-非商用-相同方式共享 4.0&#34;</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2022 zhengyumin
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
